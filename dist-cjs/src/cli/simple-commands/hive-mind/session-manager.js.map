{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/session-manager.js"],"sourcesContent":["/**\r\n * Hive Mind Session Manager\r\n * Handles session persistence and resume functionality for swarms\r\n */\r\n\r\nimport path from 'path';\r\nimport { existsSync, mkdirSync } from 'fs';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport chalk from 'chalk';\r\nimport { cwd } from '../../node-compat.js';\r\nimport { createDatabase, isSQLiteAvailable, isWindows } from '../../../memory/sqlite-wrapper.js';\r\nimport { sessionSerializer } from '../../../memory/enhanced-session-serializer.js';\r\nimport { SerializationError, DeserializationError } from '../../../memory/advanced-serializer.js';\r\n\r\nexport class HiveMindSessionManager {\r\n  constructor(hiveMindDir = null) {\r\n    this.hiveMindDir = hiveMindDir || path.join(cwd(), '.hive-mind');\r\n    this.sessionsDir = path.join(this.hiveMindDir, 'sessions');\r\n    this.dbPath = path.join(this.hiveMindDir, 'hive.db');\r\n    this.db = null;\r\n    this.isInMemory = false;\r\n    this.memoryStore = null;\r\n    this.initializationPromise = null;\r\n\r\n    // Ensure directories exist\r\n    this.ensureDirectories();\r\n\r\n    // Initialize database connection (store promise for later)\r\n    this.initializationPromise = this.initializeDatabase();\r\n  }\r\n\r\n  /**\r\n   * Initialize database with fallback support\r\n   */\r\n  async initializeDatabase() {\r\n    try {\r\n      const sqliteAvailable = await isSQLiteAvailable();\r\n      \r\n      if (!sqliteAvailable) {\r\n        console.warn('SQLite not available, using in-memory session storage');\r\n        this.initializeInMemoryFallback();\r\n        return;\r\n      }\r\n\r\n      this.db = await createDatabase(this.dbPath);\r\n      if (this.db) {\r\n        this.initializeSchema();\r\n      } else {\r\n        throw new Error('Failed to create database instance');\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to create SQLite database:', error.message);\r\n      console.warn('Falling back to in-memory session storage');\r\n      this.initializeInMemoryFallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure database is initialized before use\r\n   */\r\n  async ensureInitialized() {\r\n    if (this.initializationPromise) {\r\n      await this.initializationPromise;\r\n      this.initializationPromise = null;\r\n    }\r\n    \r\n    if (this.db === null && !this.isInMemory) {\r\n      await this.initializeDatabase();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize in-memory fallback for session storage\r\n   */\r\n  initializeInMemoryFallback() {\r\n    this.isInMemory = true;\r\n    this.memoryStore = {\r\n      sessions: new Map(),\r\n      checkpoints: new Map(),\r\n      logs: new Map()\r\n    };\r\n    \r\n    if (isWindows()) {\r\n      console.info(`\r\nNote: Session data will not persist between runs on Windows without SQLite.\r\nTo enable persistence, see: https://github.com/ruvnet/claude-code-flow/docs/windows-installation.md\r\n`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure required directories exist\r\n   */\r\n  ensureDirectories() {\r\n    if (!existsSync(this.hiveMindDir)) {\r\n      mkdirSync(this.hiveMindDir, { recursive: true });\r\n    }\r\n    if (!existsSync(this.sessionsDir)) {\r\n      mkdirSync(this.sessionsDir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize database schema for sessions\r\n   */\r\n  initializeSchema() {\r\n    if (!this.db) {\r\n      console.error('Database not initialized');\r\n      return;\r\n    }\r\n    // Create the base schema\r\n    this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS sessions (\r\n        id TEXT PRIMARY KEY,\r\n        swarm_id TEXT NOT NULL,\r\n        swarm_name TEXT NOT NULL,\r\n        objective TEXT,\r\n        status TEXT DEFAULT 'active',\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        paused_at DATETIME,\r\n        resumed_at DATETIME,\r\n        completion_percentage REAL DEFAULT 0,\r\n        checkpoint_data TEXT,\r\n        metadata TEXT,\r\n        parent_pid INTEGER,\r\n        child_pids TEXT,\r\n        FOREIGN KEY (swarm_id) REFERENCES swarms(id)\r\n      );\r\n\r\n      CREATE TABLE IF NOT EXISTS session_checkpoints (\r\n        id TEXT PRIMARY KEY,\r\n        session_id TEXT NOT NULL,\r\n        checkpoint_name TEXT NOT NULL,\r\n        checkpoint_data TEXT,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        FOREIGN KEY (session_id) REFERENCES sessions(id)\r\n      );\r\n\r\n      CREATE TABLE IF NOT EXISTS session_logs (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        session_id TEXT NOT NULL,\r\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        log_level TEXT DEFAULT 'info',\r\n        message TEXT,\r\n        agent_id TEXT,\r\n        data TEXT,\r\n        FOREIGN KEY (session_id) REFERENCES sessions(id)\r\n      );\r\n    `);\r\n\r\n    // Run migrations to add new columns\r\n    this.runMigrations();\r\n  }\r\n\r\n  /**\r\n   * Run database migrations\r\n   */\r\n  runMigrations() {\r\n    if (!this.db) {\r\n      console.error('Database not initialized for migrations');\r\n      return;\r\n    }\r\n    try {\r\n      // Check if required columns exist\r\n      const columns = this.db.prepare('PRAGMA table_info(sessions)').all();\r\n      \r\n      // Core columns\r\n      const hasObjective = columns.some((col) => col.name === 'objective');\r\n      const hasSwarmName = columns.some((col) => col.name === 'swarm_name');\r\n      const hasCheckpointData = columns.some((col) => col.name === 'checkpoint_data');\r\n      const hasMetadata = columns.some((col) => col.name === 'metadata');\r\n      const hasParentPid = columns.some((col) => col.name === 'parent_pid');\r\n      const hasChildPids = columns.some((col) => col.name === 'child_pids');\r\n      \r\n      // Timestamp columns\r\n      const hasUpdatedAt = columns.some((col) => col.name === 'updated_at');\r\n      const hasPausedAt = columns.some((col) => col.name === 'paused_at');\r\n      const hasResumedAt = columns.some((col) => col.name === 'resumed_at');\r\n      const hasCompletionPercentage = columns.some((col) => col.name === 'completion_percentage');\r\n\r\n      if (!hasObjective) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN objective TEXT');\r\n        console.log('Added objective column to sessions table');\r\n      }\r\n\r\n      if (!hasSwarmName) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN swarm_name TEXT');\r\n        console.log('Added swarm_name column to sessions table');\r\n      }\r\n\r\n      if (!hasCheckpointData) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN checkpoint_data TEXT');\r\n        console.log('Added checkpoint_data column to sessions table');\r\n      }\r\n\r\n      if (!hasMetadata) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN metadata TEXT');\r\n        console.log('Added metadata column to sessions table');\r\n      }\r\n\r\n      if (!hasParentPid) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN parent_pid INTEGER');\r\n        console.log('Added parent_pid column to sessions table');\r\n      }\r\n\r\n      if (!hasChildPids) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN child_pids TEXT');\r\n        console.log('Added child_pids column to sessions table');\r\n      }\r\n\r\n      if (!hasUpdatedAt) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');\r\n        console.log('Added updated_at column to sessions table');\r\n      }\r\n\r\n      if (!hasPausedAt) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN paused_at DATETIME');\r\n        console.log('Added paused_at column to sessions table');\r\n      }\r\n\r\n      if (!hasResumedAt) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN resumed_at DATETIME');\r\n        console.log('Added resumed_at column to sessions table');\r\n      }\r\n\r\n      if (!hasCompletionPercentage) {\r\n        this.db.exec('ALTER TABLE sessions ADD COLUMN completion_percentage REAL DEFAULT 0');\r\n        console.log('Added completion_percentage column to sessions table');\r\n      }\r\n    } catch (error) {\r\n      console.error('Migration error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new session for a swarm\r\n   */\r\n  async createSession(swarmId, swarmName, objective, metadata = {}) {\r\n    await this.ensureInitialized();\r\n    \r\n    const sessionId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\r\n\r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const sessionData = {\r\n        id: sessionId,\r\n        swarm_id: swarmId,\r\n        swarm_name: swarmName,\r\n        objective,\r\n        status: 'active',\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString(),\r\n        metadata: sessionSerializer.serializeMetadata(metadata),\r\n        parent_pid: process.pid,\r\n        child_pids: '[]'\r\n      };\r\n      this.memoryStore.sessions.set(sessionId, sessionData);\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        INSERT INTO sessions (id, swarm_id, swarm_name, objective, metadata, parent_pid)\r\n        VALUES (?, ?, ?, ?, ?, ?)\r\n      `);\r\n\r\n      stmt.run(sessionId, swarmId, swarmName, objective, sessionSerializer.serializeMetadata(metadata), process.pid);\r\n    }\r\n\r\n    // Log session creation\r\n    await this.logSessionEvent(sessionId, 'info', 'Session created', null, {\r\n      swarmId,\r\n      swarmName,\r\n      objective,\r\n      parentPid: process.pid,\r\n    });\r\n\r\n    return sessionId;\r\n  }\r\n\r\n  /**\r\n   * Save session checkpoint\r\n   */\r\n  async saveCheckpoint(sessionId, checkpointName, checkpointData) {\r\n    await this.ensureInitialized();\r\n    \r\n    const checkpointId = `checkpoint-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\r\n\r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const checkpointEntry = {\r\n        id: checkpointId,\r\n        session_id: sessionId,\r\n        checkpoint_name: checkpointName,\r\n        checkpoint_data: sessionSerializer.serializeCheckpointData(checkpointData),\r\n        created_at: new Date().toISOString()\r\n      };\r\n      \r\n      if (!this.memoryStore.checkpoints.has(sessionId)) {\r\n        this.memoryStore.checkpoints.set(sessionId, []);\r\n      }\r\n      this.memoryStore.checkpoints.get(sessionId).push(checkpointEntry);\r\n      \r\n      // Update session data\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (session) {\r\n        session.checkpoint_data = sessionSerializer.serializeCheckpointData(checkpointData);\r\n        session.updated_at = new Date().toISOString();\r\n      }\r\n    } else {\r\n      // Save to database\r\n      const stmt = this.db.prepare(`\r\n        INSERT INTO session_checkpoints (id, session_id, checkpoint_name, checkpoint_data)\r\n        VALUES (?, ?, ?, ?)\r\n      `);\r\n\r\n      stmt.run(checkpointId, sessionId, checkpointName, sessionSerializer.serializeCheckpointData(checkpointData));\r\n\r\n      // Update session checkpoint data and timestamp\r\n      const updateStmt = this.db.prepare(`\r\n        UPDATE sessions \r\n        SET checkpoint_data = ?, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `);\r\n\r\n      updateStmt.run(sessionSerializer.serializeCheckpointData(checkpointData), sessionId);\r\n    }\r\n\r\n    // Save checkpoint file for backup\r\n    const checkpointFile = path.join(this.sessionsDir, `${sessionId}-${checkpointName}.json`);\r\n    await writeFile(\r\n      checkpointFile,\r\n      sessionSerializer.serializeSessionData({\r\n        sessionId,\r\n        checkpointId,\r\n        checkpointName,\r\n        timestamp: new Date().toISOString(),\r\n        data: checkpointData,\r\n      }),\r\n    );\r\n\r\n    await this.logSessionEvent(sessionId, 'info', `Checkpoint saved: ${checkpointName}`, null, {\r\n      checkpointId,\r\n    });\r\n\r\n    return checkpointId;\r\n  }\r\n\r\n  /**\r\n   * Get active sessions\r\n   */\r\n  async getActiveSessions() {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage with real counts\r\n      const sessions = [];\r\n      for (const [sessionId, session] of this.memoryStore.sessions) {\r\n        if (session.status === 'active' || session.status === 'paused') {\r\n          // Get real agent count from memory\r\n          const agentCount = this.memoryStore.agents \r\n            ? Array.from(this.memoryStore.agents.values()).filter(a => a.swarm_id === session.swarm_id).length \r\n            : 0;\r\n          \r\n          // Get real task counts from memory\r\n          const tasks = this.memoryStore.tasks \r\n            ? Array.from(this.memoryStore.tasks.values()).filter(t => t.swarm_id === session.swarm_id)\r\n            : [];\r\n          \r\n          const taskCount = tasks.length;\r\n          const completedTasks = tasks.filter(t => t.status === 'completed').length;\r\n          const inProgressTasks = tasks.filter(t => t.status === 'in_progress').length;\r\n          const pendingTasks = tasks.filter(t => t.status === 'pending').length;\r\n          \r\n          sessions.push({\r\n            ...session,\r\n            metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\r\n            checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\r\n            agent_count: agentCount,\r\n            task_count: taskCount,\r\n            completed_tasks: completedTasks,\r\n            in_progress_tasks: inProgressTasks,\r\n            pending_tasks: pendingTasks,\r\n            completion_percentage: taskCount > 0 ? Math.round((completedTasks / taskCount) * 100) : 0\r\n          });\r\n        }\r\n      }\r\n      return sessions.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        SELECT s.*, \r\n               COUNT(DISTINCT a.id) as agent_count,\r\n               COUNT(DISTINCT t.id) as task_count,\r\n               SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) as completed_tasks\r\n        FROM sessions s\r\n        LEFT JOIN agents a ON s.swarm_id = a.swarm_id\r\n        LEFT JOIN tasks t ON s.swarm_id = t.swarm_id\r\n        WHERE s.status = 'active' OR s.status = 'paused'\r\n        GROUP BY s.id\r\n        ORDER BY s.updated_at DESC\r\n      `);\r\n\r\n      const sessions = stmt.all();\r\n\r\n      // Parse JSON fields\r\n      return sessions.map((session) => ({\r\n        ...session,\r\n        metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\r\n        checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\r\n        completion_percentage:\r\n          session.task_count > 0\r\n            ? Math.round((session.completed_tasks / session.task_count) * 100)\r\n            : 0,\r\n      }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get session by ID with full details\r\n   */\r\n  async getSession(sessionId) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (!session) {\r\n        return null;\r\n      }\r\n      \r\n      // Return simplified session data for in-memory mode\r\n      return {\r\n        ...session,\r\n        metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\r\n        checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\r\n        swarm: null, // Not available in memory mode\r\n        agents: [], // Not available in memory mode\r\n        tasks: [], // Not available in memory mode\r\n        checkpoints: this.memoryStore.checkpoints.get(sessionId) || [],\r\n        recentLogs: this.memoryStore.logs.get(sessionId) || [],\r\n        statistics: {\r\n          totalAgents: 0,\r\n          activeAgents: 0,\r\n          totalTasks: 0,\r\n          completedTasks: 0,\r\n          pendingTasks: 0,\r\n          inProgressTasks: 0,\r\n          completionPercentage: session.completion_percentage || 0,\r\n        },\r\n      };\r\n    }\r\n\r\n    const session = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM sessions WHERE id = ?\r\n    `,\r\n      )\r\n      .get(sessionId);\r\n\r\n    if (!session) {\r\n      return null;\r\n    }\r\n\r\n    // Get associated swarm data\r\n    const swarm = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM swarms WHERE id = ?\r\n    `,\r\n      )\r\n      .get(session.swarm_id);\r\n\r\n    // Get agents\r\n    const agents = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM agents WHERE swarm_id = ?\r\n    `,\r\n      )\r\n      .all(session.swarm_id);\r\n\r\n    // Get tasks\r\n    const tasks = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM tasks WHERE swarm_id = ?\r\n    `,\r\n      )\r\n      .all(session.swarm_id);\r\n\r\n    // Get checkpoints\r\n    const checkpoints = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM session_checkpoints \r\n      WHERE session_id = ? \r\n      ORDER BY created_at DESC\r\n    `,\r\n      )\r\n      .all(sessionId);\r\n\r\n    // Get recent logs\r\n    const recentLogs = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM session_logs \r\n      WHERE session_id = ? \r\n      ORDER BY timestamp DESC \r\n      LIMIT 50\r\n    `,\r\n      )\r\n      .all(sessionId);\r\n\r\n    return {\r\n      ...session,\r\n      metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\r\n      checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\r\n      swarm,\r\n      agents,\r\n      tasks,\r\n      checkpoints: checkpoints.map((cp) => ({\r\n        ...cp,\r\n        checkpoint_data: sessionSerializer.deserializeCheckpointData(cp.checkpoint_data),\r\n      })),\r\n      recentLogs,\r\n      statistics: {\r\n        totalAgents: agents.length,\r\n        activeAgents: agents.filter((a) => a.status === 'active' || a.status === 'busy').length,\r\n        totalTasks: tasks.length,\r\n        completedTasks: tasks.filter((t) => t.status === 'completed').length,\r\n        pendingTasks: tasks.filter((t) => t.status === 'pending').length,\r\n        inProgressTasks: tasks.filter((t) => t.status === 'in_progress').length,\r\n        completionPercentage:\r\n          tasks.length > 0\r\n            ? Math.round(\r\n                (tasks.filter((t) => t.status === 'completed').length / tasks.length) * 100,\r\n              )\r\n            : 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Pause a session\r\n   */\r\n  async pauseSession(sessionId) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (session) {\r\n        session.status = 'paused';\r\n        session.paused_at = new Date().toISOString();\r\n        session.updated_at = new Date().toISOString();\r\n        \r\n        await this.logSessionEvent(sessionId, 'info', 'Session paused');\r\n        return true;\r\n      }\r\n      return false;\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        UPDATE sessions \r\n        SET status = 'paused', paused_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `);\r\n\r\n      const result = stmt.run(sessionId);\r\n\r\n      if (result.changes > 0) {\r\n        await this.logSessionEvent(sessionId, 'info', 'Session paused');\r\n\r\n        // Update swarm status\r\n        const session = this.db.prepare('SELECT swarm_id FROM sessions WHERE id = ?').get(sessionId);\r\n        if (session) {\r\n          this.db\r\n            .prepare('UPDATE swarms SET status = ? WHERE id = ?')\r\n            .run('paused', session.swarm_id);\r\n        }\r\n      }\r\n\r\n      return result.changes > 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resume any previous session (paused, stopped, or inactive)\r\n   */\r\n  async resumeSession(sessionId) {\r\n    const session = await this.getSession(sessionId);\r\n\r\n    if (!session) {\r\n      throw new Error(`Session ${sessionId} not found`);\r\n    }\r\n\r\n    // Allow resuming any session regardless of status\r\n    console.log(`Resuming session ${sessionId} from status: ${session.status}`);\r\n\r\n    // If session was stopped, log that we're restarting it\r\n    if (session.status === 'stopped') {\r\n      await this.logSessionEvent(\r\n        sessionId,\r\n        'info',\r\n        `Restarting stopped session with original configuration`,\r\n      );\r\n    }\r\n\r\n    // Update session status\r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const sessionData = this.memoryStore.sessions.get(sessionId);\r\n      if (sessionData) {\r\n        sessionData.status = 'active';\r\n        sessionData.resumed_at = new Date().toISOString();\r\n        sessionData.updated_at = new Date().toISOString();\r\n      }\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        UPDATE sessions \r\n        SET status = 'active', resumed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `);\r\n\r\n      stmt.run(sessionId);\r\n\r\n      // Update swarm status\r\n      this.db.prepare('UPDATE swarms SET status = ? WHERE id = ?').run('active', session.swarm_id);\r\n\r\n      // Update agent statuses\r\n      this.db\r\n        .prepare(\r\n          `\r\n        UPDATE agents \r\n        SET status = CASE \r\n          WHEN role = 'queen' THEN 'active'\r\n          ELSE 'idle'\r\n        END\r\n        WHERE swarm_id = ?\r\n      `,\r\n        )\r\n        .run(session.swarm_id);\r\n    }\r\n\r\n    await this.logSessionEvent(sessionId, 'info', 'Session resumed', null, {\r\n      pausedDuration: session.paused_at ? new Date() - new Date(session.paused_at) : null,\r\n    });\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Mark session as completed\r\n   */\r\n  async completeSession(sessionId) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (session) {\r\n        session.status = 'completed';\r\n        session.updated_at = new Date().toISOString();\r\n        session.completion_percentage = 100;\r\n        \r\n        await this.logSessionEvent(sessionId, 'info', 'Session completed');\r\n        return true;\r\n      }\r\n      return false;\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        UPDATE sessions \r\n        SET status = 'completed', updated_at = CURRENT_TIMESTAMP, completion_percentage = 100\r\n        WHERE id = ?\r\n      `);\r\n\r\n      const result = stmt.run(sessionId);\r\n\r\n      if (result.changes > 0) {\r\n        await this.logSessionEvent(sessionId, 'info', 'Session completed');\r\n\r\n        // Update swarm status\r\n        const session = this.db.prepare('SELECT swarm_id FROM sessions WHERE id = ?').get(sessionId);\r\n        if (session) {\r\n          this.db\r\n            .prepare('UPDATE swarms SET status = ? WHERE id = ?')\r\n            .run('completed', session.swarm_id);\r\n        }\r\n      }\r\n\r\n      return result.changes > 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Archive old sessions\r\n   */\r\n  async archiveSessions(daysOld = 30) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // In-memory mode doesn't support archiving\r\n      console.warn('Session archiving not supported in in-memory mode');\r\n      return 0;\r\n    }\r\n    \r\n    const cutoffDate = new Date();\r\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld);\r\n\r\n    const sessionsToArchive = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM sessions \r\n      WHERE status = 'completed' AND updated_at < ?\r\n    `,\r\n      )\r\n      .all(cutoffDate.toISOString());\r\n\r\n    const archiveDir = path.join(this.sessionsDir, 'archive');\r\n    if (!existsSync(archiveDir)) {\r\n      mkdirSync(archiveDir, { recursive: true });\r\n    }\r\n\r\n    for (const session of sessionsToArchive) {\r\n      const sessionData = await this.getSession(session.id);\r\n      const archiveFile = path.join(archiveDir, `${session.id}-archive.json`);\r\n\r\n      await writeFile(archiveFile, sessionSerializer.serializeSessionData(sessionData));\r\n\r\n      // Remove from database\r\n      this.db.prepare('DELETE FROM session_logs WHERE session_id = ?').run(session.id);\r\n      this.db.prepare('DELETE FROM session_checkpoints WHERE session_id = ?').run(session.id);\r\n      this.db.prepare('DELETE FROM sessions WHERE id = ?').run(session.id);\r\n    }\r\n\r\n    return sessionsToArchive.length;\r\n  }\r\n\r\n  /**\r\n   * Log session event\r\n   */\r\n  async logSessionEvent(sessionId, logLevel, message, agentId = null, data = null) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage for logs\r\n      const logId = `log-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\r\n      const logEntry = {\r\n        id: logId,\r\n        session_id: sessionId,\r\n        timestamp: new Date().toISOString(),\r\n        log_level: logLevel,\r\n        message,\r\n        agent_id: agentId,\r\n        data: data ? sessionSerializer.serializeLogData(data) : null\r\n      };\r\n      \r\n      if (!this.memoryStore.logs.has(sessionId)) {\r\n        this.memoryStore.logs.set(sessionId, []);\r\n      }\r\n      this.memoryStore.logs.get(sessionId).push(logEntry);\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        INSERT INTO session_logs (session_id, log_level, message, agent_id, data)\r\n        VALUES (?, ?, ?, ?, ?)\r\n      `);\r\n\r\n      stmt.run(sessionId, logLevel, message, agentId, data ? sessionSerializer.serializeLogData(data) : null);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get session logs\r\n   */\r\n  async getSessionLogs(sessionId, limit = 100, offset = 0) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const logs = this.memoryStore.logs.get(sessionId) || [];\r\n      return logs.slice(offset, offset + limit).map((log) => ({\r\n        ...log,\r\n        data: log.data ? sessionSerializer.deserializeLogData(log.data) : null,\r\n      }));\r\n    }\r\n    \r\n    const stmt = this.db.prepare(`\r\n      SELECT * FROM session_logs \r\n      WHERE session_id = ? \r\n      ORDER BY timestamp DESC \r\n      LIMIT ? OFFSET ?\r\n    `);\r\n\r\n    const logs = stmt.all(sessionId, limit, offset);\r\n\r\n    return logs.map((log) => ({\r\n      ...log,\r\n      data: log.data ? sessionSerializer.deserializeLogData(log.data) : null,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Update session progress\r\n   */\r\n  async updateSessionProgress(sessionId, completionPercentage) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (session) {\r\n        session.completion_percentage = completionPercentage;\r\n        session.updated_at = new Date().toISOString();\r\n      }\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        UPDATE sessions \r\n        SET completion_percentage = ?, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `);\r\n\r\n      stmt.run(completionPercentage, sessionId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate session summary\r\n   */\r\n  async generateSessionSummary(sessionId) {\r\n    const session = await this.getSession(sessionId);\r\n\r\n    if (!session) {\r\n      return null;\r\n    }\r\n\r\n    const duration =\r\n      session.paused_at && session.resumed_at\r\n        ? new Date(session.updated_at) -\r\n          new Date(session.created_at) -\r\n          (new Date(session.resumed_at) - new Date(session.paused_at))\r\n        : new Date(session.updated_at) - new Date(session.created_at);\r\n\r\n    const tasksByType = session.agents.reduce((acc, agent) => {\r\n      const agentTasks = session.tasks.filter((t) => t.agent_id === agent.id);\r\n      if (!acc[agent.type]) {\r\n        acc[agent.type] = {\r\n          total: 0,\r\n          completed: 0,\r\n          inProgress: 0,\r\n          pending: 0,\r\n        };\r\n      }\r\n      acc[agent.type].total += agentTasks.length;\r\n      acc[agent.type].completed += agentTasks.filter((t) => t.status === 'completed').length;\r\n      acc[agent.type].inProgress += agentTasks.filter((t) => t.status === 'in_progress').length;\r\n      acc[agent.type].pending += agentTasks.filter((t) => t.status === 'pending').length;\r\n      return acc;\r\n    }, {});\r\n\r\n    return {\r\n      sessionId: session.id,\r\n      swarmName: session.swarm_name,\r\n      objective: session.objective,\r\n      status: session.status,\r\n      duration: Math.round(duration / 1000 / 60), // minutes\r\n      statistics: session.statistics,\r\n      tasksByType,\r\n      checkpointCount: session.checkpoints.length,\r\n      lastCheckpoint: session.checkpoints[0] || null,\r\n      timeline: {\r\n        created: session.created_at,\r\n        lastUpdated: session.updated_at,\r\n        paused: session.paused_at,\r\n        resumed: session.resumed_at,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Export session data\r\n   */\r\n  async exportSession(sessionId, exportPath = null) {\r\n    const session = await this.getSession(sessionId);\r\n\r\n    if (!session) {\r\n      throw new Error(`Session ${sessionId} not found`);\r\n    }\r\n\r\n    const exportFile = exportPath || path.join(this.sessionsDir, `${sessionId}-export.json`);\r\n\r\n    await writeFile(exportFile, sessionSerializer.serializeSessionData(session));\r\n\r\n    return exportFile;\r\n  }\r\n\r\n  /**\r\n   * Import session data\r\n   */\r\n  async importSession(importPath) {\r\n    const sessionData = sessionSerializer.deserializeSessionData(await readFile(importPath, 'utf8'));\r\n\r\n    // Create new session with imported data\r\n    const newSessionId = this.createSession(\r\n      sessionData.swarm_id,\r\n      sessionData.swarm_name,\r\n      sessionData.objective,\r\n      sessionData.metadata,\r\n    );\r\n\r\n    // Import checkpoints\r\n    for (const checkpoint of sessionData.checkpoints || []) {\r\n      await this.saveCheckpoint(\r\n        newSessionId,\r\n        checkpoint.checkpoint_name,\r\n        checkpoint.checkpoint_data,\r\n      );\r\n    }\r\n\r\n    // Import logs\r\n    for (const log of sessionData.recentLogs || []) {\r\n      await this.logSessionEvent(\r\n        newSessionId,\r\n        log.log_level,\r\n        log.message,\r\n        log.agent_id,\r\n        log.data ? sessionSerializer.deserializeLogData(log.data) : null,\r\n      );\r\n    }\r\n\r\n    return newSessionId;\r\n  }\r\n\r\n  /**\r\n   * Add a child process PID to session\r\n   */\r\n  async addChildPid(sessionId, pid) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (!session) return false;\r\n      \r\n      const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\r\n      if (!childPids.includes(pid)) {\r\n        childPids.push(pid);\r\n      }\r\n      session.child_pids = sessionSerializer.serializeLogData(childPids);\r\n      session.updated_at = new Date().toISOString();\r\n      \r\n      await this.logSessionEvent(sessionId, 'info', 'Child process added', null, { pid });\r\n      return true;\r\n    }\r\n    \r\n    const session = this.db.prepare('SELECT child_pids FROM sessions WHERE id = ?').get(sessionId);\r\n    if (!session) return false;\r\n\r\n    const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\r\n    if (!childPids.includes(pid)) {\r\n      childPids.push(pid);\r\n    }\r\n\r\n    const stmt = this.db.prepare(`\r\n      UPDATE sessions \r\n      SET child_pids = ?, updated_at = CURRENT_TIMESTAMP\r\n      WHERE id = ?\r\n    `);\r\n\r\n    stmt.run(sessionSerializer.serializeLogData(childPids), sessionId);\r\n\r\n    await this.logSessionEvent(sessionId, 'info', 'Child process added', null, { pid });\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove a child process PID from session\r\n   */\r\n  async removeChildPid(sessionId, pid) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (!session) return false;\r\n      \r\n      const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\r\n      const index = childPids.indexOf(pid);\r\n      if (index > -1) {\r\n        childPids.splice(index, 1);\r\n      }\r\n      session.child_pids = sessionSerializer.serializeLogData(childPids);\r\n      session.updated_at = new Date().toISOString();\r\n      \r\n      await this.logSessionEvent(sessionId, 'info', 'Child process removed', null, { pid });\r\n      return true;\r\n    }\r\n    \r\n    // Check if database connection is still open before operations\r\n    if (!this.db || !this.db.open) {\r\n      console.warn('Database connection closed, cannot remove child PID during cleanup');\r\n      return false;\r\n    }\r\n    \r\n    const session = this.db.prepare('SELECT child_pids FROM sessions WHERE id = ?').get(sessionId);\r\n    if (!session) return false;\r\n\r\n    const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\r\n    const index = childPids.indexOf(pid);\r\n    if (index > -1) {\r\n      childPids.splice(index, 1);\r\n    }\r\n\r\n    const stmt = this.db.prepare(`\r\n      UPDATE sessions \r\n      SET child_pids = ?, updated_at = CURRENT_TIMESTAMP\r\n      WHERE id = ?\r\n    `);\r\n\r\n    stmt.run(sessionSerializer.serializeLogData(childPids), sessionId);\r\n\r\n    await this.logSessionEvent(sessionId, 'info', 'Child process removed', null, { pid });\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get all child PIDs for a session\r\n   */\r\n  async getChildPids(sessionId) {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const session = this.memoryStore.sessions.get(sessionId);\r\n      if (!session || !session.child_pids) return [];\r\n      return sessionSerializer.deserializeLogData(session.child_pids);\r\n    } else {\r\n      // Check if database connection is still open\r\n      if (!this.db || !this.db.open) {\r\n        console.warn('Database connection closed, cannot get child PIDs during cleanup');\r\n        return [];\r\n      }\r\n      \r\n      // Use SQLite\r\n      const session = this.db.prepare('SELECT child_pids FROM sessions WHERE id = ?').get(sessionId);\r\n      if (!session || !session.child_pids) return [];\r\n      return sessionSerializer.deserializeLogData(session.child_pids);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop a session and terminate all child processes\r\n   */\r\n  async stopSession(sessionId) {\r\n    const session = await this.getSession(sessionId);\r\n    if (!session) {\r\n      throw new Error(`Session ${sessionId} not found`);\r\n    }\r\n\r\n    // Get child PIDs\r\n    const childPids = await this.getChildPids(sessionId);\r\n\r\n    // Terminate child processes\r\n    for (const pid of childPids) {\r\n      try {\r\n        process.kill(pid, 'SIGTERM');\r\n        await this.logSessionEvent(sessionId, 'info', 'Child process terminated', null, { pid });\r\n      } catch (err) {\r\n        // Process might already be dead\r\n        await this.logSessionEvent(sessionId, 'warning', 'Failed to terminate child process', null, {\r\n          pid,\r\n          error: err.message,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update session status\r\n    if (this.isInMemory) {\r\n      // Use in-memory storage\r\n      const sessionData = this.memoryStore.sessions.get(sessionId);\r\n      if (sessionData) {\r\n        sessionData.status = 'stopped';\r\n        sessionData.updated_at = new Date().toISOString();\r\n      }\r\n    } else {\r\n      // Use SQLite\r\n      const stmt = this.db.prepare(`\r\n        UPDATE sessions \r\n        SET status = 'stopped', updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `);\r\n\r\n      stmt.run(sessionId);\r\n\r\n      // Update swarm status\r\n      this.db.prepare('UPDATE swarms SET status = ? WHERE id = ?').run('stopped', session.swarm_id);\r\n    }\r\n\r\n    await this.logSessionEvent(sessionId, 'info', 'Session stopped');\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get active sessions with process information\r\n   */\r\n  async getActiveSessionsWithProcessInfo() {\r\n    const sessions = await this.getActiveSessions();\r\n\r\n    // Add process info to each session\r\n    return sessions.map((session) => {\r\n      const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\r\n      const aliveChildPids = [];\r\n\r\n      // Check which child processes are still alive\r\n      for (const pid of childPids) {\r\n        try {\r\n          process.kill(pid, 0); // Signal 0 just checks if process exists\r\n          aliveChildPids.push(pid);\r\n        } catch (err) {\r\n          // Process is dead\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...session,\r\n        parent_pid: session.parent_pid,\r\n        child_pids: aliveChildPids,\r\n        total_processes: 1 + aliveChildPids.length,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clean up orphaned processes\r\n   */\r\n  async cleanupOrphanedProcesses() {\r\n    await this.ensureInitialized();\r\n    \r\n    if (this.isInMemory) {\r\n      // In-memory mode doesn't track orphaned processes\r\n      return 0;\r\n    }\r\n    \r\n    const sessions = this.db\r\n      .prepare(\r\n        `\r\n      SELECT * FROM sessions \r\n      WHERE status IN ('active', 'paused')\r\n    `,\r\n      )\r\n      .all();\r\n\r\n    let cleanedCount = 0;\r\n\r\n    for (const session of sessions) {\r\n      // Check if parent process is still alive\r\n      try {\r\n        process.kill(session.parent_pid, 0);\r\n      } catch (err) {\r\n        // Parent is dead, clean up session\r\n        await this.stopSession(session.id);\r\n        cleanedCount++;\r\n        await this.logSessionEvent(session.id, 'info', 'Orphaned session cleaned up');\r\n      }\r\n    }\r\n\r\n    return cleanedCount;\r\n  }\r\n\r\n  /**\r\n   * Clean up and close database connection\r\n   */\r\n  close() {\r\n    if (this.db && !this.isInMemory) {\r\n      this.db.close();\r\n    }\r\n  }\r\n}\r\n\r\n// Export for use in other modules\r\nexport default HiveMindSessionManager;\r\n"],"names":["path","existsSync","mkdirSync","readFile","writeFile","cwd","createDatabase","isSQLiteAvailable","isWindows","sessionSerializer","HiveMindSessionManager","hiveMindDir","join","sessionsDir","dbPath","db","isInMemory","memoryStore","initializationPromise","ensureDirectories","initializeDatabase","sqliteAvailable","console","warn","initializeInMemoryFallback","initializeSchema","Error","error","message","ensureInitialized","sessions","Map","checkpoints","logs","info","recursive","exec","runMigrations","columns","prepare","all","hasObjective","some","col","name","hasSwarmName","hasCheckpointData","hasMetadata","hasParentPid","hasChildPids","hasUpdatedAt","hasPausedAt","hasResumedAt","hasCompletionPercentage","log","createSession","swarmId","swarmName","objective","metadata","sessionId","Date","now","Math","random","toString","substring","sessionData","id","swarm_id","swarm_name","status","created_at","toISOString","updated_at","serializeMetadata","parent_pid","process","pid","child_pids","set","stmt","run","logSessionEvent","parentPid","saveCheckpoint","checkpointName","checkpointData","checkpointId","checkpointEntry","session_id","checkpoint_name","checkpoint_data","serializeCheckpointData","has","get","push","session","updateStmt","checkpointFile","serializeSessionData","timestamp","data","getActiveSessions","agentCount","agents","Array","from","values","filter","a","length","tasks","t","taskCount","completedTasks","inProgressTasks","pendingTasks","deserializeMetadata","deserializeCheckpointData","agent_count","task_count","completed_tasks","in_progress_tasks","pending_tasks","completion_percentage","round","sort","b","map","getSession","swarm","recentLogs","statistics","totalAgents","activeAgents","totalTasks","completionPercentage","cp","pauseSession","paused_at","result","changes","resumeSession","resumed_at","pausedDuration","completeSession","archiveSessions","daysOld","cutoffDate","setDate","getDate","sessionsToArchive","archiveDir","archiveFile","logLevel","agentId","logId","logEntry","log_level","agent_id","serializeLogData","getSessionLogs","limit","offset","slice","deserializeLogData","updateSessionProgress","generateSessionSummary","duration","tasksByType","reduce","acc","agent","agentTasks","type","total","completed","inProgress","pending","checkpointCount","lastCheckpoint","timeline","created","lastUpdated","paused","resumed","exportSession","exportPath","exportFile","importSession","importPath","deserializeSessionData","newSessionId","checkpoint","addChildPid","childPids","includes","removeChildPid","index","indexOf","splice","open","getChildPids","stopSession","kill","err","getActiveSessionsWithProcessInfo","aliveChildPids","total_processes","cleanupOrphanedProcesses","cleanedCount","close"],"mappings":"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"}