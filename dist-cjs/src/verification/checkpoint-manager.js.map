{"version":3,"sources":["../../../src/verification/checkpoint-manager.ts"],"sourcesContent":["/**\r\n * Checkpoint Manager\r\n * Manages system state snapshots and verification checkpoints\r\n */\r\n\r\nimport { \r\n  Checkpoint, \r\n  StateSnapshot, \r\n  CheckpointScope, \r\n  CheckpointFilter,\r\n  Validation,\r\n  AgentState,\r\n  SystemState,\r\n  TaskState,\r\n  MemoryState,\r\n  FileSystemState,\r\n  DatabaseState,\r\n  StateScope,\r\n  SnapshotMetadata\r\n} from './interfaces.js';\r\nimport { createHash } from 'crypto';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport class CheckpointManager {\r\n  private checkpointStore: Map<string, Checkpoint> = new Map();\r\n  private snapshotStore: Map<string, StateSnapshot> = new Map();\r\n  private storagePath: string;\r\n\r\n  constructor(storagePath: string = '.claude-flow/checkpoints') {\r\n    this.storagePath = storagePath;\r\n    this.ensureStorageDirectory();\r\n  }\r\n\r\n  /**\r\n   * Create a new checkpoint with state snapshot\r\n   */\r\n  async createCheckpoint(\r\n    description: string, \r\n    scope: CheckpointScope,\r\n    agentId?: string,\r\n    taskId?: string,\r\n    validations: Validation[] = []\r\n  ): Promise<string> {\r\n    const checkpointId = this.generateCheckpointId();\r\n    const timestamp = Date.now();\r\n    \r\n    // Capture current system state\r\n    const stateSnapshot = await this.captureSystemState(scope, agentId, taskId);\r\n    \r\n    const checkpoint: Checkpoint = {\r\n      id: checkpointId,\r\n      type: 'during', // Default type, can be overridden\r\n      agent_id: agentId || 'system',\r\n      task_id: taskId || 'system',\r\n      timestamp,\r\n      required: true,\r\n      validations,\r\n      state_snapshot: stateSnapshot,\r\n      description,\r\n      scope\r\n    };\r\n\r\n    // Store checkpoint\r\n    await this.storeCheckpoint(checkpoint);\r\n    \r\n    console.log(`‚úÖ Checkpoint created: ${checkpointId} (${description})`);\r\n    return checkpointId;\r\n  }\r\n\r\n  /**\r\n   * Create a pre-execution checkpoint\r\n   */\r\n  async createPreExecutionCheckpoint(\r\n    agentId: string,\r\n    taskId: string,\r\n    description: string\r\n  ): Promise<string> {\r\n    const validations: Validation[] = [\r\n      {\r\n        name: 'agent_capabilities',\r\n        type: 'test',\r\n        command: 'validate-agent-capabilities',\r\n        expected_result: true,\r\n        passed: false,\r\n        weight: 0.3,\r\n        execution_time_ms: 0\r\n      },\r\n      {\r\n        name: 'resource_availability',\r\n        type: 'test',\r\n        command: 'check-resource-availability',\r\n        expected_result: true,\r\n        passed: false,\r\n        weight: 0.3,\r\n        execution_time_ms: 0\r\n      },\r\n      {\r\n        name: 'dependency_verification',\r\n        type: 'test',\r\n        command: 'verify-dependencies',\r\n        expected_result: true,\r\n        passed: false,\r\n        weight: 0.4,\r\n        execution_time_ms: 0\r\n      }\r\n    ];\r\n\r\n    const checkpointId = await this.createCheckpoint(\r\n      `Pre-execution: ${description}`,\r\n      'task',\r\n      agentId,\r\n      taskId,\r\n      validations\r\n    );\r\n\r\n    // Execute validations\r\n    await this.executeValidations(checkpointId, validations);\r\n\r\n    return checkpointId;\r\n  }\r\n\r\n  /**\r\n   * Create a post-execution checkpoint\r\n   */\r\n  async createPostExecutionCheckpoint(\r\n    agentId: string,\r\n    taskId: string,\r\n    description: string,\r\n    truthScore: number\r\n  ): Promise<string> {\r\n    const validations: Validation[] = [\r\n      {\r\n        name: 'result_verification',\r\n        type: 'test',\r\n        command: 'verify-task-results',\r\n        expected_result: true,\r\n        passed: false,\r\n        weight: 0.4,\r\n        execution_time_ms: 0\r\n      },\r\n      {\r\n        name: 'system_integrity',\r\n        type: 'test',\r\n        command: 'check-system-integrity',\r\n        expected_result: true,\r\n        passed: false,\r\n        weight: 0.3,\r\n        execution_time_ms: 0\r\n      },\r\n      {\r\n        name: 'truth_score_validation',\r\n        type: 'test',\r\n        command: 'validate-truth-score',\r\n        expected_result: truthScore >= 0.95,\r\n        passed: truthScore >= 0.95,\r\n        weight: 0.3,\r\n        execution_time_ms: 0\r\n      }\r\n    ];\r\n\r\n    const checkpointId = await this.createCheckpoint(\r\n      `Post-execution: ${description}`,\r\n      'task',\r\n      agentId,\r\n      taskId,\r\n      validations\r\n    );\r\n\r\n    // Execute validations\r\n    await this.executeValidations(checkpointId, validations);\r\n\r\n    return checkpointId;\r\n  }\r\n\r\n  /**\r\n   * List checkpoints with optional filtering\r\n   */\r\n  async listCheckpoints(filter?: CheckpointFilter): Promise<Checkpoint[]> {\r\n    let checkpoints = Array.from(this.checkpointStore.values());\r\n\r\n    if (filter) {\r\n      checkpoints = checkpoints.filter(checkpoint => {\r\n        if (filter.agent_id && checkpoint.agent_id !== filter.agent_id) return false;\r\n        if (filter.task_id && checkpoint.task_id !== filter.task_id) return false;\r\n        if (filter.type && checkpoint.type !== filter.type) return false;\r\n        if (filter.scope && checkpoint.scope !== filter.scope) return false;\r\n        if (filter.from_timestamp && checkpoint.timestamp < filter.from_timestamp) return false;\r\n        if (filter.to_timestamp && checkpoint.timestamp > filter.to_timestamp) return false;\r\n        return true;\r\n      });\r\n    }\r\n\r\n    return checkpoints.sort((a, b) => b.timestamp - a.timestamp);\r\n  }\r\n\r\n  /**\r\n   * Get a specific checkpoint\r\n   */\r\n  async getCheckpoint(checkpointId: string): Promise<Checkpoint | null> {\r\n    return this.checkpointStore.get(checkpointId) || null;\r\n  }\r\n\r\n  /**\r\n   * Delete a checkpoint\r\n   */\r\n  async deleteCheckpoint(checkpointId: string): Promise<void> {\r\n    const checkpoint = this.checkpointStore.get(checkpointId);\r\n    if (!checkpoint) {\r\n      throw new Error(`Checkpoint ${checkpointId} not found`);\r\n    }\r\n\r\n    // Remove from memory\r\n    this.checkpointStore.delete(checkpointId);\r\n    this.snapshotStore.delete(checkpoint.state_snapshot.id);\r\n\r\n    // Remove from disk\r\n    const checkpointFile = path.join(this.storagePath, `${checkpointId}.json`);\r\n    const snapshotFile = path.join(this.storagePath, 'snapshots', `${checkpoint.state_snapshot.id}.json`);\r\n\r\n    try {\r\n      await fs.unlink(checkpointFile);\r\n      await fs.unlink(snapshotFile);\r\n      console.log(`üóëÔ∏è Checkpoint deleted: ${checkpointId}`);\r\n    } catch (error) {\r\n      console.warn(`Warning: Failed to delete checkpoint files: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Capture current system state\r\n   */\r\n  private async captureSystemState(\r\n    scope: CheckpointScope,\r\n    agentId?: string,\r\n    taskId?: string\r\n  ): Promise<StateSnapshot> {\r\n    const snapshotId = this.generateSnapshotId();\r\n    const timestamp = Date.now();\r\n\r\n    const stateScope: StateScope = {\r\n      include_agents: scope !== 'local',\r\n      include_tasks: scope !== 'local',\r\n      include_memory: true,\r\n      include_filesystem: scope === 'system' || scope === 'global',\r\n      include_database: scope === 'system' || scope === 'global',\r\n      agent_filter: agentId ? [agentId] : undefined,\r\n      task_filter: taskId ? [taskId] : undefined\r\n    };\r\n\r\n    // Capture different state components based on scope\r\n    const agentStates = stateScope.include_agents ? await this.captureAgentStates(stateScope.agent_filter) : new Map();\r\n    const systemState = stateScope.include_agents ? await this.captureSystemState_Component() : {} as SystemState;\r\n    const taskStates = stateScope.include_tasks ? await this.captureTaskStates(stateScope.task_filter) : new Map();\r\n    const memoryState = stateScope.include_memory ? await this.captureMemoryState() : {} as MemoryState;\r\n    const fileSystemState = stateScope.include_filesystem ? await this.captureFileSystemState() : {} as FileSystemState;\r\n    const databaseState = stateScope.include_database ? await this.captureDatabaseState() : {} as DatabaseState;\r\n\r\n    // Calculate checksum for integrity verification\r\n    const checksum = this.calculateStateChecksum({\r\n      agentStates,\r\n      systemState,\r\n      taskStates,\r\n      memoryState,\r\n      fileSystemState,\r\n      databaseState\r\n    });\r\n\r\n    const metadata: SnapshotMetadata = {\r\n      version: '2.0',\r\n      created_by: agentId || 'system',\r\n      description: `State snapshot for ${scope} scope`,\r\n      tags: [scope, timestamp.toString()],\r\n      size_bytes: 0, // Will be calculated after serialization\r\n      compression_ratio: 1.0\r\n    };\r\n\r\n    const snapshot: StateSnapshot = {\r\n      id: snapshotId,\r\n      timestamp,\r\n      agent_states: agentStates,\r\n      system_state: systemState,\r\n      task_states: taskStates,\r\n      memory_state: memoryState,\r\n      file_system_state: fileSystemState,\r\n      database_state: databaseState,\r\n      checksum,\r\n      metadata\r\n    };\r\n\r\n    // Store snapshot\r\n    await this.storeSnapshot(snapshot);\r\n\r\n    return snapshot;\r\n  }\r\n\r\n  /**\r\n   * Capture agent states\r\n   */\r\n  private async captureAgentStates(agentFilter?: string[]): Promise<Map<string, AgentState>> {\r\n    const agentStates = new Map<string, AgentState>();\r\n    \r\n    // This would integrate with the actual agent manager\r\n    // For now, we'll simulate capturing agent states\r\n    const mockAgents = ['coordinator', 'coder', 'tester', 'researcher'];\r\n    \r\n    for (const agentId of mockAgents) {\r\n      if (agentFilter && !agentFilter.includes(agentId)) continue;\r\n      \r\n      const agentState: AgentState = {\r\n        id: agentId,\r\n        status: 'idle',\r\n        current_task: null,\r\n        capabilities: ['code', 'test', 'analyze'],\r\n        memory: {\r\n          working_memory: {},\r\n          long_term_memory: {},\r\n          shared_memory_keys: [],\r\n          memory_usage_mb: 10\r\n        },\r\n        configuration: {\r\n          model: 'claude-3-sonnet',\r\n          temperature: 0.7,\r\n          max_tokens: 4096,\r\n          timeout_ms: 30000,\r\n          retry_attempts: 3,\r\n          custom_parameters: {}\r\n        },\r\n        performance_metrics: {\r\n          response_time_p95_ms: 500,\r\n          throughput_requests_per_second: 10,\r\n          error_rate_percentage: 0.1,\r\n          cpu_usage_percentage: 5,\r\n          memory_usage_mb: 50\r\n        },\r\n        last_heartbeat: Date.now()\r\n      };\r\n      \r\n      agentStates.set(agentId, agentState);\r\n    }\r\n    \r\n    return agentStates;\r\n  }\r\n\r\n  /**\r\n   * Capture system state component\r\n   */\r\n  private async captureSystemState_Component(): Promise<SystemState> {\r\n    return {\r\n      version: '2.0.0-alpha.88',\r\n      uptime_ms: process.uptime() * 1000,\r\n      active_agents: 4,\r\n      active_tasks: 2,\r\n      memory_usage: {\r\n        cpu_usage_percentage: 15,\r\n        memory_usage_mb: 256,\r\n        disk_usage_mb: 1024,\r\n        network_io_mbps: 1.5,\r\n        file_descriptors_used: 50\r\n      },\r\n      configuration: {\r\n        max_agents: 10,\r\n        max_concurrent_tasks: 5,\r\n        truth_threshold: 0.95,\r\n        verification_enabled: true,\r\n        rollback_enabled: true\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Capture task states\r\n   */\r\n  private async captureTaskStates(taskFilter?: string[]): Promise<Map<string, TaskState>> {\r\n    const taskStates = new Map<string, TaskState>();\r\n    \r\n    // Mock task states\r\n    const mockTasks = ['task_001', 'task_002'];\r\n    \r\n    for (const taskId of mockTasks) {\r\n      if (taskFilter && !taskFilter.includes(taskId)) continue;\r\n      \r\n      const taskState: TaskState = {\r\n        id: taskId,\r\n        status: 'running',\r\n        assigned_agent: 'coder',\r\n        dependencies: [],\r\n        start_time: Date.now() - 60000,\r\n        progress_percentage: 50,\r\n        result: null\r\n      };\r\n      \r\n      taskStates.set(taskId, taskState);\r\n    }\r\n    \r\n    return taskStates;\r\n  }\r\n\r\n  /**\r\n   * Capture memory state\r\n   */\r\n  private async captureMemoryState(): Promise<MemoryState> {\r\n    return {\r\n      total_size_mb: 512,\r\n      used_size_mb: 128,\r\n      fragmentation_percentage: 10,\r\n      cache_hit_rate: 0.85,\r\n      active_sessions: 3\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Capture file system state\r\n   */\r\n  private async captureFileSystemState(): Promise<FileSystemState> {\r\n    return {\r\n      total_files: 1250,\r\n      total_size_mb: 45,\r\n      last_modified: Date.now(),\r\n      checksums: {\r\n        'package.json': 'abc123',\r\n        'src/index.ts': 'def456'\r\n      },\r\n      permissions_valid: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Capture database state\r\n   */\r\n  private async captureDatabaseState(): Promise<DatabaseState> {\r\n    return {\r\n      connection_status: 'connected',\r\n      transaction_count: 0,\r\n      pending_migrations: 0,\r\n      data_integrity_check: true,\r\n      backup_status: 'current'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate state checksum for integrity verification\r\n   */\r\n  private calculateStateChecksum(stateData: any): string {\r\n    const stateString = JSON.stringify(stateData, null, 0);\r\n    return createHash('sha256').update(stateString).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * Execute validations for a checkpoint\r\n   */\r\n  private async executeValidations(checkpointId: string, validations: Validation[]): Promise<void> {\r\n    const checkpoint = this.checkpointStore.get(checkpointId);\r\n    if (!checkpoint) return;\r\n\r\n    for (const validation of validations) {\r\n      const startTime = Date.now();\r\n      \r\n      try {\r\n        // Execute validation command\r\n        const result = await this.executeValidationCommand(validation.command, validation.expected_result);\r\n        \r\n        validation.actual_result = result;\r\n        validation.passed = this.compareResults(validation.expected_result, result);\r\n        validation.execution_time_ms = Date.now() - startTime;\r\n        \r\n      } catch (error: any) {\r\n        validation.passed = false;\r\n        validation.error_message = error.message;\r\n        validation.execution_time_ms = Date.now() - startTime;\r\n      }\r\n    }\r\n\r\n    // Update checkpoint with validation results\r\n    checkpoint.validations = validations;\r\n    await this.storeCheckpoint(checkpoint);\r\n  }\r\n\r\n  /**\r\n   * Execute a validation command\r\n   */\r\n  private async executeValidationCommand(command: string, expectedResult: any): Promise<any> {\r\n    // This would integrate with actual validation systems\r\n    switch (command) {\r\n      case 'validate-agent-capabilities':\r\n        return true; // Mock validation\r\n      case 'check-resource-availability':\r\n        return true; // Mock validation\r\n      case 'verify-dependencies':\r\n        return true; // Mock validation\r\n      case 'verify-task-results':\r\n        return true; // Mock validation\r\n      case 'check-system-integrity':\r\n        return true; // Mock validation\r\n      case 'validate-truth-score':\r\n        return expectedResult; // Pass through for truth score validation\r\n      default:\r\n        throw new Error(`Unknown validation command: ${command}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compare validation results\r\n   */\r\n  private compareResults(expected: any, actual: any): boolean {\r\n    if (typeof expected === 'boolean' && typeof actual === 'boolean') {\r\n      return expected === actual;\r\n    }\r\n    \r\n    if (typeof expected === 'number' && typeof actual === 'number') {\r\n      return Math.abs(expected - actual) < 0.001; // Allow small floating point differences\r\n    }\r\n    \r\n    return JSON.stringify(expected) === JSON.stringify(actual);\r\n  }\r\n\r\n  /**\r\n   * Store checkpoint to persistent storage\r\n   */\r\n  private async storeCheckpoint(checkpoint: Checkpoint): Promise<void> {\r\n    // Store in memory\r\n    this.checkpointStore.set(checkpoint.id, checkpoint);\r\n    \r\n    // Store to disk\r\n    const checkpointFile = path.join(this.storagePath, `${checkpoint.id}.json`);\r\n    await this.writeJsonFile(checkpointFile, checkpoint);\r\n  }\r\n\r\n  /**\r\n   * Store snapshot to persistent storage\r\n   */\r\n  private async storeSnapshot(snapshot: StateSnapshot): Promise<void> {\r\n    // Store in memory\r\n    this.snapshotStore.set(snapshot.id, snapshot);\r\n    \r\n    // Store to disk\r\n    const snapshotDir = path.join(this.storagePath, 'snapshots');\r\n    await this.ensureDirectory(snapshotDir);\r\n    \r\n    const snapshotFile = path.join(snapshotDir, `${snapshot.id}.json`);\r\n    await this.writeJsonFile(snapshotFile, snapshot);\r\n    \r\n    // Update metadata with actual file size\r\n    const stats = await fs.stat(snapshotFile);\r\n    snapshot.metadata.size_bytes = stats.size;\r\n  }\r\n\r\n  /**\r\n   * Ensure storage directory exists\r\n   */\r\n  private async ensureStorageDirectory(): Promise<void> {\r\n    await this.ensureDirectory(this.storagePath);\r\n    await this.ensureDirectory(path.join(this.storagePath, 'snapshots'));\r\n  }\r\n\r\n  /**\r\n   * Ensure directory exists\r\n   */\r\n  private async ensureDirectory(dirPath: string): Promise<void> {\r\n    try {\r\n      await fs.access(dirPath);\r\n    } catch {\r\n      await fs.mkdir(dirPath, { recursive: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write JSON file safely\r\n   */\r\n  private async writeJsonFile(filePath: string, data: any): Promise<void> {\r\n    const jsonData = JSON.stringify(data, null, 2);\r\n    await fs.writeFile(filePath, jsonData, 'utf8');\r\n  }\r\n\r\n  /**\r\n   * Generate unique checkpoint ID\r\n   */\r\n  private generateCheckpointId(): string {\r\n    return `checkpoint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Generate unique snapshot ID\r\n   */\r\n  private generateSnapshotId(): string {\r\n    return `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Load checkpoints from disk on startup\r\n   */\r\n  async loadCheckpointsFromDisk(): Promise<void> {\r\n    try {\r\n      const files = await fs.readdir(this.storagePath);\r\n      const checkpointFiles = files.filter(f => f.startsWith('checkpoint_') && f.endsWith('.json'));\r\n      \r\n      for (const file of checkpointFiles) {\r\n        const filePath = path.join(this.storagePath, file);\r\n        const data = await fs.readFile(filePath, 'utf8');\r\n        const checkpoint: Checkpoint = JSON.parse(data);\r\n        this.checkpointStore.set(checkpoint.id, checkpoint);\r\n      }\r\n      \r\n      console.log(`üìÅ Loaded ${checkpointFiles.length} checkpoints from disk`);\r\n    } catch (error) {\r\n      console.warn('Warning: Failed to load checkpoints from disk:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load snapshots from disk on startup\r\n   */\r\n  async loadSnapshotsFromDisk(): Promise<void> {\r\n    try {\r\n      const snapshotDir = path.join(this.storagePath, 'snapshots');\r\n      const files = await fs.readdir(snapshotDir);\r\n      const snapshotFiles = files.filter(f => f.startsWith('snapshot_') && f.endsWith('.json'));\r\n      \r\n      for (const file of snapshotFiles) {\r\n        const filePath = path.join(snapshotDir, file);\r\n        const data = await fs.readFile(filePath, 'utf8');\r\n        const snapshot: StateSnapshot = JSON.parse(data);\r\n        this.snapshotStore.set(snapshot.id, snapshot);\r\n      }\r\n      \r\n      console.log(`üìÅ Loaded ${snapshotFiles.length} snapshots from disk`);\r\n    } catch (error) {\r\n      console.warn('Warning: Failed to load snapshots from disk:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup old checkpoints and snapshots\r\n   */\r\n  async cleanup(retentionDays: number = 7): Promise<void> {\r\n    const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n    let deletedCount = 0;\r\n\r\n    // Cleanup checkpoints\r\n    for (const [id, checkpoint] of this.checkpointStore.entries()) {\r\n      if (checkpoint.timestamp < cutoffTime) {\r\n        await this.deleteCheckpoint(id);\r\n        deletedCount++;\r\n      }\r\n    }\r\n\r\n    console.log(`üßπ Cleaned up ${deletedCount} old checkpoints (retention: ${retentionDays} days)`);\r\n  }\r\n}"],"names":["createHash","promises","fs","path","CheckpointManager","checkpointStore","Map","snapshotStore","storagePath","ensureStorageDirectory","createCheckpoint","description","scope","agentId","taskId","validations","checkpointId","generateCheckpointId","timestamp","Date","now","stateSnapshot","captureSystemState","checkpoint","id","type","agent_id","task_id","required","state_snapshot","storeCheckpoint","console","log","createPreExecutionCheckpoint","name","command","expected_result","passed","weight","execution_time_ms","executeValidations","createPostExecutionCheckpoint","truthScore","listCheckpoints","filter","checkpoints","Array","from","values","from_timestamp","to_timestamp","sort","a","b","getCheckpoint","get","deleteCheckpoint","Error","delete","checkpointFile","join","snapshotFile","unlink","error","warn","snapshotId","generateSnapshotId","stateScope","include_agents","include_tasks","include_memory","include_filesystem","include_database","agent_filter","undefined","task_filter","agentStates","captureAgentStates","systemState","captureSystemState_Component","taskStates","captureTaskStates","memoryState","captureMemoryState","fileSystemState","captureFileSystemState","databaseState","captureDatabaseState","checksum","calculateStateChecksum","metadata","version","created_by","tags","toString","size_bytes","compression_ratio","snapshot","agent_states","system_state","task_states","memory_state","file_system_state","database_state","storeSnapshot","agentFilter","mockAgents","includes","agentState","status","current_task","capabilities","memory","working_memory","long_term_memory","shared_memory_keys","memory_usage_mb","configuration","model","temperature","max_tokens","timeout_ms","retry_attempts","custom_parameters","performance_metrics","response_time_p95_ms","throughput_requests_per_second","error_rate_percentage","cpu_usage_percentage","last_heartbeat","set","uptime_ms","process","uptime","active_agents","active_tasks","memory_usage","disk_usage_mb","network_io_mbps","file_descriptors_used","max_agents","max_concurrent_tasks","truth_threshold","verification_enabled","rollback_enabled","taskFilter","mockTasks","taskState","assigned_agent","dependencies","start_time","progress_percentage","result","total_size_mb","used_size_mb","fragmentation_percentage","cache_hit_rate","active_sessions","total_files","last_modified","checksums","permissions_valid","connection_status","transaction_count","pending_migrations","data_integrity_check","backup_status","stateData","stateString","JSON","stringify","update","digest","validation","startTime","executeValidationCommand","actual_result","compareResults","error_message","message","expectedResult","expected","actual","Math","abs","writeJsonFile","snapshotDir","ensureDirectory","stats","stat","size","dirPath","access","mkdir","recursive","filePath","data","jsonData","writeFile","random","substr","loadCheckpointsFromDisk","files","readdir","checkpointFiles","f","startsWith","endsWith","file","readFile","parse","length","loadSnapshotsFromDisk","snapshotFiles","cleanup","retentionDays","cutoffTime","deletedCount","entries"],"mappings":"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"}