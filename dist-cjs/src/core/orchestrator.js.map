{"version":3,"sources":["../../../src/core/orchestrator.ts"],"sourcesContent":["/**\r\n * Main orchestrator for Claude-Flow\r\n */\r\n\r\nimport {\r\n  Config,\r\n  SystemEvents,\r\n  AgentProfile,\r\n  AgentSession,\r\n  Task,\r\n  HealthStatus,\r\n  ComponentHealth,\r\n  TaskStatus,\r\n  OrchestratorMetrics,\r\n} from '../utils/types.js';\r\nimport { IEventBus } from './event-bus.js';\r\nimport type { ILogger } from './logger.js';\r\nimport type { ITerminalManager } from '../terminal/manager.js';\r\nimport type { IMemoryManager } from '../memory/manager.js';\r\nimport type { ICoordinationManager } from '../coordination/manager.js';\r\nimport type { IMCPServer } from '../mcp/server.js';\r\nimport { SystemError, InitializationError, ShutdownError } from '../utils/errors.js';\r\nimport { delay, retry, circuitBreaker, CircuitBreaker } from '../utils/helpers.js';\r\nimport { mkdir, writeFile, readFile } from 'fs/promises';\r\nimport { join, dirname } from 'path';\r\nimport { ClaudeAPIClient } from '../api/claude-client.js';\r\nimport { ConfigManager } from '../config/config-manager.js';\r\nimport { ParallelSwarmExecutor, type ParallelAgentConfig } from '../sdk/session-forking.js';\r\nimport { RealTimeQueryController } from '../sdk/query-control.js';\r\n\r\nexport interface ISessionManager {\r\n  createSession(profile: AgentProfile): Promise<AgentSession>;\r\n  getSession(sessionId: string): AgentSession | undefined;\r\n  getActiveSessions(): AgentSession[];\r\n  terminateSession(sessionId: string): Promise<void>;\r\n  terminateAllSessions(): Promise<void>;\r\n  persistSessions(): Promise<void>;\r\n  restoreSessions(): Promise<void>;\r\n  removeSession(sessionId: string): void;\r\n}\r\n\r\nexport interface IOrchestrator {\r\n  initialize(): Promise<void>;\r\n  shutdown(): Promise<void>;\r\n  spawnAgent(profile: AgentProfile): Promise<string>;\r\n  spawnParallelAgents(profiles: AgentProfile[]): Promise<Map<string, string>>;\r\n  terminateAgent(agentId: string): Promise<void>;\r\n  assignTask(task: Task): Promise<void>;\r\n  getHealthStatus(): Promise<HealthStatus>;\r\n  getMetrics(): Promise<OrchestratorMetrics>;\r\n  performMaintenance(): Promise<void>;\r\n}\r\n\r\nexport interface SessionPersistence {\r\n  sessions: Array<AgentSession & { profile: AgentProfile }>;\r\n  taskQueue: Task[];\r\n  metrics: {\r\n    completedTasks: number;\r\n    failedTasks: number;\r\n    totalTaskDuration: number;\r\n  };\r\n  savedAt: Date;\r\n}\r\n\r\n/**\r\n * Session manager implementation with persistence\r\n */\r\nclass SessionManager implements ISessionManager {\r\n  private sessions = new Map<string, AgentSession>();\r\n  private sessionProfiles = new Map<string, AgentProfile>();\r\n  private persistencePath: string;\r\n  private persistenceCircuitBreaker: CircuitBreaker;\r\n\r\n  constructor(\r\n    private terminalManager: ITerminalManager,\r\n    private memoryManager: IMemoryManager,\r\n    private eventBus: IEventBus,\r\n    private logger: ILogger,\r\n    private config: Config,\r\n  ) {\r\n    this.persistencePath = join(config.orchestrator.dataDir || './data', 'sessions.json');\r\n\r\n    // Circuit breaker for persistence operations\r\n    this.persistenceCircuitBreaker = circuitBreaker('SessionPersistence', {\r\n      threshold: 5,\r\n      timeout: 30000,\r\n      resetTimeout: 60000,\r\n    });\r\n  }\r\n\r\n  async createSession(profile: AgentProfile): Promise<AgentSession> {\r\n    try {\r\n      // Create terminal with retry logic\r\n      const terminalId = await retry(() => this.terminalManager.spawnTerminal(profile), {\r\n        maxAttempts: 3,\r\n        initialDelay: 1000,\r\n      });\r\n\r\n      // Create memory bank with retry logic\r\n      const memoryBankId = await retry(() => this.memoryManager.createBank(profile.id), {\r\n        maxAttempts: 3,\r\n        initialDelay: 1000,\r\n      });\r\n\r\n      // Create session\r\n      const session: AgentSession = {\r\n        id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        agentId: profile.id,\r\n        terminalId,\r\n        startTime: new Date(),\r\n        status: 'active',\r\n        lastActivity: new Date(),\r\n        memoryBankId,\r\n      };\r\n\r\n      this.sessions.set(session.id, session);\r\n      this.sessionProfiles.set(session.id, profile);\r\n\r\n      this.logger.info('Session created', {\r\n        sessionId: session.id,\r\n        agentId: profile.id,\r\n        terminalId,\r\n        memoryBankId,\r\n      });\r\n\r\n      // Persist sessions asynchronously\r\n      this.persistSessions().catch((error) =>\r\n        this.logger.error('Failed to persist sessions', error),\r\n      );\r\n\r\n      return session;\r\n    } catch (error) {\r\n      this.logger.error('Failed to create session', { agentId: profile.id, error });\r\n      throw new SystemError(`Failed to create session for agent ${profile.id}`, { error });\r\n    }\r\n  }\r\n\r\n  getSession(sessionId: string): AgentSession | undefined {\r\n    return this.sessions.get(sessionId);\r\n  }\r\n\r\n  getActiveSessions(): AgentSession[] {\r\n    return Array.from(this.sessions.values()).filter(\r\n      (session) => session.status === 'active' || session.status === 'idle',\r\n    );\r\n  }\r\n\r\n  async terminateSession(sessionId: string): Promise<void> {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) {\r\n      throw new Error(`Session not found: ${sessionId}`);\r\n    }\r\n\r\n    try {\r\n      // Update session status first\r\n      session.status = 'terminated';\r\n      session.endTime = new Date();\r\n\r\n      // Terminate terminal with timeout\r\n      await Promise.race([\r\n        this.terminalManager.terminateTerminal(session.terminalId),\r\n        delay(5000).then(() => {\r\n          throw new Error('Terminal termination timeout');\r\n        }),\r\n      ]).catch((error) => {\r\n        this.logger.error('Error terminating terminal', { sessionId, error });\r\n      });\r\n\r\n      // Close memory bank with timeout\r\n      await Promise.race([\r\n        this.memoryManager.closeBank(session.memoryBankId),\r\n        delay(5000).then(() => {\r\n          throw new Error('Memory bank close timeout');\r\n        }),\r\n      ]).catch((error) => {\r\n        this.logger.error('Error closing memory bank', { sessionId, error });\r\n      });\r\n\r\n      // Clean up\r\n      this.sessionProfiles.delete(sessionId);\r\n\r\n      this.logger.info('Session terminated', {\r\n        sessionId,\r\n        duration: session.endTime.getTime() - session.startTime.getTime(),\r\n      });\r\n\r\n      // Persist sessions asynchronously\r\n      this.persistSessions().catch((error) =>\r\n        this.logger.error('Failed to persist sessions', error),\r\n      );\r\n    } catch (error) {\r\n      this.logger.error('Error during session termination', { sessionId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async terminateAllSessions(): Promise<void> {\r\n    const sessions = this.getActiveSessions();\r\n\r\n    // Terminate sessions in batches to avoid overwhelming the system\r\n    const batchSize = 5;\r\n    for (let i = 0; i < sessions.length; i += batchSize) {\r\n      const batch = sessions.slice(i, i + batchSize);\r\n      await Promise.allSettled(batch.map((session) => this.terminateSession(session.id)));\r\n    }\r\n  }\r\n\r\n  removeSession(sessionId: string): void {\r\n    this.sessions.delete(sessionId);\r\n    this.sessionProfiles.delete(sessionId);\r\n  }\r\n\r\n  async persistSessions(): Promise<void> {\r\n    if (!this.config.orchestrator.persistSessions) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await this.persistenceCircuitBreaker.execute(async () => {\r\n        const data: SessionPersistence = {\r\n          sessions: Array.from(this.sessions.values())\r\n            .map((session) => ({\r\n              ...session,\r\n              profile: this.sessionProfiles.get(session.id)!,\r\n            }))\r\n            .filter((s) => s.profile),\r\n          taskQueue: [],\r\n          metrics: {\r\n            completedTasks: 0,\r\n            failedTasks: 0,\r\n            totalTaskDuration: 0,\r\n          },\r\n          savedAt: new Date(),\r\n        };\r\n\r\n        await mkdir(dirname(this.persistencePath), { recursive: true });\r\n        await writeFile(this.persistencePath, JSON.stringify(data, null, 2), 'utf8');\r\n\r\n        this.logger.debug('Sessions persisted', { count: data.sessions.length });\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to persist sessions', error);\r\n    }\r\n  }\r\n\r\n  async restoreSessions(): Promise<void> {\r\n    if (!this.config.orchestrator.persistSessions) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const data = await readFile(this.persistencePath, 'utf8');\r\n      const persistence: SessionPersistence = JSON.parse(data);\r\n\r\n      // Restore only active/idle sessions\r\n      const sessionsToRestore = persistence.sessions.filter(\r\n        (s) => s.status === 'active' || s.status === 'idle',\r\n      );\r\n\r\n      for (const sessionData of sessionsToRestore) {\r\n        try {\r\n          // Recreate session\r\n          const session = await this.createSession(sessionData.profile);\r\n\r\n          // Update with persisted data\r\n          Object.assign(session, {\r\n            id: sessionData.id,\r\n            startTime: new Date(sessionData.startTime),\r\n            lastActivity: new Date(sessionData.lastActivity),\r\n          });\r\n\r\n          this.logger.info('Session restored', { sessionId: session.id });\r\n        } catch (error) {\r\n          this.logger.error('Failed to restore session', {\r\n            sessionId: sessionData.id,\r\n            error,\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\r\n        this.logger.error('Failed to restore sessions', error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Main orchestrator implementation with enhanced features\r\n */\r\nexport class Orchestrator implements IOrchestrator {\r\n  private initialized = false;\r\n  private shutdownInProgress = false;\r\n  private sessionManager: ISessionManager;\r\n  private healthCheckInterval?: number;\r\n  private maintenanceInterval?: number;\r\n  private metricsInterval?: number;\r\n  private agents = new Map<string, AgentProfile>();\r\n  private taskQueue: Task[] = [];\r\n  private taskHistory = new Map<string, Task>();\r\n  private startTime = Date.now();\r\n  private claudeClient?: ClaudeAPIClient;\r\n  private configManager: ConfigManager;\r\n  private parallelExecutor?: ParallelSwarmExecutor;\r\n  private queryController?: RealTimeQueryController;\r\n\r\n  // Metrics tracking\r\n  private metrics = {\r\n    completedTasks: 0,\r\n    failedTasks: 0,\r\n    totalTaskDuration: 0,\r\n  };\r\n\r\n  // Circuit breakers for critical operations\r\n  private healthCheckCircuitBreaker: CircuitBreaker;\r\n  private taskAssignmentCircuitBreaker: CircuitBreaker;\r\n\r\n  constructor(\r\n    private config: Config,\r\n    private terminalManager: ITerminalManager,\r\n    private memoryManager: IMemoryManager,\r\n    private coordinationManager: ICoordinationManager,\r\n    private mcpServer: IMCPServer,\r\n    private eventBus: IEventBus,\r\n    private logger: ILogger,\r\n  ) {\r\n    this.sessionManager = new SessionManager(\r\n      terminalManager,\r\n      memoryManager,\r\n      eventBus,\r\n      logger,\r\n      config,\r\n    );\r\n\r\n    this.configManager = ConfigManager.getInstance();\r\n\r\n    // Initialize circuit breakers\r\n    this.healthCheckCircuitBreaker = circuitBreaker('HealthCheck', {\r\n      threshold: 3,\r\n      timeout: 10000,\r\n      resetTimeout: 30000,\r\n    });\r\n\r\n    this.taskAssignmentCircuitBreaker = circuitBreaker('TaskAssignment', {\r\n      threshold: 5,\r\n      timeout: 5000,\r\n      resetTimeout: 20000,\r\n    });\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.initialized) {\r\n      throw new InitializationError('Orchestrator already initialized');\r\n    }\r\n\r\n    this.logger.info('Initializing orchestrator...');\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Initialize components in parallel where possible\r\n      await Promise.all([\r\n        this.initializeComponent('Terminal Manager', () => this.terminalManager.initialize()),\r\n        this.initializeComponent('Memory Manager', () => this.memoryManager.initialize()),\r\n        this.initializeComponent('Coordination Manager', () =>\r\n          this.coordinationManager.initialize(),\r\n        ),\r\n      ]);\r\n\r\n      // MCP server needs to be started after other components\r\n      await this.initializeComponent('MCP Server', () => this.mcpServer.start());\r\n\r\n      // Initialize Claude API client if configured\r\n      if (this.configManager.isClaudeAPIConfigured()) {\r\n        try {\r\n          this.claudeClient = new ClaudeAPIClient(this.logger, this.configManager);\r\n          this.logger.info('Claude API client initialized', {\r\n            model: this.claudeClient.getConfig().model,\r\n            temperature: this.claudeClient.getConfig().temperature,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Failed to initialize Claude API client', error);\r\n        }\r\n      }\r\n\r\n      // Initialize parallel executor and query controller\r\n      this.parallelExecutor = new ParallelSwarmExecutor();\r\n      this.queryController = new RealTimeQueryController({\r\n        allowPause: true,\r\n        allowModelChange: true,\r\n        allowPermissionChange: true,\r\n        monitoringInterval: 1000\r\n      });\r\n\r\n      this.logger.info('Session forking and query control initialized', {\r\n        parallelExecutor: 'enabled',\r\n        queryController: 'enabled'\r\n      });\r\n\r\n      // Restore persisted sessions\r\n      await this.sessionManager.restoreSessions();\r\n\r\n      // Set up event handlers\r\n      this.setupEventHandlers();\r\n\r\n      // Start background tasks\r\n      this.startHealthChecks();\r\n      this.startMaintenanceTasks();\r\n      this.startMetricsCollection();\r\n\r\n      this.initialized = true;\r\n\r\n      const initDuration = Date.now() - startTime;\r\n      this.eventBus.emit(SystemEvents.SYSTEM_READY, { timestamp: new Date() });\r\n      this.logger.info('Orchestrator initialized successfully', { duration: initDuration });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize orchestrator', error);\r\n\r\n      // Attempt cleanup on initialization failure\r\n      await this.emergencyShutdown();\r\n\r\n      throw new InitializationError('Orchestrator', { error });\r\n    }\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    if (!this.initialized || this.shutdownInProgress) {\r\n      return;\r\n    }\r\n\r\n    this.shutdownInProgress = true;\r\n    this.logger.info('Shutting down orchestrator...');\r\n    const shutdownStart = Date.now();\r\n\r\n    try {\r\n      // Stop background tasks\r\n      this.stopBackgroundTasks();\r\n\r\n      // Save current state\r\n      await this.sessionManager.persistSessions();\r\n\r\n      // Process any remaining critical tasks\r\n      await this.processShutdownTasks();\r\n\r\n      // Terminate all sessions\r\n      await this.sessionManager.terminateAllSessions();\r\n\r\n      // Shutdown components with timeout\r\n      await Promise.race([\r\n        this.shutdownComponents(),\r\n        delay(this.config.orchestrator.shutdownTimeout),\r\n      ]);\r\n\r\n      const shutdownDuration = Date.now() - shutdownStart;\r\n      this.eventBus.emit(SystemEvents.SYSTEM_SHUTDOWN, { reason: 'Graceful shutdown' });\r\n      this.logger.info('Orchestrator shutdown complete', { duration: shutdownDuration });\r\n    } catch (error) {\r\n      this.logger.error('Error during shutdown', error);\r\n\r\n      // Force shutdown if graceful shutdown fails\r\n      await this.emergencyShutdown();\r\n\r\n      throw new ShutdownError('Failed to shutdown gracefully', { error });\r\n    } finally {\r\n      this.initialized = false;\r\n      this.shutdownInProgress = false;\r\n    }\r\n  }\r\n\r\n  async spawnAgent(profile: AgentProfile): Promise<string> {\r\n    if (!this.initialized) {\r\n      throw new SystemError('Orchestrator not initialized');\r\n    }\r\n\r\n    // Check agent limit\r\n    if (this.agents.size >= this.config.orchestrator.maxConcurrentAgents) {\r\n      throw new SystemError('Maximum concurrent agents reached');\r\n    }\r\n\r\n    // Validate agent profile\r\n    this.validateAgentProfile(profile);\r\n\r\n    this.logger.info('Spawning agent', { agentId: profile.id, type: profile.type });\r\n\r\n    try {\r\n      // Create session with retry\r\n      const session = await retry(() => this.sessionManager.createSession(profile), {\r\n        maxAttempts: 3,\r\n        initialDelay: 2000,\r\n      });\r\n\r\n      // Store agent profile\r\n      this.agents.set(profile.id, profile);\r\n\r\n      // Emit event\r\n      this.eventBus.emit(SystemEvents.AGENT_SPAWNED, {\r\n        agentId: profile.id,\r\n        profile,\r\n        sessionId: session.id,\r\n      });\r\n\r\n      // Start agent health monitoring\r\n      this.startAgentHealthMonitoring(profile.id);\r\n\r\n      return session.id;\r\n    } catch (error) {\r\n      this.logger.error('Failed to spawn agent', { agentId: profile.id, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawn multiple agents in parallel using session forking\r\n   * Achieves 10-20x performance improvement over sequential spawning\r\n   */\r\n  async spawnParallelAgents(profiles: AgentProfile[]): Promise<Map<string, string>> {\r\n    if (!this.initialized) {\r\n      throw new SystemError('Orchestrator not initialized');\r\n    }\r\n\r\n    if (!this.parallelExecutor) {\r\n      throw new SystemError('Parallel executor not initialized');\r\n    }\r\n\r\n    // Check agent limit\r\n    if (this.agents.size + profiles.length > this.config.orchestrator.maxConcurrentAgents) {\r\n      throw new SystemError('Would exceed maximum concurrent agents');\r\n    }\r\n\r\n    // Validate all profiles\r\n    profiles.forEach(profile => this.validateAgentProfile(profile));\r\n\r\n    this.logger.info('Spawning parallel agents', {\r\n      count: profiles.length,\r\n      types: profiles.map(p => p.type)\r\n    });\r\n\r\n    try {\r\n      // Convert profiles to agent configs\r\n      const agentConfigs: ParallelAgentConfig[] = profiles.map(profile => ({\r\n        agentId: profile.id,\r\n        agentType: profile.type,\r\n        task: `Initialize ${profile.type} agent with capabilities: ${profile.capabilities.join(', ')}`,\r\n        capabilities: profile.capabilities,\r\n        priority: profile.priority >= 90 ? 'critical' :\r\n                  profile.priority >= 70 ? 'high' :\r\n                  profile.priority >= 40 ? 'medium' : 'low',\r\n        timeout: 60000\r\n      }));\r\n\r\n      // Execute parallel spawning using session forking\r\n      const result = await this.parallelExecutor.spawnParallelAgents(agentConfigs, {\r\n        maxParallelAgents: Math.min(profiles.length, 10),\r\n        timeout: 60000,\r\n        model: 'claude-sonnet-4'\r\n      });\r\n\r\n      // Create session mappings\r\n      const sessionMap = new Map<string, string>();\r\n\r\n      // Store successful agents\r\n      for (const profile of profiles) {\r\n        if (result.successfulAgents.includes(profile.id)) {\r\n          // Create a lightweight session for the forked agent\r\n          const session: AgentSession = {\r\n            id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n            agentId: profile.id,\r\n            terminalId: 'forked',\r\n            startTime: new Date(),\r\n            status: 'active',\r\n            lastActivity: new Date(),\r\n            memoryBankId: `memory_${profile.id}`\r\n          };\r\n\r\n          this.agents.set(profile.id, profile);\r\n          sessionMap.set(profile.id, session.id);\r\n\r\n          // Emit event\r\n          this.eventBus.emit(SystemEvents.AGENT_SPAWNED, {\r\n            agentId: profile.id,\r\n            profile,\r\n            sessionId: session.id,\r\n            parallel: true\r\n          });\r\n\r\n          // Start health monitoring\r\n          this.startAgentHealthMonitoring(profile.id);\r\n        }\r\n      }\r\n\r\n      this.logger.info('Parallel agent spawning completed', {\r\n        successful: result.successfulAgents.length,\r\n        failed: result.failedAgents.length,\r\n        duration: result.totalDuration,\r\n        performanceGain: this.parallelExecutor.getMetrics().performanceGain\r\n      });\r\n\r\n      return sessionMap;\r\n    } catch (error) {\r\n      this.logger.error('Failed to spawn parallel agents', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async terminateAgent(agentId: string): Promise<void> {\r\n    if (!this.initialized) {\r\n      throw new SystemError('Orchestrator not initialized');\r\n    }\r\n\r\n    const profile = this.agents.get(agentId);\r\n    if (!profile) {\r\n      throw new SystemError(`Agent not found: ${agentId}`);\r\n    }\r\n\r\n    this.logger.info('Terminating agent', { agentId });\r\n\r\n    try {\r\n      // Cancel any assigned tasks\r\n      await this.cancelAgentTasks(agentId);\r\n\r\n      // Find and terminate all sessions for this agent\r\n      const sessions = this.sessionManager\r\n        .getActiveSessions()\r\n        .filter((session) => session.agentId === agentId);\r\n\r\n      await Promise.allSettled(\r\n        sessions.map((session) => this.sessionManager.terminateSession(session.id)),\r\n      );\r\n\r\n      // Remove agent\r\n      this.agents.delete(agentId);\r\n\r\n      // Emit event\r\n      this.eventBus.emit(SystemEvents.AGENT_TERMINATED, {\r\n        agentId,\r\n        reason: 'User requested',\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to terminate agent', { agentId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async assignTask(task: Task): Promise<void> {\r\n    if (!this.initialized) {\r\n      throw new SystemError('Orchestrator not initialized');\r\n    }\r\n\r\n    // Validate task\r\n    this.validateTask(task);\r\n\r\n    // Store task in history\r\n    this.taskHistory.set(task.id, task);\r\n\r\n    try {\r\n      await this.taskAssignmentCircuitBreaker.execute(async () => {\r\n        // Add to queue if no agent assigned\r\n        if (!task.assignedAgent) {\r\n          if (this.taskQueue.length >= this.config.orchestrator.taskQueueSize) {\r\n            throw new SystemError('Task queue is full');\r\n          }\r\n\r\n          this.taskQueue.push(task);\r\n          this.eventBus.emit(SystemEvents.TASK_CREATED, { task });\r\n\r\n          // Try to assign immediately\r\n          await this.processTaskQueue();\r\n          return;\r\n        }\r\n\r\n        // Assign to specific agent\r\n        const agent = this.agents.get(task.assignedAgent);\r\n        if (!agent) {\r\n          throw new SystemError(`Agent not found: ${task.assignedAgent}`);\r\n        }\r\n\r\n        await this.coordinationManager.assignTask(task, task.assignedAgent);\r\n\r\n        this.eventBus.emit(SystemEvents.TASK_ASSIGNED, {\r\n          taskId: task.id,\r\n          agentId: task.assignedAgent,\r\n        });\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to assign task', { taskId: task.id, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getHealthStatus(): Promise<HealthStatus> {\r\n    try {\r\n      return await this.healthCheckCircuitBreaker.execute(async () => {\r\n        const components: Record<string, ComponentHealth> = {};\r\n\r\n        // Check all components in parallel\r\n        const [terminal, memory, coordination, mcp] = await Promise.allSettled([\r\n          this.getComponentHealth(\r\n            'Terminal Manager',\r\n            async () => await this.terminalManager.getHealthStatus(),\r\n          ),\r\n          this.getComponentHealth(\r\n            'Memory Manager',\r\n            async () => await this.memoryManager.getHealthStatus(),\r\n          ),\r\n          this.getComponentHealth(\r\n            'Coordination Manager',\r\n            async () => await this.coordinationManager.getHealthStatus(),\r\n          ),\r\n          this.getComponentHealth('MCP Server', async () => await this.mcpServer.getHealthStatus()),\r\n        ]);\r\n\r\n        // Process results\r\n        components.terminal = this.processHealthResult(terminal, 'Terminal Manager');\r\n        components.memory = this.processHealthResult(memory, 'Memory Manager');\r\n        components.coordination = this.processHealthResult(coordination, 'Coordination Manager');\r\n        components.mcp = this.processHealthResult(mcp, 'MCP Server');\r\n\r\n        // Add orchestrator self-check\r\n        components.orchestrator = {\r\n          name: 'Orchestrator',\r\n          status: 'healthy',\r\n          lastCheck: new Date(),\r\n          metrics: {\r\n            uptime: Date.now() - this.startTime,\r\n            activeAgents: this.agents.size,\r\n            queuedTasks: this.taskQueue.length,\r\n            memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024, // MB\r\n          },\r\n        };\r\n\r\n        // Determine overall status\r\n        const statuses = Object.values(components).map((c) => c.status);\r\n        let overallStatus: HealthStatus['status'] = 'healthy';\r\n\r\n        if (statuses.some((s) => s === 'unhealthy')) {\r\n          overallStatus = 'unhealthy';\r\n        } else if (statuses.some((s) => s === 'degraded')) {\r\n          overallStatus = 'degraded';\r\n        }\r\n\r\n        return {\r\n          status: overallStatus,\r\n          components,\r\n          timestamp: new Date(),\r\n        };\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Health check failed', error);\r\n\r\n      // Return degraded status if health check fails\r\n      return {\r\n        status: 'degraded',\r\n        components: {\r\n          orchestrator: {\r\n            name: 'Orchestrator',\r\n            status: 'degraded',\r\n            lastCheck: new Date(),\r\n            error: 'Health check circuit breaker open',\r\n          },\r\n        },\r\n        timestamp: new Date(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async getMetrics(): Promise<OrchestratorMetrics> {\r\n    const memUsage = process.memoryUsage();\r\n    const cpuUsage = process.cpuUsage();\r\n\r\n    const avgTaskDuration =\r\n      this.metrics.completedTasks > 0\r\n        ? this.metrics.totalTaskDuration / this.metrics.completedTasks\r\n        : 0;\r\n\r\n    return {\r\n      uptime: Date.now() - this.startTime,\r\n      totalAgents: this.agents.size,\r\n      activeAgents: this.sessionManager.getActiveSessions().length,\r\n      totalTasks: this.taskHistory.size,\r\n      completedTasks: this.metrics.completedTasks,\r\n      failedTasks: this.metrics.failedTasks,\r\n      queuedTasks: this.taskQueue.length,\r\n      avgTaskDuration,\r\n      memoryUsage: memUsage,\r\n      cpuUsage: cpuUsage,\r\n      timestamp: new Date(),\r\n    };\r\n  }\r\n\r\n  async performMaintenance(): Promise<void> {\r\n    this.logger.debug('Performing maintenance tasks');\r\n\r\n    try {\r\n      // Clean up terminated sessions\r\n      await this.cleanupTerminatedSessions();\r\n\r\n      // Clean up old task history\r\n      await this.cleanupTaskHistory();\r\n\r\n      // Perform component maintenance\r\n      await Promise.allSettled([\r\n        this.terminalManager.performMaintenance(),\r\n        this.memoryManager.performMaintenance(),\r\n        this.coordinationManager.performMaintenance(),\r\n      ]);\r\n\r\n      // Persist current state\r\n      await this.sessionManager.persistSessions();\r\n\r\n      // Force garbage collection if available\r\n      if (global.gc) {\r\n        global.gc();\r\n      }\r\n\r\n      this.logger.debug('Maintenance tasks completed');\r\n    } catch (error) {\r\n      this.logger.error('Error during maintenance', error);\r\n    }\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    // Handle task lifecycle events\r\n    this.eventBus.on(SystemEvents.TASK_STARTED, (data: unknown) => {\r\n      const { taskId, agentId } = data as { taskId: string; agentId: string };\r\n      const task = this.taskHistory.get(taskId);\r\n      if (task) {\r\n        task.status = 'running';\r\n        task.startedAt = new Date();\r\n      }\r\n    });\r\n\r\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: unknown) => {\r\n      const { taskId, result } = data as { taskId: string; result: unknown };\r\n      const task = this.taskHistory.get(taskId);\r\n      if (task) {\r\n        task.status = 'completed';\r\n        task.completedAt = new Date();\r\n        if (result !== undefined) {\r\n          task.output = result as Record<string, unknown>;\r\n        }\r\n\r\n        // Update metrics\r\n        this.metrics.completedTasks++;\r\n        if (task.startedAt) {\r\n          this.metrics.totalTaskDuration += task.completedAt.getTime() - task.startedAt.getTime();\r\n        }\r\n      }\r\n\r\n      await this.processTaskQueue();\r\n    });\r\n\r\n    this.eventBus.on(SystemEvents.TASK_FAILED, async (data: unknown) => {\r\n      const { taskId, error } = data as { taskId: string; error: Error };\r\n      const task = this.taskHistory.get(taskId);\r\n      if (task) {\r\n        task.status = 'failed';\r\n        task.completedAt = new Date();\r\n        task.error = error;\r\n\r\n        // Update metrics\r\n        this.metrics.failedTasks++;\r\n      }\r\n\r\n      // Retry or requeue based on configuration\r\n      await this.handleTaskFailure(taskId, error);\r\n    });\r\n\r\n    // Handle agent events\r\n    this.eventBus.on(SystemEvents.AGENT_ERROR, async (data: unknown) => {\r\n      const { agentId, error } = data as { agentId: string; error: Error };\r\n      this.logger.error('Agent error', { agentId, error });\r\n\r\n      // Implement agent recovery\r\n      await this.handleAgentError(agentId, error);\r\n    });\r\n\r\n    this.eventBus.on(SystemEvents.AGENT_IDLE, async (data: unknown) => {\r\n      const { agentId } = data as { agentId: string };\r\n      // Update session status\r\n      const sessions = this.sessionManager.getActiveSessions().filter((s) => s.agentId === agentId);\r\n      sessions.forEach((s) => (s.status = 'idle'));\r\n\r\n      // Try to assign queued tasks\r\n      await this.processTaskQueue();\r\n    });\r\n\r\n    // Handle system events\r\n    this.eventBus.on(SystemEvents.SYSTEM_ERROR, (data: unknown) => {\r\n      const { error, component } = data as { error: Error; component: string };\r\n      this.logger.error('System error', { component, error });\r\n\r\n      // Implement system-level error recovery\r\n      this.handleSystemError(component, error);\r\n    });\r\n\r\n    // Handle resource events\r\n    this.eventBus.on(SystemEvents.DEADLOCK_DETECTED, (data: unknown) => {\r\n      const { agents, resources } = data as { agents: string[]; resources: string[] };\r\n      this.logger.error('Deadlock detected', { agents, resources });\r\n\r\n      // Implement deadlock resolution\r\n      this.resolveDeadlock(agents, resources);\r\n    });\r\n  }\r\n\r\n  private startHealthChecks(): void {\r\n    this.healthCheckInterval = setInterval(async () => {\r\n      try {\r\n        const health = await this.getHealthStatus();\r\n        this.eventBus.emit(SystemEvents.SYSTEM_HEALTHCHECK, { status: health });\r\n\r\n        if (health.status === 'unhealthy') {\r\n          this.logger.warn('System health check failed', health);\r\n\r\n          // Attempt recovery for unhealthy components\r\n          await this.recoverUnhealthyComponents(health);\r\n        }\r\n      } catch (error) {\r\n        this.logger.error('Health check error', error);\r\n      }\r\n    }, this.config.orchestrator.healthCheckInterval);\r\n  }\r\n\r\n  private startMaintenanceTasks(): void {\r\n    this.maintenanceInterval = setInterval(async () => {\r\n      await this.performMaintenance();\r\n    }, this.config.orchestrator.maintenanceInterval || 300000); // 5 minutes default\r\n  }\r\n\r\n  private startMetricsCollection(): void {\r\n    this.metricsInterval = setInterval(async () => {\r\n      try {\r\n        const metrics = await this.getMetrics();\r\n        this.logger.debug('Metrics collected', metrics);\r\n\r\n        // Emit metrics event for monitoring systems\r\n        this.eventBus.emit('metrics:collected', metrics);\r\n      } catch (error) {\r\n        this.logger.error('Metrics collection error', error);\r\n      }\r\n    }, this.config.orchestrator.metricsInterval || 60000); // 1 minute default\r\n  }\r\n\r\n  private stopBackgroundTasks(): void {\r\n    if (this.healthCheckInterval) {\r\n      clearInterval(this.healthCheckInterval);\r\n    }\r\n    if (this.maintenanceInterval) {\r\n      clearInterval(this.maintenanceInterval);\r\n    }\r\n    if (this.metricsInterval) {\r\n      clearInterval(this.metricsInterval);\r\n    }\r\n  }\r\n\r\n  private async shutdownComponents(): Promise<void> {\r\n    const shutdownTasks = [\r\n      this.shutdownComponent('Terminal Manager', () => this.terminalManager.shutdown()),\r\n      this.shutdownComponent('Memory Manager', () => this.memoryManager.shutdown()),\r\n      this.shutdownComponent('Coordination Manager', () => this.coordinationManager.shutdown()),\r\n      this.shutdownComponent('MCP Server', () => this.mcpServer.stop()),\r\n    ];\r\n\r\n    const results = await Promise.allSettled(shutdownTasks);\r\n\r\n    // Log any shutdown failures\r\n    results.forEach((result, index) => {\r\n      if (result.status === 'rejected') {\r\n        const componentName = [\r\n          'Terminal Manager',\r\n          'Memory Manager',\r\n          'Coordination Manager',\r\n          'MCP Server',\r\n        ][index];\r\n        this.logger.error(`Failed to shutdown ${componentName}`, result.reason);\r\n      }\r\n    });\r\n  }\r\n\r\n  private async emergencyShutdown(): Promise<void> {\r\n    this.logger.warn('Performing emergency shutdown');\r\n\r\n    try {\r\n      // Force stop all components\r\n      await Promise.allSettled([\r\n        this.terminalManager.shutdown().catch(() => {}),\r\n        this.memoryManager.shutdown().catch(() => {}),\r\n        this.coordinationManager.shutdown().catch(() => {}),\r\n        this.mcpServer.stop().catch(() => {}),\r\n      ]);\r\n    } catch (error) {\r\n      this.logger.error('Emergency shutdown error', error);\r\n    }\r\n  }\r\n\r\n  private async processTaskQueue(): Promise<void> {\r\n    if (this.taskQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const availableAgents = await this.getAvailableAgents();\r\n\r\n    while (this.taskQueue.length > 0 && availableAgents.length > 0) {\r\n      const task = this.taskQueue.shift()!;\r\n      const agent = this.selectAgentForTask(task, availableAgents);\r\n\r\n      if (agent) {\r\n        task.assignedAgent = agent.id;\r\n        task.status = 'assigned';\r\n\r\n        try {\r\n          await this.coordinationManager.assignTask(task, agent.id);\r\n\r\n          this.eventBus.emit(SystemEvents.TASK_ASSIGNED, {\r\n            taskId: task.id,\r\n            agentId: agent.id,\r\n          });\r\n\r\n          // Remove agent from available list\r\n          const index = availableAgents.indexOf(agent);\r\n          availableAgents.splice(index, 1);\r\n        } catch (error) {\r\n          // Put task back in queue\r\n          this.taskQueue.unshift(task);\r\n          this.logger.error('Failed to assign task', { taskId: task.id, error });\r\n          break;\r\n        }\r\n      } else {\r\n        // No suitable agent, put task back\r\n        this.taskQueue.unshift(task);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async getAvailableAgents(): Promise<AgentProfile[]> {\r\n    const sessions = this.sessionManager.getActiveSessions();\r\n    const available: AgentProfile[] = [];\r\n\r\n    for (const session of sessions) {\r\n      if (session.status === 'idle' || session.status === 'active') {\r\n        const profile = this.agents.get(session.agentId);\r\n        if (profile) {\r\n          try {\r\n            const taskCount = await this.coordinationManager.getAgentTaskCount(profile.id);\r\n            if (taskCount < profile.maxConcurrentTasks) {\r\n              available.push(profile);\r\n            }\r\n          } catch (error) {\r\n            this.logger.error('Failed to get agent task count', { agentId: profile.id, error });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return available.sort((a, b) => b.priority - a.priority);\r\n  }\r\n\r\n  private selectAgentForTask(task: Task, agents: AgentProfile[]): AgentProfile | undefined {\r\n    // Score agents based on capabilities, load, and priority\r\n    const scoredAgents = agents.map((agent) => {\r\n      let score = agent.priority * 10;\r\n\r\n      // Check capability match\r\n      const requiredCapabilities = (task.metadata?.requiredCapabilities as string[]) || [];\r\n      const matchedCapabilities = requiredCapabilities.filter((cap) =>\r\n        agent.capabilities.includes(cap),\r\n      ).length;\r\n\r\n      if (requiredCapabilities.length > 0 && matchedCapabilities === 0) {\r\n        return { agent, score: -1 }; // Can't handle task\r\n      }\r\n\r\n      score += matchedCapabilities * 5;\r\n\r\n      // Prefer agents with matching type\r\n      if (task.type === agent.type) {\r\n        score += 20;\r\n      }\r\n\r\n      return { agent, score };\r\n    });\r\n\r\n    // Filter out agents that can't handle the task\r\n    const eligibleAgents = scoredAgents.filter(({ score }) => score >= 0);\r\n\r\n    if (eligibleAgents.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    // Select agent with highest score\r\n    eligibleAgents.sort((a, b) => b.score - a.score);\r\n    return eligibleAgents[0].agent;\r\n  }\r\n\r\n  private async getComponentHealth(\r\n    name: string,\r\n    check: () => Promise<{ healthy: boolean; error?: string; metrics?: Record<string, number> }>,\r\n  ): Promise<ComponentHealth> {\r\n    try {\r\n      const result = await Promise.race([\r\n        check(),\r\n        delay(5000).then(() => ({ healthy: false, error: 'Health check timeout' })),\r\n      ]);\r\n\r\n      const health: ComponentHealth = {\r\n        name,\r\n        status: result.healthy ? 'healthy' : 'unhealthy',\r\n        lastCheck: new Date(),\r\n      };\r\n      if (result.error !== undefined) {\r\n        health.error = result.error;\r\n      }\r\n      if ('metrics' in result && result.metrics !== undefined) {\r\n        health.metrics = result.metrics;\r\n      }\r\n      return health;\r\n    } catch (error) {\r\n      return {\r\n        name,\r\n        status: 'unhealthy',\r\n        lastCheck: new Date(),\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      };\r\n    }\r\n  }\r\n\r\n  private processHealthResult(\r\n    result: PromiseSettledResult<ComponentHealth>,\r\n    componentName: string,\r\n  ): ComponentHealth {\r\n    if (result.status === 'fulfilled') {\r\n      return result.value;\r\n    } else {\r\n      return {\r\n        name: componentName,\r\n        status: 'unhealthy',\r\n        lastCheck: new Date(),\r\n        error: result.reason?.message || 'Health check failed',\r\n      };\r\n    }\r\n  }\r\n\r\n  private async initializeComponent(name: string, init: () => Promise<void>): Promise<void> {\r\n    try {\r\n      await retry(init, { maxAttempts: 3, initialDelay: 2000 });\r\n      this.logger.info(`${name} initialized`);\r\n    } catch (error) {\r\n      this.logger.error(`Failed to initialize ${name}`, error);\r\n      throw new InitializationError(name, { error });\r\n    }\r\n  }\r\n\r\n  private async shutdownComponent(name: string, shutdown: () => Promise<void>): Promise<void> {\r\n    try {\r\n      await Promise.race([\r\n        shutdown(),\r\n        delay(10000), // 10 second timeout per component\r\n      ]);\r\n      this.logger.info(`${name} shut down`);\r\n    } catch (error) {\r\n      this.logger.error(`Failed to shutdown ${name}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private validateAgentProfile(profile: AgentProfile): void {\r\n    if (!profile.id || !profile.name || !profile.type) {\r\n      throw new Error('Invalid agent profile: missing required fields');\r\n    }\r\n\r\n    if (profile.maxConcurrentTasks < 1) {\r\n      throw new Error('Invalid agent profile: maxConcurrentTasks must be at least 1');\r\n    }\r\n\r\n    if (this.agents.has(profile.id)) {\r\n      throw new Error(`Agent with ID ${profile.id} already exists`);\r\n    }\r\n  }\r\n\r\n  private validateTask(task: Task): void {\r\n    if (!task.id || !task.type || !task.description) {\r\n      throw new Error('Invalid task: missing required fields');\r\n    }\r\n\r\n    if (task.priority < 0 || task.priority > 100) {\r\n      throw new Error('Invalid task: priority must be between 0 and 100');\r\n    }\r\n\r\n    if (this.taskHistory.has(task.id)) {\r\n      throw new Error(`Task with ID ${task.id} already exists`);\r\n    }\r\n  }\r\n\r\n  private async handleAgentError(agentId: string, error: Error): Promise<void> {\r\n    const profile = this.agents.get(agentId);\r\n    if (!profile) {\r\n      return;\r\n    }\r\n\r\n    // Log error details\r\n    this.logger.error('Handling agent error', { agentId, error });\r\n\r\n    // Check if agent should be restarted\r\n    const errorCount = (profile.metadata?.errorCount as number) || 0;\r\n    profile.metadata = { ...profile.metadata, errorCount: errorCount + 1 };\r\n\r\n    if (errorCount < 3) {\r\n      // Attempt to restart agent\r\n      try {\r\n        await this.terminateAgent(agentId);\r\n        await delay(2000); // Wait before restart\r\n        await this.spawnAgent({ ...profile, metadata: { ...profile.metadata, errorCount: 0 } });\r\n        this.logger.info('Agent restarted after error', { agentId });\r\n      } catch (restartError) {\r\n        this.logger.error('Failed to restart agent', { agentId, error: restartError });\r\n      }\r\n    } else {\r\n      // Too many errors, terminate agent\r\n      this.logger.error('Agent exceeded error threshold, terminating', { agentId, errorCount });\r\n      await this.terminateAgent(agentId);\r\n    }\r\n  }\r\n\r\n  private async handleTaskFailure(taskId: string, error: Error): Promise<void> {\r\n    const task = this.taskHistory.get(taskId);\r\n    if (!task) {\r\n      return;\r\n    }\r\n\r\n    const retryCount = (task.metadata?.retryCount as number) || 0;\r\n    const maxRetries = this.config.orchestrator.taskMaxRetries || 3;\r\n\r\n    if (retryCount < maxRetries) {\r\n      // Retry task\r\n      task.metadata = { ...task.metadata, retryCount: retryCount + 1 };\r\n      task.status = 'queued';\r\n      delete task.assignedAgent;\r\n\r\n      // Add back to queue with delay\r\n      setTimeout(\r\n        () => {\r\n          this.taskQueue.push(task);\r\n          this.processTaskQueue();\r\n        },\r\n        Math.pow(2, retryCount) * 1000,\r\n      ); // Exponential backoff\r\n\r\n      this.logger.info('Task queued for retry', { taskId, retryCount: retryCount + 1 });\r\n    } else {\r\n      this.logger.error('Task exceeded retry limit', { taskId, retryCount });\r\n    }\r\n  }\r\n\r\n  private handleSystemError(component: string, error: Error): void {\r\n    // Implement system-level error recovery strategies\r\n    this.logger.error('Handling system error', { component, error });\r\n\r\n    // TODO: Implement specific recovery strategies based on component and error type\r\n  }\r\n\r\n  private async resolveDeadlock(agents: string[], resources: string[]): Promise<void> {\r\n    this.logger.warn('Resolving deadlock', { agents, resources });\r\n\r\n    // Simple deadlock resolution: cancel lowest priority agent's tasks\r\n    const agentProfiles = agents.map((id) => this.agents.get(id)).filter(Boolean) as AgentProfile[];\r\n\r\n    if (agentProfiles.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Sort by priority (lowest first)\r\n    agentProfiles.sort((a, b) => a.priority - b.priority);\r\n\r\n    // Cancel tasks for lowest priority agent\r\n    const targetAgent = agentProfiles[0];\r\n    await this.cancelAgentTasks(targetAgent.id);\r\n\r\n    this.logger.info('Deadlock resolved by cancelling tasks', { agentId: targetAgent.id });\r\n  }\r\n\r\n  private async cancelAgentTasks(agentId: string): Promise<void> {\r\n    try {\r\n      const tasks = await this.coordinationManager.getAgentTasks(agentId);\r\n\r\n      for (const task of tasks) {\r\n        await this.coordinationManager.cancelTask(task.id);\r\n\r\n        // Update task status\r\n        const trackedTask = this.taskHistory.get(task.id);\r\n        if (trackedTask) {\r\n          trackedTask.status = 'cancelled';\r\n          trackedTask.completedAt = new Date();\r\n        }\r\n\r\n        this.eventBus.emit(SystemEvents.TASK_CANCELLED, {\r\n          taskId: task.id,\r\n          reason: 'Agent termination',\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to cancel agent tasks', { agentId, error });\r\n    }\r\n  }\r\n\r\n  private startAgentHealthMonitoring(agentId: string): void {\r\n    // TODO: Implement periodic health checks for individual agents\r\n  }\r\n\r\n  private async recoverUnhealthyComponents(health: HealthStatus): Promise<void> {\r\n    for (const [name, component] of Object.entries(health.components)) {\r\n      if (component.status === 'unhealthy') {\r\n        this.logger.warn('Attempting to recover unhealthy component', { name });\r\n\r\n        // TODO: Implement component-specific recovery strategies\r\n        switch (name) {\r\n          case 'Terminal Manager':\r\n            // Restart terminal pools, etc.\r\n            break;\r\n          case 'Memory Manager':\r\n            // Clear cache, reconnect to backends, etc.\r\n            break;\r\n          case 'Coordination Manager':\r\n            // Reset locks, clear message queues, etc.\r\n            break;\r\n          case 'MCP Server':\r\n            // Restart server, reset connections, etc.\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async cleanupTerminatedSessions(): Promise<void> {\r\n    const allSessions = this.sessionManager.getActiveSessions();\r\n    const terminatedSessions = allSessions.filter((s) => (s as any).status === 'terminated');\r\n\r\n    const cutoffTime = Date.now() - (this.config.orchestrator.sessionRetentionMs || 3600000); // 1 hour default\r\n\r\n    for (const session of terminatedSessions) {\r\n      const typedSession = session as any;\r\n      if (typedSession.endTime && typedSession.endTime.getTime() < cutoffTime) {\r\n        await this.sessionManager.terminateSession(typedSession.id);\r\n        this.logger.debug('Cleaned up old session', { sessionId: typedSession.id });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async cleanupTaskHistory(): Promise<void> {\r\n    const cutoffTime = Date.now() - (this.config.orchestrator.taskHistoryRetentionMs || 86400000); // 24 hours default\r\n\r\n    for (const [taskId, task] of this.taskHistory.entries()) {\r\n      if (task.completedAt && task.completedAt.getTime() < cutoffTime) {\r\n        this.taskHistory.delete(taskId);\r\n        this.logger.debug('Cleaned up old task', { taskId });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async processShutdownTasks(): Promise<void> {\r\n    // Process any critical tasks before shutdown\r\n    const criticalTasks = this.taskQueue.filter(\r\n      (t) => t.priority >= 90 || t.metadata?.critical === true,\r\n    );\r\n\r\n    if (criticalTasks.length > 0) {\r\n      this.logger.info('Processing critical tasks before shutdown', {\r\n        count: criticalTasks.length,\r\n      });\r\n\r\n      // TODO: Implement critical task processing\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Claude API client instance\r\n   */\r\n  getClaudeClient(): ClaudeAPIClient | undefined {\r\n    return this.claudeClient;\r\n  }\r\n\r\n  /**\r\n   * Get parallel executor instance\r\n   */\r\n  getParallelExecutor(): ParallelSwarmExecutor | undefined {\r\n    return this.parallelExecutor;\r\n  }\r\n\r\n  /**\r\n   * Get query controller instance\r\n   */\r\n  getQueryController(): RealTimeQueryController | undefined {\r\n    return this.queryController;\r\n  }\r\n\r\n  /**\r\n   * Update Claude API configuration dynamically\r\n   */\r\n  updateClaudeConfig(config: Partial<Config['claude']>): void {\r\n    this.configManager.setClaudeConfig(config);\r\n\r\n    if (this.claudeClient) {\r\n      this.claudeClient.updateConfig(config);\r\n    } else if (this.configManager.isClaudeAPIConfigured()) {\r\n      // Initialize Claude client with new config\r\n      try {\r\n        this.claudeClient = new ClaudeAPIClient(this.logger, this.configManager);\r\n        this.logger.info('Claude API client initialized with new configuration');\r\n      } catch (error) {\r\n        this.logger.error('Failed to initialize Claude API client', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a Claude API request\r\n   */\r\n  async executeClaudeRequest(\r\n    prompt: string,\r\n    options?: {\r\n      model?: string;\r\n      temperature?: number;\r\n      maxTokens?: number;\r\n      systemPrompt?: string;\r\n    },\r\n  ): Promise<string | null> {\r\n    if (!this.claudeClient) {\r\n      this.logger.error('Claude API client not initialized');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const response = await this.claudeClient.complete(prompt, options as any);\r\n      return response;\r\n    } catch (error) {\r\n      this.logger.error('Claude API request failed', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n"],"names":["SystemEvents","SystemError","InitializationError","ShutdownError","delay","retry","circuitBreaker","mkdir","writeFile","readFile","join","dirname","ClaudeAPIClient","ConfigManager","ParallelSwarmExecutor","RealTimeQueryController","SessionManager","sessions","Map","sessionProfiles","persistencePath","persistenceCircuitBreaker","terminalManager","memoryManager","eventBus","logger","config","orchestrator","dataDir","threshold","timeout","resetTimeout","createSession","profile","terminalId","spawnTerminal","maxAttempts","initialDelay","memoryBankId","createBank","id","session","Date","now","Math","random","toString","substr","agentId","startTime","status","lastActivity","set","info","sessionId","persistSessions","catch","error","getSession","get","getActiveSessions","Array","from","values","filter","terminateSession","Error","endTime","Promise","race","terminateTerminal","then","closeBank","delete","duration","getTime","terminateAllSessions","batchSize","i","length","batch","slice","allSettled","map","removeSession","execute","data","s","taskQueue","metrics","completedTasks","failedTasks","totalTaskDuration","savedAt","recursive","JSON","stringify","debug","count","restoreSessions","persistence","parse","sessionsToRestore","sessionData","Object","assign","code","Orchestrator","initialized","shutdownInProgress","sessionManager","healthCheckInterval","maintenanceInterval","metricsInterval","agents","taskHistory","claudeClient","configManager","parallelExecutor","queryController","healthCheckCircuitBreaker","taskAssignmentCircuitBreaker","coordinationManager","mcpServer","getInstance","initialize","all","initializeComponent","start","isClaudeAPIConfigured","model","getConfig","temperature","warn","allowPause","allowModelChange","allowPermissionChange","monitoringInterval","setupEventHandlers","startHealthChecks","startMaintenanceTasks","startMetricsCollection","initDuration","emit","SYSTEM_READY","timestamp","emergencyShutdown","shutdown","shutdownStart","stopBackgroundTasks","processShutdownTasks","shutdownComponents","shutdownTimeout","shutdownDuration","SYSTEM_SHUTDOWN","reason","spawnAgent","size","maxConcurrentAgents","validateAgentProfile","type","AGENT_SPAWNED","startAgentHealthMonitoring","spawnParallelAgents","profiles","forEach","types","p","agentConfigs","agentType","task","capabilities","priority","result","maxParallelAgents","min","sessionMap","successfulAgents","includes","parallel","successful","failed","failedAgents","totalDuration","performanceGain","getMetrics","terminateAgent","cancelAgentTasks","AGENT_TERMINATED","assignTask","validateTask","assignedAgent","taskQueueSize","push","TASK_CREATED","processTaskQueue","agent","TASK_ASSIGNED","taskId","getHealthStatus","components","terminal","memory","coordination","mcp","getComponentHealth","processHealthResult","name","lastCheck","uptime","activeAgents","queuedTasks","memoryUsage","process","heapUsed","statuses","c","overallStatus","some","memUsage","cpuUsage","avgTaskDuration","totalAgents","totalTasks","performMaintenance","cleanupTerminatedSessions","cleanupTaskHistory","global","gc","on","TASK_STARTED","startedAt","TASK_COMPLETED","completedAt","undefined","output","TASK_FAILED","handleTaskFailure","AGENT_ERROR","handleAgentError","AGENT_IDLE","SYSTEM_ERROR","component","handleSystemError","DEADLOCK_DETECTED","resources","resolveDeadlock","setInterval","health","SYSTEM_HEALTHCHECK","recoverUnhealthyComponents","clearInterval","shutdownTasks","shutdownComponent","stop","results","index","componentName","availableAgents","getAvailableAgents","shift","selectAgentForTask","indexOf","splice","unshift","available","taskCount","getAgentTaskCount","maxConcurrentTasks","sort","a","b","scoredAgents","score","requiredCapabilities","metadata","matchedCapabilities","cap","eligibleAgents","check","healthy","message","value","init","has","description","errorCount","restartError","retryCount","maxRetries","taskMaxRetries","setTimeout","pow","agentProfiles","Boolean","targetAgent","tasks","getAgentTasks","cancelTask","trackedTask","TASK_CANCELLED","entries","allSessions","terminatedSessions","cutoffTime","sessionRetentionMs","typedSession","taskHistoryRetentionMs","criticalTasks","t","critical","getClaudeClient","getParallelExecutor","getQueryController","updateClaudeConfig","setClaudeConfig","updateConfig","executeClaudeRequest","prompt","options","response","complete"],"mappings":"AAIA,SAEEA,YAAY,QAQP,oBAAoB;AAO3B,SAASC,WAAW,EAAEC,mBAAmB,EAAEC,aAAa,QAAQ,qBAAqB;AACrF,SAASC,KAAK,EAAEC,KAAK,EAAEC,cAAc,QAAwB,sBAAsB;AACnF,SAASC,KAAK,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,cAAc;AACzD,SAASC,IAAI,EAAEC,OAAO,QAAQ,OAAO;AACrC,SAASC,eAAe,QAAQ,0BAA0B;AAC1D,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,qBAAqB,QAAkC,4BAA4B;AAC5F,SAASC,uBAAuB,QAAQ,0BAA0B;AAuClE,IAAA,AAAMC,iBAAN,MAAMA;;;;;;IACIC,WAAW,IAAIC,MAA4B;IAC3CC,kBAAkB,IAAID,MAA4B;IAClDE,gBAAwB;IACxBC,0BAA0C;IAElD,YACE,AAAQC,eAAiC,EACzC,AAAQC,aAA6B,EACrC,AAAQC,QAAmB,EAC3B,AAAQC,MAAe,EACvB,AAAQC,MAAc,CACtB;aALQJ,kBAAAA;aACAC,gBAAAA;aACAC,WAAAA;aACAC,SAAAA;aACAC,SAAAA;QAER,IAAI,CAACN,eAAe,GAAGV,KAAKgB,OAAOC,YAAY,CAACC,OAAO,IAAI,UAAU;QAGrE,IAAI,CAACP,yBAAyB,GAAGf,eAAe,sBAAsB;YACpEuB,WAAW;YACXC,SAAS;YACTC,cAAc;QAChB;IACF;IAEA,MAAMC,cAAcC,OAAqB,EAAyB;QAChE,IAAI;YAEF,MAAMC,aAAa,MAAM7B,MAAM,IAAM,IAAI,CAACiB,eAAe,CAACa,aAAa,CAACF,UAAU;gBAChFG,aAAa;gBACbC,cAAc;YAChB;YAGA,MAAMC,eAAe,MAAMjC,MAAM,IAAM,IAAI,CAACkB,aAAa,CAACgB,UAAU,CAACN,QAAQO,EAAE,GAAG;gBAChFJ,aAAa;gBACbC,cAAc;YAChB;YAGA,MAAMI,UAAwB;gBAC5BD,IAAI,CAAC,QAAQ,EAAEE,KAAKC,GAAG,GAAG,CAAC,EAAEC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,IAAI;gBACtEC,SAASf,QAAQO,EAAE;gBACnBN;gBACAe,WAAW,IAAIP;gBACfQ,QAAQ;gBACRC,cAAc,IAAIT;gBAClBJ;YACF;YAEA,IAAI,CAACrB,QAAQ,CAACmC,GAAG,CAACX,QAAQD,EAAE,EAAEC;YAC9B,IAAI,CAACtB,eAAe,CAACiC,GAAG,CAACX,QAAQD,EAAE,EAAEP;YAErC,IAAI,CAACR,MAAM,CAAC4B,IAAI,CAAC,mBAAmB;gBAClCC,WAAWb,QAAQD,EAAE;gBACrBQ,SAASf,QAAQO,EAAE;gBACnBN;gBACAI;YACF;YAGA,IAAI,CAACiB,eAAe,GAAGC,KAAK,CAAC,CAACC,QAC5B,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,8BAA8BA;YAGlD,OAAOhB;QACT,EAAE,OAAOgB,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,4BAA4B;gBAAET,SAASf,QAAQO,EAAE;gBAAEiB;YAAM;YAC3E,MAAM,IAAIxD,YAAY,CAAC,mCAAmC,EAAEgC,QAAQO,EAAE,EAAE,EAAE;gBAAEiB;YAAM;QACpF;IACF;IAEAC,WAAWJ,SAAiB,EAA4B;QACtD,OAAO,IAAI,CAACrC,QAAQ,CAAC0C,GAAG,CAACL;IAC3B;IAEAM,oBAAoC;QAClC,OAAOC,MAAMC,IAAI,CAAC,IAAI,CAAC7C,QAAQ,CAAC8C,MAAM,IAAIC,MAAM,CAC9C,CAACvB,UAAYA,QAAQS,MAAM,KAAK,YAAYT,QAAQS,MAAM,KAAK;IAEnE;IAEA,MAAMe,iBAAiBX,SAAiB,EAAiB;QACvD,MAAMb,UAAU,IAAI,CAACxB,QAAQ,CAAC0C,GAAG,CAACL;QAClC,IAAI,CAACb,SAAS;YACZ,MAAM,IAAIyB,MAAM,CAAC,mBAAmB,EAAEZ,WAAW;QACnD;QAEA,IAAI;YAEFb,QAAQS,MAAM,GAAG;YACjBT,QAAQ0B,OAAO,GAAG,IAAIzB;YAGtB,MAAM0B,QAAQC,IAAI,CAAC;gBACjB,IAAI,CAAC/C,eAAe,CAACgD,iBAAiB,CAAC7B,QAAQP,UAAU;gBACzD9B,MAAM,MAAMmE,IAAI,CAAC;oBACf,MAAM,IAAIL,MAAM;gBAClB;aACD,EAAEV,KAAK,CAAC,CAACC;gBACR,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,8BAA8B;oBAAEH;oBAAWG;gBAAM;YACrE;YAGA,MAAMW,QAAQC,IAAI,CAAC;gBACjB,IAAI,CAAC9C,aAAa,CAACiD,SAAS,CAAC/B,QAAQH,YAAY;gBACjDlC,MAAM,MAAMmE,IAAI,CAAC;oBACf,MAAM,IAAIL,MAAM;gBAClB;aACD,EAAEV,KAAK,CAAC,CAACC;gBACR,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,6BAA6B;oBAAEH;oBAAWG;gBAAM;YACpE;YAGA,IAAI,CAACtC,eAAe,CAACsD,MAAM,CAACnB;YAE5B,IAAI,CAAC7B,MAAM,CAAC4B,IAAI,CAAC,sBAAsB;gBACrCC;gBACAoB,UAAUjC,QAAQ0B,OAAO,CAACQ,OAAO,KAAKlC,QAAQQ,SAAS,CAAC0B,OAAO;YACjE;YAGA,IAAI,CAACpB,eAAe,GAAGC,KAAK,CAAC,CAACC,QAC5B,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,8BAA8BA;QAEpD,EAAE,OAAOA,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,oCAAoC;gBAAEH;gBAAWG;YAAM;YACzE,MAAMA;QACR;IACF;IAEA,MAAMmB,uBAAsC;QAC1C,MAAM3D,WAAW,IAAI,CAAC2C,iBAAiB;QAGvC,MAAMiB,YAAY;QAClB,IAAK,IAAIC,IAAI,GAAGA,IAAI7D,SAAS8D,MAAM,EAAED,KAAKD,UAAW;YACnD,MAAMG,QAAQ/D,SAASgE,KAAK,CAACH,GAAGA,IAAID;YACpC,MAAMT,QAAQc,UAAU,CAACF,MAAMG,GAAG,CAAC,CAAC1C,UAAY,IAAI,CAACwB,gBAAgB,CAACxB,QAAQD,EAAE;QAClF;IACF;IAEA4C,cAAc9B,SAAiB,EAAQ;QACrC,IAAI,CAACrC,QAAQ,CAACwD,MAAM,CAACnB;QACrB,IAAI,CAACnC,eAAe,CAACsD,MAAM,CAACnB;IAC9B;IAEA,MAAMC,kBAAiC;QACrC,IAAI,CAAC,IAAI,CAAC7B,MAAM,CAACC,YAAY,CAAC4B,eAAe,EAAE;YAC7C;QACF;QAEA,IAAI;YACF,MAAM,IAAI,CAAClC,yBAAyB,CAACgE,OAAO,CAAC;gBAC3C,MAAMC,OAA2B;oBAC/BrE,UAAU4C,MAAMC,IAAI,CAAC,IAAI,CAAC7C,QAAQ,CAAC8C,MAAM,IACtCoB,GAAG,CAAC,CAAC1C,UAAa,CAAA;4BACjB,GAAGA,OAAO;4BACVR,SAAS,IAAI,CAACd,eAAe,CAACwC,GAAG,CAAClB,QAAQD,EAAE;wBAC9C,CAAA,GACCwB,MAAM,CAAC,CAACuB,IAAMA,EAAEtD,OAAO;oBAC1BuD,WAAW,EAAE;oBACbC,SAAS;wBACPC,gBAAgB;wBAChBC,aAAa;wBACbC,mBAAmB;oBACrB;oBACAC,SAAS,IAAInD;gBACf;gBAEA,MAAMnC,MAAMI,QAAQ,IAAI,CAACS,eAAe,GAAG;oBAAE0E,WAAW;gBAAK;gBAC7D,MAAMtF,UAAU,IAAI,CAACY,eAAe,EAAE2E,KAAKC,SAAS,CAACV,MAAM,MAAM,IAAI;gBAErE,IAAI,CAAC7D,MAAM,CAACwE,KAAK,CAAC,sBAAsB;oBAAEC,OAAOZ,KAAKrE,QAAQ,CAAC8D,MAAM;gBAAC;YACxE;QACF,EAAE,OAAOtB,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,8BAA8BA;QAClD;IACF;IAEA,MAAM0C,kBAAiC;QACrC,IAAI,CAAC,IAAI,CAACzE,MAAM,CAACC,YAAY,CAAC4B,eAAe,EAAE;YAC7C;QACF;QAEA,IAAI;YACF,MAAM+B,OAAO,MAAM7E,SAAS,IAAI,CAACW,eAAe,EAAE;YAClD,MAAMgF,cAAkCL,KAAKM,KAAK,CAACf;YAGnD,MAAMgB,oBAAoBF,YAAYnF,QAAQ,CAAC+C,MAAM,CACnD,CAACuB,IAAMA,EAAErC,MAAM,KAAK,YAAYqC,EAAErC,MAAM,KAAK;YAG/C,KAAK,MAAMqD,eAAeD,kBAAmB;gBAC3C,IAAI;oBAEF,MAAM7D,UAAU,MAAM,IAAI,CAACT,aAAa,CAACuE,YAAYtE,OAAO;oBAG5DuE,OAAOC,MAAM,CAAChE,SAAS;wBACrBD,IAAI+D,YAAY/D,EAAE;wBAClBS,WAAW,IAAIP,KAAK6D,YAAYtD,SAAS;wBACzCE,cAAc,IAAIT,KAAK6D,YAAYpD,YAAY;oBACjD;oBAEA,IAAI,CAAC1B,MAAM,CAAC4B,IAAI,CAAC,oBAAoB;wBAAEC,WAAWb,QAAQD,EAAE;oBAAC;gBAC/D,EAAE,OAAOiB,OAAO;oBACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,6BAA6B;wBAC7CH,WAAWiD,YAAY/D,EAAE;wBACzBiB;oBACF;gBACF;YACF;QACF,EAAE,OAAOA,OAAO;YACd,IAAI,AAACA,MAAgCiD,IAAI,KAAK,UAAU;gBACtD,IAAI,CAACjF,MAAM,CAACgC,KAAK,CAAC,8BAA8BA;YAClD;QACF;IACF;AACF;AAKA,OAAO,MAAMkD;;;;;;;;IACHC,cAAc,MAAM;IACpBC,qBAAqB,MAAM;IAC3BC,eAAgC;IAChCC,oBAA6B;IAC7BC,oBAA6B;IAC7BC,gBAAyB;IACzBC,SAAS,IAAIhG,MAA4B;IACzCsE,YAAoB,EAAE,CAAC;IACvB2B,cAAc,IAAIjG,MAAoB;IACtC+B,YAAYP,KAAKC,GAAG,GAAG;IACvByE,aAA+B;IAC/BC,cAA6B;IAC7BC,iBAAyC;IACzCC,gBAA0C;IAG1C9B,UAAU;QAChBC,gBAAgB;QAChBC,aAAa;QACbC,mBAAmB;IACrB,EAAE;IAGM4B,0BAA0C;IAC1CC,6BAA6C;IAErD,YACE,AAAQ/F,MAAc,EACtB,AAAQJ,eAAiC,EACzC,AAAQC,aAA6B,EACrC,AAAQmG,mBAAyC,EACjD,AAAQC,SAAqB,EAC7B,AAAQnG,QAAmB,EAC3B,AAAQC,MAAe,CACvB;aAPQC,SAAAA;aACAJ,kBAAAA;aACAC,gBAAAA;aACAmG,sBAAAA;aACAC,YAAAA;aACAnG,WAAAA;aACAC,SAAAA;QAER,IAAI,CAACqF,cAAc,GAAG,IAAI9F,eACxBM,iBACAC,eACAC,UACAC,QACAC;QAGF,IAAI,CAAC2F,aAAa,GAAGxG,cAAc+G,WAAW;QAG9C,IAAI,CAACJ,yBAAyB,GAAGlH,eAAe,eAAe;YAC7DuB,WAAW;YACXC,SAAS;YACTC,cAAc;QAChB;QAEA,IAAI,CAAC0F,4BAA4B,GAAGnH,eAAe,kBAAkB;YACnEuB,WAAW;YACXC,SAAS;YACTC,cAAc;QAChB;IACF;IAEA,MAAM8F,aAA4B;QAChC,IAAI,IAAI,CAACjB,WAAW,EAAE;YACpB,MAAM,IAAI1G,oBAAoB;QAChC;QAEA,IAAI,CAACuB,MAAM,CAAC4B,IAAI,CAAC;QACjB,MAAMJ,YAAYP,KAAKC,GAAG;QAE1B,IAAI;YAEF,MAAMyB,QAAQ0D,GAAG,CAAC;gBAChB,IAAI,CAACC,mBAAmB,CAAC,oBAAoB,IAAM,IAAI,CAACzG,eAAe,CAACuG,UAAU;gBAClF,IAAI,CAACE,mBAAmB,CAAC,kBAAkB,IAAM,IAAI,CAACxG,aAAa,CAACsG,UAAU;gBAC9E,IAAI,CAACE,mBAAmB,CAAC,wBAAwB,IAC/C,IAAI,CAACL,mBAAmB,CAACG,UAAU;aAEtC;YAGD,MAAM,IAAI,CAACE,mBAAmB,CAAC,cAAc,IAAM,IAAI,CAACJ,SAAS,CAACK,KAAK;YAGvE,IAAI,IAAI,CAACX,aAAa,CAACY,qBAAqB,IAAI;gBAC9C,IAAI;oBACF,IAAI,CAACb,YAAY,GAAG,IAAIxG,gBAAgB,IAAI,CAACa,MAAM,EAAE,IAAI,CAAC4F,aAAa;oBACvE,IAAI,CAAC5F,MAAM,CAAC4B,IAAI,CAAC,iCAAiC;wBAChD6E,OAAO,IAAI,CAACd,YAAY,CAACe,SAAS,GAAGD,KAAK;wBAC1CE,aAAa,IAAI,CAAChB,YAAY,CAACe,SAAS,GAAGC,WAAW;oBACxD;gBACF,EAAE,OAAO3E,OAAO;oBACd,IAAI,CAAChC,MAAM,CAAC4G,IAAI,CAAC,0CAA0C5E;gBAC7D;YACF;YAGA,IAAI,CAAC6D,gBAAgB,GAAG,IAAIxG;YAC5B,IAAI,CAACyG,eAAe,GAAG,IAAIxG,wBAAwB;gBACjDuH,YAAY;gBACZC,kBAAkB;gBAClBC,uBAAuB;gBACvBC,oBAAoB;YACtB;YAEA,IAAI,CAAChH,MAAM,CAAC4B,IAAI,CAAC,iDAAiD;gBAChEiE,kBAAkB;gBAClBC,iBAAiB;YACnB;YAGA,MAAM,IAAI,CAACT,cAAc,CAACX,eAAe;YAGzC,IAAI,CAACuC,kBAAkB;YAGvB,IAAI,CAACC,iBAAiB;YACtB,IAAI,CAACC,qBAAqB;YAC1B,IAAI,CAACC,sBAAsB;YAE3B,IAAI,CAACjC,WAAW,GAAG;YAEnB,MAAMkC,eAAepG,KAAKC,GAAG,KAAKM;YAClC,IAAI,CAACzB,QAAQ,CAACuH,IAAI,CAAC/I,aAAagJ,YAAY,EAAE;gBAAEC,WAAW,IAAIvG;YAAO;YACtE,IAAI,CAACjB,MAAM,CAAC4B,IAAI,CAAC,yCAAyC;gBAAEqB,UAAUoE;YAAa;QACrF,EAAE,OAAOrF,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,qCAAqCA;YAGvD,MAAM,IAAI,CAACyF,iBAAiB;YAE5B,MAAM,IAAIhJ,oBAAoB,gBAAgB;gBAAEuD;YAAM;QACxD;IACF;IAEA,MAAM0F,WAA0B;QAC9B,IAAI,CAAC,IAAI,CAACvC,WAAW,IAAI,IAAI,CAACC,kBAAkB,EAAE;YAChD;QACF;QAEA,IAAI,CAACA,kBAAkB,GAAG;QAC1B,IAAI,CAACpF,MAAM,CAAC4B,IAAI,CAAC;QACjB,MAAM+F,gBAAgB1G,KAAKC,GAAG;QAE9B,IAAI;YAEF,IAAI,CAAC0G,mBAAmB;YAGxB,MAAM,IAAI,CAACvC,cAAc,CAACvD,eAAe;YAGzC,MAAM,IAAI,CAAC+F,oBAAoB;YAG/B,MAAM,IAAI,CAACxC,cAAc,CAAClC,oBAAoB;YAG9C,MAAMR,QAAQC,IAAI,CAAC;gBACjB,IAAI,CAACkF,kBAAkB;gBACvBnJ,MAAM,IAAI,CAACsB,MAAM,CAACC,YAAY,CAAC6H,eAAe;aAC/C;YAED,MAAMC,mBAAmB/G,KAAKC,GAAG,KAAKyG;YACtC,IAAI,CAAC5H,QAAQ,CAACuH,IAAI,CAAC/I,aAAa0J,eAAe,EAAE;gBAAEC,QAAQ;YAAoB;YAC/E,IAAI,CAAClI,MAAM,CAAC4B,IAAI,CAAC,kCAAkC;gBAAEqB,UAAU+E;YAAiB;QAClF,EAAE,OAAOhG,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,yBAAyBA;YAG3C,MAAM,IAAI,CAACyF,iBAAiB;YAE5B,MAAM,IAAI/I,cAAc,iCAAiC;gBAAEsD;YAAM;QACnE,SAAU;YACR,IAAI,CAACmD,WAAW,GAAG;YACnB,IAAI,CAACC,kBAAkB,GAAG;QAC5B;IACF;IAEA,MAAM+C,WAAW3H,OAAqB,EAAmB;QACvD,IAAI,CAAC,IAAI,CAAC2E,WAAW,EAAE;YACrB,MAAM,IAAI3G,YAAY;QACxB;QAGA,IAAI,IAAI,CAACiH,MAAM,CAAC2C,IAAI,IAAI,IAAI,CAACnI,MAAM,CAACC,YAAY,CAACmI,mBAAmB,EAAE;YACpE,MAAM,IAAI7J,YAAY;QACxB;QAGA,IAAI,CAAC8J,oBAAoB,CAAC9H;QAE1B,IAAI,CAACR,MAAM,CAAC4B,IAAI,CAAC,kBAAkB;YAAEL,SAASf,QAAQO,EAAE;YAAEwH,MAAM/H,QAAQ+H,IAAI;QAAC;QAE7E,IAAI;YAEF,MAAMvH,UAAU,MAAMpC,MAAM,IAAM,IAAI,CAACyG,cAAc,CAAC9E,aAAa,CAACC,UAAU;gBAC5EG,aAAa;gBACbC,cAAc;YAChB;YAGA,IAAI,CAAC6E,MAAM,CAAC9D,GAAG,CAACnB,QAAQO,EAAE,EAAEP;YAG5B,IAAI,CAACT,QAAQ,CAACuH,IAAI,CAAC/I,aAAaiK,aAAa,EAAE;gBAC7CjH,SAASf,QAAQO,EAAE;gBACnBP;gBACAqB,WAAWb,QAAQD,EAAE;YACvB;YAGA,IAAI,CAAC0H,0BAA0B,CAACjI,QAAQO,EAAE;YAE1C,OAAOC,QAAQD,EAAE;QACnB,EAAE,OAAOiB,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,yBAAyB;gBAAET,SAASf,QAAQO,EAAE;gBAAEiB;YAAM;YACxE,MAAMA;QACR;IACF;IAMA,MAAM0G,oBAAoBC,QAAwB,EAAgC;QAChF,IAAI,CAAC,IAAI,CAACxD,WAAW,EAAE;YACrB,MAAM,IAAI3G,YAAY;QACxB;QAEA,IAAI,CAAC,IAAI,CAACqH,gBAAgB,EAAE;YAC1B,MAAM,IAAIrH,YAAY;QACxB;QAGA,IAAI,IAAI,CAACiH,MAAM,CAAC2C,IAAI,GAAGO,SAASrF,MAAM,GAAG,IAAI,CAACrD,MAAM,CAACC,YAAY,CAACmI,mBAAmB,EAAE;YACrF,MAAM,IAAI7J,YAAY;QACxB;QAGAmK,SAASC,OAAO,CAACpI,CAAAA,UAAW,IAAI,CAAC8H,oBAAoB,CAAC9H;QAEtD,IAAI,CAACR,MAAM,CAAC4B,IAAI,CAAC,4BAA4B;YAC3C6C,OAAOkE,SAASrF,MAAM;YACtBuF,OAAOF,SAASjF,GAAG,CAACoF,CAAAA,IAAKA,EAAEP,IAAI;QACjC;QAEA,IAAI;YAEF,MAAMQ,eAAsCJ,SAASjF,GAAG,CAAClD,CAAAA,UAAY,CAAA;oBACnEe,SAASf,QAAQO,EAAE;oBACnBiI,WAAWxI,QAAQ+H,IAAI;oBACvBU,MAAM,CAAC,WAAW,EAAEzI,QAAQ+H,IAAI,CAAC,0BAA0B,EAAE/H,QAAQ0I,YAAY,CAACjK,IAAI,CAAC,OAAO;oBAC9FiK,cAAc1I,QAAQ0I,YAAY;oBAClCC,UAAU3I,QAAQ2I,QAAQ,IAAI,KAAK,aACzB3I,QAAQ2I,QAAQ,IAAI,KAAK,SACzB3I,QAAQ2I,QAAQ,IAAI,KAAK,WAAW;oBAC9C9I,SAAS;gBACX,CAAA;YAGA,MAAM+I,SAAS,MAAM,IAAI,CAACvD,gBAAgB,CAAC6C,mBAAmB,CAACK,cAAc;gBAC3EM,mBAAmBlI,KAAKmI,GAAG,CAACX,SAASrF,MAAM,EAAE;gBAC7CjD,SAAS;gBACToG,OAAO;YACT;YAGA,MAAM8C,aAAa,IAAI9J;YAGvB,KAAK,MAAMe,WAAWmI,SAAU;gBAC9B,IAAIS,OAAOI,gBAAgB,CAACC,QAAQ,CAACjJ,QAAQO,EAAE,GAAG;oBAEhD,MAAMC,UAAwB;wBAC5BD,IAAI,CAAC,QAAQ,EAAEE,KAAKC,GAAG,GAAG,CAAC,EAAEC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,IAAI;wBACtEC,SAASf,QAAQO,EAAE;wBACnBN,YAAY;wBACZe,WAAW,IAAIP;wBACfQ,QAAQ;wBACRC,cAAc,IAAIT;wBAClBJ,cAAc,CAAC,OAAO,EAAEL,QAAQO,EAAE,EAAE;oBACtC;oBAEA,IAAI,CAAC0E,MAAM,CAAC9D,GAAG,CAACnB,QAAQO,EAAE,EAAEP;oBAC5B+I,WAAW5H,GAAG,CAACnB,QAAQO,EAAE,EAAEC,QAAQD,EAAE;oBAGrC,IAAI,CAAChB,QAAQ,CAACuH,IAAI,CAAC/I,aAAaiK,aAAa,EAAE;wBAC7CjH,SAASf,QAAQO,EAAE;wBACnBP;wBACAqB,WAAWb,QAAQD,EAAE;wBACrB2I,UAAU;oBACZ;oBAGA,IAAI,CAACjB,0BAA0B,CAACjI,QAAQO,EAAE;gBAC5C;YACF;YAEA,IAAI,CAACf,MAAM,CAAC4B,IAAI,CAAC,qCAAqC;gBACpD+H,YAAYP,OAAOI,gBAAgB,CAAClG,MAAM;gBAC1CsG,QAAQR,OAAOS,YAAY,CAACvG,MAAM;gBAClCL,UAAUmG,OAAOU,aAAa;gBAC9BC,iBAAiB,IAAI,CAAClE,gBAAgB,CAACmE,UAAU,GAAGD,eAAe;YACrE;YAEA,OAAOR;QACT,EAAE,OAAOvH,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,mCAAmC;gBAAEA;YAAM;YAC7D,MAAMA;QACR;IACF;IAEA,MAAMiI,eAAe1I,OAAe,EAAiB;QACnD,IAAI,CAAC,IAAI,CAAC4D,WAAW,EAAE;YACrB,MAAM,IAAI3G,YAAY;QACxB;QAEA,MAAMgC,UAAU,IAAI,CAACiF,MAAM,CAACvD,GAAG,CAACX;QAChC,IAAI,CAACf,SAAS;YACZ,MAAM,IAAIhC,YAAY,CAAC,iBAAiB,EAAE+C,SAAS;QACrD;QAEA,IAAI,CAACvB,MAAM,CAAC4B,IAAI,CAAC,qBAAqB;YAAEL;QAAQ;QAEhD,IAAI;YAEF,MAAM,IAAI,CAAC2I,gBAAgB,CAAC3I;YAG5B,MAAM/B,WAAW,IAAI,CAAC6F,cAAc,CACjClD,iBAAiB,GACjBI,MAAM,CAAC,CAACvB,UAAYA,QAAQO,OAAO,KAAKA;YAE3C,MAAMoB,QAAQc,UAAU,CACtBjE,SAASkE,GAAG,CAAC,CAAC1C,UAAY,IAAI,CAACqE,cAAc,CAAC7C,gBAAgB,CAACxB,QAAQD,EAAE;YAI3E,IAAI,CAAC0E,MAAM,CAACzC,MAAM,CAACzB;YAGnB,IAAI,CAACxB,QAAQ,CAACuH,IAAI,CAAC/I,aAAa4L,gBAAgB,EAAE;gBAChD5I;gBACA2G,QAAQ;YACV;QACF,EAAE,OAAOlG,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,6BAA6B;gBAAET;gBAASS;YAAM;YAChE,MAAMA;QACR;IACF;IAEA,MAAMoI,WAAWnB,IAAU,EAAiB;QAC1C,IAAI,CAAC,IAAI,CAAC9D,WAAW,EAAE;YACrB,MAAM,IAAI3G,YAAY;QACxB;QAGA,IAAI,CAAC6L,YAAY,CAACpB;QAGlB,IAAI,CAACvD,WAAW,CAAC/D,GAAG,CAACsH,KAAKlI,EAAE,EAAEkI;QAE9B,IAAI;YACF,MAAM,IAAI,CAACjD,4BAA4B,CAACpC,OAAO,CAAC;gBAE9C,IAAI,CAACqF,KAAKqB,aAAa,EAAE;oBACvB,IAAI,IAAI,CAACvG,SAAS,CAACT,MAAM,IAAI,IAAI,CAACrD,MAAM,CAACC,YAAY,CAACqK,aAAa,EAAE;wBACnE,MAAM,IAAI/L,YAAY;oBACxB;oBAEA,IAAI,CAACuF,SAAS,CAACyG,IAAI,CAACvB;oBACpB,IAAI,CAAClJ,QAAQ,CAACuH,IAAI,CAAC/I,aAAakM,YAAY,EAAE;wBAAExB;oBAAK;oBAGrD,MAAM,IAAI,CAACyB,gBAAgB;oBAC3B;gBACF;gBAGA,MAAMC,QAAQ,IAAI,CAAClF,MAAM,CAACvD,GAAG,CAAC+G,KAAKqB,aAAa;gBAChD,IAAI,CAACK,OAAO;oBACV,MAAM,IAAInM,YAAY,CAAC,iBAAiB,EAAEyK,KAAKqB,aAAa,EAAE;gBAChE;gBAEA,MAAM,IAAI,CAACrE,mBAAmB,CAACmE,UAAU,CAACnB,MAAMA,KAAKqB,aAAa;gBAElE,IAAI,CAACvK,QAAQ,CAACuH,IAAI,CAAC/I,aAAaqM,aAAa,EAAE;oBAC7CC,QAAQ5B,KAAKlI,EAAE;oBACfQ,SAAS0H,KAAKqB,aAAa;gBAC7B;YACF;QACF,EAAE,OAAOtI,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,yBAAyB;gBAAE6I,QAAQ5B,KAAKlI,EAAE;gBAAEiB;YAAM;YACpE,MAAMA;QACR;IACF;IAEA,MAAM8I,kBAAyC;QAC7C,IAAI;YACF,OAAO,MAAM,IAAI,CAAC/E,yBAAyB,CAACnC,OAAO,CAAC;gBAClD,MAAMmH,aAA8C,CAAC;gBAGrD,MAAM,CAACC,UAAUC,QAAQC,cAAcC,IAAI,GAAG,MAAMxI,QAAQc,UAAU,CAAC;oBACrE,IAAI,CAAC2H,kBAAkB,CACrB,oBACA,UAAY,MAAM,IAAI,CAACvL,eAAe,CAACiL,eAAe;oBAExD,IAAI,CAACM,kBAAkB,CACrB,kBACA,UAAY,MAAM,IAAI,CAACtL,aAAa,CAACgL,eAAe;oBAEtD,IAAI,CAACM,kBAAkB,CACrB,wBACA,UAAY,MAAM,IAAI,CAACnF,mBAAmB,CAAC6E,eAAe;oBAE5D,IAAI,CAACM,kBAAkB,CAAC,cAAc,UAAY,MAAM,IAAI,CAAClF,SAAS,CAAC4E,eAAe;iBACvF;gBAGDC,WAAWC,QAAQ,GAAG,IAAI,CAACK,mBAAmB,CAACL,UAAU;gBACzDD,WAAWE,MAAM,GAAG,IAAI,CAACI,mBAAmB,CAACJ,QAAQ;gBACrDF,WAAWG,YAAY,GAAG,IAAI,CAACG,mBAAmB,CAACH,cAAc;gBACjEH,WAAWI,GAAG,GAAG,IAAI,CAACE,mBAAmB,CAACF,KAAK;gBAG/CJ,WAAW7K,YAAY,GAAG;oBACxBoL,MAAM;oBACN7J,QAAQ;oBACR8J,WAAW,IAAItK;oBACf+C,SAAS;wBACPwH,QAAQvK,KAAKC,GAAG,KAAK,IAAI,CAACM,SAAS;wBACnCiK,cAAc,IAAI,CAAChG,MAAM,CAAC2C,IAAI;wBAC9BsD,aAAa,IAAI,CAAC3H,SAAS,CAACT,MAAM;wBAClCqI,aAAaC,QAAQD,WAAW,GAAGE,QAAQ,GAAG,OAAO;oBACvD;gBACF;gBAGA,MAAMC,WAAW/G,OAAOzC,MAAM,CAACyI,YAAYrH,GAAG,CAAC,CAACqI,IAAMA,EAAEtK,MAAM;gBAC9D,IAAIuK,gBAAwC;gBAE5C,IAAIF,SAASG,IAAI,CAAC,CAACnI,IAAMA,MAAM,cAAc;oBAC3CkI,gBAAgB;gBAClB,OAAO,IAAIF,SAASG,IAAI,CAAC,CAACnI,IAAMA,MAAM,aAAa;oBACjDkI,gBAAgB;gBAClB;gBAEA,OAAO;oBACLvK,QAAQuK;oBACRjB;oBACAvD,WAAW,IAAIvG;gBACjB;YACF;QACF,EAAE,OAAOe,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,uBAAuBA;YAGzC,OAAO;gBACLP,QAAQ;gBACRsJ,YAAY;oBACV7K,cAAc;wBACZoL,MAAM;wBACN7J,QAAQ;wBACR8J,WAAW,IAAItK;wBACfe,OAAO;oBACT;gBACF;gBACAwF,WAAW,IAAIvG;YACjB;QACF;IACF;IAEA,MAAM+I,aAA2C;QAC/C,MAAMkC,WAAWN,QAAQD,WAAW;QACpC,MAAMQ,WAAWP,QAAQO,QAAQ;QAEjC,MAAMC,kBACJ,IAAI,CAACpI,OAAO,CAACC,cAAc,GAAG,IAC1B,IAAI,CAACD,OAAO,CAACG,iBAAiB,GAAG,IAAI,CAACH,OAAO,CAACC,cAAc,GAC5D;QAEN,OAAO;YACLuH,QAAQvK,KAAKC,GAAG,KAAK,IAAI,CAACM,SAAS;YACnC6K,aAAa,IAAI,CAAC5G,MAAM,CAAC2C,IAAI;YAC7BqD,cAAc,IAAI,CAACpG,cAAc,CAAClD,iBAAiB,GAAGmB,MAAM;YAC5DgJ,YAAY,IAAI,CAAC5G,WAAW,CAAC0C,IAAI;YACjCnE,gBAAgB,IAAI,CAACD,OAAO,CAACC,cAAc;YAC3CC,aAAa,IAAI,CAACF,OAAO,CAACE,WAAW;YACrCwH,aAAa,IAAI,CAAC3H,SAAS,CAACT,MAAM;YAClC8I;YACAT,aAAaO;YACbC,UAAUA;YACV3E,WAAW,IAAIvG;QACjB;IACF;IAEA,MAAMsL,qBAAoC;QACxC,IAAI,CAACvM,MAAM,CAACwE,KAAK,CAAC;QAElB,IAAI;YAEF,MAAM,IAAI,CAACgI,yBAAyB;YAGpC,MAAM,IAAI,CAACC,kBAAkB;YAG7B,MAAM9J,QAAQc,UAAU,CAAC;gBACvB,IAAI,CAAC5D,eAAe,CAAC0M,kBAAkB;gBACvC,IAAI,CAACzM,aAAa,CAACyM,kBAAkB;gBACrC,IAAI,CAACtG,mBAAmB,CAACsG,kBAAkB;aAC5C;YAGD,MAAM,IAAI,CAAClH,cAAc,CAACvD,eAAe;YAGzC,IAAI4K,OAAOC,EAAE,EAAE;gBACbD,OAAOC,EAAE;YACX;YAEA,IAAI,CAAC3M,MAAM,CAACwE,KAAK,CAAC;QACpB,EAAE,OAAOxC,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,4BAA4BA;QAChD;IACF;IAEQiF,qBAA2B;QAEjC,IAAI,CAAClH,QAAQ,CAAC6M,EAAE,CAACrO,aAAasO,YAAY,EAAE,CAAChJ;YAC3C,MAAM,EAAEgH,MAAM,EAAEtJ,OAAO,EAAE,GAAGsC;YAC5B,MAAMoF,OAAO,IAAI,CAACvD,WAAW,CAACxD,GAAG,CAAC2I;YAClC,IAAI5B,MAAM;gBACRA,KAAKxH,MAAM,GAAG;gBACdwH,KAAK6D,SAAS,GAAG,IAAI7L;YACvB;QACF;QAEA,IAAI,CAAClB,QAAQ,CAAC6M,EAAE,CAACrO,aAAawO,cAAc,EAAE,OAAOlJ;YACnD,MAAM,EAAEgH,MAAM,EAAEzB,MAAM,EAAE,GAAGvF;YAC3B,MAAMoF,OAAO,IAAI,CAACvD,WAAW,CAACxD,GAAG,CAAC2I;YAClC,IAAI5B,MAAM;gBACRA,KAAKxH,MAAM,GAAG;gBACdwH,KAAK+D,WAAW,GAAG,IAAI/L;gBACvB,IAAImI,WAAW6D,WAAW;oBACxBhE,KAAKiE,MAAM,GAAG9D;gBAChB;gBAGA,IAAI,CAACpF,OAAO,CAACC,cAAc;gBAC3B,IAAIgF,KAAK6D,SAAS,EAAE;oBAClB,IAAI,CAAC9I,OAAO,CAACG,iBAAiB,IAAI8E,KAAK+D,WAAW,CAAC9J,OAAO,KAAK+F,KAAK6D,SAAS,CAAC5J,OAAO;gBACvF;YACF;YAEA,MAAM,IAAI,CAACwH,gBAAgB;QAC7B;QAEA,IAAI,CAAC3K,QAAQ,CAAC6M,EAAE,CAACrO,aAAa4O,WAAW,EAAE,OAAOtJ;YAChD,MAAM,EAAEgH,MAAM,EAAE7I,KAAK,EAAE,GAAG6B;YAC1B,MAAMoF,OAAO,IAAI,CAACvD,WAAW,CAACxD,GAAG,CAAC2I;YAClC,IAAI5B,MAAM;gBACRA,KAAKxH,MAAM,GAAG;gBACdwH,KAAK+D,WAAW,GAAG,IAAI/L;gBACvBgI,KAAKjH,KAAK,GAAGA;gBAGb,IAAI,CAACgC,OAAO,CAACE,WAAW;YAC1B;YAGA,MAAM,IAAI,CAACkJ,iBAAiB,CAACvC,QAAQ7I;QACvC;QAGA,IAAI,CAACjC,QAAQ,CAAC6M,EAAE,CAACrO,aAAa8O,WAAW,EAAE,OAAOxJ;YAChD,MAAM,EAAEtC,OAAO,EAAES,KAAK,EAAE,GAAG6B;YAC3B,IAAI,CAAC7D,MAAM,CAACgC,KAAK,CAAC,eAAe;gBAAET;gBAASS;YAAM;YAGlD,MAAM,IAAI,CAACsL,gBAAgB,CAAC/L,SAASS;QACvC;QAEA,IAAI,CAACjC,QAAQ,CAAC6M,EAAE,CAACrO,aAAagP,UAAU,EAAE,OAAO1J;YAC/C,MAAM,EAAEtC,OAAO,EAAE,GAAGsC;YAEpB,MAAMrE,WAAW,IAAI,CAAC6F,cAAc,CAAClD,iBAAiB,GAAGI,MAAM,CAAC,CAACuB,IAAMA,EAAEvC,OAAO,KAAKA;YACrF/B,SAASoJ,OAAO,CAAC,CAAC9E,IAAOA,EAAErC,MAAM,GAAG;YAGpC,MAAM,IAAI,CAACiJ,gBAAgB;QAC7B;QAGA,IAAI,CAAC3K,QAAQ,CAAC6M,EAAE,CAACrO,aAAaiP,YAAY,EAAE,CAAC3J;YAC3C,MAAM,EAAE7B,KAAK,EAAEyL,SAAS,EAAE,GAAG5J;YAC7B,IAAI,CAAC7D,MAAM,CAACgC,KAAK,CAAC,gBAAgB;gBAAEyL;gBAAWzL;YAAM;YAGrD,IAAI,CAAC0L,iBAAiB,CAACD,WAAWzL;QACpC;QAGA,IAAI,CAACjC,QAAQ,CAAC6M,EAAE,CAACrO,aAAaoP,iBAAiB,EAAE,CAAC9J;YAChD,MAAM,EAAE4B,MAAM,EAAEmI,SAAS,EAAE,GAAG/J;YAC9B,IAAI,CAAC7D,MAAM,CAACgC,KAAK,CAAC,qBAAqB;gBAAEyD;gBAAQmI;YAAU;YAG3D,IAAI,CAACC,eAAe,CAACpI,QAAQmI;QAC/B;IACF;IAEQ1G,oBAA0B;QAChC,IAAI,CAAC5B,mBAAmB,GAAGwI,YAAY;YACrC,IAAI;gBACF,MAAMC,SAAS,MAAM,IAAI,CAACjD,eAAe;gBACzC,IAAI,CAAC/K,QAAQ,CAACuH,IAAI,CAAC/I,aAAayP,kBAAkB,EAAE;oBAAEvM,QAAQsM;gBAAO;gBAErE,IAAIA,OAAOtM,MAAM,KAAK,aAAa;oBACjC,IAAI,CAACzB,MAAM,CAAC4G,IAAI,CAAC,8BAA8BmH;oBAG/C,MAAM,IAAI,CAACE,0BAA0B,CAACF;gBACxC;YACF,EAAE,OAAO/L,OAAO;gBACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,sBAAsBA;YAC1C;QACF,GAAG,IAAI,CAAC/B,MAAM,CAACC,YAAY,CAACoF,mBAAmB;IACjD;IAEQ6B,wBAA8B;QACpC,IAAI,CAAC5B,mBAAmB,GAAGuI,YAAY;YACrC,MAAM,IAAI,CAACvB,kBAAkB;QAC/B,GAAG,IAAI,CAACtM,MAAM,CAACC,YAAY,CAACqF,mBAAmB,IAAI;IACrD;IAEQ6B,yBAA+B;QACrC,IAAI,CAAC5B,eAAe,GAAGsI,YAAY;YACjC,IAAI;gBACF,MAAM9J,UAAU,MAAM,IAAI,CAACgG,UAAU;gBACrC,IAAI,CAAChK,MAAM,CAACwE,KAAK,CAAC,qBAAqBR;gBAGvC,IAAI,CAACjE,QAAQ,CAACuH,IAAI,CAAC,qBAAqBtD;YAC1C,EAAE,OAAOhC,OAAO;gBACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,4BAA4BA;YAChD;QACF,GAAG,IAAI,CAAC/B,MAAM,CAACC,YAAY,CAACsF,eAAe,IAAI;IACjD;IAEQoC,sBAA4B;QAClC,IAAI,IAAI,CAACtC,mBAAmB,EAAE;YAC5B4I,cAAc,IAAI,CAAC5I,mBAAmB;QACxC;QACA,IAAI,IAAI,CAACC,mBAAmB,EAAE;YAC5B2I,cAAc,IAAI,CAAC3I,mBAAmB;QACxC;QACA,IAAI,IAAI,CAACC,eAAe,EAAE;YACxB0I,cAAc,IAAI,CAAC1I,eAAe;QACpC;IACF;IAEA,MAAcsC,qBAAoC;QAChD,MAAMqG,gBAAgB;YACpB,IAAI,CAACC,iBAAiB,CAAC,oBAAoB,IAAM,IAAI,CAACvO,eAAe,CAAC6H,QAAQ;YAC9E,IAAI,CAAC0G,iBAAiB,CAAC,kBAAkB,IAAM,IAAI,CAACtO,aAAa,CAAC4H,QAAQ;YAC1E,IAAI,CAAC0G,iBAAiB,CAAC,wBAAwB,IAAM,IAAI,CAACnI,mBAAmB,CAACyB,QAAQ;YACtF,IAAI,CAAC0G,iBAAiB,CAAC,cAAc,IAAM,IAAI,CAAClI,SAAS,CAACmI,IAAI;SAC/D;QAED,MAAMC,UAAU,MAAM3L,QAAQc,UAAU,CAAC0K;QAGzCG,QAAQ1F,OAAO,CAAC,CAACQ,QAAQmF;YACvB,IAAInF,OAAO3H,MAAM,KAAK,YAAY;gBAChC,MAAM+M,gBAAgB;oBACpB;oBACA;oBACA;oBACA;iBACD,CAACD,MAAM;gBACR,IAAI,CAACvO,MAAM,CAACgC,KAAK,CAAC,CAAC,mBAAmB,EAAEwM,eAAe,EAAEpF,OAAOlB,MAAM;YACxE;QACF;IACF;IAEA,MAAcT,oBAAmC;QAC/C,IAAI,CAACzH,MAAM,CAAC4G,IAAI,CAAC;QAEjB,IAAI;YAEF,MAAMjE,QAAQc,UAAU,CAAC;gBACvB,IAAI,CAAC5D,eAAe,CAAC6H,QAAQ,GAAG3F,KAAK,CAAC,KAAO;gBAC7C,IAAI,CAACjC,aAAa,CAAC4H,QAAQ,GAAG3F,KAAK,CAAC,KAAO;gBAC3C,IAAI,CAACkE,mBAAmB,CAACyB,QAAQ,GAAG3F,KAAK,CAAC,KAAO;gBACjD,IAAI,CAACmE,SAAS,CAACmI,IAAI,GAAGtM,KAAK,CAAC,KAAO;aACpC;QACH,EAAE,OAAOC,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,4BAA4BA;QAChD;IACF;IAEA,MAAc0I,mBAAkC;QAC9C,IAAI,IAAI,CAAC3G,SAAS,CAACT,MAAM,KAAK,GAAG;YAC/B;QACF;QAEA,MAAMmL,kBAAkB,MAAM,IAAI,CAACC,kBAAkB;QAErD,MAAO,IAAI,CAAC3K,SAAS,CAACT,MAAM,GAAG,KAAKmL,gBAAgBnL,MAAM,GAAG,EAAG;YAC9D,MAAM2F,OAAO,IAAI,CAAClF,SAAS,CAAC4K,KAAK;YACjC,MAAMhE,QAAQ,IAAI,CAACiE,kBAAkB,CAAC3F,MAAMwF;YAE5C,IAAI9D,OAAO;gBACT1B,KAAKqB,aAAa,GAAGK,MAAM5J,EAAE;gBAC7BkI,KAAKxH,MAAM,GAAG;gBAEd,IAAI;oBACF,MAAM,IAAI,CAACwE,mBAAmB,CAACmE,UAAU,CAACnB,MAAM0B,MAAM5J,EAAE;oBAExD,IAAI,CAAChB,QAAQ,CAACuH,IAAI,CAAC/I,aAAaqM,aAAa,EAAE;wBAC7CC,QAAQ5B,KAAKlI,EAAE;wBACfQ,SAASoJ,MAAM5J,EAAE;oBACnB;oBAGA,MAAMwN,QAAQE,gBAAgBI,OAAO,CAAClE;oBACtC8D,gBAAgBK,MAAM,CAACP,OAAO;gBAChC,EAAE,OAAOvM,OAAO;oBAEd,IAAI,CAAC+B,SAAS,CAACgL,OAAO,CAAC9F;oBACvB,IAAI,CAACjJ,MAAM,CAACgC,KAAK,CAAC,yBAAyB;wBAAE6I,QAAQ5B,KAAKlI,EAAE;wBAAEiB;oBAAM;oBACpE;gBACF;YACF,OAAO;gBAEL,IAAI,CAAC+B,SAAS,CAACgL,OAAO,CAAC9F;gBACvB;YACF;QACF;IACF;IAEA,MAAcyF,qBAA8C;QAC1D,MAAMlP,WAAW,IAAI,CAAC6F,cAAc,CAAClD,iBAAiB;QACtD,MAAM6M,YAA4B,EAAE;QAEpC,KAAK,MAAMhO,WAAWxB,SAAU;YAC9B,IAAIwB,QAAQS,MAAM,KAAK,UAAUT,QAAQS,MAAM,KAAK,UAAU;gBAC5D,MAAMjB,UAAU,IAAI,CAACiF,MAAM,CAACvD,GAAG,CAAClB,QAAQO,OAAO;gBAC/C,IAAIf,SAAS;oBACX,IAAI;wBACF,MAAMyO,YAAY,MAAM,IAAI,CAAChJ,mBAAmB,CAACiJ,iBAAiB,CAAC1O,QAAQO,EAAE;wBAC7E,IAAIkO,YAAYzO,QAAQ2O,kBAAkB,EAAE;4BAC1CH,UAAUxE,IAAI,CAAChK;wBACjB;oBACF,EAAE,OAAOwB,OAAO;wBACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,kCAAkC;4BAAET,SAASf,QAAQO,EAAE;4BAAEiB;wBAAM;oBACnF;gBACF;YACF;QACF;QAEA,OAAOgN,UAAUI,IAAI,CAAC,CAACC,GAAGC,IAAMA,EAAEnG,QAAQ,GAAGkG,EAAElG,QAAQ;IACzD;IAEQyF,mBAAmB3F,IAAU,EAAExD,MAAsB,EAA4B;QAEvF,MAAM8J,eAAe9J,OAAO/B,GAAG,CAAC,CAACiH;YAC/B,IAAI6E,QAAQ7E,MAAMxB,QAAQ,GAAG;YAG7B,MAAMsG,uBAAuB,AAACxG,KAAKyG,QAAQ,EAAED,wBAAqC,EAAE;YACpF,MAAME,sBAAsBF,qBAAqBlN,MAAM,CAAC,CAACqN,MACvDjF,MAAMzB,YAAY,CAACO,QAAQ,CAACmG,MAC5BtM,MAAM;YAER,IAAImM,qBAAqBnM,MAAM,GAAG,KAAKqM,wBAAwB,GAAG;gBAChE,OAAO;oBAAEhF;oBAAO6E,OAAO,CAAC;gBAAE;YAC5B;YAEAA,SAASG,sBAAsB;YAG/B,IAAI1G,KAAKV,IAAI,KAAKoC,MAAMpC,IAAI,EAAE;gBAC5BiH,SAAS;YACX;YAEA,OAAO;gBAAE7E;gBAAO6E;YAAM;QACxB;QAGA,MAAMK,iBAAiBN,aAAahN,MAAM,CAAC,CAAC,EAAEiN,KAAK,EAAE,GAAKA,SAAS;QAEnE,IAAIK,eAAevM,MAAM,KAAK,GAAG;YAC/B,OAAO2J;QACT;QAGA4C,eAAeT,IAAI,CAAC,CAACC,GAAGC,IAAMA,EAAEE,KAAK,GAAGH,EAAEG,KAAK;QAC/C,OAAOK,cAAc,CAAC,EAAE,CAAClF,KAAK;IAChC;IAEA,MAAcS,mBACZE,IAAY,EACZwE,KAA4F,EAClE;QAC1B,IAAI;YACF,MAAM1G,SAAS,MAAMzG,QAAQC,IAAI,CAAC;gBAChCkN;gBACAnR,MAAM,MAAMmE,IAAI,CAAC,IAAO,CAAA;wBAAEiN,SAAS;wBAAO/N,OAAO;oBAAuB,CAAA;aACzE;YAED,MAAM+L,SAA0B;gBAC9BzC;gBACA7J,QAAQ2H,OAAO2G,OAAO,GAAG,YAAY;gBACrCxE,WAAW,IAAItK;YACjB;YACA,IAAImI,OAAOpH,KAAK,KAAKiL,WAAW;gBAC9Bc,OAAO/L,KAAK,GAAGoH,OAAOpH,KAAK;YAC7B;YACA,IAAI,aAAaoH,UAAUA,OAAOpF,OAAO,KAAKiJ,WAAW;gBACvDc,OAAO/J,OAAO,GAAGoF,OAAOpF,OAAO;YACjC;YACA,OAAO+J;QACT,EAAE,OAAO/L,OAAO;YACd,OAAO;gBACLsJ;gBACA7J,QAAQ;gBACR8J,WAAW,IAAItK;gBACfe,OAAOA,iBAAiBS,QAAQT,MAAMgO,OAAO,GAAG;YAClD;QACF;IACF;IAEQ3E,oBACNjC,MAA6C,EAC7CoF,aAAqB,EACJ;QACjB,IAAIpF,OAAO3H,MAAM,KAAK,aAAa;YACjC,OAAO2H,OAAO6G,KAAK;QACrB,OAAO;YACL,OAAO;gBACL3E,MAAMkD;gBACN/M,QAAQ;gBACR8J,WAAW,IAAItK;gBACfe,OAAOoH,OAAOlB,MAAM,EAAE8H,WAAW;YACnC;QACF;IACF;IAEA,MAAc1J,oBAAoBgF,IAAY,EAAE4E,IAAyB,EAAiB;QACxF,IAAI;YACF,MAAMtR,MAAMsR,MAAM;gBAAEvP,aAAa;gBAAGC,cAAc;YAAK;YACvD,IAAI,CAACZ,MAAM,CAAC4B,IAAI,CAAC,GAAG0J,KAAK,YAAY,CAAC;QACxC,EAAE,OAAOtJ,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,CAAC,qBAAqB,EAAEsJ,MAAM,EAAEtJ;YAClD,MAAM,IAAIvD,oBAAoB6M,MAAM;gBAAEtJ;YAAM;QAC9C;IACF;IAEA,MAAcoM,kBAAkB9C,IAAY,EAAE5D,QAA6B,EAAiB;QAC1F,IAAI;YACF,MAAM/E,QAAQC,IAAI,CAAC;gBACjB8E;gBACA/I,MAAM;aACP;YACD,IAAI,CAACqB,MAAM,CAAC4B,IAAI,CAAC,GAAG0J,KAAK,UAAU,CAAC;QACtC,EAAE,OAAOtJ,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,CAAC,mBAAmB,EAAEsJ,MAAM,EAAEtJ;YAChD,MAAMA;QACR;IACF;IAEQsG,qBAAqB9H,OAAqB,EAAQ;QACxD,IAAI,CAACA,QAAQO,EAAE,IAAI,CAACP,QAAQ8K,IAAI,IAAI,CAAC9K,QAAQ+H,IAAI,EAAE;YACjD,MAAM,IAAI9F,MAAM;QAClB;QAEA,IAAIjC,QAAQ2O,kBAAkB,GAAG,GAAG;YAClC,MAAM,IAAI1M,MAAM;QAClB;QAEA,IAAI,IAAI,CAACgD,MAAM,CAAC0K,GAAG,CAAC3P,QAAQO,EAAE,GAAG;YAC/B,MAAM,IAAI0B,MAAM,CAAC,cAAc,EAAEjC,QAAQO,EAAE,CAAC,eAAe,CAAC;QAC9D;IACF;IAEQsJ,aAAapB,IAAU,EAAQ;QACrC,IAAI,CAACA,KAAKlI,EAAE,IAAI,CAACkI,KAAKV,IAAI,IAAI,CAACU,KAAKmH,WAAW,EAAE;YAC/C,MAAM,IAAI3N,MAAM;QAClB;QAEA,IAAIwG,KAAKE,QAAQ,GAAG,KAAKF,KAAKE,QAAQ,GAAG,KAAK;YAC5C,MAAM,IAAI1G,MAAM;QAClB;QAEA,IAAI,IAAI,CAACiD,WAAW,CAACyK,GAAG,CAAClH,KAAKlI,EAAE,GAAG;YACjC,MAAM,IAAI0B,MAAM,CAAC,aAAa,EAAEwG,KAAKlI,EAAE,CAAC,eAAe,CAAC;QAC1D;IACF;IAEA,MAAcuM,iBAAiB/L,OAAe,EAAES,KAAY,EAAiB;QAC3E,MAAMxB,UAAU,IAAI,CAACiF,MAAM,CAACvD,GAAG,CAACX;QAChC,IAAI,CAACf,SAAS;YACZ;QACF;QAGA,IAAI,CAACR,MAAM,CAACgC,KAAK,CAAC,wBAAwB;YAAET;YAASS;QAAM;QAG3D,MAAMqO,aAAa,AAAC7P,QAAQkP,QAAQ,EAAEW,cAAyB;QAC/D7P,QAAQkP,QAAQ,GAAG;YAAE,GAAGlP,QAAQkP,QAAQ;YAAEW,YAAYA,aAAa;QAAE;QAErE,IAAIA,aAAa,GAAG;YAElB,IAAI;gBACF,MAAM,IAAI,CAACpG,cAAc,CAAC1I;gBAC1B,MAAM5C,MAAM;gBACZ,MAAM,IAAI,CAACwJ,UAAU,CAAC;oBAAE,GAAG3H,OAAO;oBAAEkP,UAAU;wBAAE,GAAGlP,QAAQkP,QAAQ;wBAAEW,YAAY;oBAAE;gBAAE;gBACrF,IAAI,CAACrQ,MAAM,CAAC4B,IAAI,CAAC,+BAA+B;oBAAEL;gBAAQ;YAC5D,EAAE,OAAO+O,cAAc;gBACrB,IAAI,CAACtQ,MAAM,CAACgC,KAAK,CAAC,2BAA2B;oBAAET;oBAASS,OAAOsO;gBAAa;YAC9E;QACF,OAAO;YAEL,IAAI,CAACtQ,MAAM,CAACgC,KAAK,CAAC,+CAA+C;gBAAET;gBAAS8O;YAAW;YACvF,MAAM,IAAI,CAACpG,cAAc,CAAC1I;QAC5B;IACF;IAEA,MAAc6L,kBAAkBvC,MAAc,EAAE7I,KAAY,EAAiB;QAC3E,MAAMiH,OAAO,IAAI,CAACvD,WAAW,CAACxD,GAAG,CAAC2I;QAClC,IAAI,CAAC5B,MAAM;YACT;QACF;QAEA,MAAMsH,aAAa,AAACtH,KAAKyG,QAAQ,EAAEa,cAAyB;QAC5D,MAAMC,aAAa,IAAI,CAACvQ,MAAM,CAACC,YAAY,CAACuQ,cAAc,IAAI;QAE9D,IAAIF,aAAaC,YAAY;YAE3BvH,KAAKyG,QAAQ,GAAG;gBAAE,GAAGzG,KAAKyG,QAAQ;gBAAEa,YAAYA,aAAa;YAAE;YAC/DtH,KAAKxH,MAAM,GAAG;YACd,OAAOwH,KAAKqB,aAAa;YAGzBoG,WACE;gBACE,IAAI,CAAC3M,SAAS,CAACyG,IAAI,CAACvB;gBACpB,IAAI,CAACyB,gBAAgB;YACvB,GACAvJ,KAAKwP,GAAG,CAAC,GAAGJ,cAAc;YAG5B,IAAI,CAACvQ,MAAM,CAAC4B,IAAI,CAAC,yBAAyB;gBAAEiJ;gBAAQ0F,YAAYA,aAAa;YAAE;QACjF,OAAO;YACL,IAAI,CAACvQ,MAAM,CAACgC,KAAK,CAAC,6BAA6B;gBAAE6I;gBAAQ0F;YAAW;QACtE;IACF;IAEQ7C,kBAAkBD,SAAiB,EAAEzL,KAAY,EAAQ;QAE/D,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,yBAAyB;YAAEyL;YAAWzL;QAAM;IAGhE;IAEA,MAAc6L,gBAAgBpI,MAAgB,EAAEmI,SAAmB,EAAiB;QAClF,IAAI,CAAC5N,MAAM,CAAC4G,IAAI,CAAC,sBAAsB;YAAEnB;YAAQmI;QAAU;QAG3D,MAAMgD,gBAAgBnL,OAAO/B,GAAG,CAAC,CAAC3C,KAAO,IAAI,CAAC0E,MAAM,CAACvD,GAAG,CAACnB,KAAKwB,MAAM,CAACsO;QAErE,IAAID,cAActN,MAAM,KAAK,GAAG;YAC9B;QACF;QAGAsN,cAAcxB,IAAI,CAAC,CAACC,GAAGC,IAAMD,EAAElG,QAAQ,GAAGmG,EAAEnG,QAAQ;QAGpD,MAAM2H,cAAcF,aAAa,CAAC,EAAE;QACpC,MAAM,IAAI,CAAC1G,gBAAgB,CAAC4G,YAAY/P,EAAE;QAE1C,IAAI,CAACf,MAAM,CAAC4B,IAAI,CAAC,yCAAyC;YAAEL,SAASuP,YAAY/P,EAAE;QAAC;IACtF;IAEA,MAAcmJ,iBAAiB3I,OAAe,EAAiB;QAC7D,IAAI;YACF,MAAMwP,QAAQ,MAAM,IAAI,CAAC9K,mBAAmB,CAAC+K,aAAa,CAACzP;YAE3D,KAAK,MAAM0H,QAAQ8H,MAAO;gBACxB,MAAM,IAAI,CAAC9K,mBAAmB,CAACgL,UAAU,CAAChI,KAAKlI,EAAE;gBAGjD,MAAMmQ,cAAc,IAAI,CAACxL,WAAW,CAACxD,GAAG,CAAC+G,KAAKlI,EAAE;gBAChD,IAAImQ,aAAa;oBACfA,YAAYzP,MAAM,GAAG;oBACrByP,YAAYlE,WAAW,GAAG,IAAI/L;gBAChC;gBAEA,IAAI,CAAClB,QAAQ,CAACuH,IAAI,CAAC/I,aAAa4S,cAAc,EAAE;oBAC9CtG,QAAQ5B,KAAKlI,EAAE;oBACfmH,QAAQ;gBACV;YACF;QACF,EAAE,OAAOlG,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,gCAAgC;gBAAET;gBAASS;YAAM;QACrE;IACF;IAEQyG,2BAA2BlH,OAAe,EAAQ,CAE1D;IAEA,MAAc0M,2BAA2BF,MAAoB,EAAiB;QAC5E,KAAK,MAAM,CAACzC,MAAMmC,UAAU,IAAI1I,OAAOqM,OAAO,CAACrD,OAAOhD,UAAU,EAAG;YACjE,IAAI0C,UAAUhM,MAAM,KAAK,aAAa;gBACpC,IAAI,CAACzB,MAAM,CAAC4G,IAAI,CAAC,6CAA6C;oBAAE0E;gBAAK;gBAGrE,OAAQA;oBACN,KAAK;wBAEH;oBACF,KAAK;wBAEH;oBACF,KAAK;wBAEH;oBACF,KAAK;wBAEH;gBACJ;YACF;QACF;IACF;IAEA,MAAckB,4BAA2C;QACvD,MAAM6E,cAAc,IAAI,CAAChM,cAAc,CAAClD,iBAAiB;QACzD,MAAMmP,qBAAqBD,YAAY9O,MAAM,CAAC,CAACuB,IAAM,AAACA,EAAUrC,MAAM,KAAK;QAE3E,MAAM8P,aAAatQ,KAAKC,GAAG,KAAM,CAAA,IAAI,CAACjB,MAAM,CAACC,YAAY,CAACsR,kBAAkB,IAAI,OAAM;QAEtF,KAAK,MAAMxQ,WAAWsQ,mBAAoB;YACxC,MAAMG,eAAezQ;YACrB,IAAIyQ,aAAa/O,OAAO,IAAI+O,aAAa/O,OAAO,CAACQ,OAAO,KAAKqO,YAAY;gBACvE,MAAM,IAAI,CAAClM,cAAc,CAAC7C,gBAAgB,CAACiP,aAAa1Q,EAAE;gBAC1D,IAAI,CAACf,MAAM,CAACwE,KAAK,CAAC,0BAA0B;oBAAE3C,WAAW4P,aAAa1Q,EAAE;gBAAC;YAC3E;QACF;IACF;IAEA,MAAc0L,qBAAoC;QAChD,MAAM8E,aAAatQ,KAAKC,GAAG,KAAM,CAAA,IAAI,CAACjB,MAAM,CAACC,YAAY,CAACwR,sBAAsB,IAAI,QAAO;QAE3F,KAAK,MAAM,CAAC7G,QAAQ5B,KAAK,IAAI,IAAI,CAACvD,WAAW,CAAC0L,OAAO,GAAI;YACvD,IAAInI,KAAK+D,WAAW,IAAI/D,KAAK+D,WAAW,CAAC9J,OAAO,KAAKqO,YAAY;gBAC/D,IAAI,CAAC7L,WAAW,CAAC1C,MAAM,CAAC6H;gBACxB,IAAI,CAAC7K,MAAM,CAACwE,KAAK,CAAC,uBAAuB;oBAAEqG;gBAAO;YACpD;QACF;IACF;IAEA,MAAchD,uBAAsC;QAElD,MAAM8J,gBAAgB,IAAI,CAAC5N,SAAS,CAACxB,MAAM,CACzC,CAACqP,IAAMA,EAAEzI,QAAQ,IAAI,MAAMyI,EAAElC,QAAQ,EAAEmC,aAAa;QAGtD,IAAIF,cAAcrO,MAAM,GAAG,GAAG;YAC5B,IAAI,CAACtD,MAAM,CAAC4B,IAAI,CAAC,6CAA6C;gBAC5D6C,OAAOkN,cAAcrO,MAAM;YAC7B;QAGF;IACF;IAKAwO,kBAA+C;QAC7C,OAAO,IAAI,CAACnM,YAAY;IAC1B;IAKAoM,sBAAyD;QACvD,OAAO,IAAI,CAAClM,gBAAgB;IAC9B;IAKAmM,qBAA0D;QACxD,OAAO,IAAI,CAAClM,eAAe;IAC7B;IAKAmM,mBAAmBhS,MAAiC,EAAQ;QAC1D,IAAI,CAAC2F,aAAa,CAACsM,eAAe,CAACjS;QAEnC,IAAI,IAAI,CAAC0F,YAAY,EAAE;YACrB,IAAI,CAACA,YAAY,CAACwM,YAAY,CAAClS;QACjC,OAAO,IAAI,IAAI,CAAC2F,aAAa,CAACY,qBAAqB,IAAI;YAErD,IAAI;gBACF,IAAI,CAACb,YAAY,GAAG,IAAIxG,gBAAgB,IAAI,CAACa,MAAM,EAAE,IAAI,CAAC4F,aAAa;gBACvE,IAAI,CAAC5F,MAAM,CAAC4B,IAAI,CAAC;YACnB,EAAE,OAAOI,OAAO;gBACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,0CAA0CA;YAC9D;QACF;IACF;IAKA,MAAMoQ,qBACJC,MAAc,EACdC,OAKC,EACuB;QACxB,IAAI,CAAC,IAAI,CAAC3M,YAAY,EAAE;YACtB,IAAI,CAAC3F,MAAM,CAACgC,KAAK,CAAC;YAClB,OAAO;QACT;QAEA,IAAI;YACF,MAAMuQ,WAAW,MAAM,IAAI,CAAC5M,YAAY,CAAC6M,QAAQ,CAACH,QAAQC;YAC1D,OAAOC;QACT,EAAE,OAAOvQ,OAAO;YACd,IAAI,CAAChC,MAAM,CAACgC,KAAK,CAAC,6BAA6BA;YAC/C,OAAO;QACT;IACF;AACF"}