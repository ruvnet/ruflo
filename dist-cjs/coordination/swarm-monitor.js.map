{
  "version": 3,
  "sources": ["../../src/coordination/swarm-monitor.ts"],
  "sourcesContent": ["import { EventEmitter } from 'node:events';\nimport * as os from 'node:os';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\nimport { Logger } from '../core/logger.js';\nimport { performance } from 'node:perf_hooks';\n\ninterface AgentMetrics {\n  id: string;\n  name: string;\n  status: 'idle' | 'running' | 'completed' | 'failed' | 'stalled';\n  currentTask?: string;\n  startTime?: number;\n  endTime?: number;\n  duration?: number;\n  cpuUsage?: number;\n  memoryUsage?: number;\n  taskCount: number;\n  successCount: number;\n  failureCount: number;\n  averageTaskDuration: number;\n  lastActivity: number;\n  outputSize?: number;\n  errorRate: number;\n}\n\ninterface SystemMetrics {\n  timestamp: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  totalMemory: number;\n  freeMemory: number;\n  loadAverage: number[];\n  activeAgents: number;\n  totalTasks: number;\n  completedTasks: number;\n  failedTasks: number;\n  pendingTasks: number;\n  averageTaskDuration: number;\n  throughput: number; // tasks per minute\n}\n\ninterface Alert {\n  id: string;\n  timestamp: number;\n  level: 'info' | 'warning' | 'error' | 'critical';\n  type:\n    | 'agent_failure'\n    | 'high_cpu'\n    | 'high_memory'\n    | 'stalled_agent'\n    | 'low_throughput'\n    | 'error_rate';\n  message: string;\n  details?: any;\n}\n\ninterface MonitoringConfig {\n  updateInterval: number; // milliseconds\n  metricsRetention: number; // hours\n  cpuThreshold: number; // percentage\n  memoryThreshold: number; // percentage\n  stallTimeout: number; // milliseconds\n  errorRateThreshold: number; // percentage\n  throughputThreshold: number; // tasks per minute\n  enableAlerts: boolean;\n  enableHistory: boolean;\n  historyPath?: string;\n}\n\nexport class SwarmMonitor extends EventEmitter {\n  private logger: Logger;\n  private config: MonitoringConfig;\n  private agentMetrics: Map<string, AgentMetrics> = new Map();\n  private systemMetrics: SystemMetrics[] = [];\n  private alerts: Alert[] = [];\n  private monitoringInterval?: NodeJS.Timeout;\n  private startTime: number;\n  private taskStartTimes: Map<string, number> = new Map();\n  private taskCompletionTimes: number[] = [];\n  private lastThroughputCheck: number;\n  private tasksInLastMinute: number = 0;\n\n  constructor(config?: Partial<MonitoringConfig>) {\n    super();\n    this.logger = new Logger('SwarmMonitor');\n    this.config = {\n      updateInterval: 1000, // 1 second\n      metricsRetention: 24, // 24 hours\n      cpuThreshold: 80, // 80%\n      memoryThreshold: 85, // 85%\n      stallTimeout: 300000, // 5 minutes\n      errorRateThreshold: 10, // 10%\n      throughputThreshold: 1, // 1 task per minute minimum\n      enableAlerts: true,\n      enableHistory: true,\n      historyPath: './monitoring/history',\n      ...config,\n    };\n    this.startTime = Date.now();\n    this.lastThroughputCheck = Date.now();\n  }\n\n  async start(): Promise<void> {\n    this.logger.info('Starting swarm monitoring...');\n\n    // Create history directory if needed\n    if (this.config.enableHistory && this.config.historyPath) {\n      await fs.mkdir(this.config.historyPath, { recursive: true });\n    }\n\n    // Start periodic monitoring\n    this.monitoringInterval = setInterval(() => {\n      this.collectMetrics();\n    }, this.config.updateInterval);\n\n    // Start initial collection\n    await this.collectMetrics();\n  }\n\n  stop(): void {\n    this.logger.info('Stopping swarm monitoring...');\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = undefined;\n    }\n  }\n\n  // Agent registration and tracking\n  registerAgent(agentId: string, name: string): void {\n    this.agentMetrics.set(agentId, {\n      id: agentId,\n      name,\n      status: 'idle',\n      taskCount: 0,\n      successCount: 0,\n      failureCount: 0,\n      averageTaskDuration: 0,\n      lastActivity: Date.now(),\n      errorRate: 0,\n    });\n    this.logger.debug(`Registered agent: ${name} (${agentId})`);\n  }\n\n  unregisterAgent(agentId: string): void {\n    const metrics = this.agentMetrics.get(agentId);\n    if (metrics) {\n      this.logger.debug(`Unregistered agent: ${metrics.name} (${agentId})`);\n      this.agentMetrics.delete(agentId);\n    }\n  }\n\n  // Task tracking\n  taskStarted(agentId: string, taskId: string, taskDescription?: string): void {\n    const metrics = this.agentMetrics.get(agentId);\n    if (metrics) {\n      metrics.status = 'running';\n      metrics.currentTask = taskDescription || taskId;\n      metrics.startTime = Date.now();\n      metrics.lastActivity = Date.now();\n      metrics.taskCount++;\n      this.taskStartTimes.set(taskId, Date.now());\n      this.emit('task:started', { agentId, taskId, taskDescription });\n    }\n  }\n\n  taskCompleted(agentId: string, taskId: string, outputSize?: number): void {\n    const metrics = this.agentMetrics.get(agentId);\n    const startTime = this.taskStartTimes.get(taskId);\n\n    if (metrics && startTime) {\n      const duration = Date.now() - startTime;\n      metrics.status = 'completed';\n      metrics.endTime = Date.now();\n      metrics.duration = duration;\n      metrics.lastActivity = Date.now();\n      metrics.successCount++;\n      metrics.outputSize = outputSize;\n\n      // Update average duration\n      const totalDuration = metrics.averageTaskDuration * (metrics.successCount - 1) + duration;\n      metrics.averageTaskDuration = totalDuration / metrics.successCount;\n\n      // Update error rate\n      metrics.errorRate = (metrics.failureCount / metrics.taskCount) * 100;\n\n      // Track for throughput calculation\n      this.taskCompletionTimes.push(Date.now());\n      this.tasksInLastMinute++;\n\n      this.taskStartTimes.delete(taskId);\n      this.emit('task:completed', { agentId, taskId, duration, outputSize });\n    }\n  }\n\n  taskFailed(agentId: string, taskId: string, error: string): void {\n    const metrics = this.agentMetrics.get(agentId);\n    const startTime = this.taskStartTimes.get(taskId);\n\n    if (metrics) {\n      const duration = startTime ? Date.now() - startTime : 0;\n      metrics.status = 'failed';\n      metrics.endTime = Date.now();\n      metrics.duration = duration;\n      metrics.lastActivity = Date.now();\n      metrics.failureCount++;\n\n      // Update error rate\n      metrics.errorRate = (metrics.failureCount / metrics.taskCount) * 100;\n\n      this.taskStartTimes.delete(taskId);\n      this.emit('task:failed', { agentId, taskId, error, duration });\n\n      // Check error rate threshold\n      if (metrics.errorRate > this.config.errorRateThreshold) {\n        this.createAlert(\n          'error_rate',\n          'critical',\n          `Agent ${metrics.name} has high error rate: ${metrics.errorRate.toFixed(1)}%`,\n        );\n      }\n    }\n  }\n\n  // Metrics collection\n  private async collectMetrics(): Promise<void> {\n    try {\n      // Collect system metrics\n      const cpuUsage = this.getCPUUsage();\n      const memInfo = this.getMemoryInfo();\n      const loadAvg = os.loadavg();\n\n      // Calculate throughput\n      const now = Date.now();\n      const minuteAgo = now - 60000;\n      this.taskCompletionTimes = this.taskCompletionTimes.filter((time) => time > minuteAgo);\n      const throughput = this.taskCompletionTimes.length;\n\n      // Calculate task statistics\n      let totalTasks = 0;\n      let completedTasks = 0;\n      let failedTasks = 0;\n      let activeAgents = 0;\n      let totalDuration = 0;\n      let durationCount = 0;\n\n      // Check for stalled agents\n      for (const [agentId, metrics] of this.agentMetrics) {\n        if (metrics.status === 'running') {\n          activeAgents++;\n\n          // Check for stalled agent\n          const stallTime = now - metrics.lastActivity;\n          if (stallTime > this.config.stallTimeout) {\n            metrics.status = 'stalled';\n            this.createAlert(\n              'stalled_agent',\n              'warning',\n              `Agent ${metrics.name} appears to be stalled (${Math.round(stallTime / 1000)}s inactive)`,\n            );\n          }\n        }\n\n        totalTasks += metrics.taskCount;\n        completedTasks += metrics.successCount;\n        failedTasks += metrics.failureCount;\n\n        if (metrics.averageTaskDuration > 0) {\n          totalDuration += metrics.averageTaskDuration * metrics.successCount;\n          durationCount += metrics.successCount;\n        }\n      }\n\n      const avgDuration = durationCount > 0 ? totalDuration / durationCount : 0;\n      const pendingTasks = totalTasks - completedTasks - failedTasks;\n\n      // Create system metrics\n      const systemMetrics: SystemMetrics = {\n        timestamp: now,\n        cpuUsage,\n        memoryUsage: memInfo.usagePercent,\n        totalMemory: memInfo.total,\n        freeMemory: memInfo.free,\n        loadAverage: loadAvg,\n        activeAgents,\n        totalTasks,\n        completedTasks,\n        failedTasks,\n        pendingTasks,\n        averageTaskDuration: avgDuration,\n        throughput,\n      };\n\n      this.systemMetrics.push(systemMetrics);\n\n      // Check system thresholds\n      if (this.config.enableAlerts) {\n        this.checkThresholds(systemMetrics);\n      }\n\n      // Clean old metrics\n      this.cleanOldMetrics();\n\n      // Save history if enabled\n      if (this.config.enableHistory) {\n        await this.saveHistory(systemMetrics);\n      }\n\n      // Emit metrics update\n      this.emit('metrics:updated', {\n        system: systemMetrics,\n        agents: Array.from(this.agentMetrics.values()),\n      });\n    } catch (error) {\n      this.logger.error('Error collecting metrics:', error);\n    }\n  }\n\n  private getCPUUsage(): number {\n    const cpus = os.cpus();\n    let totalIdle = 0;\n    let totalTick = 0;\n\n    cpus.forEach((cpu) => {\n      for (const type in cpu.times) {\n        totalTick += cpu.times[type as keyof typeof cpu.times];\n      }\n      totalIdle += cpu.times.idle;\n    });\n\n    return 100 - Math.floor((totalIdle / totalTick) * 100);\n  }\n\n  private getMemoryInfo(): { total: number; free: number; used: number; usagePercent: number } {\n    const total = os.totalmem();\n    const free = os.freemem();\n    const used = total - free;\n    const usagePercent = (used / total) * 100;\n\n    return { total, free, used, usagePercent };\n  }\n\n  private checkThresholds(metrics: SystemMetrics): void {\n    // CPU threshold\n    if (metrics.cpuUsage > this.config.cpuThreshold) {\n      this.createAlert('high_cpu', 'warning', `High CPU usage detected: ${metrics.cpuUsage}%`);\n    }\n\n    // Memory threshold\n    if (metrics.memoryUsage > this.config.memoryThreshold) {\n      this.createAlert(\n        'high_memory',\n        'warning',\n        `High memory usage detected: ${metrics.memoryUsage.toFixed(1)}%`,\n      );\n    }\n\n    // Throughput threshold\n    if (metrics.activeAgents > 0 && metrics.throughput < this.config.throughputThreshold) {\n      this.createAlert(\n        'low_throughput',\n        'warning',\n        `Low throughput detected: ${metrics.throughput} tasks/min`,\n      );\n    }\n  }\n\n  private createAlert(\n    type: Alert['type'],\n    level: Alert['level'],\n    message: string,\n    details?: any,\n  ): void {\n    const alert: Alert = {\n      id: `${type}_${Date.now()}`,\n      timestamp: Date.now(),\n      level,\n      type,\n      message,\n      details,\n    };\n\n    this.alerts.push(alert);\n    this.emit('alert', alert);\n    this.logger[level](message);\n  }\n\n  private cleanOldMetrics(): void {\n    const retentionTime = this.config.metricsRetention * 60 * 60 * 1000;\n    const cutoff = Date.now() - retentionTime;\n\n    this.systemMetrics = this.systemMetrics.filter((m) => m.timestamp > cutoff);\n    this.alerts = this.alerts.filter((a) => a.timestamp > cutoff);\n  }\n\n  private async saveHistory(metrics: SystemMetrics): Promise<void> {\n    if (!this.config.historyPath) return;\n\n    try {\n      const date = new Date();\n      const filename = `metrics_${date.toISOString().split('T')[0]}.jsonl`;\n      const filepath = path.join(this.config.historyPath, filename);\n\n      const line =\n        JSON.stringify({\n          ...metrics,\n          agents: Array.from(this.agentMetrics.values()),\n        }) + '\\n';\n\n      await fs.appendFile(filepath, line);\n    } catch (error) {\n      this.logger.error('Error saving history:', error);\n    }\n  }\n\n  // Getters for current state\n  getSystemMetrics(): SystemMetrics | undefined {\n    return this.systemMetrics[this.systemMetrics.length - 1];\n  }\n\n  getAgentMetrics(agentId?: string): AgentMetrics | AgentMetrics[] | undefined {\n    if (agentId) {\n      return this.agentMetrics.get(agentId);\n    }\n    return Array.from(this.agentMetrics.values());\n  }\n\n  getAlerts(since?: number): Alert[] {\n    if (since) {\n      return this.alerts.filter((a) => a.timestamp > since);\n    }\n    return this.alerts;\n  }\n\n  getHistoricalMetrics(hours: number = 1): SystemMetrics[] {\n    const since = Date.now() - hours * 60 * 60 * 1000;\n    return this.systemMetrics.filter((m) => m.timestamp > since);\n  }\n\n  // Summary statistics\n  getSummary(): {\n    uptime: number;\n    totalAgents: number;\n    activeAgents: number;\n    totalTasks: number;\n    completedTasks: number;\n    failedTasks: number;\n    successRate: number;\n    averageDuration: number;\n    currentThroughput: number;\n    alerts: number;\n  } {\n    const current = this.getSystemMetrics();\n    const uptime = Date.now() - this.startTime;\n    const totalAgents = this.agentMetrics.size;\n    const activeAgents = current?.activeAgents || 0;\n    const totalTasks = current?.totalTasks || 0;\n    const completedTasks = current?.completedTasks || 0;\n    const failedTasks = current?.failedTasks || 0;\n    const successRate = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n    const averageDuration = current?.averageTaskDuration || 0;\n    const currentThroughput = current?.throughput || 0;\n    const alerts = this.alerts.filter((a) => a.timestamp > Date.now() - 3600000).length; // Last hour\n\n    return {\n      uptime,\n      totalAgents,\n      activeAgents,\n      totalTasks,\n      completedTasks,\n      failedTasks,\n      successRate,\n      averageDuration,\n      currentThroughput,\n      alerts,\n    };\n  }\n\n  // Export monitoring data\n  async exportMetrics(filepath: string): Promise<void> {\n    const data = {\n      summary: this.getSummary(),\n      systemMetrics: this.systemMetrics,\n      agentMetrics: Array.from(this.agentMetrics.values()),\n      alerts: this.alerts,\n      exported: new Date().toISOString(),\n    };\n\n    await fs.writeFile(filepath, JSON.stringify(data, null, 2));\n    this.logger.info(`Exported metrics to ${filepath}`);\n  }\n}\n\n// Export types for external use\nexport type { AgentMetrics, SystemMetrics, Alert, MonitoringConfig };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAA6B;AAC7B,SAAoB;AACpB,SAAoB;AACpB,WAAsB;AACtB,oBAAuB;AAkEhB,MAAM,qBAAqB,gCAAa;AAAA,EAtE/C,OAsE+C;AAAA;AAAA;AAAA,EACrC;AAAA,EACA;AAAA,EACA,eAA0C,oBAAI,IAAI;AAAA,EAClD,gBAAiC,CAAC;AAAA,EAClC,SAAkB,CAAC;AAAA,EACnB;AAAA,EACA;AAAA,EACA,iBAAsC,oBAAI,IAAI;AAAA,EAC9C,sBAAgC,CAAC;AAAA,EACjC;AAAA,EACA,oBAA4B;AAAA,EAEpC,YAAY,QAAoC;AAC9C,UAAM;AACN,SAAK,SAAS,IAAI,qBAAO,cAAc;AACvC,SAAK,SAAS;AAAA,MACZ,gBAAgB;AAAA;AAAA,MAChB,kBAAkB;AAAA;AAAA,MAClB,cAAc;AAAA;AAAA,MACd,iBAAiB;AAAA;AAAA,MACjB,cAAc;AAAA;AAAA,MACd,oBAAoB;AAAA;AAAA,MACpB,qBAAqB;AAAA;AAAA,MACrB,cAAc;AAAA,MACd,eAAe;AAAA,MACf,aAAa;AAAA,MACb,GAAG;AAAA,IACL;AACA,SAAK,YAAY,KAAK,IAAI;AAC1B,SAAK,sBAAsB,KAAK,IAAI;AAAA,EACtC;AAAA,EAEA,MAAM,QAAuB;AAC3B,SAAK,OAAO,KAAK,8BAA8B;AAG/C,QAAI,KAAK,OAAO,iBAAiB,KAAK,OAAO,aAAa;AACxD,YAAM,GAAG,MAAM,KAAK,OAAO,aAAa,EAAE,WAAW,KAAK,CAAC;AAAA,IAC7D;AAGA,SAAK,qBAAqB,YAAY,MAAM;AAC1C,WAAK,eAAe;AAAA,IACtB,GAAG,KAAK,OAAO,cAAc;AAG7B,UAAM,KAAK,eAAe;AAAA,EAC5B;AAAA,EAEA,OAAa;AACX,SAAK,OAAO,KAAK,8BAA8B;AAC/C,QAAI,KAAK,oBAAoB;AAC3B,oBAAc,KAAK,kBAAkB;AACrC,WAAK,qBAAqB;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA,EAGA,cAAc,SAAiB,MAAoB;AACjD,SAAK,aAAa,IAAI,SAAS;AAAA,MAC7B,IAAI;AAAA,MACJ;AAAA,MACA,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,cAAc;AAAA,MACd,cAAc;AAAA,MACd,qBAAqB;AAAA,MACrB,cAAc,KAAK,IAAI;AAAA,MACvB,WAAW;AAAA,IACb,CAAC;AACD,SAAK,OAAO,MAAM,qBAAqB,IAAI,KAAK,OAAO,GAAG;AAAA,EAC5D;AAAA,EAEA,gBAAgB,SAAuB;AACrC,UAAM,UAAU,KAAK,aAAa,IAAI,OAAO;AAC7C,QAAI,SAAS;AACX,WAAK,OAAO,MAAM,uBAAuB,QAAQ,IAAI,KAAK,OAAO,GAAG;AACpE,WAAK,aAAa,OAAO,OAAO;AAAA,IAClC;AAAA,EACF;AAAA;AAAA,EAGA,YAAY,SAAiB,QAAgB,iBAAgC;AAC3E,UAAM,UAAU,KAAK,aAAa,IAAI,OAAO;AAC7C,QAAI,SAAS;AACX,cAAQ,SAAS;AACjB,cAAQ,cAAc,mBAAmB;AACzC,cAAQ,YAAY,KAAK,IAAI;AAC7B,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ;AACR,WAAK,eAAe,IAAI,QAAQ,KAAK,IAAI,CAAC;AAC1C,WAAK,KAAK,gBAAgB,EAAE,SAAS,QAAQ,gBAAgB,CAAC;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,cAAc,SAAiB,QAAgB,YAA2B;AACxE,UAAM,UAAU,KAAK,aAAa,IAAI,OAAO;AAC7C,UAAM,YAAY,KAAK,eAAe,IAAI,MAAM;AAEhD,QAAI,WAAW,WAAW;AACxB,YAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,cAAQ,SAAS;AACjB,cAAQ,UAAU,KAAK,IAAI;AAC3B,cAAQ,WAAW;AACnB,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ;AACR,cAAQ,aAAa;AAGrB,YAAM,gBAAgB,QAAQ,uBAAuB,QAAQ,eAAe,KAAK;AACjF,cAAQ,sBAAsB,gBAAgB,QAAQ;AAGtD,cAAQ,YAAa,QAAQ,eAAe,QAAQ,YAAa;AAGjE,WAAK,oBAAoB,KAAK,KAAK,IAAI,CAAC;AACxC,WAAK;AAEL,WAAK,eAAe,OAAO,MAAM;AACjC,WAAK,KAAK,kBAAkB,EAAE,SAAS,QAAQ,UAAU,WAAW,CAAC;AAAA,IACvE;AAAA,EACF;AAAA,EAEA,WAAW,SAAiB,QAAgB,OAAqB;AAC/D,UAAM,UAAU,KAAK,aAAa,IAAI,OAAO;AAC7C,UAAM,YAAY,KAAK,eAAe,IAAI,MAAM;AAEhD,QAAI,SAAS;AACX,YAAM,WAAW,YAAY,KAAK,IAAI,IAAI,YAAY;AACtD,cAAQ,SAAS;AACjB,cAAQ,UAAU,KAAK,IAAI;AAC3B,cAAQ,WAAW;AACnB,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ;AAGR,cAAQ,YAAa,QAAQ,eAAe,QAAQ,YAAa;AAEjE,WAAK,eAAe,OAAO,MAAM;AACjC,WAAK,KAAK,eAAe,EAAE,SAAS,QAAQ,OAAO,SAAS,CAAC;AAG7D,UAAI,QAAQ,YAAY,KAAK,OAAO,oBAAoB;AACtD,aAAK;AAAA,UACH;AAAA,UACA;AAAA,UACA,SAAS,QAAQ,IAAI,yBAAyB,QAAQ,UAAU,QAAQ,CAAC,CAAC;AAAA,QAC5E;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,iBAAgC;AAC5C,QAAI;AAEF,YAAM,WAAW,KAAK,YAAY;AAClC,YAAM,UAAU,KAAK,cAAc;AACnC,YAAM,UAAU,GAAG,QAAQ;AAG3B,YAAM,MAAM,KAAK,IAAI;AACrB,YAAM,YAAY,MAAM;AACxB,WAAK,sBAAsB,KAAK,oBAAoB,OAAO,CAAC,SAAS,OAAO,SAAS;AACrF,YAAM,aAAa,KAAK,oBAAoB;AAG5C,UAAI,aAAa;AACjB,UAAI,iBAAiB;AACrB,UAAI,cAAc;AAClB,UAAI,eAAe;AACnB,UAAI,gBAAgB;AACpB,UAAI,gBAAgB;AAGpB,iBAAW,CAAC,SAAS,OAAO,KAAK,KAAK,cAAc;AAClD,YAAI,QAAQ,WAAW,WAAW;AAChC;AAGA,gBAAM,YAAY,MAAM,QAAQ;AAChC,cAAI,YAAY,KAAK,OAAO,cAAc;AACxC,oBAAQ,SAAS;AACjB,iBAAK;AAAA,cACH;AAAA,cACA;AAAA,cACA,SAAS,QAAQ,IAAI,2BAA2B,KAAK,MAAM,YAAY,GAAI,CAAC;AAAA,YAC9E;AAAA,UACF;AAAA,QACF;AAEA,sBAAc,QAAQ;AACtB,0BAAkB,QAAQ;AAC1B,uBAAe,QAAQ;AAEvB,YAAI,QAAQ,sBAAsB,GAAG;AACnC,2BAAiB,QAAQ,sBAAsB,QAAQ;AACvD,2BAAiB,QAAQ;AAAA,QAC3B;AAAA,MACF;AAEA,YAAM,cAAc,gBAAgB,IAAI,gBAAgB,gBAAgB;AACxE,YAAM,eAAe,aAAa,iBAAiB;AAGnD,YAAM,gBAA+B;AAAA,QACnC,WAAW;AAAA,QACX;AAAA,QACA,aAAa,QAAQ;AAAA,QACrB,aAAa,QAAQ;AAAA,QACrB,YAAY,QAAQ;AAAA,QACpB,aAAa;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,qBAAqB;AAAA,QACrB;AAAA,MACF;AAEA,WAAK,cAAc,KAAK,aAAa;AAGrC,UAAI,KAAK,OAAO,cAAc;AAC5B,aAAK,gBAAgB,aAAa;AAAA,MACpC;AAGA,WAAK,gBAAgB;AAGrB,UAAI,KAAK,OAAO,eAAe;AAC7B,cAAM,KAAK,YAAY,aAAa;AAAA,MACtC;AAGA,WAAK,KAAK,mBAAmB;AAAA,QAC3B,QAAQ;AAAA,QACR,QAAQ,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAAA,MAC/C,CAAC;AAAA,IACH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,6BAA6B,KAAK;AAAA,IACtD;AAAA,EACF;AAAA,EAEQ,cAAsB;AAC5B,UAAM,OAAO,GAAG,KAAK;AACrB,QAAI,YAAY;AAChB,QAAI,YAAY;AAEhB,SAAK,QAAQ,CAAC,QAAQ;AACpB,iBAAW,QAAQ,IAAI,OAAO;AAC5B,qBAAa,IAAI,MAAM,IAA8B;AAAA,MACvD;AACA,mBAAa,IAAI,MAAM;AAAA,IACzB,CAAC;AAED,WAAO,MAAM,KAAK,MAAO,YAAY,YAAa,GAAG;AAAA,EACvD;AAAA,EAEQ,gBAAqF;AAC3F,UAAM,QAAQ,GAAG,SAAS;AAC1B,UAAM,OAAO,GAAG,QAAQ;AACxB,UAAM,OAAO,QAAQ;AACrB,UAAM,eAAgB,OAAO,QAAS;AAEtC,WAAO,EAAE,OAAO,MAAM,MAAM,aAAa;AAAA,EAC3C;AAAA,EAEQ,gBAAgB,SAA8B;AAEpD,QAAI,QAAQ,WAAW,KAAK,OAAO,cAAc;AAC/C,WAAK,YAAY,YAAY,WAAW,4BAA4B,QAAQ,QAAQ,GAAG;AAAA,IACzF;AAGA,QAAI,QAAQ,cAAc,KAAK,OAAO,iBAAiB;AACrD,WAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,+BAA+B,QAAQ,YAAY,QAAQ,CAAC,CAAC;AAAA,MAC/D;AAAA,IACF;AAGA,QAAI,QAAQ,eAAe,KAAK,QAAQ,aAAa,KAAK,OAAO,qBAAqB;AACpF,WAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,4BAA4B,QAAQ,UAAU;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,YACN,MACA,OACA,SACA,SACM;AACN,UAAM,QAAe;AAAA,MACnB,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC;AAAA,MACzB,WAAW,KAAK,IAAI;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,SAAK,OAAO,KAAK,KAAK;AACtB,SAAK,KAAK,SAAS,KAAK;AACxB,SAAK,OAAO,KAAK,EAAE,OAAO;AAAA,EAC5B;AAAA,EAEQ,kBAAwB;AAC9B,UAAM,gBAAgB,KAAK,OAAO,mBAAmB,KAAK,KAAK;AAC/D,UAAM,SAAS,KAAK,IAAI,IAAI;AAE5B,SAAK,gBAAgB,KAAK,cAAc,OAAO,CAAC,MAAM,EAAE,YAAY,MAAM;AAC1E,SAAK,SAAS,KAAK,OAAO,OAAO,CAAC,MAAM,EAAE,YAAY,MAAM;AAAA,EAC9D;AAAA,EAEA,MAAc,YAAY,SAAuC;AAC/D,QAAI,CAAC,KAAK,OAAO;AAAa;AAE9B,QAAI;AACF,YAAM,OAAO,oBAAI,KAAK;AACtB,YAAM,WAAW,WAAW,KAAK,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC;AAC5D,YAAM,WAAW,KAAK,KAAK,KAAK,OAAO,aAAa,QAAQ;AAE5D,YAAM,OACJ,KAAK,UAAU;AAAA,QACb,GAAG;AAAA,QACH,QAAQ,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAAA,MAC/C,CAAC,IAAI;AAEP,YAAM,GAAG,WAAW,UAAU,IAAI;AAAA,IACpC,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,yBAAyB,KAAK;AAAA,IAClD;AAAA,EACF;AAAA;AAAA,EAGA,mBAA8C;AAC5C,WAAO,KAAK,cAAc,KAAK,cAAc,SAAS,CAAC;AAAA,EACzD;AAAA,EAEA,gBAAgB,SAA6D;AAC3E,QAAI,SAAS;AACX,aAAO,KAAK,aAAa,IAAI,OAAO;AAAA,IACtC;AACA,WAAO,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAAA,EAC9C;AAAA,EAEA,UAAU,OAAyB;AACjC,QAAI,OAAO;AACT,aAAO,KAAK,OAAO,OAAO,CAAC,MAAM,EAAE,YAAY,KAAK;AAAA,IACtD;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,qBAAqB,QAAgB,GAAoB;AACvD,UAAM,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,KAAK;AAC7C,WAAO,KAAK,cAAc,OAAO,CAAC,MAAM,EAAE,YAAY,KAAK;AAAA,EAC7D;AAAA;AAAA,EAGA,aAWE;AACA,UAAM,UAAU,KAAK,iBAAiB;AACtC,UAAM,SAAS,KAAK,IAAI,IAAI,KAAK;AACjC,UAAM,cAAc,KAAK,aAAa;AACtC,UAAM,eAAe,SAAS,gBAAgB;AAC9C,UAAM,aAAa,SAAS,cAAc;AAC1C,UAAM,iBAAiB,SAAS,kBAAkB;AAClD,UAAM,cAAc,SAAS,eAAe;AAC5C,UAAM,cAAc,aAAa,IAAK,iBAAiB,aAAc,MAAM;AAC3E,UAAM,kBAAkB,SAAS,uBAAuB;AACxD,UAAM,oBAAoB,SAAS,cAAc;AACjD,UAAM,SAAS,KAAK,OAAO,OAAO,CAAC,MAAM,EAAE,YAAY,KAAK,IAAI,IAAI,IAAO,EAAE;AAE7E,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,cAAc,UAAiC;AACnD,UAAM,OAAO;AAAA,MACX,SAAS,KAAK,WAAW;AAAA,MACzB,eAAe,KAAK;AAAA,MACpB,cAAc,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAAA,MACnD,QAAQ,KAAK;AAAA,MACb,WAAU,oBAAI,KAAK,GAAE,YAAY;AAAA,IACnC;AAEA,UAAM,GAAG,UAAU,UAAU,KAAK,UAAU,MAAM,MAAM,CAAC,CAAC;AAC1D,SAAK,OAAO,KAAK,uBAAuB,QAAQ,EAAE;AAAA,EACpD;AACF;",
  "names": []
}
