{
  "version": 3,
  "sources": ["../../../src/memory/backends/sqlite.ts"],
  "sourcesContent": ["/**\n * SQLite backend implementation for memory storage\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport type { IMemoryBackend } from './base.js';\nimport type { MemoryEntry, MemoryQuery } from '../../utils/types.js';\nimport type { ILogger } from '../../core/logger.js';\nimport { MemoryBackendError } from '../../utils/errors.js';\n\n// Dynamic imports for SQLite\nlet createDatabase: any;\nlet isSQLiteAvailable: any;\n\n/**\n * SQLite-based memory backend\n */\nexport class SQLiteBackend implements IMemoryBackend {\n  private db?: any;\n  private sqliteLoaded: boolean = false;\n\n  constructor(\n    private dbPath: string,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing SQLite backend', { dbPath: this.dbPath });\n\n    try {\n      // Load SQLite wrapper if not loaded\n      if (!this.sqliteLoaded) {\n        const module = await import('../sqlite-wrapper.js');\n        createDatabase = module.createDatabase;\n        isSQLiteAvailable = module.isSQLiteAvailable;\n        this.sqliteLoaded = true;\n      }\n\n      // Check if SQLite is available\n      const sqliteAvailable = await isSQLiteAvailable();\n      if (!sqliteAvailable) {\n        throw new Error('SQLite module not available');\n      }\n\n      // Ensure directory exists\n      const dir = path.dirname(this.dbPath);\n      await fs.mkdir(dir, { recursive: true });\n\n      // Open SQLite connection\n      this.db = await createDatabase(this.dbPath);\n\n      // Enable WAL mode for better performance\n      this.db.pragma('journal_mode = WAL');\n      this.db.pragma('synchronous = NORMAL');\n      this.db.pragma('cache_size = 1000');\n      this.db.pragma('temp_store = memory');\n\n      // Create tables\n      this.createTables();\n\n      // Create indexes\n      this.createIndexes();\n\n      this.logger.info('SQLite backend initialized');\n    } catch (error) {\n      throw new MemoryBackendError('Failed to initialize SQLite backend', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down SQLite backend');\n\n    if (this.db) {\n      this.db.close();\n      delete this.db;\n    }\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = `\n      INSERT OR REPLACE INTO memory_entries (\n        id, agent_id, session_id, type, content, \n        context, timestamp, tags, version, parent_id, metadata\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    const params = [\n      entry.id,\n      entry.agentId,\n      entry.sessionId,\n      entry.type,\n      entry.content,\n      JSON.stringify(entry.context),\n      entry.timestamp.toISOString(),\n      JSON.stringify(entry.tags),\n      entry.version,\n      entry.parentId || null,\n      entry.metadata ? JSON.stringify(entry.metadata) : null,\n    ];\n\n    try {\n      const stmt = this.db.prepare(sql);\n      stmt.run(...params);\n    } catch (error) {\n      throw new MemoryBackendError('Failed to store entry', { error });\n    }\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = 'SELECT * FROM memory_entries WHERE id = ?';\n\n    try {\n      const stmt = this.db.prepare(sql);\n      const row = stmt.get(id);\n\n      if (!row) {\n        return undefined;\n      }\n\n      return this.rowToEntry(row as Record<string, unknown>);\n    } catch (error) {\n      throw new MemoryBackendError('Failed to retrieve entry', { error });\n    }\n  }\n\n  async update(id: string, entry: MemoryEntry): Promise<void> {\n    // SQLite INSERT OR REPLACE handles updates\n    await this.store(entry);\n  }\n\n  async delete(id: string): Promise<void> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = 'DELETE FROM memory_entries WHERE id = ?';\n\n    try {\n      const stmt = this.db.prepare(sql);\n      stmt.run(id);\n    } catch (error) {\n      throw new MemoryBackendError('Failed to delete entry', { error });\n    }\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const conditions: string[] = [];\n    const params: unknown[] = [];\n\n    if (query.agentId) {\n      conditions.push('agent_id = ?');\n      params.push(query.agentId);\n    }\n\n    if (query.sessionId) {\n      conditions.push('session_id = ?');\n      params.push(query.sessionId);\n    }\n\n    if (query.type) {\n      conditions.push('type = ?');\n      params.push(query.type);\n    }\n\n    if (query.startTime) {\n      conditions.push('timestamp >= ?');\n      params.push(query.startTime.toISOString());\n    }\n\n    if (query.endTime) {\n      conditions.push('timestamp <= ?');\n      params.push(query.endTime.toISOString());\n    }\n\n    if (query.search) {\n      conditions.push('(content LIKE ? OR tags LIKE ?)');\n      params.push(`%${query.search}%`, `%${query.search}%`);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      const tagConditions = query.tags.map(() => 'tags LIKE ?');\n      conditions.push(`(${tagConditions.join(' OR ')})`);\n      query.tags.forEach((tag: string) => params.push(`%\"${tag}\"%`));\n    }\n\n    let sql = 'SELECT * FROM memory_entries';\n    if (conditions.length > 0) {\n      sql += ' WHERE ' + conditions.join(' AND ');\n    }\n\n    sql += ' ORDER BY timestamp DESC';\n\n    if (query.limit) {\n      sql += ' LIMIT ?';\n      params.push(query.limit);\n    }\n\n    if (query.offset) {\n      // SQLite requires LIMIT when using OFFSET\n      if (!query.limit) {\n        sql += ' LIMIT -1'; // -1 means no limit in SQLite\n      }\n      sql += ' OFFSET ?';\n      params.push(query.offset);\n    }\n\n    try {\n      const stmt = this.db.prepare(sql);\n      const rows = stmt.all(...params);\n      return rows.map((row: any) => this.rowToEntry(row as Record<string, unknown>));\n    } catch (error) {\n      throw new MemoryBackendError('Failed to query entries', { error });\n    }\n  }\n\n  async getAllEntries(): Promise<MemoryEntry[]> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = 'SELECT * FROM memory_entries ORDER BY timestamp DESC';\n\n    try {\n      const stmt = this.db.prepare(sql);\n      const rows = stmt.all();\n      return rows.map((row: any) => this.rowToEntry(row as Record<string, unknown>));\n    } catch (error) {\n      throw new MemoryBackendError('Failed to get all entries', { error });\n    }\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    if (!this.db) {\n      return {\n        healthy: false,\n        error: 'Database not initialized',\n      };\n    }\n\n    try {\n      // Check database connectivity\n      this.db.prepare('SELECT 1').get();\n\n      // Get metrics\n      const countResult = this.db\n        .prepare('SELECT COUNT(*) as count FROM memory_entries')\n        .get() as any;\n      const entryCount = countResult.count;\n\n      const sizeResult = this.db\n        .prepare(\n          'SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()',\n        )\n        .get() as any;\n      const dbSize = sizeResult.size;\n\n      return {\n        healthy: true,\n        metrics: {\n          entryCount,\n          dbSizeBytes: dbSize,\n        },\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private createTables(): void {\n    const sql = `\n      CREATE TABLE IF NOT EXISTS memory_entries (\n        id TEXT PRIMARY KEY,\n        agent_id TEXT NOT NULL,\n        session_id TEXT NOT NULL,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        context TEXT NOT NULL,\n        timestamp TEXT NOT NULL,\n        tags TEXT NOT NULL,\n        version INTEGER NOT NULL,\n        parent_id TEXT,\n        metadata TEXT,\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP\n      )\n    `;\n\n    this.db!.exec(sql);\n  }\n\n  private createIndexes(): void {\n    const indexes = [\n      'CREATE INDEX IF NOT EXISTS idx_agent_id ON memory_entries(agent_id)',\n      'CREATE INDEX IF NOT EXISTS idx_session_id ON memory_entries(session_id)',\n      'CREATE INDEX IF NOT EXISTS idx_type ON memory_entries(type)',\n      'CREATE INDEX IF NOT EXISTS idx_timestamp ON memory_entries(timestamp)',\n      'CREATE INDEX IF NOT EXISTS idx_parent_id ON memory_entries(parent_id)',\n    ];\n\n    for (const sql of indexes) {\n      this.db!.exec(sql);\n    }\n  }\n\n  private rowToEntry(row: Record<string, unknown>): MemoryEntry {\n    const entry: MemoryEntry = {\n      id: row.id as string,\n      agentId: row.agent_id as string,\n      sessionId: row.session_id as string,\n      type: row.type as MemoryEntry['type'],\n      content: row.content as string,\n      context: JSON.parse(row.context as string),\n      timestamp: new Date(row.timestamp as string),\n      tags: JSON.parse(row.tags as string),\n      version: row.version as number,\n    };\n\n    if (row.parent_id) {\n      entry.parentId = row.parent_id as string;\n    }\n\n    if (row.metadata) {\n      entry.metadata = JSON.parse(row.metadata as string);\n    }\n\n    return entry;\n  }\n}\n"],
  "mappings": "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",
  "names": ["module", "path", "fs"]
}
