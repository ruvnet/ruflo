{"version":3,"sources":["../../../src/task/engine.ts"],"sourcesContent":["/**\r\n * Task Engine Core - Comprehensive task management with orchestration features\r\n * Integrates with TodoWrite/TodoRead for coordination and Memory for persistence\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport type { Task, TaskStatus, AgentProfile, Resource } from '../utils/types.js';\r\nimport type { TaskMetadata } from './types.js';\r\nimport { generateId } from '../utils/helpers.js';\r\n\r\nexport interface TaskDependency {\r\n  taskId: string;\r\n  type: 'finish-to-start' | 'start-to-start' | 'finish-to-finish' | 'start-to-finish';\r\n  lag?: number; // delay in milliseconds\r\n}\r\n\r\nexport interface ResourceRequirement {\r\n  resourceId: string;\r\n  type: 'cpu' | 'memory' | 'disk' | 'network' | 'custom';\r\n  amount: number;\r\n  unit: string;\r\n  exclusive?: boolean;\r\n  priority?: number;\r\n}\r\n\r\nexport interface TaskSchedule {\r\n  startTime?: Date;\r\n  endTime?: Date;\r\n  deadline?: Date;\r\n  recurring?: {\r\n    interval: 'daily' | 'weekly' | 'monthly';\r\n    count?: number;\r\n    until?: Date;\r\n  };\r\n  timezone?: string;\r\n}\r\n\r\nexport interface WorkflowTask extends Omit<Task, 'dependencies' | 'metadata'> {\r\n  dependencies: TaskDependency[];\r\n  resourceRequirements: ResourceRequirement[];\r\n  schedule?: TaskSchedule;\r\n  retryPolicy?: {\r\n    maxAttempts: number;\r\n    backoffMs: number;\r\n    backoffMultiplier: number;\r\n  };\r\n  timeout?: number;\r\n  tags: string[];\r\n  estimatedDurationMs?: number;\r\n  actualDurationMs?: number;\r\n  progressPercentage: number;\r\n  checkpoints: TaskCheckpoint[];\r\n  rollbackStrategy?: 'previous-checkpoint' | 'initial-state' | 'custom';\r\n  customRollbackHandler?: string;\r\n  metadata: TaskMetadata;\r\n}\r\n\r\nexport interface TaskCheckpoint {\r\n  id: string;\r\n  timestamp: Date;\r\n  description: string;\r\n  state: Record<string, unknown>;\r\n  artifacts: string[];\r\n}\r\n\r\nexport interface TaskExecution {\r\n  id: string;\r\n  taskId: string;\r\n  agentId: string;\r\n  startedAt: Date;\r\n  completedAt?: Date;\r\n  status: TaskStatus;\r\n  progress: number;\r\n  metrics: TaskMetrics;\r\n  logs: TaskLog[];\r\n}\r\n\r\nexport interface TaskMetrics {\r\n  cpuUsage: number;\r\n  memoryUsage: number;\r\n  diskIO: number;\r\n  networkIO: number;\r\n  customMetrics: Record<string, number>;\r\n}\r\n\r\nexport interface TaskLog {\r\n  timestamp: Date;\r\n  level: 'debug' | 'info' | 'warn' | 'error';\r\n  message: string;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\nexport interface Workflow {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  version: string;\r\n  tasks: WorkflowTask[];\r\n  variables: Record<string, unknown>;\r\n  parallelism: {\r\n    maxConcurrent: number;\r\n    strategy: 'breadth-first' | 'depth-first' | 'priority-based';\r\n  };\r\n  errorHandling: {\r\n    strategy: 'fail-fast' | 'continue-on-error' | 'retry-failed';\r\n    maxRetries: number;\r\n  };\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  createdBy: string;\r\n}\r\n\r\nexport interface TaskFilter {\r\n  status?: TaskStatus[];\r\n  assignedAgent?: string[];\r\n  priority?: { min?: number; max?: number };\r\n  tags?: string[];\r\n  createdAfter?: Date;\r\n  createdBefore?: Date;\r\n  dueBefore?: Date;\r\n  search?: string;\r\n}\r\n\r\nexport interface TaskSort {\r\n  field: 'createdAt' | 'priority' | 'deadline' | 'status' | 'estimatedDuration';\r\n  direction: 'asc' | 'desc';\r\n}\r\n\r\nexport class TaskEngine extends EventEmitter {\r\n  private tasks = new Map<string, WorkflowTask>();\r\n  private executions = new Map<string, TaskExecution>();\r\n  private workflows = new Map<string, Workflow>();\r\n  private resources = new Map<string, Resource>();\r\n  private dependencyGraph = new Map<string, Set<string>>();\r\n  private readyQueue: string[] = [];\r\n  private runningTasks = new Set<string>();\r\n  private cancelledTasks = new Set<string>();\r\n  private taskState = new Map<string, Record<string, unknown>>();\r\n\r\n  constructor(\r\n    private maxConcurrent: number = 10,\r\n    private memoryManager?: any, // Memory interface for persistence\r\n  ) {\r\n    super();\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.on('task:created', this.handleTaskCreated.bind(this));\r\n    this.on('task:completed', this.handleTaskCompleted.bind(this));\r\n    this.on('task:failed', this.handleTaskFailed.bind(this));\r\n    this.on('task:cancelled', this.handleTaskCancelled.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Create a new task with comprehensive options\r\n   */\r\n  async createTask(taskData: Partial<WorkflowTask>): Promise<WorkflowTask> {\r\n    const task: WorkflowTask = {\r\n      id: taskData.id || generateId('task'),\r\n      type: taskData.type || 'general',\r\n      description: taskData.description || '',\r\n      priority: taskData.priority || 0,\r\n      status: 'pending',\r\n      input: taskData.input || {},\r\n      createdAt: new Date(),\r\n      dependencies: taskData.dependencies || [],\r\n      resourceRequirements: taskData.resourceRequirements || [],\r\n      schedule: taskData.schedule,\r\n      retryPolicy: taskData.retryPolicy || {\r\n        maxAttempts: 3,\r\n        backoffMs: 1000,\r\n        backoffMultiplier: 2,\r\n      },\r\n      timeout: taskData.timeout || 300000, // 5 minutes default\r\n      tags: taskData.tags || [],\r\n      estimatedDurationMs: taskData.estimatedDurationMs,\r\n      progressPercentage: 0,\r\n      checkpoints: [],\r\n      rollbackStrategy: taskData.rollbackStrategy || 'previous-checkpoint',\r\n      metadata: taskData.metadata || {},\r\n    };\r\n\r\n    this.tasks.set(task.id, task);\r\n    this.updateDependencyGraph(task);\r\n\r\n    // Store in memory if manager available\r\n    if (this.memoryManager) {\r\n      await this.memoryManager.store(`task:${task.id}`, task);\r\n    }\r\n\r\n    this.emit('task:created', { task });\r\n    this.scheduleTask(task);\r\n\r\n    return task;\r\n  }\r\n\r\n  /**\r\n   * List tasks with filtering and sorting\r\n   */\r\n  async listTasks(\r\n    filter?: TaskFilter,\r\n    sort?: TaskSort,\r\n    limit?: number,\r\n    offset?: number,\r\n  ): Promise<{ tasks: WorkflowTask[]; total: number; hasMore: boolean }> {\r\n    let filteredTasks = Array.from(this.tasks.values());\r\n\r\n    // Apply filters\r\n    if (filter) {\r\n      filteredTasks = filteredTasks.filter((task) => {\r\n        if (filter.status && !filter.status.includes(task.status)) return false;\r\n        if (filter.assignedAgent && !filter.assignedAgent.includes(task.assignedAgent || ''))\r\n          return false;\r\n        if (filter.priority) {\r\n          if (filter.priority.min !== undefined && task.priority < filter.priority.min)\r\n            return false;\r\n          if (filter.priority.max !== undefined && task.priority > filter.priority.max)\r\n            return false;\r\n        }\r\n        if (filter.tags && !filter.tags.some((tag) => task.tags.includes(tag))) return false;\r\n        if (filter.createdAfter && task.createdAt < filter.createdAfter) return false;\r\n        if (filter.createdBefore && task.createdAt > filter.createdBefore) return false;\r\n        if (\r\n          filter.dueBefore &&\r\n          task.schedule?.deadline &&\r\n          task.schedule.deadline > filter.dueBefore\r\n        )\r\n          return false;\r\n        if (filter.search && !this.matchesSearch(task, filter.search)) return false;\r\n        return true;\r\n      });\r\n    }\r\n\r\n    // Apply sorting\r\n    if (sort) {\r\n      filteredTasks.sort((a, b) => {\r\n        const direction = sort.direction === 'desc' ? -1 : 1;\r\n        switch (sort.field) {\r\n          case 'createdAt':\r\n            return direction * (a.createdAt.getTime() - b.createdAt.getTime());\r\n          case 'priority':\r\n            return direction * (a.priority - b.priority);\r\n          case 'deadline':\r\n            const aDeadline = a.schedule?.deadline?.getTime() || 0;\r\n            const bDeadline = b.schedule?.deadline?.getTime() || 0;\r\n            return direction * (aDeadline - bDeadline);\r\n          case 'estimatedDuration':\r\n            return direction * ((a.estimatedDurationMs || 0) - (b.estimatedDurationMs || 0));\r\n          default:\r\n            return 0;\r\n        }\r\n      });\r\n    }\r\n\r\n    const total = filteredTasks.length;\r\n    const startIndex = offset || 0;\r\n    const endIndex = limit ? startIndex + limit : filteredTasks.length;\r\n    const tasks = filteredTasks.slice(startIndex, endIndex);\r\n\r\n    return {\r\n      tasks,\r\n      total,\r\n      hasMore: endIndex < total,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get detailed task status with progress and metrics\r\n   */\r\n  async getTaskStatus(taskId: string): Promise<{\r\n    task: WorkflowTask;\r\n    execution?: TaskExecution;\r\n    dependencies: { task: WorkflowTask; satisfied: boolean }[];\r\n    dependents: WorkflowTask[];\r\n    resourceStatus: { required: ResourceRequirement; available: boolean; allocated: boolean }[];\r\n  } | null> {\r\n    const task = this.tasks.get(taskId);\r\n    if (!task) return null;\r\n\r\n    const execution = this.executions.get(taskId);\r\n\r\n    // Get dependency status\r\n    const dependencies = await Promise.all(\r\n      task.dependencies.map(async (dep) => {\r\n        const depTask = this.tasks.get(dep.taskId);\r\n        if (!depTask) throw new Error(`Dependency task ${dep.taskId} not found`);\r\n        const satisfied = this.isDependencySatisfied(dep, depTask);\r\n        return { task: depTask, satisfied };\r\n      }),\r\n    );\r\n\r\n    // Get dependent tasks\r\n    const dependents = Array.from(this.tasks.values()).filter((t) =>\r\n      t.dependencies.some((dep) => dep.taskId === taskId),\r\n    );\r\n\r\n    // Get resource status\r\n    const resourceStatus = task.resourceRequirements.map((req) => {\r\n      const resource = this.resources.get(req.resourceId);\r\n      return {\r\n        required: req,\r\n        available: !!resource,\r\n        allocated: resource?.lockedBy === taskId,\r\n      };\r\n    });\r\n\r\n    return {\r\n      task,\r\n      execution,\r\n      dependencies,\r\n      dependents,\r\n      resourceStatus,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cancel task with rollback and cleanup\r\n   */\r\n  async cancelTask(\r\n    taskId: string,\r\n    reason: string = 'User requested',\r\n    rollback: boolean = true,\r\n  ): Promise<void> {\r\n    const task = this.tasks.get(taskId);\r\n    if (!task) throw new Error(`Task ${taskId} not found`);\r\n\r\n    if (task.status === 'completed') {\r\n      throw new Error(`Cannot cancel completed task ${taskId}`);\r\n    }\r\n\r\n    this.cancelledTasks.add(taskId);\r\n\r\n    // Stop running execution\r\n    if (this.runningTasks.has(taskId)) {\r\n      this.runningTasks.delete(taskId);\r\n      const execution = this.executions.get(taskId);\r\n      if (execution) {\r\n        execution.status = 'cancelled';\r\n        execution.completedAt = new Date();\r\n      }\r\n    }\r\n\r\n    // Release resources\r\n    await this.releaseTaskResources(taskId);\r\n\r\n    // Perform rollback if requested\r\n    if (rollback && task.checkpoints.length > 0) {\r\n      await this.rollbackTask(task);\r\n    }\r\n\r\n    // Update task status\r\n    task.status = 'cancelled';\r\n    task.metadata = {\r\n      ...task.metadata,\r\n      cancellationReason: reason,\r\n      cancelledAt: new Date(),\r\n    };\r\n\r\n    // Update memory\r\n    if (this.memoryManager) {\r\n      await this.memoryManager.store(`task:${taskId}`, task);\r\n    }\r\n\r\n    this.emit('task:cancelled', { taskId, reason });\r\n\r\n    // Cancel dependent tasks if configured\r\n    const dependents = Array.from(this.tasks.values()).filter((t) =>\r\n      t.dependencies.some((dep) => dep.taskId === taskId),\r\n    );\r\n\r\n    for (const dependent of dependents) {\r\n      if (dependent.status === 'pending' || dependent.status === 'queued') {\r\n        await this.cancelTask(dependent.id, `Dependency ${taskId} was cancelled`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute workflow with parallel processing\r\n   */\r\n  async executeWorkflow(workflow: Workflow): Promise<void> {\r\n    this.workflows.set(workflow.id, workflow);\r\n\r\n    // Add all workflow tasks\r\n    for (const task of workflow.tasks) {\r\n      this.tasks.set(task.id, task);\r\n      this.updateDependencyGraph(task);\r\n    }\r\n\r\n    // Start execution with parallel processing\r\n    await this.processWorkflow(workflow);\r\n  }\r\n\r\n  /**\r\n   * Create workflow from tasks\r\n   */\r\n  async createWorkflow(workflowData: Partial<Workflow>): Promise<Workflow> {\r\n    const workflow: Workflow = {\r\n      id: workflowData.id || generateId('workflow'),\r\n      name: workflowData.name || 'Unnamed Workflow',\r\n      description: workflowData.description || '',\r\n      version: workflowData.version || '1.0.0',\r\n      tasks: workflowData.tasks || [],\r\n      variables: workflowData.variables || {},\r\n      parallelism: workflowData.parallelism || {\r\n        maxConcurrent: this.maxConcurrent,\r\n        strategy: 'priority-based',\r\n      },\r\n      errorHandling: workflowData.errorHandling || {\r\n        strategy: 'fail-fast',\r\n        maxRetries: 3,\r\n      },\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      createdBy: workflowData.createdBy || 'system',\r\n    };\r\n\r\n    this.workflows.set(workflow.id, workflow);\r\n\r\n    if (this.memoryManager) {\r\n      await this.memoryManager.store(`workflow:${workflow.id}`, workflow);\r\n    }\r\n\r\n    return workflow;\r\n  }\r\n\r\n  /**\r\n   * Get dependency visualization\r\n   */\r\n  getDependencyGraph(): { nodes: any[]; edges: any[] } {\r\n    const nodes = Array.from(this.tasks.values()).map((task) => ({\r\n      id: task.id,\r\n      label: task.description,\r\n      status: task.status,\r\n      priority: task.priority,\r\n      progress: task.progressPercentage,\r\n      estimatedDuration: task.estimatedDurationMs,\r\n      tags: task.tags,\r\n    }));\r\n\r\n    const edges: any[] = [];\r\n    for (const task of Array.from(this.tasks.values())) {\r\n      for (const dep of task.dependencies) {\r\n        edges.push({\r\n          from: dep.taskId,\r\n          to: task.id,\r\n          type: dep.type,\r\n          lag: dep.lag,\r\n        });\r\n      }\r\n    }\r\n\r\n    return { nodes, edges };\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private updateDependencyGraph(task: WorkflowTask): void {\r\n    if (!this.dependencyGraph.has(task.id)) {\r\n      this.dependencyGraph.set(task.id, new Set());\r\n    }\r\n\r\n    for (const dep of task.dependencies) {\r\n      if (!this.dependencyGraph.has(dep.taskId)) {\r\n        this.dependencyGraph.set(dep.taskId, new Set());\r\n      }\r\n      this.dependencyGraph.get(dep.taskId)!.add(task.id);\r\n    }\r\n  }\r\n\r\n  private scheduleTask(task: WorkflowTask): void {\r\n    if (this.areTaskDependenciesSatisfied(task)) {\r\n      this.readyQueue.push(task.id);\r\n      this.processReadyQueue();\r\n    }\r\n  }\r\n\r\n  private areTaskDependenciesSatisfied(task: WorkflowTask): boolean {\r\n    return task.dependencies.every((dep) => {\r\n      const depTask = this.tasks.get(dep.taskId);\r\n      return depTask && this.isDependencySatisfied(dep, depTask);\r\n    });\r\n  }\r\n\r\n  private isDependencySatisfied(dependency: TaskDependency, depTask: WorkflowTask): boolean {\r\n    switch (dependency.type) {\r\n      case 'finish-to-start':\r\n        return depTask.status === 'completed';\r\n      case 'start-to-start':\r\n        return depTask.status !== 'pending';\r\n      case 'finish-to-finish':\r\n        return depTask.status === 'completed';\r\n      case 'start-to-finish':\r\n        return depTask.status !== 'pending';\r\n      default:\r\n        return depTask.status === 'completed';\r\n    }\r\n  }\r\n\r\n  private async processReadyQueue(): Promise<void> {\r\n    while (this.readyQueue.length > 0 && this.runningTasks.size < this.maxConcurrent) {\r\n      const taskId = this.readyQueue.shift()!;\r\n      if (this.cancelledTasks.has(taskId)) continue;\r\n\r\n      const task = this.tasks.get(taskId);\r\n      if (!task) continue;\r\n\r\n      await this.executeTask(task);\r\n    }\r\n  }\r\n\r\n  private async executeTask(task: WorkflowTask): Promise<void> {\r\n    if (!(await this.acquireTaskResources(task))) {\r\n      // Resources not available, put back in queue\r\n      this.readyQueue.unshift(task.id);\r\n      return;\r\n    }\r\n\r\n    const execution: TaskExecution = {\r\n      id: generateId('execution'),\r\n      taskId: task.id,\r\n      agentId: task.assignedAgent || 'system',\r\n      startedAt: new Date(),\r\n      status: 'running',\r\n      progress: 0,\r\n      metrics: {\r\n        cpuUsage: 0,\r\n        memoryUsage: 0,\r\n        diskIO: 0,\r\n        networkIO: 0,\r\n        customMetrics: {},\r\n      },\r\n      logs: [],\r\n    };\r\n\r\n    this.executions.set(task.id, execution);\r\n    this.runningTasks.add(task.id);\r\n    task.status = 'running';\r\n    task.startedAt = new Date();\r\n\r\n    this.emit('task:started', { taskId: task.id, agentId: execution.agentId });\r\n\r\n    try {\r\n      // Simulate task execution - in real implementation, this would delegate to agents\r\n      await this.simulateTaskExecution(task, execution);\r\n\r\n      task.status = 'completed';\r\n      task.completedAt = new Date();\r\n      task.progressPercentage = 100;\r\n      execution.status = 'completed';\r\n      execution.completedAt = new Date();\r\n\r\n      this.emit('task:completed', { taskId: task.id, result: task.output });\r\n    } catch (error) {\r\n      task.status = 'failed';\r\n      task.error = error as Error;\r\n      execution.status = 'failed';\r\n      execution.completedAt = new Date();\r\n\r\n      this.emit('task:failed', { taskId: task.id, error });\r\n    } finally {\r\n      this.runningTasks.delete(task.id);\r\n      await this.releaseTaskResources(task.id);\r\n\r\n      if (this.memoryManager) {\r\n        await this.memoryManager.store(`task:${task.id}`, task);\r\n        await this.memoryManager.store(`execution:${execution.id}`, execution);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async simulateTaskExecution(task: WorkflowTask, execution: TaskExecution): Promise<void> {\r\n    // Simulate work with progress updates\r\n    const steps = 10;\r\n    for (let i = 0; i <= steps; i++) {\r\n      if (this.cancelledTasks.has(task.id)) {\r\n        throw new Error('Task was cancelled');\r\n      }\r\n\r\n      task.progressPercentage = (i / steps) * 100;\r\n      execution.progress = task.progressPercentage;\r\n\r\n      // Create checkpoint every 25%\r\n      if (i % Math.ceil(steps / 4) === 0) {\r\n        await this.createCheckpoint(task, `Step ${i} completed`);\r\n      }\r\n\r\n      await new Promise((resolve) => setTimeout(resolve, 100));\r\n    }\r\n\r\n    task.output = { result: 'Task completed successfully', timestamp: new Date() };\r\n  }\r\n\r\n  private async createCheckpoint(task: WorkflowTask, description: string): Promise<void> {\r\n    const checkpoint: TaskCheckpoint = {\r\n      id: generateId('checkpoint'),\r\n      timestamp: new Date(),\r\n      description,\r\n      state: { ...(this.taskState.get(task.id) || {}) },\r\n      artifacts: [],\r\n    };\r\n\r\n    task.checkpoints.push(checkpoint);\r\n\r\n    if (this.memoryManager) {\r\n      await this.memoryManager.store(`checkpoint:${checkpoint.id}`, checkpoint);\r\n    }\r\n  }\r\n\r\n  private async rollbackTask(task: WorkflowTask): Promise<void> {\r\n    if (task.checkpoints.length === 0) return;\r\n\r\n    const targetCheckpoint =\r\n      task.rollbackStrategy === 'initial-state'\r\n        ? task.checkpoints[0]\r\n        : task.checkpoints[task.checkpoints.length - 1];\r\n\r\n    // Restore state from checkpoint\r\n    this.taskState.set(task.id, { ...targetCheckpoint.state });\r\n\r\n    // Remove checkpoints after the target\r\n    const targetIndex = task.checkpoints.findIndex((cp) => cp.id === targetCheckpoint.id);\r\n    task.checkpoints = task.checkpoints.slice(0, targetIndex + 1);\r\n\r\n    task.progressPercentage = Math.max(0, task.progressPercentage - 25);\r\n  }\r\n\r\n  private async acquireTaskResources(task: WorkflowTask): Promise<boolean> {\r\n    for (const requirement of task.resourceRequirements) {\r\n      const resource = this.resources.get(requirement.resourceId);\r\n      if (!resource) return false;\r\n\r\n      if (resource.locked && requirement.exclusive) return false;\r\n\r\n      resource.locked = true;\r\n      resource.lockedBy = task.id;\r\n      resource.lockedAt = new Date();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private async releaseTaskResources(taskId: string): Promise<void> {\r\n    for (const resource of Array.from(this.resources.values())) {\r\n      if (resource.lockedBy === taskId) {\r\n        resource.locked = false;\r\n        resource.lockedBy = undefined;\r\n        resource.lockedAt = undefined;\r\n      }\r\n    }\r\n  }\r\n\r\n  private matchesSearch(task: WorkflowTask, search: string): boolean {\r\n    const searchLower = search.toLowerCase();\r\n    return (\r\n      task.description.toLowerCase().includes(searchLower) ||\r\n      task.type.toLowerCase().includes(searchLower) ||\r\n      task.tags.some((tag) => tag.toLowerCase().includes(searchLower)) ||\r\n      (task.assignedAgent ? task.assignedAgent.toLowerCase().includes(searchLower) : false)\r\n    );\r\n  }\r\n\r\n  private async processWorkflow(workflow: Workflow): Promise<void> {\r\n    // Implementation would manage workflow execution based on parallelism settings\r\n    // This is a simplified version\r\n    for (const task of workflow.tasks) {\r\n      this.scheduleTask(task);\r\n    }\r\n  }\r\n\r\n  private handleTaskCreated(data: { task: WorkflowTask }): void {\r\n    // Handle task creation events\r\n  }\r\n\r\n  private handleTaskCompleted(data: { taskId: string; result: unknown }): void {\r\n    // Schedule dependent tasks\r\n    const dependents = Array.from(this.tasks.values()).filter((task) =>\r\n      task.dependencies.some((dep) => dep.taskId === data.taskId),\r\n    );\r\n\r\n    for (const dependent of dependents) {\r\n      if (this.areTaskDependenciesSatisfied(dependent)) {\r\n        this.readyQueue.push(dependent.id);\r\n      }\r\n    }\r\n\r\n    this.processReadyQueue();\r\n  }\r\n\r\n  private handleTaskFailed(data: { taskId: string; error: Error }): void {\r\n    // Handle task failure, potentially retry or fail dependents\r\n    const task = this.tasks.get(data.taskId);\r\n    if (!task) return;\r\n\r\n    // Implement retry logic based on retryPolicy\r\n    if (task.retryPolicy && (task.metadata.retryCount || 0) < task.retryPolicy.maxAttempts) {\r\n      const currentRetryCount = task.metadata.retryCount || 0;\r\n      task.metadata = {\r\n        ...task.metadata,\r\n        retryCount: currentRetryCount + 1,\r\n        lastRetryAt: new Date(),\r\n      };\r\n      task.status = 'pending';\r\n\r\n      // Schedule retry with backoff\r\n      setTimeout(\r\n        () => {\r\n          this.scheduleTask(task);\r\n        },\r\n        task.retryPolicy!.backoffMs *\r\n          Math.pow(task.retryPolicy!.backoffMultiplier, currentRetryCount),\r\n      );\r\n    }\r\n  }\r\n\r\n  private handleTaskCancelled(data: { taskId: string; reason: string }): void {\r\n    // Handle task cancellation\r\n  }\r\n}\r\n"],"names":["EventEmitter","generateId","TaskEngine","tasks","Map","executions","workflows","resources","dependencyGraph","readyQueue","runningTasks","Set","cancelledTasks","taskState","maxConcurrent","memoryManager","setupEventHandlers","on","handleTaskCreated","bind","handleTaskCompleted","handleTaskFailed","handleTaskCancelled","createTask","taskData","task","id","type","description","priority","status","input","createdAt","Date","dependencies","resourceRequirements","schedule","retryPolicy","maxAttempts","backoffMs","backoffMultiplier","timeout","tags","estimatedDurationMs","progressPercentage","checkpoints","rollbackStrategy","metadata","set","updateDependencyGraph","store","emit","scheduleTask","listTasks","filter","sort","limit","offset","filteredTasks","Array","from","values","includes","assignedAgent","min","undefined","max","some","tag","createdAfter","createdBefore","dueBefore","deadline","search","matchesSearch","a","b","direction","field","getTime","aDeadline","bDeadline","total","length","startIndex","endIndex","slice","hasMore","getTaskStatus","taskId","get","execution","Promise","all","map","dep","depTask","Error","satisfied","isDependencySatisfied","dependents","t","resourceStatus","req","resource","resourceId","required","available","allocated","lockedBy","cancelTask","reason","rollback","add","has","delete","completedAt","releaseTaskResources","rollbackTask","cancellationReason","cancelledAt","dependent","executeWorkflow","workflow","processWorkflow","createWorkflow","workflowData","name","version","variables","parallelism","strategy","errorHandling","maxRetries","updatedAt","createdBy","getDependencyGraph","nodes","label","progress","estimatedDuration","edges","push","to","lag","areTaskDependenciesSatisfied","processReadyQueue","every","dependency","size","shift","executeTask","acquireTaskResources","unshift","agentId","startedAt","metrics","cpuUsage","memoryUsage","diskIO","networkIO","customMetrics","logs","simulateTaskExecution","result","output","error","steps","i","Math","ceil","createCheckpoint","resolve","setTimeout","timestamp","checkpoint","state","artifacts","targetCheckpoint","targetIndex","findIndex","cp","requirement","locked","exclusive","lockedAt","searchLower","toLowerCase","data","retryCount","currentRetryCount","lastRetryAt","pow"],"mappings":"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"}