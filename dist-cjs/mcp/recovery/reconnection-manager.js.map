{
  "version": 3,
  "sources": ["../../../src/mcp/recovery/reconnection-manager.ts"],
  "sourcesContent": ["/**\n * Reconnection Manager for MCP\n * Handles automatic reconnection with exponential backoff\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPClient } from '../client.js';\n\nexport interface ReconnectionConfig {\n  maxRetries: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitterFactor: number;\n  resetAfterSuccess: boolean;\n}\n\nexport interface ReconnectionState {\n  attempts: number;\n  nextDelay: number;\n  isReconnecting: boolean;\n  lastAttempt?: Date;\n  lastError?: Error;\n}\n\nexport class ReconnectionManager extends EventEmitter {\n  private state: ReconnectionState;\n  private reconnectTimer?: NodeJS.Timeout;\n  private reconnectPromise?: Promise<boolean>;\n\n  private readonly defaultConfig: ReconnectionConfig = {\n    maxRetries: 10,\n    initialDelay: 1000,\n    maxDelay: 30000,\n    backoffMultiplier: 2,\n    jitterFactor: 0.1,\n    resetAfterSuccess: true,\n  };\n\n  constructor(\n    private client: MCPClient,\n    private logger: ILogger,\n    config?: Partial<ReconnectionConfig>,\n  ) {\n    super();\n    this.config = { ...this.defaultConfig, ...config };\n\n    this.state = {\n      attempts: 0,\n      nextDelay: this.config.initialDelay,\n      isReconnecting: false,\n    };\n  }\n\n  private config: ReconnectionConfig;\n\n  /**\n   * Attempt to reconnect\n   */\n  async attemptReconnection(): Promise<boolean> {\n    // Prevent concurrent reconnection attempts\n    if (this.reconnectPromise) {\n      this.logger.debug('Reconnection already in progress');\n      return this.reconnectPromise;\n    }\n\n    if (this.state.attempts >= this.config.maxRetries) {\n      this.logger.error('Max reconnection attempts exceeded');\n      this.emit('maxRetriesExceeded', this.state);\n      return false;\n    }\n\n    this.reconnectPromise = this.performReconnection();\n    const result = await this.reconnectPromise;\n    this.reconnectPromise = undefined;\n\n    return result;\n  }\n\n  /**\n   * Start automatic reconnection\n   */\n  startAutoReconnect(): void {\n    if (this.state.isReconnecting) {\n      this.logger.debug('Auto-reconnect already active');\n      return;\n    }\n\n    this.logger.info('Starting automatic reconnection');\n    this.state.isReconnecting = true;\n    this.emit('reconnectStart');\n\n    this.scheduleReconnect();\n  }\n\n  /**\n   * Stop reconnection attempts\n   */\n  stopReconnection(): void {\n    if (!this.state.isReconnecting) {\n      return;\n    }\n\n    this.logger.info('Stopping reconnection attempts');\n\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = undefined;\n    }\n\n    this.state.isReconnecting = false;\n    this.emit('reconnectStop');\n  }\n\n  /**\n   * Reset reconnection state\n   */\n  reset(): void {\n    this.logger.debug('Resetting reconnection manager');\n\n    this.stopReconnection();\n    this.state = {\n      attempts: 0,\n      nextDelay: this.config.initialDelay,\n      isReconnecting: false,\n    };\n  }\n\n  /**\n   * Get current reconnection state\n   */\n  getState(): ReconnectionState {\n    return { ...this.state };\n  }\n\n  /**\n   * Calculate next retry delay\n   */\n  getNextDelay(): number {\n    return this.state.nextDelay;\n  }\n\n  private async performReconnection(): Promise<boolean> {\n    this.state.attempts++;\n    this.state.lastAttempt = new Date();\n\n    this.logger.info('Attempting reconnection', {\n      attempt: this.state.attempts,\n      maxRetries: this.config.maxRetries,\n      delay: this.state.nextDelay,\n    });\n\n    this.emit('attemptStart', {\n      attempt: this.state.attempts,\n      delay: this.state.nextDelay,\n    });\n\n    try {\n      // Disconnect first if needed\n      if (this.client.isConnected()) {\n        await this.client.disconnect();\n      }\n\n      // Attempt to reconnect\n      await this.client.connect();\n\n      // Success!\n      this.logger.info('Reconnection successful', {\n        attempts: this.state.attempts,\n      });\n\n      this.emit('success', {\n        attempts: this.state.attempts,\n        duration: Date.now() - this.state.lastAttempt.getTime(),\n      });\n\n      // Reset state if configured\n      if (this.config.resetAfterSuccess) {\n        this.reset();\n      }\n\n      return true;\n    } catch (error) {\n      this.state.lastError = error as Error;\n\n      this.logger.error('Reconnection failed', {\n        attempt: this.state.attempts,\n        error: (error as Error).message,\n      });\n\n      this.emit('attemptFailed', {\n        attempt: this.state.attempts,\n        error: error as Error,\n      });\n\n      // Calculate next delay with exponential backoff\n      this.calculateNextDelay();\n\n      // Schedule next attempt if within retry limit\n      if (this.state.attempts < this.config.maxRetries && this.state.isReconnecting) {\n        this.scheduleReconnect();\n      } else if (this.state.attempts >= this.config.maxRetries) {\n        this.logger.error('Max reconnection attempts reached');\n        this.emit('maxRetriesExceeded', this.state);\n        this.state.isReconnecting = false;\n      }\n\n      return false;\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (!this.state.isReconnecting) {\n      return;\n    }\n\n    const delay = this.addJitter(this.state.nextDelay);\n\n    this.logger.debug('Scheduling next reconnection attempt', {\n      delay,\n      baseDelay: this.state.nextDelay,\n    });\n\n    this.reconnectTimer = setTimeout(() => {\n      this.attemptReconnection().catch((error) => {\n        this.logger.error('Scheduled reconnection error', error);\n      });\n    }, delay);\n\n    this.emit('attemptScheduled', {\n      attempt: this.state.attempts + 1,\n      delay,\n    });\n  }\n\n  private calculateNextDelay(): void {\n    // Exponential backoff calculation\n    const nextDelay = Math.min(\n      this.state.nextDelay * this.config.backoffMultiplier,\n      this.config.maxDelay,\n    );\n\n    this.state.nextDelay = nextDelay;\n\n    this.logger.debug('Calculated next delay', {\n      delay: nextDelay,\n      multiplier: this.config.backoffMultiplier,\n      maxDelay: this.config.maxDelay,\n    });\n  }\n\n  private addJitter(delay: number): number {\n    // Add random jitter to prevent thundering herd\n    const jitter = delay * this.config.jitterFactor;\n    const randomJitter = (Math.random() - 0.5) * 2 * jitter;\n\n    return Math.max(0, delay + randomJitter);\n  }\n\n  /**\n   * Force immediate reconnection attempt\n   */\n  async forceReconnect(): Promise<boolean> {\n    this.logger.info('Forcing immediate reconnection');\n\n    // Cancel any scheduled reconnect\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = undefined;\n    }\n\n    // Reset delay for immediate attempt\n    const originalDelay = this.state.nextDelay;\n    this.state.nextDelay = 0;\n\n    const result = await this.attemptReconnection();\n\n    // Restore delay if failed\n    if (!result) {\n      this.state.nextDelay = originalDelay;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get estimated time until next reconnection attempt\n   */\n  getTimeUntilNextAttempt(): number | null {\n    if (!this.state.isReconnecting || !this.reconnectTimer) {\n      return null;\n    }\n\n    // This is an approximation since we don't track the exact timer start\n    return this.state.nextDelay;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
