{
  "version": 3,
  "sources": ["../../src/migration/rollback-manager.ts"],
  "sourcesContent": ["/**\n * Rollback Manager - Handles rollback operations and backup management\n */\n\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport type { MigrationBackup, BackupFile } from './types.js';\nimport { logger } from './logger.js';\nimport * as chalk from 'chalk';\nimport * as inquirer from 'inquirer';\n\nexport class RollbackManager {\n  private projectPath: string;\n  private backupDir: string;\n\n  constructor(projectPath: string, backupDir: string = '.claude-backup') {\n    this.projectPath = projectPath;\n    this.backupDir = path.join(projectPath, backupDir);\n  }\n\n  async createBackup(metadata: Record<string, any> = {}): Promise<MigrationBackup> {\n    const timestamp = new Date();\n    const backupId = timestamp.toISOString().replace(/[:.]/g, '-');\n    const backupPath = path.join(this.backupDir, backupId);\n\n    logger.info(`Creating backup at ${backupPath}...`);\n\n    await fs.ensureDir(backupPath);\n\n    const backup: MigrationBackup = {\n      timestamp,\n      version: '1.0.0',\n      files: [],\n      metadata: {\n        projectPath: this.projectPath,\n        backupId,\n        ...metadata,\n      },\n    };\n\n    // Backup critical files and directories\n    const backupTargets = [\n      '.claude',\n      'CLAUDE.md',\n      '.roomodes',\n      'package.json',\n      'memory/memory-store.json',\n      'coordination/config.json',\n    ];\n\n    for (const target of backupTargets) {\n      const sourcePath = path.join(this.projectPath, target);\n      const targetPath = path.join(backupPath, target);\n\n      if (await fs.pathExists(sourcePath)) {\n        const stats = await fs.stat(sourcePath);\n\n        if (stats.isDirectory()) {\n          await this.backupDirectory(sourcePath, targetPath, backup);\n        } else {\n          await this.backupFile(sourcePath, targetPath, backup, target);\n        }\n      }\n    }\n\n    // Save backup manifest\n    const manifestPath = path.join(backupPath, 'backup-manifest.json');\n    await fs.writeJson(manifestPath, backup, { spaces: 2 });\n\n    // Update backup index\n    await this.updateBackupIndex(backup);\n\n    logger.success(`Backup created with ${backup.files.length} files`);\n    return backup;\n  }\n\n  private async backupDirectory(\n    sourcePath: string,\n    targetPath: string,\n    backup: MigrationBackup,\n  ): Promise<void> {\n    await fs.ensureDir(targetPath);\n\n    const entries = await fs.readdir(sourcePath);\n\n    for (const entry of entries) {\n      const entrySource = path.join(sourcePath, entry);\n      const entryTarget = path.join(targetPath, entry);\n      const stats = await fs.stat(entrySource);\n\n      if (stats.isDirectory()) {\n        await this.backupDirectory(entrySource, entryTarget, backup);\n      } else {\n        const relativePath = path.relative(this.projectPath, entrySource);\n        await this.backupFile(entrySource, entryTarget, backup, relativePath);\n      }\n    }\n  }\n\n  private async backupFile(\n    sourcePath: string,\n    targetPath: string,\n    backup: MigrationBackup,\n    relativePath: string,\n  ): Promise<void> {\n    const content = await fs.readFile(sourcePath, 'utf-8');\n    const checksum = crypto.createHash('sha256').update(content).digest('hex');\n\n    await fs.ensureDir(path.dirname(targetPath));\n    await fs.writeFile(targetPath, content);\n\n    const backupFile: BackupFile = {\n      path: relativePath,\n      content,\n      checksum,\n      permissions: (await fs.stat(sourcePath)).mode.toString(8),\n    };\n\n    backup.files.push(backupFile);\n  }\n\n  async listBackups(): Promise<MigrationBackup[]> {\n    if (!(await fs.pathExists(this.backupDir))) {\n      return [];\n    }\n\n    const backupFolders = await fs.readdir(this.backupDir);\n    const backups: MigrationBackup[] = [];\n\n    for (const folder of backupFolders.sort().reverse()) {\n      const manifestPath = path.join(this.backupDir, folder, 'backup-manifest.json');\n\n      if (await fs.pathExists(manifestPath)) {\n        try {\n          const backup = await fs.readJson(manifestPath);\n          backups.push(backup);\n        } catch (error) {\n          logger.warn(\n            `Invalid backup manifest in ${folder}: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n    }\n\n    return backups;\n  }\n\n  async rollback(backupId?: string, interactive: boolean = true): Promise<void> {\n    const backups = await this.listBackups();\n\n    if (backups.length === 0) {\n      throw new Error('No backups found');\n    }\n\n    let selectedBackup: MigrationBackup;\n\n    if (backupId) {\n      selectedBackup = backups.find((b) => b.metadata.backupId === backupId);\n      if (!selectedBackup) {\n        throw new Error(`Backup not found: ${backupId}`);\n      }\n    } else if (interactive) {\n      selectedBackup = await this.selectBackupInteractively(backups);\n    } else {\n      selectedBackup = backups[0]; // Most recent\n    }\n\n    logger.info(`Rolling back to backup from ${selectedBackup.timestamp.toISOString()}...`);\n\n    // Confirm rollback\n    if (interactive) {\n      const confirm = await inquirer.prompt([\n        {\n          type: 'confirm',\n          name: 'proceed',\n          message: `Are you sure you want to rollback? This will overwrite current files.`,\n          default: false,\n        },\n      ]);\n\n      if (!confirm.proceed) {\n        logger.info('Rollback cancelled');\n        return;\n      }\n    }\n\n    // Create pre-rollback backup\n    const preRollbackBackup = await this.createBackup({\n      type: 'pre-rollback',\n      rollingBackTo: selectedBackup.metadata.backupId,\n    });\n\n    try {\n      // Restore files\n      await this.restoreFiles(selectedBackup);\n\n      // Validate restoration\n      await this.validateRestore(selectedBackup);\n\n      logger.success('Rollback completed successfully');\n    } catch (error) {\n      logger.error('Rollback failed, attempting to restore pre-rollback state...');\n\n      try {\n        await this.restoreFiles(preRollbackBackup);\n        logger.success('Pre-rollback state restored');\n      } catch (restoreError) {\n        logger.error('Failed to restore pre-rollback state:', restoreError);\n        throw new Error('Rollback failed and unable to restore previous state');\n      }\n\n      throw error;\n    }\n  }\n\n  private async selectBackupInteractively(backups: MigrationBackup[]): Promise<MigrationBackup> {\n    const choices = backups.map((backup) => ({\n      name: `${backup.timestamp.toLocaleString()} - ${backup.files.length} files (${backup.metadata.type || 'migration'})`,\n      value: backup,\n      short: backup.metadata.backupId,\n    }));\n\n    const answer = await inquirer.prompt([\n      {\n        type: 'list',\n        name: 'backup',\n        message: 'Select backup to rollback to:',\n        choices,\n        pageSize: 10,\n      },\n    ]);\n\n    return answer.backup;\n  }\n\n  private async restoreFiles(backup: MigrationBackup): Promise<void> {\n    logger.info(`Restoring ${backup.files.length} files...`);\n\n    for (const file of backup.files) {\n      const targetPath = path.join(this.projectPath, file.path);\n\n      logger.debug(`Restoring ${file.path}`);\n\n      await fs.ensureDir(path.dirname(targetPath));\n      await fs.writeFile(targetPath, file.content);\n\n      // Restore permissions if available\n      if (file.permissions) {\n        try {\n          await fs.chmod(targetPath, parseInt(file.permissions, 8));\n        } catch (error) {\n          logger.warn(\n            `Could not restore permissions for ${file.path}: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n    }\n  }\n\n  private async validateRestore(backup: MigrationBackup): Promise<void> {\n    logger.info('Validating restored files...');\n\n    const errors: string[] = [];\n\n    for (const file of backup.files) {\n      const filePath = path.join(this.projectPath, file.path);\n\n      if (!(await fs.pathExists(filePath))) {\n        errors.push(`Missing file: ${file.path}`);\n        continue;\n      }\n\n      const content = await fs.readFile(filePath, 'utf-8');\n      const checksum = crypto.createHash('sha256').update(content).digest('hex');\n\n      if (checksum !== file.checksum) {\n        errors.push(`Checksum mismatch: ${file.path}`);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Validation failed:\\n${errors.join('\\n')}`);\n    }\n\n    logger.success('Validation passed');\n  }\n\n  async cleanupOldBackups(retentionDays: number = 30, maxBackups: number = 10): Promise<void> {\n    const backups = await this.listBackups();\n\n    if (backups.length <= maxBackups) {\n      return; // No cleanup needed\n    }\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n    const backupsToDelete = backups.filter((backup, index) => {\n      // Keep the most recent maxBackups\n      if (index < maxBackups) {\n        return false;\n      }\n\n      // Delete old backups\n      return backup.timestamp < cutoffDate;\n    });\n\n    if (backupsToDelete.length === 0) {\n      return;\n    }\n\n    logger.info(`Cleaning up ${backupsToDelete.length} old backups...`);\n\n    for (const backup of backupsToDelete) {\n      const backupPath = path.join(this.backupDir, backup.metadata.backupId);\n      await fs.remove(backupPath);\n      logger.debug(`Removed backup: ${backup.metadata.backupId}`);\n    }\n\n    logger.success(`Cleanup completed, removed ${backupsToDelete.length} backups`);\n  }\n\n  async getBackupInfo(backupId: string): Promise<MigrationBackup | null> {\n    const backups = await this.listBackups();\n    return backups.find((b) => b.metadata.backupId === backupId) || null;\n  }\n\n  async exportBackup(backupId: string, exportPath: string): Promise<void> {\n    const backup = await this.getBackupInfo(backupId);\n    if (!backup) {\n      throw new Error(`Backup not found: ${backupId}`);\n    }\n\n    const backupPath = path.join(this.backupDir, backup.metadata.backupId);\n    await fs.copy(backupPath, exportPath);\n\n    logger.success(`Backup exported to ${exportPath}`);\n  }\n\n  async importBackup(importPath: string): Promise<MigrationBackup> {\n    const manifestPath = path.join(importPath, 'backup-manifest.json');\n\n    if (!(await fs.pathExists(manifestPath))) {\n      throw new Error('Invalid backup: missing manifest');\n    }\n\n    const backup = await fs.readJson(manifestPath);\n    const backupPath = path.join(this.backupDir, backup.metadata.backupId);\n\n    await fs.copy(importPath, backupPath);\n    await this.updateBackupIndex(backup);\n\n    logger.success(`Backup imported: ${backup.metadata.backupId}`);\n    return backup;\n  }\n\n  private async updateBackupIndex(backup: MigrationBackup): Promise<void> {\n    const indexPath = path.join(this.backupDir, 'backup-index.json');\n\n    let index: Record<string, any> = {};\n    if (await fs.pathExists(indexPath)) {\n      index = await fs.readJson(indexPath);\n    }\n\n    index[backup.metadata.backupId] = {\n      timestamp: backup.timestamp,\n      version: backup.version,\n      fileCount: backup.files.length,\n      metadata: backup.metadata,\n    };\n\n    await fs.writeJson(indexPath, index, { spaces: 2 });\n  }\n\n  printBackupSummary(backups: MigrationBackup[]): void {\n    if (backups.length === 0) {\n      console.log(chalk.yellow('No backups found'));\n      return;\n    }\n\n    console.log(chalk.bold('\\n\uD83D\uDCBE Available Backups'));\n    console.log(chalk.gray('\u2500'.repeat(70)));\n\n    backups.forEach((backup, index) => {\n      const isRecent = index === 0;\n      const date = backup.timestamp.toLocaleString();\n      const type = backup.metadata.type || 'migration';\n      const fileCount = backup.files.length;\n\n      console.log(\n        `\\n${isRecent ? chalk.green('\u25CF') : chalk.gray('\u25CB')} ${chalk.bold(backup.metadata.backupId)}`,\n      );\n      console.log(`  ${chalk.gray('Date:')} ${date}`);\n      console.log(`  ${chalk.gray('Type:')} ${type}`);\n      console.log(`  ${chalk.gray('Files:')} ${fileCount}`);\n\n      if (backup.metadata.strategy) {\n        console.log(`  ${chalk.gray('Strategy:')} ${backup.metadata.strategy}`);\n      }\n    });\n\n    console.log(chalk.gray('\\n' + '\u2500'.repeat(70)));\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
