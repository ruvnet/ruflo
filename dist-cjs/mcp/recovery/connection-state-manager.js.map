{
  "version": 3,
  "sources": ["../../../src/mcp/recovery/connection-state-manager.ts"],
  "sourcesContent": ["/**\n * Connection State Manager for MCP\n * Persists connection state across disconnections\n */\n\nimport { promises as fs } from 'node:fs';\nimport { join } from 'node:path';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPRequest, MCPConfig } from '../../utils/types.js';\n\nexport interface ConnectionState {\n  sessionId: string;\n  lastConnected: Date;\n  lastDisconnected?: Date;\n  pendingRequests: MCPRequest[];\n  configuration: MCPConfig;\n  metadata: Record<string, unknown>;\n}\n\nexport interface ConnectionEvent {\n  timestamp: Date;\n  type: 'connect' | 'disconnect' | 'reconnect' | 'error';\n  sessionId: string;\n  details?: Record<string, unknown>;\n  error?: string;\n}\n\nexport interface ConnectionMetrics {\n  totalConnections: number;\n  totalDisconnections: number;\n  totalReconnections: number;\n  averageSessionDuration: number;\n  averageReconnectionTime: number;\n  lastConnectionDuration?: number;\n  connectionHistory: ConnectionEvent[];\n}\n\nexport interface StateManagerConfig {\n  enablePersistence: boolean;\n  stateDirectory: string;\n  maxHistorySize: number;\n  persistenceInterval: number;\n}\n\nexport class ConnectionStateManager {\n  private currentState?: ConnectionState;\n  private connectionHistory: ConnectionEvent[] = [];\n  private metrics: ConnectionMetrics = {\n    totalConnections: 0,\n    totalDisconnections: 0,\n    totalReconnections: 0,\n    averageSessionDuration: 0,\n    averageReconnectionTime: 0,\n    connectionHistory: [],\n  };\n\n  private persistenceTimer?: NodeJS.Timeout;\n  private statePath: string;\n  private metricsPath: string;\n\n  private readonly defaultConfig: StateManagerConfig = {\n    enablePersistence: true,\n    stateDirectory: '.mcp-state',\n    maxHistorySize: 1000,\n    persistenceInterval: 60000, // 1 minute\n  };\n\n  constructor(\n    private logger: ILogger,\n    config?: Partial<StateManagerConfig>,\n  ) {\n    this.config = { ...this.defaultConfig, ...config };\n\n    this.statePath = join(this.config.stateDirectory, 'connection-state.json');\n    this.metricsPath = join(this.config.stateDirectory, 'connection-metrics.json');\n\n    this.initialize().catch((error) => {\n      this.logger.error('Failed to initialize state manager', error);\n    });\n  }\n\n  private config: StateManagerConfig;\n\n  /**\n   * Initialize the state manager\n   */\n  private async initialize(): Promise<void> {\n    if (!this.config.enablePersistence) {\n      return;\n    }\n\n    try {\n      // Ensure state directory exists\n      await fs.mkdir(this.config.stateDirectory, { recursive: true });\n\n      // Load existing state\n      await this.loadState();\n      await this.loadMetrics();\n\n      // Start persistence timer\n      this.startPersistenceTimer();\n\n      this.logger.info('Connection state manager initialized', {\n        stateDirectory: this.config.stateDirectory,\n      });\n    } catch (error) {\n      this.logger.error('Failed to initialize state manager', error);\n    }\n  }\n\n  /**\n   * Save current connection state\n   */\n  saveState(state: ConnectionState): void {\n    this.currentState = {\n      ...state,\n      metadata: {\n        ...state.metadata,\n        lastSaved: new Date().toISOString(),\n      },\n    };\n\n    this.logger.debug('Connection state saved', {\n      sessionId: state.sessionId,\n      pendingRequests: state.pendingRequests.length,\n    });\n\n    // Persist immediately if critical\n    if (state.pendingRequests.length > 0) {\n      this.persistState().catch((error) => {\n        this.logger.error('Failed to persist critical state', error);\n      });\n    }\n  }\n\n  /**\n   * Restore previous connection state\n   */\n  restoreState(): ConnectionState | null {\n    if (!this.currentState) {\n      this.logger.debug('No state to restore');\n      return null;\n    }\n\n    this.logger.info('Restoring connection state', {\n      sessionId: this.currentState.sessionId,\n      pendingRequests: this.currentState.pendingRequests.length,\n    });\n\n    return { ...this.currentState };\n  }\n\n  /**\n   * Record a connection event\n   */\n  recordEvent(event: Omit<ConnectionEvent, 'timestamp'>): void {\n    const fullEvent: ConnectionEvent = {\n      ...event,\n      timestamp: new Date(),\n    };\n\n    this.connectionHistory.push(fullEvent);\n\n    // Trim history if needed\n    if (this.connectionHistory.length > this.config.maxHistorySize) {\n      this.connectionHistory = this.connectionHistory.slice(-this.config.maxHistorySize);\n    }\n\n    // Update metrics\n    this.updateMetrics(fullEvent);\n\n    this.logger.debug('Connection event recorded', {\n      type: event.type,\n      sessionId: event.sessionId,\n    });\n  }\n\n  /**\n   * Get connection metrics\n   */\n  getMetrics(): ConnectionMetrics {\n    return {\n      ...this.metrics,\n      connectionHistory: [...this.connectionHistory],\n    };\n  }\n\n  /**\n   * Clear a specific session state\n   */\n  clearSession(sessionId: string): void {\n    if (this.currentState?.sessionId === sessionId) {\n      this.currentState = undefined;\n\n      this.logger.info('Session state cleared', { sessionId });\n\n      this.persistState().catch((error) => {\n        this.logger.error('Failed to persist cleared state', error);\n      });\n    }\n  }\n\n  /**\n   * Add a pending request\n   */\n  addPendingRequest(request: MCPRequest): void {\n    if (!this.currentState) {\n      this.logger.warn('No active state to add pending request');\n      return;\n    }\n\n    this.currentState.pendingRequests.push(request);\n\n    this.logger.debug('Pending request added', {\n      requestId: request.id,\n      method: request.method,\n      total: this.currentState.pendingRequests.length,\n    });\n  }\n\n  /**\n   * Remove a pending request\n   */\n  removePendingRequest(requestId: string): void {\n    if (!this.currentState) {\n      return;\n    }\n\n    this.currentState.pendingRequests = this.currentState.pendingRequests.filter(\n      (req) => req.id !== requestId,\n    );\n  }\n\n  /**\n   * Get pending requests\n   */\n  getPendingRequests(): MCPRequest[] {\n    return this.currentState?.pendingRequests || [];\n  }\n\n  /**\n   * Update session metadata\n   */\n  updateMetadata(metadata: Record<string, unknown>): void {\n    if (!this.currentState) {\n      return;\n    }\n\n    this.currentState.metadata = {\n      ...this.currentState.metadata,\n      ...metadata,\n    };\n  }\n\n  /**\n   * Calculate session duration\n   */\n  getSessionDuration(sessionId: string): number | null {\n    const connectEvent = this.connectionHistory.find(\n      (e) => e.sessionId === sessionId && e.type === 'connect',\n    );\n\n    const disconnectEvent = this.connectionHistory.find(\n      (e) => e.sessionId === sessionId && e.type === 'disconnect',\n    );\n\n    if (!connectEvent) {\n      return null;\n    }\n\n    const endTime = disconnectEvent ? disconnectEvent.timestamp : new Date();\n    return endTime.getTime() - connectEvent.timestamp.getTime();\n  }\n\n  /**\n   * Get reconnection time for a session\n   */\n  getReconnectionTime(sessionId: string): number | null {\n    const disconnectEvent = this.connectionHistory.find(\n      (e) => e.sessionId === sessionId && e.type === 'disconnect',\n    );\n\n    const reconnectEvent = this.connectionHistory.find(\n      (e) =>\n        e.sessionId === sessionId &&\n        e.type === 'reconnect' &&\n        e.timestamp > (disconnectEvent?.timestamp || new Date(0)),\n    );\n\n    if (!disconnectEvent || !reconnectEvent) {\n      return null;\n    }\n\n    return reconnectEvent.timestamp.getTime() - disconnectEvent.timestamp.getTime();\n  }\n\n  private updateMetrics(event: ConnectionEvent): void {\n    switch (event.type) {\n      case 'connect':\n        this.metrics.totalConnections++;\n        break;\n\n      case 'disconnect':\n        this.metrics.totalDisconnections++;\n\n        // Calculate session duration\n        const duration = this.getSessionDuration(event.sessionId);\n        if (duration !== null) {\n          this.metrics.lastConnectionDuration = duration;\n\n          // Update average\n          const totalDuration =\n            this.metrics.averageSessionDuration * (this.metrics.totalDisconnections - 1) + duration;\n          this.metrics.averageSessionDuration = totalDuration / this.metrics.totalDisconnections;\n        }\n        break;\n\n      case 'reconnect':\n        this.metrics.totalReconnections++;\n\n        // Calculate reconnection time\n        const reconnectTime = this.getReconnectionTime(event.sessionId);\n        if (reconnectTime !== null) {\n          // Update average\n          const totalTime =\n            this.metrics.averageReconnectionTime * (this.metrics.totalReconnections - 1) +\n            reconnectTime;\n          this.metrics.averageReconnectionTime = totalTime / this.metrics.totalReconnections;\n        }\n        break;\n    }\n  }\n\n  private async loadState(): Promise<void> {\n    try {\n      const data = await fs.readFile(this.statePath, 'utf-8');\n      const state = JSON.parse(data);\n\n      // Convert date strings back to Date objects\n      state.lastConnected = new Date(state.lastConnected);\n      if (state.lastDisconnected) {\n        state.lastDisconnected = new Date(state.lastDisconnected);\n      }\n\n      this.currentState = state;\n\n      this.logger.info('Connection state loaded', {\n        sessionId: state.sessionId,\n        pendingRequests: state.pendingRequests.length,\n      });\n    } catch (error) {\n      if ((error as any).code !== 'ENOENT') {\n        this.logger.error('Failed to load connection state', error);\n      }\n    }\n  }\n\n  private async loadMetrics(): Promise<void> {\n    try {\n      const data = await fs.readFile(this.metricsPath, 'utf-8');\n      const loaded = JSON.parse(data);\n\n      // Convert date strings back to Date objects\n      loaded.connectionHistory = loaded.connectionHistory.map((event: any) => ({\n        ...event,\n        timestamp: new Date(event.timestamp),\n      }));\n\n      this.metrics = loaded;\n      this.connectionHistory = loaded.connectionHistory;\n\n      this.logger.info('Connection metrics loaded', {\n        totalConnections: this.metrics.totalConnections,\n        historySize: this.connectionHistory.length,\n      });\n    } catch (error) {\n      if ((error as any).code !== 'ENOENT') {\n        this.logger.error('Failed to load connection metrics', error);\n      }\n    }\n  }\n\n  private async persistState(): Promise<void> {\n    if (!this.config.enablePersistence) {\n      return;\n    }\n\n    try {\n      if (this.currentState) {\n        await fs.writeFile(this.statePath, JSON.stringify(this.currentState, null, 2), 'utf-8');\n      }\n\n      // Also persist metrics\n      await fs.writeFile(\n        this.metricsPath,\n        JSON.stringify(\n          {\n            ...this.metrics,\n            connectionHistory: this.connectionHistory,\n          },\n          null,\n          2,\n        ),\n        'utf-8',\n      );\n\n      this.logger.debug('State and metrics persisted');\n    } catch (error) {\n      this.logger.error('Failed to persist state', error);\n    }\n  }\n\n  private startPersistenceTimer(): void {\n    if (this.persistenceTimer) {\n      return;\n    }\n\n    this.persistenceTimer = setInterval(() => {\n      this.persistState().catch((error) => {\n        this.logger.error('Periodic persistence failed', error);\n      });\n    }, this.config.persistenceInterval);\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    if (this.persistenceTimer) {\n      clearInterval(this.persistenceTimer);\n      this.persistenceTimer = undefined;\n    }\n\n    // Final persistence\n    await this.persistState();\n  }\n}\n"],
  "mappings": "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",
  "names": ["fs"]
}
