{
  "version": 3,
  "sources": ["../../src/memory/indexer.ts"],
  "sourcesContent": ["/**\n * Memory indexer for fast querying\n */\n\nimport type { MemoryEntry, MemoryQuery } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\n\ninterface Index<T> {\n  get(key: T): Set<string>;\n  add(key: T, entryId: string): void;\n  remove(key: T, entryId: string): void;\n  clear(): void;\n}\n\n/**\n * Simple index implementation\n */\nclass SimpleIndex<T> implements Index<T> {\n  private index = new Map<T, Set<string>>();\n\n  get(key: T): Set<string> {\n    return this.index.get(key) || new Set();\n  }\n\n  add(key: T, entryId: string): void {\n    if (!this.index.has(key)) {\n      this.index.set(key, new Set());\n    }\n    this.index.get(key)!.add(entryId);\n  }\n\n  remove(key: T, entryId: string): void {\n    const set = this.index.get(key);\n    if (set) {\n      set.delete(entryId);\n      if (set.size === 0) {\n        this.index.delete(key);\n      }\n    }\n  }\n\n  clear(): void {\n    this.index.clear();\n  }\n\n  keys(): T[] {\n    return Array.from(this.index.keys());\n  }\n}\n\n/**\n * Memory indexer for efficient querying\n */\nexport class MemoryIndexer {\n  private entries = new Map<string, MemoryEntry>();\n  private agentIndex = new SimpleIndex<string>();\n  private sessionIndex = new SimpleIndex<string>();\n  private typeIndex = new SimpleIndex<string>();\n  private tagIndex = new SimpleIndex<string>();\n  private timeIndex = new Map<string, number>(); // id -> timestamp\n\n  constructor(private logger: ILogger) {}\n\n  /**\n   * Builds index from a list of entries\n   */\n  async buildIndex(entries: MemoryEntry[]): Promise<void> {\n    this.logger.info('Building memory index', { entries: entries.length });\n\n    this.clear();\n\n    for (const entry of entries) {\n      this.addEntry(entry);\n    }\n\n    this.logger.info('Memory index built', {\n      totalEntries: this.entries.size,\n      agents: this.agentIndex.keys().length,\n      sessions: this.sessionIndex.keys().length,\n      types: this.typeIndex.keys().length,\n      tags: this.tagIndex.keys().length,\n    });\n  }\n\n  /**\n   * Adds an entry to the index\n   */\n  addEntry(entry: MemoryEntry): void {\n    // Store entry\n    this.entries.set(entry.id, entry);\n\n    // Update indexes\n    this.agentIndex.add(entry.agentId, entry.id);\n    this.sessionIndex.add(entry.sessionId, entry.id);\n    this.typeIndex.add(entry.type, entry.id);\n\n    for (const tag of entry.tags) {\n      this.tagIndex.add(tag, entry.id);\n    }\n\n    this.timeIndex.set(entry.id, entry.timestamp.getTime());\n  }\n\n  /**\n   * Updates an entry in the index\n   */\n  updateEntry(entry: MemoryEntry): void {\n    const existing = this.entries.get(entry.id);\n    if (existing) {\n      this.removeEntry(entry.id);\n    }\n    this.addEntry(entry);\n  }\n\n  /**\n   * Removes an entry from the index\n   */\n  removeEntry(id: string): void {\n    const entry = this.entries.get(id);\n    if (!entry) {\n      return;\n    }\n\n    // Remove from indexes\n    this.agentIndex.remove(entry.agentId, id);\n    this.sessionIndex.remove(entry.sessionId, id);\n    this.typeIndex.remove(entry.type, id);\n\n    for (const tag of entry.tags) {\n      this.tagIndex.remove(tag, id);\n    }\n\n    this.timeIndex.delete(id);\n    this.entries.delete(id);\n  }\n\n  /**\n   * Searches entries using the index\n   */\n  search(query: MemoryQuery): MemoryEntry[] {\n    let resultIds: Set<string> | undefined;\n\n    // Apply index-based filters\n    if (query.agentId) {\n      resultIds = this.intersectSets(resultIds, this.agentIndex.get(query.agentId));\n    }\n\n    if (query.sessionId) {\n      resultIds = this.intersectSets(resultIds, this.sessionIndex.get(query.sessionId));\n    }\n\n    if (query.type) {\n      resultIds = this.intersectSets(resultIds, this.typeIndex.get(query.type));\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      const tagSets = query.tags.map((tag) => this.tagIndex.get(tag));\n      const unionSet = this.unionSets(...tagSets);\n      resultIds = this.intersectSets(resultIds, unionSet);\n    }\n\n    // If no filters applied, get all entries\n    if (!resultIds) {\n      resultIds = new Set(this.entries.keys());\n    }\n\n    // Convert IDs to entries\n    const results: MemoryEntry[] = [];\n    for (const id of resultIds) {\n      const entry = this.entries.get(id);\n      if (entry) {\n        results.push(entry);\n      }\n    }\n\n    // Sort by timestamp (newest first)\n    results.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    return results;\n  }\n\n  /**\n   * Gets index metrics\n   */\n  getMetrics(): {\n    totalEntries: number;\n    indexSizes: Record<string, number>;\n  } {\n    return {\n      totalEntries: this.entries.size,\n      indexSizes: {\n        agents: this.agentIndex.keys().length,\n        sessions: this.sessionIndex.keys().length,\n        types: this.typeIndex.keys().length,\n        tags: this.tagIndex.keys().length,\n      },\n    };\n  }\n\n  /**\n   * Clears all indexes\n   */\n  clear(): void {\n    this.entries.clear();\n    this.agentIndex.clear();\n    this.sessionIndex.clear();\n    this.typeIndex.clear();\n    this.tagIndex.clear();\n    this.timeIndex.clear();\n  }\n\n  private intersectSets(set1: Set<string> | undefined, set2: Set<string>): Set<string> {\n    if (!set1) {\n      return new Set(set2);\n    }\n\n    const result = new Set<string>();\n    for (const item of set1) {\n      if (set2.has(item)) {\n        result.add(item);\n      }\n    }\n    return result;\n  }\n\n  private unionSets(...sets: Set<string>[]): Set<string> {\n    const result = new Set<string>();\n    for (const set of sets) {\n      for (const item of set) {\n        result.add(item);\n      }\n    }\n    return result;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
