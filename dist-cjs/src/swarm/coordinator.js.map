{"version":3,"sources":["../../../src/swarm/coordinator.ts"],"sourcesContent":["import { EventEmitter } from 'events';\r\nimport { promises as fs } from 'node:fs';\r\nimport { Logger } from '../core/logger.js';\r\nimport { generateId } from '../utils/helpers.js';\r\nimport {\r\n  SwarmId,\r\n  AgentId,\r\n  TaskId,\r\n  AgentState,\r\n  TaskDefinition,\r\n  SwarmObjective,\r\n  SwarmConfig,\r\n  SwarmStatus,\r\n  SwarmProgress,\r\n  SwarmResults,\r\n  SwarmMetrics,\r\n  SwarmMode,\r\n  SwarmStrategy,\r\n  AgentType,\r\n  TaskType,\r\n  TaskStatus,\r\n  TaskPriority,\r\n  SwarmEvent,\r\n  EventType,\r\n  SwarmEventEmitter,\r\n  ValidationResult,\r\n  SWARM_CONSTANTS,\r\n} from './types.js';\r\nimport { AutoStrategy } from './strategies/auto.js';\r\nimport { getClaudeFlowRoot, getClaudeFlowBin } from '../utils/paths.js';\r\nimport { SwarmJsonOutputAggregator } from './json-output-aggregator.js';\r\n\r\nexport class SwarmCoordinator extends EventEmitter implements SwarmEventEmitter {\r\n  private logger: Logger;\r\n  private config: SwarmConfig;\r\n  private swarmId: SwarmId;\r\n\r\n  // Core state management\r\n  private agents: Map<string, AgentState> = new Map();\r\n  private tasks: Map<string, TaskDefinition> = new Map();\r\n  private objectives: Map<string, SwarmObjective> = new Map();\r\n\r\n  // Execution state\r\n  private _isRunning: boolean = false;\r\n  private status: SwarmStatus = 'planning';\r\n  private startTime?: Date;\r\n  private endTime?: Date;\r\n\r\n  // Performance tracking\r\n  private metrics: SwarmMetrics;\r\n  private events: SwarmEvent[] = [];\r\n  private lastHeartbeat: Date = new Date();\r\n\r\n  // JSON output aggregation (optional)\r\n  private jsonOutputAggregator?: SwarmJsonOutputAggregator;\r\n\r\n  // Background processes\r\n  private heartbeatTimer?: NodeJS.Timeout;\r\n  private monitoringTimer?: NodeJS.Timeout;\r\n  private cleanupTimer?: NodeJS.Timeout;\r\n  private executionIntervals?: Map<string, NodeJS.Timeout>;\r\n\r\n  // Strategy instances\r\n  private autoStrategy: AutoStrategy;\r\n\r\n  constructor(config: Partial<SwarmConfig> = {}) {\r\n    super();\r\n\r\n    // Configure logger based on config or default to quiet mode\r\n    const logLevel = (config as any).logging?.level || 'error';\r\n    const logFormat = (config as any).logging?.format || 'text';\r\n    const logDestination = (config as any).logging?.destination || 'console';\r\n\r\n    this.logger = new Logger(\r\n      { level: logLevel, format: logFormat, destination: logDestination },\r\n      { component: 'SwarmCoordinator' },\r\n    );\r\n    this.swarmId = this.generateSwarmId();\r\n\r\n    // Initialize configuration with defaults\r\n    this.config = this.mergeWithDefaults(config);\r\n\r\n    // Initialize metrics\r\n    this.metrics = this.initializeMetrics();\r\n\r\n    // Initialize strategy instances\r\n    this.autoStrategy = new AutoStrategy(config);\r\n\r\n    // Setup event handlers\r\n    this.setupEventHandlers();\r\n\r\n    this.logger.info('SwarmCoordinator initialized', {\r\n      swarmId: this.swarmId.id,\r\n      mode: this.config.mode,\r\n      strategy: this.config.strategy,\r\n    });\r\n  }\r\n\r\n  // ===== LIFECYCLE MANAGEMENT =====\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this._isRunning) {\r\n      throw new Error('Swarm coordinator already running');\r\n    }\r\n\r\n    this.logger.info('Initializing swarm coordinator...');\r\n    this.status = 'initializing';\r\n\r\n    try {\r\n      // Validate configuration\r\n      const validation = await this.validateConfiguration();\r\n      if (!validation.valid) {\r\n        throw new Error(\r\n          `Configuration validation failed: ${validation.errors.map((e) => e.message).join(', ')}`,\r\n        );\r\n      }\r\n\r\n      // Initialize subsystems\r\n      await this.initializeSubsystems();\r\n\r\n      // Start background processes\r\n      this.startBackgroundProcesses();\r\n\r\n      this._isRunning = true;\r\n      this.startTime = new Date();\r\n      this.status = 'executing';\r\n\r\n      this.emitSwarmEvent({\r\n        id: generateId('event'),\r\n        timestamp: new Date(),\r\n        type: 'swarm.started',\r\n        source: this.swarmId.id,\r\n        data: { swarmId: this.swarmId },\r\n        broadcast: true,\r\n        processed: false,\r\n      });\r\n\r\n      this.logger.info('Swarm coordinator initialized successfully');\r\n    } catch (error) {\r\n      this.status = 'failed';\r\n      this.logger.error('Failed to initialize swarm coordinator', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    if (!this._isRunning) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Shutting down swarm coordinator...');\r\n    this.status = 'paused';\r\n\r\n    try {\r\n      // Stop background processes\r\n      this.stopBackgroundProcesses();\r\n\r\n      // Gracefully stop all agents\r\n      await this.stopAllAgents();\r\n\r\n      // Complete any running tasks\r\n      await this.completeRunningTasks();\r\n\r\n      // Save final state\r\n      await this.saveState();\r\n\r\n      this._isRunning = false;\r\n      this.endTime = new Date();\r\n      this.status = 'completed';\r\n\r\n      this.emitSwarmEvent({\r\n        id: generateId('event'),\r\n        timestamp: new Date(),\r\n        type: 'swarm.completed',\r\n        source: this.swarmId.id,\r\n        data: {\r\n          swarmId: this.swarmId,\r\n          metrics: this.metrics,\r\n          duration: this.endTime.getTime() - (this.startTime?.getTime() || 0),\r\n        },\r\n        broadcast: true,\r\n        processed: false,\r\n      });\r\n\r\n      this.logger.info('Swarm coordinator shut down successfully');\r\n    } catch (error) {\r\n      this.logger.error('Error during swarm coordinator shutdown', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async pause(): Promise<void> {\r\n    if (!this._isRunning || this.status === 'paused') {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Pausing swarm coordinator...');\r\n    this.status = 'paused';\r\n\r\n    // Pause all agents\r\n    for (const agent of this.agents.values()) {\r\n      if (agent.status === 'busy') {\r\n        await this.pauseAgent(agent.id);\r\n      }\r\n    }\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'swarm.paused',\r\n      source: this.swarmId.id,\r\n      data: { swarmId: this.swarmId },\r\n      broadcast: true,\r\n      processed: false,\r\n    });\r\n  }\r\n\r\n  async resume(): Promise<void> {\r\n    if (!this._isRunning || this.status !== 'paused') {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Resuming swarm coordinator...');\r\n    this.status = 'executing';\r\n\r\n    // Resume all paused agents\r\n    for (const agent of this.agents.values()) {\r\n      if (agent.status === 'paused') {\r\n        await this.resumeAgent(agent.id);\r\n      }\r\n    }\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'swarm.resumed',\r\n      source: this.swarmId.id,\r\n      data: { swarmId: this.swarmId },\r\n      broadcast: true,\r\n      processed: false,\r\n    });\r\n  }\r\n\r\n  // ===== OBJECTIVE MANAGEMENT =====\r\n\r\n  async createObjective(\r\n    name: string,\r\n    description: string,\r\n    strategy: SwarmStrategy = 'auto',\r\n    requirements: Partial<SwarmObjective['requirements']> = {},\r\n  ): Promise<string> {\r\n    const objectiveId = generateId('objective');\r\n\r\n    const objective: SwarmObjective = {\r\n      id: objectiveId,\r\n      name,\r\n      description,\r\n      strategy,\r\n      mode: this.config.mode,\r\n      requirements: {\r\n        minAgents: 1,\r\n        maxAgents: this.config.maxAgents,\r\n        agentTypes: this.determineRequiredAgentTypes(strategy),\r\n        estimatedDuration: 60 * 60 * 1000, // 1 hour default\r\n        maxDuration: 4 * 60 * 60 * 1000, // 4 hours default\r\n        qualityThreshold: this.config.qualityThreshold,\r\n        reviewCoverage: 0.8,\r\n        testCoverage: 0.7,\r\n        reliabilityTarget: 0.95,\r\n        ...requirements,\r\n      },\r\n      constraints: {\r\n        minQuality: this.config.qualityThreshold,\r\n        requiredApprovals: [],\r\n        allowedFailures: Math.floor(this.config.maxAgents * 0.1),\r\n        recoveryTime: 5 * 60 * 1000, // 5 minutes\r\n        milestones: [],\r\n      },\r\n      tasks: [],\r\n      dependencies: [],\r\n      status: 'planning',\r\n      progress: this.initializeProgress(),\r\n      createdAt: new Date(),\r\n      metrics: this.initializeMetrics(),\r\n    };\r\n\r\n    // Decompose objective into tasks using optimized AUTO strategy\r\n    if (objective.strategy === 'auto') {\r\n      const decompositionResult = await this.autoStrategy.decomposeObjective(objective);\r\n      objective.tasks = decompositionResult.tasks;\r\n      objective.dependencies = this.convertDependenciesToTaskDependencies(\r\n        decompositionResult.dependencies,\r\n      );\r\n    } else {\r\n      objective.tasks = await this.decomposeObjective(objective);\r\n      objective.dependencies = this.analyzeDependencies(objective.tasks);\r\n    }\r\n\r\n    this.objectives.set(objectiveId, objective);\r\n\r\n    this.logger.info('Created objective', {\r\n      objectiveId,\r\n      name,\r\n      strategy,\r\n      taskCount: objective.tasks.length,\r\n    });\r\n\r\n    return objectiveId;\r\n  }\r\n\r\n  async executeObjective(objectiveId: string): Promise<void> {\r\n    const objective = this.objectives.get(objectiveId);\r\n    if (!objective) {\r\n      throw new Error(`Objective not found: ${objectiveId}`);\r\n    }\r\n\r\n    if (objective.status !== 'planning') {\r\n      throw new Error(`Objective already ${objective.status}`);\r\n    }\r\n\r\n    this.logger.info('Executing objective', { objectiveId, name: objective.name });\r\n    objective.status = 'executing';\r\n    objective.startedAt = new Date();\r\n\r\n    try {\r\n      // Ensure we have required agents\r\n      await this.ensureRequiredAgents(objective);\r\n\r\n      // Schedule initial tasks\r\n      await this.scheduleInitialTasks(objective);\r\n\r\n      // Start task execution loop\r\n      this.startTaskExecutionLoop(objective);\r\n    } catch (error) {\r\n      objective.status = 'failed';\r\n      this.logger.error('Failed to execute objective', { objectiveId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ===== AGENT MANAGEMENT =====\r\n\r\n  async registerAgent(\r\n    name: string,\r\n    type: AgentType,\r\n    capabilities: Partial<AgentState['capabilities']> = {},\r\n  ): Promise<string> {\r\n    const agentId: AgentId = {\r\n      id: generateId('agent'),\r\n      swarmId: this.swarmId.id,\r\n      type,\r\n      instance: this.getNextInstanceNumber(type),\r\n    };\r\n\r\n    const agentState: AgentState = {\r\n      id: agentId,\r\n      name,\r\n      type,\r\n      status: 'initializing',\r\n      capabilities: {\r\n        // Default capabilities\r\n        codeGeneration: false,\r\n        codeReview: false,\r\n        testing: false,\r\n        documentation: false,\r\n        research: false,\r\n        analysis: false,\r\n        webSearch: false,\r\n        apiIntegration: false,\r\n        fileSystem: true,\r\n        terminalAccess: true,\r\n        languages: [],\r\n        frameworks: [],\r\n        domains: [],\r\n        tools: [],\r\n        maxConcurrentTasks: 3,\r\n        maxMemoryUsage: SWARM_CONSTANTS.DEFAULT_MEMORY_LIMIT,\r\n        maxExecutionTime: SWARM_CONSTANTS.DEFAULT_TASK_TIMEOUT,\r\n        reliability: 0.8,\r\n        speed: 1.0,\r\n        quality: 0.8,\r\n        ...capabilities,\r\n      },\r\n      metrics: {\r\n        tasksCompleted: 0,\r\n        tasksFailed: 0,\r\n        averageExecutionTime: 0,\r\n        successRate: 0,\r\n        cpuUsage: 0,\r\n        memoryUsage: 0,\r\n        diskUsage: 0,\r\n        networkUsage: 0,\r\n        codeQuality: 0,\r\n        testCoverage: 0,\r\n        bugRate: 0,\r\n        userSatisfaction: 0,\r\n        totalUptime: 0,\r\n        lastActivity: new Date(),\r\n        responseTime: 0,\r\n      },\r\n      workload: 0,\r\n      health: 1.0,\r\n      config: {\r\n        autonomyLevel: 0.7,\r\n        learningEnabled: true,\r\n        adaptationEnabled: true,\r\n        maxTasksPerHour: 10,\r\n        maxConcurrentTasks: capabilities.maxConcurrentTasks || 3,\r\n        timeoutThreshold: SWARM_CONSTANTS.DEFAULT_TASK_TIMEOUT,\r\n        reportingInterval: 30000,\r\n        heartbeatInterval: SWARM_CONSTANTS.DEFAULT_HEARTBEAT_INTERVAL,\r\n        permissions: this.getDefaultPermissions(type),\r\n        trustedAgents: [],\r\n        expertise: {},\r\n        preferences: {},\r\n      },\r\n      environment: {\r\n        runtime: 'deno',\r\n        version: '1.0.0',\r\n        workingDirectory: `/tmp/swarm/${this.swarmId.id}/agents/${agentId.id}`,\r\n        tempDirectory: `/tmp/swarm/${this.swarmId.id}/agents/${agentId.id}/temp`,\r\n        logDirectory: `/tmp/swarm/${this.swarmId.id}/agents/${agentId.id}/logs`,\r\n        apiEndpoints: {},\r\n        credentials: {},\r\n        availableTools: [],\r\n        toolConfigs: {},\r\n      },\r\n      endpoints: [],\r\n      lastHeartbeat: new Date(),\r\n      taskHistory: [],\r\n      errorHistory: [],\r\n      childAgents: [],\r\n      collaborators: [],\r\n    };\r\n\r\n    this.agents.set(agentId.id, agentState);\r\n\r\n    // Track agent in JSON output if enabled\r\n    this.trackAgentInJsonOutput(agentState);\r\n\r\n    // Initialize agent capabilities based on type\r\n    await this.initializeAgentCapabilities(agentState);\r\n\r\n    // Start agent\r\n    await this.startAgent(agentId.id);\r\n\r\n    this.logger.info('Registered agent', {\r\n      agentId: agentId.id,\r\n      name,\r\n      type,\r\n      capabilities: Object.keys(capabilities),\r\n    });\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'agent.created',\r\n      source: agentId.id,\r\n      data: { agent: agentState },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n\r\n    return agentId.id;\r\n  }\r\n\r\n  async unregisterAgent(agentId: string): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Unregistering agent', { agentId, name: agent.name });\r\n\r\n    // Stop agent gracefully\r\n    await this.stopAgent(agentId);\r\n\r\n    // Reassign any active tasks\r\n    if (agent.currentTask) {\r\n      await this.reassignTask(agent.currentTask.id);\r\n    }\r\n\r\n    // Remove from agents map\r\n    this.agents.delete(agentId);\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'agent.stopped',\r\n      source: agentId,\r\n      data: { agentId },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n  }\r\n\r\n  async startAgent(agentId: string): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent) {\r\n      throw new Error(`Agent not found: ${agentId}`);\r\n    }\r\n\r\n    if (agent.status !== 'initializing' && agent.status !== 'offline') {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Starting agent', { agentId, name: agent.name });\r\n\r\n    try {\r\n      // Initialize agent environment\r\n      await this.initializeAgentEnvironment(agent);\r\n\r\n      // Start agent heartbeat\r\n      this.startAgentHeartbeat(agent);\r\n\r\n      agent.status = 'idle';\r\n      agent.lastHeartbeat = new Date();\r\n\r\n      this.emitSwarmEvent({\r\n        id: generateId('event'),\r\n        timestamp: new Date(),\r\n        type: 'agent.started',\r\n        source: agentId,\r\n        data: { agent },\r\n        broadcast: false,\r\n        processed: false,\r\n      });\r\n    } catch (error) {\r\n      agent.status = 'error';\r\n      agent.errorHistory.push({\r\n        timestamp: new Date(),\r\n        type: 'startup_error',\r\n        message: error instanceof Error ? error.message : String(error),\r\n        stack: error.stack,\r\n        context: { agentId },\r\n        severity: 'high',\r\n        resolved: false,\r\n      });\r\n\r\n      this.logger.error('Failed to start agent', { agentId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async stopAgent(agentId: string): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent) {\r\n      return;\r\n    }\r\n\r\n    if (agent.status === 'offline' || agent.status === 'terminated') {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Stopping agent', { agentId, name: agent.name });\r\n\r\n    agent.status = 'terminating';\r\n\r\n    try {\r\n      // Cancel current task if any\r\n      if (agent.currentTask) {\r\n        await this.cancelTask(agent.currentTask.id, 'Agent stopping');\r\n      }\r\n\r\n      // Stop heartbeat\r\n      this.stopAgentHeartbeat(agent);\r\n\r\n      // Cleanup agent environment\r\n      await this.cleanupAgentEnvironment(agent);\r\n\r\n      agent.status = 'terminated';\r\n    } catch (error) {\r\n      agent.status = 'error';\r\n      this.logger.error('Error stopping agent', { agentId, error });\r\n    }\r\n  }\r\n\r\n  async pauseAgent(agentId: string): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent || agent.status !== 'busy') {\r\n      return;\r\n    }\r\n\r\n    agent.status = 'paused';\r\n    this.logger.info('Paused agent', { agentId });\r\n  }\r\n\r\n  async resumeAgent(agentId: string): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent || agent.status !== 'paused') {\r\n      return;\r\n    }\r\n\r\n    agent.status = 'busy';\r\n    this.logger.info('Resumed agent', { agentId });\r\n  }\r\n\r\n  // ===== TASK MANAGEMENT =====\r\n\r\n  async createTask(\r\n    type: TaskType,\r\n    name: string,\r\n    description: string,\r\n    instructions: string,\r\n    options: Partial<TaskDefinition> = {},\r\n  ): Promise<string> {\r\n    const taskId: TaskId = {\r\n      id: generateId('task'),\r\n      swarmId: this.swarmId.id,\r\n      sequence: this.tasks.size + 1,\r\n      priority: 1,\r\n    };\r\n\r\n    const task: TaskDefinition = {\r\n      id: taskId,\r\n      type,\r\n      name,\r\n      description,\r\n      instructions,\r\n      requirements: {\r\n        capabilities: this.getRequiredCapabilities(type),\r\n        tools: this.getRequiredTools(type),\r\n        permissions: this.getRequiredPermissions(type),\r\n        ...options.requirements,\r\n      },\r\n      constraints: {\r\n        dependencies: [],\r\n        dependents: [],\r\n        conflicts: [],\r\n        maxRetries: SWARM_CONSTANTS.MAX_RETRIES,\r\n        timeoutAfter: SWARM_CONSTANTS.DEFAULT_TASK_TIMEOUT,\r\n        ...options.constraints,\r\n      },\r\n      priority: 'normal',\r\n      input: options.input || {},\r\n      context: options.context || {},\r\n      examples: options.examples || [],\r\n      status: 'created',\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      attempts: [],\r\n      statusHistory: [\r\n        {\r\n          timestamp: new Date(),\r\n          from: 'created' as TaskStatus,\r\n          to: 'created' as TaskStatus,\r\n          reason: 'Task created',\r\n          triggeredBy: 'system',\r\n        },\r\n      ],\r\n      ...options,\r\n    };\r\n\r\n    this.tasks.set(taskId.id, task);\r\n\r\n    // Track task in JSON output if enabled\r\n    this.trackTaskInJsonOutput(task);\r\n\r\n    this.logger.info('Created task', {\r\n      taskId: taskId.id,\r\n      type,\r\n      name,\r\n      priority: task.priority,\r\n    });\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'task.created',\r\n      source: this.swarmId.id,\r\n      data: { task },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n\r\n    return taskId.id;\r\n  }\r\n\r\n  async assignTask(taskId: string, agentId?: string): Promise<void> {\r\n    const task = this.tasks.get(taskId);\r\n    if (!task) {\r\n      throw new Error(`Task not found: ${taskId}`);\r\n    }\r\n\r\n    if (task.status !== 'created' && task.status !== 'queued') {\r\n      throw new Error(`Task cannot be assigned, current status: ${task.status}`);\r\n    }\r\n\r\n    // Select agent if not specified\r\n    if (!agentId) {\r\n      agentId = await this.selectAgentForTask(task);\r\n      if (!agentId) {\r\n        throw new Error('No suitable agent available for task');\r\n      }\r\n    }\r\n\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent) {\r\n      throw new Error(`Agent not found: ${agentId}`);\r\n    }\r\n\r\n    if (agent.status !== 'idle') {\r\n      throw new Error(`Agent not available: ${agent.status}`);\r\n    }\r\n\r\n    // Assign task\r\n    task.assignedTo = agent.id;\r\n    task.assignedAt = new Date();\r\n    task.status = 'assigned';\r\n\r\n    agent.currentTask = task.id;\r\n    agent.status = 'busy';\r\n\r\n    // Update status history\r\n    task.statusHistory.push({\r\n      timestamp: new Date(),\r\n      from: task.statusHistory[task.statusHistory.length - 1].to,\r\n      to: 'assigned',\r\n      reason: `Assigned to agent ${agent.name}`,\r\n      triggeredBy: 'system',\r\n    });\r\n\r\n    this.logger.info('Assigned task', {\r\n      taskId,\r\n      agentId,\r\n      agentName: agent.name,\r\n    });\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'task.assigned',\r\n      source: agentId,\r\n      data: { task, agent },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n\r\n    // Start task execution\r\n    await this.startTaskExecution(task);\r\n  }\r\n\r\n  async startTaskExecution(task: TaskDefinition): Promise<void> {\r\n    if (!task.assignedTo) {\r\n      throw new Error('Task not assigned to any agent');\r\n    }\r\n\r\n    const agent = this.agents.get(task.assignedTo.id);\r\n    if (!agent) {\r\n      throw new Error(`Agent not found: ${task.assignedTo.id}`);\r\n    }\r\n\r\n    this.logger.info('Starting task execution', {\r\n      taskId: task.id.id,\r\n      agentId: agent.id.id,\r\n    });\r\n\r\n    task.status = 'running';\r\n    task.startedAt = new Date();\r\n\r\n    // Create attempt record\r\n    const attempt = {\r\n      attemptNumber: task.attempts.length + 1,\r\n      agent: agent.id,\r\n      startedAt: new Date(),\r\n      status: 'running' as TaskStatus,\r\n      resourcesUsed: {},\r\n    };\r\n    task.attempts.push(attempt);\r\n\r\n    // Update status history\r\n    task.statusHistory.push({\r\n      timestamp: new Date(),\r\n      from: 'assigned',\r\n      to: 'running',\r\n      reason: 'Task execution started',\r\n      triggeredBy: agent.id,\r\n    });\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'task.started',\r\n      source: agent.id.id,\r\n      data: { task, agent, attempt },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n\r\n    try {\r\n      // Execute task (this would spawn actual Claude process)\r\n      const result = await this.executeTaskWithAgent(task, agent);\r\n      await this.completeTask(task.id.id, result);\r\n    } catch (error) {\r\n      await this.failTask(task.id.id, error);\r\n    }\r\n  }\r\n\r\n  async completeTask(taskId: string, result: any): Promise<void> {\r\n    const task = this.tasks.get(taskId);\r\n    if (!task) {\r\n      throw new Error(`Task not found: ${taskId}`);\r\n    }\r\n\r\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo.id) : null;\r\n    if (!agent) {\r\n      throw new Error('Task not assigned to any agent');\r\n    }\r\n\r\n    this.logger.info('Completing task', { taskId, agentId: agent.id.id });\r\n\r\n    task.status = 'completed';\r\n    task.completedAt = new Date();\r\n    task.result = {\r\n      output: result,\r\n      artifacts: {},\r\n      metadata: {},\r\n      quality: this.assessTaskQuality(task, result),\r\n      completeness: 1.0,\r\n      accuracy: 1.0,\r\n      executionTime: task.completedAt.getTime() - (task.startedAt?.getTime() || 0),\r\n      resourcesUsed: {},\r\n      validated: false,\r\n    };\r\n\r\n    // Update attempt\r\n    const currentAttempt = task.attempts[task.attempts.length - 1];\r\n    if (currentAttempt) {\r\n      currentAttempt.completedAt = new Date();\r\n      currentAttempt.status = 'completed';\r\n      currentAttempt.result = task.result;\r\n    }\r\n\r\n    // Update agent state\r\n    agent.status = 'idle';\r\n    agent.currentTask = undefined;\r\n    agent.metrics.tasksCompleted++;\r\n    agent.metrics.lastActivity = new Date();\r\n    agent.taskHistory.push(task.id);\r\n\r\n    // Update agent metrics\r\n    this.updateAgentMetrics(agent, task);\r\n\r\n    // Update status history\r\n    task.statusHistory.push({\r\n      timestamp: new Date(),\r\n      from: 'running',\r\n      to: 'completed',\r\n      reason: 'Task completed successfully',\r\n      triggeredBy: agent.id,\r\n    });\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'task.completed',\r\n      source: agent.id.id,\r\n      data: { task, agent, result: task.result },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n\r\n    // Check for dependent tasks\r\n    await this.processDependentTasks(task);\r\n  }\r\n\r\n  async failTask(taskId: string, error: any): Promise<void> {\r\n    const task = this.tasks.get(taskId);\r\n    if (!task) {\r\n      throw new Error(`Task not found: ${taskId}`);\r\n    }\r\n\r\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo.id) : null;\r\n    if (!agent) {\r\n      throw new Error('Task not assigned to any agent');\r\n    }\r\n\r\n    this.logger.warn('Task failed', {\r\n      taskId,\r\n      agentId: agent.id.id,\r\n      error: error instanceof Error ? error.message : String(error),\r\n    });\r\n\r\n    task.error = {\r\n      type: error.constructor.name,\r\n      message: error instanceof Error ? error.message : String(error),\r\n      code: error.code,\r\n      stack: error.stack,\r\n      context: { taskId, agentId: agent.id.id },\r\n      recoverable: this.isRecoverableError(error),\r\n      retryable: this.isRetryableError(error),\r\n    };\r\n\r\n    // Update attempt\r\n    const currentAttempt = task.attempts[task.attempts.length - 1];\r\n    if (currentAttempt) {\r\n      currentAttempt.completedAt = new Date();\r\n      currentAttempt.status = 'failed';\r\n      currentAttempt.error = task.error;\r\n    }\r\n\r\n    // Update agent state\r\n    agent.status = 'idle';\r\n    agent.currentTask = undefined;\r\n    agent.metrics.tasksFailed++;\r\n    agent.metrics.lastActivity = new Date();\r\n\r\n    // Add to error history\r\n    agent.errorHistory.push({\r\n      timestamp: new Date(),\r\n      type: 'task_failure',\r\n      message: error instanceof Error ? error.message : String(error),\r\n      stack: error.stack,\r\n      context: { taskId },\r\n      severity: 'medium',\r\n      resolved: false,\r\n    });\r\n\r\n    // Determine if we should retry\r\n    const shouldRetry =\r\n      task.error.retryable &&\r\n      task.attempts.length < (task.constraints.maxRetries || SWARM_CONSTANTS.MAX_RETRIES);\r\n\r\n    if (shouldRetry) {\r\n      task.status = 'retrying';\r\n      task.assignedTo = undefined;\r\n\r\n      // Update status history\r\n      task.statusHistory.push({\r\n        timestamp: new Date(),\r\n        from: 'running',\r\n        to: 'retrying',\r\n        reason: `Task failed, will retry: ${error instanceof Error ? error.message : String(error)}`,\r\n        triggeredBy: agent.id,\r\n      });\r\n\r\n      this.emitSwarmEvent({\r\n        id: generateId('event'),\r\n        timestamp: new Date(),\r\n        type: 'task.retried',\r\n        source: agent.id.id,\r\n        data: { task, error: task.error, attempt: task.attempts.length },\r\n        broadcast: false,\r\n        processed: false,\r\n      });\r\n\r\n      // Schedule retry with exponential backoff\r\n      const retryDelay = Math.pow(2, task.attempts.length) * 1000;\r\n      setTimeout(() => {\r\n        this.assignTask(taskId).catch((retryError) => {\r\n          this.logger.error('Failed to retry task', { taskId, retryError });\r\n        });\r\n      }, retryDelay);\r\n    } else {\r\n      task.status = 'failed';\r\n      task.completedAt = new Date();\r\n\r\n      // Update status history\r\n      task.statusHistory.push({\r\n        timestamp: new Date(),\r\n        from: 'running',\r\n        to: 'failed',\r\n        reason: `Task failed permanently: ${error instanceof Error ? error.message : String(error)}`,\r\n        triggeredBy: agent.id,\r\n      });\r\n\r\n      this.emitSwarmEvent({\r\n        id: generateId('event'),\r\n        timestamp: new Date(),\r\n        type: 'task.failed',\r\n        source: agent.id.id,\r\n        data: { task, error: task.error },\r\n        broadcast: false,\r\n        processed: false,\r\n      });\r\n\r\n      // Handle failure cascade\r\n      await this.handleTaskFailureCascade(task);\r\n    }\r\n  }\r\n\r\n  async cancelTask(taskId: string, reason: string): Promise<void> {\r\n    const task = this.tasks.get(taskId);\r\n    if (!task) {\r\n      throw new Error(`Task not found: ${taskId}`);\r\n    }\r\n\r\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo.id) : null;\r\n\r\n    this.logger.info('Cancelling task', { taskId, reason });\r\n\r\n    task.status = 'cancelled';\r\n    task.completedAt = new Date();\r\n\r\n    if (agent) {\r\n      agent.status = 'idle';\r\n      agent.currentTask = undefined;\r\n    }\r\n\r\n    // Update status history\r\n    task.statusHistory.push({\r\n      timestamp: new Date(),\r\n      from: task.statusHistory[task.statusHistory.length - 1].to,\r\n      to: 'cancelled',\r\n      reason: `Task cancelled: ${reason}`,\r\n      triggeredBy: 'system',\r\n    });\r\n\r\n    this.emitSwarmEvent({\r\n      id: generateId('event'),\r\n      timestamp: new Date(),\r\n      type: 'task.cancelled',\r\n      source: this.swarmId.id,\r\n      data: { task, reason },\r\n      broadcast: false,\r\n      processed: false,\r\n    });\r\n  }\r\n\r\n  // ===== ADVANCED FEATURES =====\r\n\r\n  async selectAgentForTask(task: TaskDefinition): Promise<string | null> {\r\n    const availableAgents = Array.from(this.agents.values()).filter(\r\n      (agent) => agent.status === 'idle' && this.agentCanHandleTask(agent, task),\r\n    );\r\n\r\n    if (availableAgents.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Score agents based on multiple criteria\r\n    const scoredAgents = availableAgents.map((agent) => ({\r\n      agent,\r\n      score: this.calculateAgentScore(agent, task),\r\n    }));\r\n\r\n    // Sort by score (highest first)\r\n    scoredAgents.sort((a, b) => b.score - a.score);\r\n\r\n    return scoredAgents[0].agent.id.id;\r\n  }\r\n\r\n  private calculateAgentScore(agent: AgentState, task: TaskDefinition): number {\r\n    let score = 0;\r\n\r\n    // Capability match (40% weight)\r\n    const capabilityMatch = this.calculateCapabilityMatch(agent, task);\r\n    score += capabilityMatch * 0.4;\r\n\r\n    // Performance history (30% weight)\r\n    const performanceScore = agent.metrics.successRate * agent.capabilities.reliability;\r\n    score += performanceScore * 0.3;\r\n\r\n    // Current workload (20% weight)\r\n    const workloadScore = 1 - agent.workload;\r\n    score += workloadScore * 0.2;\r\n\r\n    // Quality rating (10% weight)\r\n    score += agent.capabilities.quality * 0.1;\r\n\r\n    return score;\r\n  }\r\n\r\n  private calculateCapabilityMatch(agent: AgentState, task: TaskDefinition): number {\r\n    const requiredCapabilities = task.requirements.capabilities;\r\n    let matches = 0;\r\n    const total = requiredCapabilities.length;\r\n\r\n    for (const capability of requiredCapabilities) {\r\n      if (this.agentHasCapability(agent, capability)) {\r\n        matches++;\r\n      }\r\n    }\r\n\r\n    return total > 0 ? matches / total : 1.0;\r\n  }\r\n\r\n  private agentHasCapability(agent: AgentState, capability: string): boolean {\r\n    const caps = agent.capabilities;\r\n\r\n    switch (capability) {\r\n      case 'code-generation':\r\n        return caps.codeGeneration;\r\n      case 'code-review':\r\n        return caps.codeReview;\r\n      case 'testing':\r\n        return caps.testing;\r\n      case 'documentation':\r\n        return caps.documentation;\r\n      case 'research':\r\n        return caps.research;\r\n      case 'analysis':\r\n        return caps.analysis;\r\n      case 'web-search':\r\n        return caps.webSearch;\r\n      case 'api-integration':\r\n        return caps.apiIntegration;\r\n      case 'file-system':\r\n        return caps.fileSystem;\r\n      case 'terminal-access':\r\n        return caps.terminalAccess;\r\n      case 'validation':\r\n        return caps.testing; // Validation is part of testing capability\r\n      default:\r\n        return (\r\n          caps.domains.includes(capability) ||\r\n          caps.languages.includes(capability) ||\r\n          caps.frameworks.includes(capability) ||\r\n          caps.tools.includes(capability)\r\n        );\r\n    }\r\n  }\r\n\r\n  private agentCanHandleTask(agent: AgentState, task: TaskDefinition): boolean {\r\n    // Check if agent type is suitable\r\n    if (task.requirements.agentType && agent.type !== task.requirements.agentType) {\r\n      return false;\r\n    }\r\n\r\n    // Check if agent has required capabilities\r\n    for (const capability of task.requirements.capabilities) {\r\n      if (!this.agentHasCapability(agent, capability)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Check reliability requirement\r\n    if (\r\n      task.requirements.minReliability &&\r\n      agent.capabilities.reliability < task.requirements.minReliability\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    // Check if agent has capacity\r\n    if (agent.workload >= 1.0) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // ===== HELPER METHODS =====\r\n\r\n  private generateSwarmId(): SwarmId {\r\n    return {\r\n      id: generateId('swarm'),\r\n      timestamp: Date.now(),\r\n      namespace: 'default',\r\n    };\r\n  }\r\n\r\n  private mergeWithDefaults(config: Partial<SwarmConfig>): SwarmConfig {\r\n    return {\r\n      name: 'Unnamed Swarm',\r\n      description: 'Auto-generated swarm',\r\n      version: '1.0.0',\r\n      mode: 'centralized',\r\n      strategy: 'auto',\r\n      coordinationStrategy: {\r\n        name: 'default',\r\n        description: 'Default coordination strategy',\r\n        agentSelection: 'capability-based',\r\n        taskScheduling: 'priority',\r\n        loadBalancing: 'work-stealing',\r\n        faultTolerance: 'retry',\r\n        communication: 'event-driven',\r\n      },\r\n      maxAgents: 10,\r\n      maxTasks: 100,\r\n      maxDuration: 4 * 60 * 60 * 1000, // 4 hours\r\n      resourceLimits: {\r\n        memory: SWARM_CONSTANTS.DEFAULT_MEMORY_LIMIT,\r\n        cpu: SWARM_CONSTANTS.DEFAULT_CPU_LIMIT,\r\n        disk: SWARM_CONSTANTS.DEFAULT_DISK_LIMIT,\r\n      },\r\n      qualityThreshold: SWARM_CONSTANTS.DEFAULT_QUALITY_THRESHOLD,\r\n      reviewRequired: true,\r\n      testingRequired: true,\r\n      monitoring: {\r\n        metricsEnabled: true,\r\n        loggingEnabled: true,\r\n        tracingEnabled: false,\r\n        metricsInterval: 10000,\r\n        heartbeatInterval: SWARM_CONSTANTS.DEFAULT_HEARTBEAT_INTERVAL,\r\n        healthCheckInterval: 30000,\r\n        retentionPeriod: 24 * 60 * 60 * 1000, // 24 hours\r\n        maxLogSize: 100 * 1024 * 1024, // 100MB\r\n        maxMetricPoints: 10000,\r\n        alertingEnabled: true,\r\n        alertThresholds: {\r\n          errorRate: 0.1,\r\n          responseTime: 5000,\r\n          memoryUsage: 0.8,\r\n          cpuUsage: 0.8,\r\n        },\r\n        exportEnabled: false,\r\n        exportFormat: 'json',\r\n        exportDestination: '/tmp/swarm-metrics',\r\n      },\r\n      memory: {\r\n        namespace: 'default',\r\n        partitions: [],\r\n        permissions: {\r\n          read: 'swarm',\r\n          write: 'team',\r\n          delete: 'private',\r\n          share: 'team',\r\n        },\r\n        persistent: true,\r\n        backupEnabled: true,\r\n        distributed: false,\r\n        consistency: 'eventual',\r\n        cacheEnabled: true,\r\n        compressionEnabled: false,\r\n      },\r\n      security: {\r\n        authenticationRequired: false,\r\n        authorizationRequired: false,\r\n        encryptionEnabled: false,\r\n        defaultPermissions: ['read', 'write'],\r\n        adminRoles: ['admin', 'coordinator'],\r\n        auditEnabled: true,\r\n        auditLevel: 'info',\r\n        inputValidation: true,\r\n        outputSanitization: true,\r\n      },\r\n      performance: {\r\n        maxConcurrency: 10,\r\n        defaultTimeout: SWARM_CONSTANTS.DEFAULT_TASK_TIMEOUT,\r\n        cacheEnabled: true,\r\n        cacheSize: 100,\r\n        cacheTtl: 3600000, // 1 hour\r\n        optimizationEnabled: true,\r\n        adaptiveScheduling: true,\r\n        predictiveLoading: false,\r\n        resourcePooling: true,\r\n        connectionPooling: true,\r\n        memoryPooling: false,\r\n      },\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  private initializeMetrics(): SwarmMetrics {\r\n    return {\r\n      throughput: 0,\r\n      latency: 0,\r\n      efficiency: 0,\r\n      reliability: 0,\r\n      averageQuality: 0,\r\n      defectRate: 0,\r\n      reworkRate: 0,\r\n      resourceUtilization: {},\r\n      costEfficiency: 0,\r\n      agentUtilization: 0,\r\n      agentSatisfaction: 0,\r\n      collaborationEffectiveness: 0,\r\n      scheduleVariance: 0,\r\n      deadlineAdherence: 0,\r\n    };\r\n  }\r\n\r\n  private initializeProgress(): SwarmProgress {\r\n    return {\r\n      totalTasks: 0,\r\n      completedTasks: 0,\r\n      failedTasks: 0,\r\n      runningTasks: 0,\r\n      estimatedCompletion: new Date(),\r\n      timeRemaining: 0,\r\n      percentComplete: 0,\r\n      averageQuality: 0,\r\n      passedReviews: 0,\r\n      passedTests: 0,\r\n      resourceUtilization: {},\r\n      costSpent: 0,\r\n      activeAgents: 0,\r\n      idleAgents: 0,\r\n      busyAgents: 0,\r\n    };\r\n  }\r\n\r\n  // ===== EVENT HANDLING =====\r\n\r\n  private setupEventHandlers(): void {\r\n    // Handle agent heartbeats\r\n    this.on('agent.heartbeat', (data: any) => {\r\n      const agent = this.agents.get(data.agentId);\r\n      if (agent) {\r\n        agent.lastHeartbeat = new Date();\r\n        agent.health = data.health || 1.0;\r\n        agent.metrics = { ...agent.metrics, ...data.metrics };\r\n      }\r\n    });\r\n\r\n    // Handle task completion events\r\n    this.on('task.completed', (data: any) => {\r\n      this.updateSwarmMetrics();\r\n      this.checkObjectiveCompletion();\r\n    });\r\n\r\n    // Handle task failure events\r\n    this.on('task.failed', (data: any) => {\r\n      this.updateSwarmMetrics();\r\n      this.checkObjectiveFailure(data.task);\r\n    });\r\n\r\n    // Handle agent errors\r\n    this.on('agent.error', (data: any) => {\r\n      this.handleAgentError(data.agentId, data.error);\r\n    });\r\n  }\r\n\r\n  // ===== SWARM EVENT EMITTER IMPLEMENTATION =====\r\n\r\n  emitSwarmEvent(event: SwarmEvent): boolean {\r\n    this.events.push(event);\r\n\r\n    // Limit event history\r\n    if (this.events.length > 1000) {\r\n      this.events = this.events.slice(-500);\r\n    }\r\n\r\n    return this.emit(event.type, event);\r\n  }\r\n\r\n  emitSwarmEvents(events: SwarmEvent[]): boolean {\r\n    let success = true;\r\n    for (const event of events) {\r\n      if (!this.emitSwarmEvent(event)) {\r\n        success = false;\r\n      }\r\n    }\r\n    return success;\r\n  }\r\n\r\n  onSwarmEvent(type: EventType, handler: (event: SwarmEvent) => void): this {\r\n    return this.on(type, handler);\r\n  }\r\n\r\n  offSwarmEvent(type: EventType, handler: (event: SwarmEvent) => void): this {\r\n    return this.off(type, handler);\r\n  }\r\n\r\n  filterEvents(predicate: (event: SwarmEvent) => boolean): SwarmEvent[] {\r\n    return this.events.filter(predicate);\r\n  }\r\n\r\n  correlateEvents(correlationId: string): SwarmEvent[] {\r\n    return this.events.filter((event) => event.correlationId === correlationId);\r\n  }\r\n\r\n  // ===== PUBLIC API METHODS =====\r\n\r\n  getSwarmId(): SwarmId {\r\n    return this.swarmId;\r\n  }\r\n\r\n  getStatus(): SwarmStatus {\r\n    return this.status;\r\n  }\r\n\r\n  getAgents(): AgentState[] {\r\n    return Array.from(this.agents.values());\r\n  }\r\n\r\n  getAgent(agentId: string): AgentState | undefined {\r\n    return this.agents.get(agentId);\r\n  }\r\n\r\n  getTasks(): TaskDefinition[] {\r\n    return Array.from(this.tasks.values());\r\n  }\r\n\r\n  getTask(taskId: string): TaskDefinition | undefined {\r\n    return this.tasks.get(taskId);\r\n  }\r\n\r\n  getObjectives(): SwarmObjective[] {\r\n    return Array.from(this.objectives.values());\r\n  }\r\n\r\n  getObjective(objectiveId: string): SwarmObjective | undefined {\r\n    return this.objectives.get(objectiveId);\r\n  }\r\n\r\n  getMetrics(): SwarmMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  getEvents(): SwarmEvent[] {\r\n    return [...this.events];\r\n  }\r\n\r\n  isRunning(): boolean {\r\n    return this._isRunning;\r\n  }\r\n\r\n  getUptime(): number {\r\n    if (!this.startTime) return 0;\r\n    const endTime = this.endTime || new Date();\r\n    return endTime.getTime() - this.startTime.getTime();\r\n  }\r\n\r\n  getSwarmStatus(): {\r\n    status: SwarmStatus;\r\n    objectives: number;\r\n    tasks: { completed: number; failed: number; total: number };\r\n    agents: { total: number };\r\n  } {\r\n    const tasks = Array.from(this.tasks.values());\r\n    const completedTasks = tasks.filter((t) => t.status === 'completed').length;\r\n    const failedTasks = tasks.filter((t) => t.status === 'failed').length;\r\n\r\n    return {\r\n      status: this.status,\r\n      objectives: this.objectives.size,\r\n      tasks: {\r\n        completed: completedTasks,\r\n        failed: failedTasks,\r\n        total: tasks.length,\r\n      },\r\n      agents: {\r\n        total: this.agents.size,\r\n      },\r\n    };\r\n  }\r\n\r\n  // ===== STUB METHODS (TO BE IMPLEMENTED) =====\r\n\r\n  private async validateConfiguration(): Promise<ValidationResult> {\r\n    // Implementation needed\r\n    return {\r\n      valid: true,\r\n      errors: [],\r\n      warnings: [],\r\n      validatedAt: new Date(),\r\n      validator: 'SwarmCoordinator',\r\n      context: {},\r\n    };\r\n  }\r\n\r\n  private async initializeSubsystems(): Promise<void> {\r\n    // Implementation needed\r\n  }\r\n\r\n  private startBackgroundProcesses(): void {\r\n    // Start heartbeat monitoring\r\n    this.heartbeatTimer = setInterval(() => {\r\n      this.processHeartbeats();\r\n    }, this.config.monitoring.heartbeatInterval);\r\n\r\n    // Start performance monitoring\r\n    this.monitoringTimer = setInterval(() => {\r\n      this.updateSwarmMetrics();\r\n    }, this.config.monitoring.metricsInterval);\r\n\r\n    // Start cleanup process\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.performCleanup();\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  private stopBackgroundProcesses(): void {\r\n    if (this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer);\r\n      this.heartbeatTimer = undefined;\r\n    }\r\n    if (this.monitoringTimer) {\r\n      clearInterval(this.monitoringTimer);\r\n      this.monitoringTimer = undefined;\r\n    }\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = undefined;\r\n    }\r\n    // Stop all execution intervals\r\n    if (this.executionIntervals) {\r\n      for (const [objectiveId, interval] of this.executionIntervals) {\r\n        clearInterval(interval);\r\n      }\r\n      this.executionIntervals.clear();\r\n    }\r\n  }\r\n\r\n  private async stopAllAgents(): Promise<void> {\r\n    const stopPromises = Array.from(this.agents.keys()).map((agentId) => this.stopAgent(agentId));\r\n    await Promise.allSettled(stopPromises);\r\n  }\r\n\r\n  private async completeRunningTasks(): Promise<void> {\r\n    const runningTasks = Array.from(this.tasks.values()).filter(\r\n      (task) => task.status === 'running',\r\n    );\r\n\r\n    // Wait for tasks to complete or timeout\r\n    const timeout = 30000; // 30 seconds\r\n    const deadline = Date.now() + timeout;\r\n\r\n    while (runningTasks.some((task) => task.status === 'running') && Date.now() < deadline) {\r\n      await new Promise((resolve) => setTimeout(resolve, 1000));\r\n    }\r\n\r\n    // Cancel any remaining running tasks\r\n    for (const task of runningTasks) {\r\n      if (task.status === 'running') {\r\n        await this.cancelTask(task.id.id, 'Swarm shutdown');\r\n      }\r\n    }\r\n  }\r\n\r\n  private async saveState(): Promise<void> {\r\n    // Implementation needed - save swarm state to persistence layer\r\n  }\r\n\r\n  private determineRequiredAgentTypes(strategy: SwarmStrategy): AgentType[] {\r\n    switch (strategy) {\r\n      case 'research':\r\n        return ['researcher', 'analyst'];\r\n      case 'development':\r\n        return ['coder', 'tester', 'reviewer'];\r\n      case 'analysis':\r\n        return ['analyst', 'researcher'];\r\n      case 'testing':\r\n        return ['tester', 'coder'];\r\n      case 'optimization':\r\n        return ['analyst', 'coder'];\r\n      case 'maintenance':\r\n        return ['coder', 'monitor'];\r\n      default:\r\n        return ['coordinator', 'coder', 'analyst'];\r\n    }\r\n  }\r\n\r\n  private getAgentTypeInstructions(agentType: string): string {\r\n    switch (agentType) {\r\n      case 'coder':\r\n        return '- Focus on implementation, code quality, and best practices\\n- Create clean, maintainable code\\n- Consider architecture and design patterns';\r\n      case 'tester':\r\n        return '- Focus on testing, edge cases, and quality assurance\\n- Create comprehensive test suites\\n- Identify potential bugs and issues';\r\n      case 'analyst':\r\n        return '- Focus on analysis, research, and understanding\\n- Break down complex problems\\n- Provide insights and recommendations';\r\n      case 'researcher':\r\n        return '- Focus on gathering information and best practices\\n- Research existing solutions and patterns\\n- Document findings and recommendations';\r\n      case 'reviewer':\r\n        return '- Focus on code review and quality checks\\n- Identify improvements and optimizations\\n- Ensure standards compliance';\r\n      case 'coordinator':\r\n        return '- Focus on coordination and integration\\n- Ensure all parts work together\\n- Manage dependencies and interfaces';\r\n      case 'monitor':\r\n        return '- Focus on monitoring and observability\\n- Set up logging and metrics\\n- Ensure system health tracking';\r\n      default:\r\n        return '- Execute the task to the best of your ability\\n- Follow best practices for your domain';\r\n    }\r\n  }\r\n\r\n  private getAgentCapabilities(agentType: string): string[] {\r\n    switch (agentType) {\r\n      case 'coder':\r\n        return ['code-generation', 'file-system', 'debugging'];\r\n      case 'tester':\r\n        return ['testing', 'code-generation', 'analysis'];\r\n      case 'analyst':\r\n        return ['analysis', 'documentation', 'research'];\r\n      case 'researcher':\r\n        return ['research', 'documentation', 'analysis'];\r\n      case 'reviewer':\r\n        return ['code-review', 'analysis', 'documentation'];\r\n      case 'coordinator':\r\n        return ['coordination', 'analysis', 'documentation'];\r\n      case 'monitor':\r\n        return ['monitoring', 'analysis', 'documentation'];\r\n      default:\r\n        return ['analysis', 'documentation'];\r\n    }\r\n  }\r\n\r\n  private async decomposeObjective(objective: SwarmObjective): Promise<TaskDefinition[]> {\r\n    // Decompose objective into tasks with clear instructions for Claude\r\n    this.logger.info('Decomposing objective', {\r\n      objectiveId: objective.id,\r\n      description: objective.description,\r\n    });\r\n\r\n    const tasks: TaskDefinition[] = [];\r\n\r\n    // Extract target directory from objective\r\n    const targetDirMatch = objective.description.match(\r\n      /(?:in|to|at)\\s+([^\\s]+\\/[^\\s]+)|([^\\s]+\\/[^\\s]+)$/,\r\n    );\r\n    const targetDir = targetDirMatch ? targetDirMatch[1] || targetDirMatch[2] : null;\r\n    const targetPath = targetDir\r\n      ? targetDir.startsWith('/')\r\n        ? targetDir\r\n        : `${getClaudeFlowRoot()}/${targetDir}`\r\n      : null;\r\n\r\n    // Check if objective requests \"each agent\" or \"each agent type\" for parallel execution\r\n    const eachAgentPattern = /\\beach\\s+agent(?:\\s+type)?\\b/i;\r\n    const requestsParallelAgents = eachAgentPattern.test(objective.description);\r\n\r\n    // Create tasks with specific prompts for Claude\r\n    if (requestsParallelAgents && this.config.mode === 'parallel') {\r\n      // Create parallel tasks for each agent type\r\n      const agentTypes = this.determineRequiredAgentTypes(objective.strategy);\r\n      this.logger.info('Creating parallel tasks for each agent type', {\r\n        agentTypes,\r\n        mode: this.config.mode,\r\n      });\r\n\r\n      for (const agentType of agentTypes) {\r\n        const taskId = this.createTaskForObjective(`${agentType}-task`, agentType as TaskType, {\r\n          title: `${agentType.charAt(0).toUpperCase() + agentType.slice(1)} Agent Task`,\r\n          description: `${agentType} agent executing: ${objective.description}`,\r\n          instructions: `You are a ${agentType} agent. Please execute the following task from your perspective:\r\n\r\n${objective.description}\r\n\r\n${targetPath ? `Target Directory: ${targetPath}` : ''}\r\n\r\nAs a ${agentType} agent, focus on aspects relevant to your role:\r\n${this.getAgentTypeInstructions(agentType)}\r\n\r\nWork independently but be aware that other agents are working on this same objective from their perspectives.`,\r\n          priority: 'high' as TaskPriority,\r\n          estimatedDuration: 10 * 60 * 1000,\r\n          requiredCapabilities: this.getAgentCapabilities(agentType),\r\n        });\r\n        tasks.push(taskId);\r\n      }\r\n    } else if (objective.strategy === 'development') {\r\n      // Task 1: Analyze and Plan\r\n      const task1 = this.createTaskForObjective('analyze-requirements', 'analysis', {\r\n        title: 'Analyze Requirements and Plan Implementation',\r\n        description: `Analyze the requirements and create a plan for: ${objective.description}`,\r\n        instructions: `Please analyze the following request and create a detailed implementation plan:\r\n\r\nRequest: ${objective.description}\r\n\r\nTarget Directory: ${targetPath || 'Not specified - determine appropriate location'}\r\n\r\nYour analysis should include:\r\n1. Understanding of what needs to be built\r\n2. Technology choices and rationale\r\n3. Project structure and file organization\r\n4. Key components and their responsibilities\r\n5. Any external dependencies needed\r\n\r\nPlease provide a clear, structured plan that the next tasks can follow.`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: 5 * 60 * 1000,\r\n        requiredCapabilities: ['analysis', 'documentation'],\r\n      });\r\n      tasks.push(task1);\r\n\r\n      // Task 2: Implementation\r\n      const task2 = this.createTaskForObjective('create-implementation', 'coding', {\r\n        title: 'Implement the Solution',\r\n        description: `Create the implementation for: ${objective.description}`,\r\n        instructions: `Please implement the following request:\r\n\r\nRequest: ${objective.description}\r\n\r\nTarget Directory: ${targetPath || 'Create in an appropriate location'}\r\n\r\nBased on the analysis from the previous task, please:\r\n1. Create all necessary files and directories\r\n2. Implement the core functionality as requested\r\n3. Ensure the code is well-structured and follows best practices\r\n4. Include appropriate error handling\r\n5. Add any necessary configuration files (package.json, requirements.txt, etc.)\r\n\r\nFocus on creating a working implementation that matches the user's request exactly.`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: 10 * 60 * 1000,\r\n        requiredCapabilities: ['code-generation', 'file-system'],\r\n        dependencies: [task1.id.id],\r\n      });\r\n      tasks.push(task2);\r\n\r\n      // Task 3: Testing\r\n      const task3 = this.createTaskForObjective('write-tests', 'testing', {\r\n        title: 'Create Tests',\r\n        description: `Write tests for the implementation`,\r\n        instructions: `Please create comprehensive tests for the implementation created in the previous task.\r\n\r\nTarget Directory: ${targetPath || 'Use the same directory as the implementation'}\r\n\r\nCreate appropriate test files that:\r\n1. Test the main functionality\r\n2. Cover edge cases\r\n3. Ensure the implementation works as expected\r\n4. Use appropriate testing frameworks for the technology stack\r\n5. Include both unit tests and integration tests where applicable`,\r\n        priority: 'medium' as TaskPriority,\r\n        estimatedDuration: 5 * 60 * 1000,\r\n        requiredCapabilities: ['testing', 'code-generation'],\r\n        dependencies: [task2.id.id],\r\n      });\r\n      tasks.push(task3);\r\n\r\n      // Task 4: Documentation\r\n      const task4 = this.createTaskForObjective('create-documentation', 'documentation', {\r\n        title: 'Create Documentation',\r\n        description: `Document the implementation`,\r\n        instructions: `Please create comprehensive documentation for the implemented solution.\r\n\r\nTarget Directory: ${targetPath || 'Use the same directory as the implementation'}\r\n\r\nCreate documentation that includes:\r\n1. README.md with project overview, setup instructions, and usage examples\r\n2. API documentation (if applicable)\r\n3. Configuration options\r\n4. Architecture overview\r\n5. Deployment instructions (if applicable)\r\n6. Any other relevant documentation\r\n\r\nMake sure the documentation is clear, complete, and helps users understand and use the implementation.`,\r\n        priority: 'medium' as TaskPriority,\r\n        estimatedDuration: 5 * 60 * 1000,\r\n        requiredCapabilities: ['documentation'],\r\n        dependencies: [task2.id.id],\r\n      });\r\n      tasks.push(task4);\r\n    } else {\r\n      // For other strategies, create a comprehensive single task\r\n      tasks.push(\r\n        this.createTaskForObjective('execute-objective', 'generic', {\r\n          title: 'Execute Objective',\r\n          description: objective.description,\r\n          instructions: `Please complete the following request:\r\n\r\n${objective.description}\r\n\r\n${targetPath ? `Target Directory: ${targetPath}` : ''}\r\n\r\nPlease analyze what is being requested and implement it appropriately. This may involve:\r\n- Creating files and directories\r\n- Writing code\r\n- Setting up configurations\r\n- Creating documentation\r\n- Any other tasks necessary to fulfill the request\r\n\r\nEnsure your implementation is complete, well-structured, and follows best practices.`,\r\n          priority: 'high' as TaskPriority,\r\n          estimatedDuration: 15 * 60 * 1000,\r\n          requiredCapabilities: ['code-generation', 'file-system', 'documentation'],\r\n        }),\r\n      );\r\n    }\r\n\r\n    this.logger.info('Objective decomposed', {\r\n      objectiveId: objective.id,\r\n      taskCount: tasks.length,\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createTaskForObjective(id: string, type: TaskType, params: any): TaskDefinition {\r\n    const taskId: TaskId = {\r\n      id: generateId('task'),\r\n      swarmId: this.swarmId.id,\r\n      sequence: this.tasks.size + 1,\r\n      priority: 1,\r\n    };\r\n\r\n    return {\r\n      id: taskId,\r\n      type,\r\n      name: params.title,\r\n      description: params.description,\r\n      instructions: params.description,\r\n      requirements: {\r\n        capabilities: params.requiredCapabilities || [],\r\n        tools: this.getRequiredTools(type),\r\n        permissions: this.getRequiredPermissions(type),\r\n      },\r\n      constraints: {\r\n        dependencies: params.dependencies || [],\r\n        dependents: [],\r\n        conflicts: [],\r\n        maxRetries: SWARM_CONSTANTS.MAX_RETRIES,\r\n        timeoutAfter: params.estimatedDuration || SWARM_CONSTANTS.DEFAULT_TASK_TIMEOUT,\r\n      },\r\n      priority: params.priority || 'medium',\r\n      input: {\r\n        description: params.description,\r\n        objective: params.description,\r\n      },\r\n      context: {\r\n        objectiveId: id,\r\n        targetDir: params.targetDir,\r\n      },\r\n      examples: [],\r\n      status: 'created',\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      attempts: [],\r\n      statusHistory: [\r\n        {\r\n          timestamp: new Date(),\r\n          from: 'created' as TaskStatus,\r\n          to: 'created' as TaskStatus,\r\n          reason: 'Task created',\r\n          triggeredBy: 'system',\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  private analyzeDependencies(tasks: TaskDefinition[]): any[] {\r\n    // Implementation needed - analyze task dependencies\r\n    return [];\r\n  }\r\n\r\n  private convertDependenciesToTaskDependencies(dependencies: Map<string, string[]>): any[] {\r\n    // Convert decomposition dependencies to task dependencies format\r\n    const result: any[] = [];\r\n    dependencies.forEach((deps, taskId) => {\r\n      deps.forEach((dependsOn) => {\r\n        result.push({\r\n          taskId,\r\n          dependsOn,\r\n          type: 'sequential',\r\n        });\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private async ensureRequiredAgents(objective: SwarmObjective): Promise<void> {\r\n    // Implementation needed - ensure required agents are available\r\n  }\r\n\r\n  private async scheduleInitialTasks(objective: SwarmObjective): Promise<void> {\r\n    this.logger.info('Scheduling initial tasks for objective', {\r\n      objectiveId: objective.id,\r\n      taskCount: objective.tasks.length,\r\n    });\r\n\r\n    // Extract target directory from objective description\r\n    const targetDirPatterns = [\r\n      /in\\s+([^\\s]+\\/?)$/i,\r\n      /(?:in|to|at)\\s+([^\\s]+\\/[^\\s]+)/i,\r\n      /([^\\s]+\\/[^\\s]+)$/,\r\n      /examples\\/[^\\s]+/i,\r\n    ];\r\n\r\n    let objectiveTargetDir = null;\r\n    for (const pattern of targetDirPatterns) {\r\n      const match = objective.description.match(pattern);\r\n      if (match) {\r\n        objectiveTargetDir = match[1] || match[0];\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Add all tasks to the tasks map\r\n    for (const task of objective.tasks) {\r\n      task.context.objectiveId = objective.id;\r\n      // Propagate target directory to all tasks\r\n      if (objectiveTargetDir && !task.context.targetDir) {\r\n        task.context.targetDir = objectiveTargetDir;\r\n      }\r\n      this.tasks.set(task.id.id, task);\r\n\r\n      // Track task in JSON output if enabled\r\n      this.trackTaskInJsonOutput(task);\r\n    }\r\n\r\n    // Find tasks with no dependencies and queue them\r\n    const initialTasks = objective.tasks.filter(\r\n      (task) => !task.constraints.dependencies || task.constraints.dependencies.length === 0,\r\n    );\r\n\r\n    this.logger.info('Found initial tasks without dependencies', {\r\n      count: initialTasks.length,\r\n      tasks: initialTasks.map((t) => ({ id: t.id.id, name: t.name })),\r\n    });\r\n\r\n    // Queue initial tasks for execution\r\n    for (const task of initialTasks) {\r\n      task.status = 'queued';\r\n      task.updatedAt = new Date();\r\n\r\n      // Update status history\r\n      task.statusHistory.push({\r\n        timestamp: new Date(),\r\n        from: 'created' as TaskStatus,\r\n        to: 'queued' as TaskStatus,\r\n        reason: 'Task queued for execution',\r\n        triggeredBy: 'system',\r\n      });\r\n\r\n      // Emit task queued event\r\n      this.emitSwarmEvent({\r\n        id: generateId('event'),\r\n        timestamp: new Date(),\r\n        type: 'task.queued',\r\n        source: this.swarmId.id,\r\n        data: { task },\r\n        broadcast: false,\r\n        processed: false,\r\n      });\r\n    }\r\n\r\n    // Update objective progress\r\n    objective.progress.totalTasks = objective.tasks.length;\r\n    objective.progress.runningTasks = 0;\r\n    objective.progress.completedTasks = 0;\r\n    objective.progress.failedTasks = 0;\r\n  }\r\n\r\n  private startTaskExecutionLoop(objective: SwarmObjective): void {\r\n    this.logger.info('Starting task execution loop for objective', {\r\n      objectiveId: objective.id,\r\n    });\r\n\r\n    // Create an interval to process queued tasks\r\n    const executionInterval = setInterval(async () => {\r\n      try {\r\n        // Check if objective is still executing\r\n        if (objective.status !== 'executing') {\r\n          clearInterval(executionInterval);\r\n          return;\r\n        }\r\n\r\n        // Find queued tasks\r\n        const queuedTasks = Array.from(this.tasks.values()).filter(\r\n          (task) => task.context?.objectiveId === objective.id && task.status === 'queued',\r\n        );\r\n\r\n        // Find idle agents\r\n        const idleAgents = Array.from(this.agents.values()).filter(\r\n          (agent) => agent.status === 'idle',\r\n        );\r\n\r\n        if (queuedTasks.length > 0 && idleAgents.length > 0) {\r\n          this.logger.debug('Processing queued tasks', {\r\n            queuedTasks: queuedTasks.length,\r\n            idleAgents: idleAgents.length,\r\n          });\r\n        }\r\n\r\n        // Assign tasks to idle agents\r\n        for (const task of queuedTasks) {\r\n          if (idleAgents.length === 0) break;\r\n\r\n          // Find suitable agent\r\n          const suitableAgents = idleAgents.filter((agent) => this.agentCanHandleTask(agent, task));\r\n\r\n          if (suitableAgents.length > 0) {\r\n            // Assign to first suitable agent\r\n            await this.assignTask(task.id.id, suitableAgents[0].id.id);\r\n\r\n            // Remove agent from idle list\r\n            const agentIndex = idleAgents.findIndex((a) => a.id.id === suitableAgents[0].id.id);\r\n            if (agentIndex >= 0) {\r\n              idleAgents.splice(agentIndex, 1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Check for completed tasks and process dependencies\r\n        const completedTasks = Array.from(this.tasks.values()).filter(\r\n          (task) => task.context?.objectiveId === objective.id && task.status === 'completed',\r\n        );\r\n\r\n        // Find tasks that can now be queued (dependencies met)\r\n        const pendingTasks = Array.from(this.tasks.values()).filter(\r\n          (task) =>\r\n            task.context?.objectiveId === objective.id &&\r\n            task.status === 'created' &&\r\n            this.taskDependenciesMet(task, completedTasks),\r\n        );\r\n\r\n        // Queue tasks with met dependencies\r\n        for (const task of pendingTasks) {\r\n          task.status = 'queued';\r\n          task.updatedAt = new Date();\r\n\r\n          task.statusHistory.push({\r\n            timestamp: new Date(),\r\n            from: 'created' as TaskStatus,\r\n            to: 'queued' as TaskStatus,\r\n            reason: 'Dependencies met, task queued',\r\n            triggeredBy: 'system',\r\n          });\r\n\r\n          this.emitSwarmEvent({\r\n            id: generateId('event'),\r\n            timestamp: new Date(),\r\n            type: 'task.queued',\r\n            source: this.swarmId.id,\r\n            data: { task },\r\n            broadcast: false,\r\n            processed: false,\r\n          });\r\n        }\r\n\r\n        // Check for stuck/timed out tasks\r\n        const runningTasks = Array.from(this.tasks.values()).filter(\r\n          (task) => task.context?.objectiveId === objective.id && task.status === 'running',\r\n        );\r\n\r\n        const now = Date.now();\r\n        for (const task of runningTasks) {\r\n          if (task.startedAt) {\r\n            const runtime = now - task.startedAt.getTime();\r\n            const timeout = task.constraints?.timeoutAfter || SWARM_CONSTANTS.DEFAULT_TASK_TIMEOUT;\r\n\r\n            if (runtime > timeout) {\r\n              this.logger.warn('Task timed out', {\r\n                taskId: task.id.id,\r\n                runtime: Math.round(runtime / 1000),\r\n                timeout: Math.round(timeout / 1000),\r\n              });\r\n\r\n              // Mark task as failed due to timeout\r\n              task.status = 'failed';\r\n              task.completedAt = new Date();\r\n              task.error = {\r\n                type: 'TimeoutError',\r\n                message: `Task exceeded timeout of ${timeout}ms`,\r\n                code: 'TASK_TIMEOUT',\r\n                context: { taskId: task.id.id, runtime },\r\n                recoverable: true,\r\n                retryable: true,\r\n              };\r\n\r\n              // Update agent state if assigned\r\n              if (task.assignedTo) {\r\n                const agent = this.agents.get(task.assignedTo.id);\r\n                if (agent) {\r\n                  agent.status = 'idle';\r\n                  agent.currentTask = undefined;\r\n                  agent.metrics.tasksFailed++;\r\n                }\r\n              }\r\n\r\n              // Emit timeout event\r\n              this.emitSwarmEvent({\r\n                id: generateId('event'),\r\n                timestamp: new Date(),\r\n                type: 'task.failed',\r\n                source: this.swarmId.id,\r\n                data: { task, reason: 'timeout' },\r\n                broadcast: false,\r\n                processed: false,\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        // Update objective progress\r\n        const allTasks = Array.from(this.tasks.values()).filter(\r\n          (task) => task.context?.objectiveId === objective.id,\r\n        );\r\n\r\n        objective.progress.totalTasks = allTasks.length;\r\n        objective.progress.completedTasks = allTasks.filter((t) => t.status === 'completed').length;\r\n        objective.progress.failedTasks = allTasks.filter((t) => t.status === 'failed').length;\r\n        objective.progress.runningTasks = allTasks.filter((t) => t.status === 'running').length;\r\n        objective.progress.percentComplete =\r\n          objective.progress.totalTasks > 0\r\n            ? (objective.progress.completedTasks / objective.progress.totalTasks) * 100\r\n            : 0;\r\n\r\n        // Check if objective is complete\r\n        if (\r\n          objective.progress.completedTasks + objective.progress.failedTasks ===\r\n          objective.progress.totalTasks\r\n        ) {\r\n          objective.status = objective.progress.failedTasks === 0 ? 'completed' : 'failed';\r\n          objective.completedAt = new Date();\r\n          clearInterval(executionInterval);\r\n\r\n          this.logger.info('Objective completed', {\r\n            objectiveId: objective.id,\r\n            status: objective.status,\r\n            completedTasks: objective.progress.completedTasks,\r\n            failedTasks: objective.progress.failedTasks,\r\n          });\r\n\r\n          this.emitSwarmEvent({\r\n            id: generateId('event'),\r\n            timestamp: new Date(),\r\n            type: objective.status === 'completed' ? 'objective.completed' : 'objective.failed',\r\n            source: this.swarmId.id,\r\n            data: { objective },\r\n            broadcast: true,\r\n            processed: false,\r\n          });\r\n        }\r\n      } catch (error) {\r\n        this.logger.error('Error in task execution loop', { error });\r\n      }\r\n    }, 2000); // Check every 2 seconds\r\n\r\n    // Store interval reference for cleanup\r\n    if (!this.executionIntervals) {\r\n      this.executionIntervals = new Map();\r\n    }\r\n    this.executionIntervals.set(objective.id, executionInterval);\r\n  }\r\n\r\n  private taskDependenciesMet(task: TaskDefinition, completedTasks: TaskDefinition[]): boolean {\r\n    if (!task.constraints.dependencies || task.constraints.dependencies.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    const completedTaskIds = completedTasks.map((t) => t.id.id);\r\n    return task.constraints.dependencies.every((dep) => {\r\n      // Handle both string and TaskId object dependencies\r\n      const depId = typeof dep === 'string' ? dep : dep.id;\r\n      return completedTaskIds.includes(depId);\r\n    });\r\n  }\r\n\r\n  private getNextInstanceNumber(type: AgentType): number {\r\n    const agentsOfType = Array.from(this.agents.values()).filter((agent) => agent.type === type);\r\n    return agentsOfType.length + 1;\r\n  }\r\n\r\n  private getDefaultPermissions(type: AgentType): string[] {\r\n    switch (type) {\r\n      case 'coordinator':\r\n        return ['read', 'write', 'execute', 'admin'];\r\n      case 'coder':\r\n        return ['read', 'write', 'execute'];\r\n      case 'tester':\r\n        return ['read', 'execute'];\r\n      case 'reviewer':\r\n        return ['read', 'write'];\r\n      default:\r\n        return ['read'];\r\n    }\r\n  }\r\n\r\n  private async initializeAgentCapabilities(agent: AgentState): Promise<void> {\r\n    // Set capabilities based on agent type\r\n    switch (agent.type) {\r\n      case 'coordinator':\r\n        agent.capabilities.codeGeneration = false;\r\n        agent.capabilities.codeReview = true;\r\n        agent.capabilities.testing = false;\r\n        agent.capabilities.documentation = true;\r\n        agent.capabilities.research = true;\r\n        agent.capabilities.analysis = true;\r\n        break;\r\n      case 'coder':\r\n        agent.capabilities.codeGeneration = true;\r\n        agent.capabilities.codeReview = true;\r\n        agent.capabilities.testing = true;\r\n        agent.capabilities.documentation = true;\r\n        break;\r\n      case 'researcher':\r\n        agent.capabilities.research = true;\r\n        agent.capabilities.analysis = true;\r\n        agent.capabilities.webSearch = true;\r\n        agent.capabilities.documentation = true;\r\n        break;\r\n      case 'analyst':\r\n        agent.capabilities.analysis = true;\r\n        agent.capabilities.research = true;\r\n        agent.capabilities.documentation = true;\r\n        break;\r\n      case 'reviewer':\r\n        agent.capabilities.codeReview = true;\r\n        agent.capabilities.testing = true;\r\n        agent.capabilities.documentation = true;\r\n        break;\r\n      case 'tester':\r\n        agent.capabilities.testing = true;\r\n        agent.capabilities.codeReview = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async initializeAgentEnvironment(agent: AgentState): Promise<void> {\r\n    // Implementation needed - setup agent environment\r\n  }\r\n\r\n  private startAgentHeartbeat(agent: AgentState): void {\r\n    // Implementation needed - start agent heartbeat\r\n  }\r\n\r\n  private stopAgentHeartbeat(agent: AgentState): void {\r\n    // Implementation needed - stop agent heartbeat\r\n  }\r\n\r\n  private async cleanupAgentEnvironment(agent: AgentState): Promise<void> {\r\n    // Implementation needed - cleanup agent environment\r\n  }\r\n\r\n  private getRequiredCapabilities(type: TaskType): string[] {\r\n    switch (type) {\r\n      case 'coding':\r\n        return ['code-generation', 'file-system'];\r\n      case 'testing':\r\n        return ['testing', 'code-review'];\r\n      case 'research':\r\n        return ['research', 'web-search'];\r\n      case 'analysis':\r\n        return ['analysis', 'documentation'];\r\n      case 'review':\r\n        return ['code-review', 'documentation'];\r\n      case 'documentation':\r\n        return ['documentation'];\r\n      default:\r\n        return [];\r\n    }\r\n  }\r\n\r\n  private getRequiredTools(type: TaskType): string[] {\r\n    switch (type) {\r\n      case 'coding':\r\n        return ['editor', 'compiler', 'debugger'];\r\n      case 'testing':\r\n        return ['test-runner', 'coverage-tool'];\r\n      case 'research':\r\n        return ['web-browser', 'search-engine'];\r\n      case 'analysis':\r\n        return ['data-tools', 'visualization'];\r\n      default:\r\n        return [];\r\n    }\r\n  }\r\n\r\n  private getRequiredPermissions(type: TaskType): string[] {\r\n    switch (type) {\r\n      case 'coding':\r\n        return ['read', 'write', 'execute'];\r\n      case 'testing':\r\n        return ['read', 'execute'];\r\n      case 'research':\r\n        return ['read', 'network'];\r\n      default:\r\n        return ['read'];\r\n    }\r\n  }\r\n\r\n  private async executeTaskWithAgent(task: TaskDefinition, agent: AgentState): Promise<any> {\r\n    this.logger.info('Executing task with agent', {\r\n      taskId: task.id.id,\r\n      taskName: task.name,\r\n      agentId: agent.id.id,\r\n      agentName: agent.name,\r\n    });\r\n\r\n    // Extract target directory from task\r\n    const targetDir = this.extractTargetDirectory(task);\r\n\r\n    try {\r\n      // Use Claude Flow executor for full SPARC system in non-interactive mode\r\n      const { ClaudeFlowExecutor } = await import('./claude-flow-executor.ts');\r\n      const executor = new ClaudeFlowExecutor({\r\n        logger: this.logger,\r\n        claudeFlowPath: getClaudeFlowBin(),\r\n        enableSparc: true,\r\n        verbose: this.config.logging?.level === 'debug',\r\n        timeoutMinutes: this.config.taskTimeoutMinutes,\r\n      });\r\n\r\n      const result = await executor.executeTask(task, agent, targetDir);\r\n\r\n      this.logger.info('Task execution completed', {\r\n        taskId: task.id.id,\r\n        success: true,\r\n        outputLength: JSON.stringify(result).length,\r\n      });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('Task execution failed', {\r\n        taskId: task.id.id,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private createExecutionPrompt(task: TaskDefinition): string {\r\n    // Create a prompt that Claude will understand\r\n    let prompt = `# Swarm Task Execution\\n\\n`;\r\n    prompt += `## Task: ${task.name}\\n\\n`;\r\n    prompt += `${task.instructions || task.description}\\n\\n`;\r\n\r\n    // Add working directory information if available\r\n    const targetDir = this.extractTargetDirectory(task);\r\n    if (targetDir) {\r\n      prompt += `## Working Directory\\n`;\r\n      prompt += `Please create all files in: ${targetDir}\\n\\n`;\r\n    }\r\n\r\n    if (task.input && Object.keys(task.input).length > 0) {\r\n      prompt += `## Additional Input\\n`;\r\n      prompt += `${JSON.stringify(task.input, null, 2)}\\n\\n`;\r\n    }\r\n\r\n    if (task.context && Object.keys(task.context).length > 0) {\r\n      prompt += `## Context\\n`;\r\n      prompt += `${JSON.stringify(task.context, null, 2)}\\n\\n`;\r\n    }\r\n\r\n    // Add execution guidelines\r\n    prompt += `## Guidelines\\n`;\r\n    prompt += `- Focus on completing this specific task\\n`;\r\n    prompt += `- Create all necessary files and directories\\n`;\r\n    prompt += `- Follow best practices for the technology being used\\n`;\r\n    prompt += `- Ensure the implementation is complete and functional\\n`;\r\n\r\n    return prompt;\r\n  }\r\n\r\n  private extractTargetDirectory(task: TaskDefinition): string | null {\r\n    // Try multiple patterns to find the target directory\r\n    const patterns = [\r\n      /in\\s+([^\\s]+\\/?)$/i, // \"in examples/dir\" at end\r\n      /(?:in|to|at)\\s+([^\\s]+\\/[^\\s]+)/i, // \"in examples/gradio\" anywhere\r\n      /([^\\s]+\\/[^\\s]+)$/, // \"examples/gradio\" at end\r\n      /examples\\/[^\\s]+/i, // specifically match examples/ paths\r\n    ];\r\n\r\n    let targetDir = null;\r\n\r\n    // First check task description and input\r\n    for (const pattern of patterns) {\r\n      const descMatch = task.description.match(pattern);\r\n      const inputMatch = task.input?.objective?.match(pattern);\r\n      if (descMatch || inputMatch) {\r\n        targetDir = (descMatch || inputMatch)[descMatch ? 1 : 0];\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If not found and task has context with targetDir, use that\r\n    if (!targetDir && task.context?.targetDir) {\r\n      targetDir = task.context.targetDir;\r\n    }\r\n\r\n    // If still not found, check objective description from context\r\n    if (!targetDir && task.context?.objectiveId) {\r\n      const objective = this.objectives.get(task.context.objectiveId);\r\n      if (objective) {\r\n        for (const pattern of patterns) {\r\n          const match = objective.description.match(pattern);\r\n          if (match) {\r\n            targetDir = match[1] || match[0];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (targetDir) {\r\n      // Clean up the target directory\r\n      targetDir = targetDir.replace(/\\s+.*$/, '');\r\n      // Resolve relative to current directory\r\n      if (!targetDir.startsWith('/')) {\r\n        targetDir = `${getClaudeFlowRoot()}/${targetDir}`;\r\n      }\r\n    }\r\n\r\n    return targetDir;\r\n  }\r\n\r\n  private async executeClaudeTask(\r\n    task: TaskDefinition,\r\n    agent: AgentState,\r\n    prompt: string,\r\n    targetDir: string | null,\r\n  ): Promise<any> {\r\n    // Create unique instance ID for this execution\r\n    const instanceId = `swarm-${this.swarmId.id}-${task.id.id}-${Date.now()}`;\r\n\r\n    // Build Claude arguments for non-interactive execution\r\n    const claudeArgs = [prompt];\r\n\r\n    // Always skip permissions for swarm automation\r\n    claudeArgs.push('--dangerously-skip-permissions');\r\n\r\n    // Add non-interactive flags for automation\r\n    claudeArgs.push('-p'); // Print mode\r\n    claudeArgs.push('--output-format', 'stream-json');\r\n    claudeArgs.push('--verbose'); // Required when using stream-json with -p\r\n\r\n    // Set working directory if specified\r\n    if (targetDir) {\r\n      // Ensure directory exists\r\n      await Deno.mkdir(targetDir, { recursive: true });\r\n\r\n      // Add directory context to prompt\r\n      const enhancedPrompt = `${prompt}\\n\\n## Important: Working Directory\\nPlease ensure all files are created in: ${targetDir}`;\r\n      claudeArgs[0] = enhancedPrompt;\r\n    }\r\n\r\n    try {\r\n      // Check if claude command exists\r\n      const checkCommand = new Deno.Command('which', {\r\n        args: ['claude'],\r\n        stdout: 'piped',\r\n        stderr: 'piped',\r\n      });\r\n      const checkResult = await checkCommand.output();\r\n      if (!checkResult.success) {\r\n        throw new Error('Claude CLI not found. Please ensure claude is installed and in PATH.');\r\n      }\r\n\r\n      // Execute Claude with the prompt\r\n      const command = new Deno.Command('claude', {\r\n        args: claudeArgs,\r\n        cwd: targetDir || process.cwd(),\r\n        env: {\r\n          ...Deno.env.toObject(),\r\n          CLAUDE_INSTANCE_ID: instanceId,\r\n          CLAUDE_SWARM_MODE: 'true',\r\n          CLAUDE_SWARM_ID: this.swarmId.id,\r\n          CLAUDE_TASK_ID: task.id.id,\r\n          CLAUDE_AGENT_ID: agent.id.id,\r\n          CLAUDE_WORKING_DIRECTORY: targetDir || process.cwd(),\r\n          CLAUDE_FLOW_MEMORY_ENABLED: 'true',\r\n          CLAUDE_FLOW_MEMORY_NAMESPACE: `swarm-${this.swarmId.id}`,\r\n        },\r\n        stdin: 'null',\r\n        stdout: 'piped',\r\n        stderr: 'piped',\r\n      });\r\n\r\n      this.logger.info('Spawning Claude agent for task', {\r\n        taskId: task.id.id,\r\n        agentId: agent.id.id,\r\n        instanceId,\r\n        targetDir,\r\n      });\r\n\r\n      const child = command.spawn();\r\n      const { code, stdout, stderr } = await child.output();\r\n\r\n      if (code === 0) {\r\n        const output = new TextDecoder().decode(stdout);\r\n        this.logger.info('Claude agent completed task successfully', {\r\n          taskId: task.id.id,\r\n          outputLength: output.length,\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          output,\r\n          instanceId,\r\n          targetDir,\r\n        };\r\n      } else {\r\n        const errorOutput = new TextDecoder().decode(stderr);\r\n        this.logger.error(`Claude agent failed with code ${code}`, {\r\n          taskId: task.id.id,\r\n          error: errorOutput,\r\n        });\r\n        throw new Error(`Claude execution failed: ${errorOutput}`);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to execute Claude agent', {\r\n        taskId: task.id.id,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private determineToolsForTask(task: TaskDefinition, agent: AgentState): string[] {\r\n    const tools = new Set<string>();\r\n\r\n    // Basic tools for all tasks\r\n    tools.add('View');\r\n    tools.add('Edit');\r\n    tools.add('Bash');\r\n\r\n    // Add tools based on task type\r\n    switch (task.type) {\r\n      case 'coding':\r\n        tools.add('Create');\r\n        tools.add('Write');\r\n        tools.add('MultiEdit');\r\n        tools.add('Test');\r\n        break;\r\n      case 'testing':\r\n        tools.add('Test');\r\n        tools.add('View');\r\n        break;\r\n      case 'documentation':\r\n        tools.add('Write');\r\n        tools.add('Create');\r\n        break;\r\n      case 'analysis':\r\n        tools.add('Analyze');\r\n        tools.add('Search');\r\n        break;\r\n      case 'research':\r\n        tools.add('WebSearch');\r\n        tools.add('Search');\r\n        break;\r\n    }\r\n\r\n    // Add tools based on agent capabilities\r\n    if (agent.capabilities.fileSystem) {\r\n      tools.add('FileSystem');\r\n    }\r\n    if (agent.capabilities.terminalAccess) {\r\n      tools.add('Terminal');\r\n    }\r\n    if (agent.capabilities.webSearch) {\r\n      tools.add('WebSearch');\r\n    }\r\n    if (agent.capabilities.apiIntegration) {\r\n      tools.add('API');\r\n    }\r\n\r\n    return Array.from(tools);\r\n  }\r\n\r\n  private async simulateTaskExecution(\r\n    task: TaskDefinition,\r\n    agent: AgentState,\r\n    prompt: string,\r\n  ): Promise<any> {\r\n    // Simulate different task types with actual file operations\r\n    // Check if task has a target directory in the description or context\r\n    let workDir = `/tmp/swarm/${this.swarmId.id}/work`;\r\n\r\n    // Extract target directory from task description or input\r\n    // Try multiple patterns to find the target directory\r\n    const patterns = [\r\n      /in\\s+([^\\s]+\\/?)$/i, // \"in examples/dir\" at end\r\n      /(?:in|to|at)\\s+([^\\s]+\\/[^\\s]+)/i, // \"in examples/gradio\" anywhere\r\n      /([^\\s]+\\/[^\\s]+)$/, // \"examples/gradio\" at end\r\n      /examples\\/[^\\s]+/i, // specifically match examples/ paths\r\n    ];\r\n\r\n    let targetDir = null;\r\n    for (const pattern of patterns) {\r\n      const descMatch = task.description.match(pattern);\r\n      const inputMatch = task.input?.objective?.match(pattern);\r\n      if (descMatch || inputMatch) {\r\n        targetDir = (descMatch || inputMatch)[descMatch ? 1 : 0];\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (targetDir) {\r\n      // Clean up the target directory (remove trailing words if needed)\r\n      targetDir = targetDir.replace(/\\s+.*$/, '');\r\n      // Use absolute path or resolve relative to current directory\r\n      workDir = targetDir.startsWith('/') ? targetDir : `${getClaudeFlowRoot()}/${targetDir}`;\r\n\r\n      this.logger.debug('Extracted target directory', {\r\n        original: task.description,\r\n        targetDir,\r\n        workDir,\r\n      });\r\n    }\r\n\r\n    try {\r\n      // Ensure work directory exists\r\n      await Deno.mkdir(workDir, { recursive: true });\r\n\r\n      switch (task.type) {\r\n        case 'coding':\r\n          return await this.executeCodeGenerationTask(task, workDir, agent);\r\n\r\n        case 'analysis':\r\n          return await this.executeAnalysisTask(task, workDir, agent);\r\n\r\n        case 'documentation':\r\n          return await this.executeDocumentationTask(task, workDir, agent);\r\n\r\n        case 'testing':\r\n          return await this.executeTestingTask(task, workDir, agent);\r\n\r\n        default:\r\n          return await this.executeGenericTask(task, workDir, agent);\r\n      }\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Task execution failed: ${error instanceof Error ? error.message : String(error)}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  private async executeCodeGenerationTask(\r\n    task: TaskDefinition,\r\n    workDir: string,\r\n    agent: AgentState,\r\n  ): Promise<any> {\r\n    this.logger.info('Executing code generation task', { taskId: task.id.id });\r\n\r\n    // Detect technology from description\r\n    const description = task.description.toLowerCase();\r\n    const isGradio = description.includes('gradio');\r\n    const isPython =\r\n      isGradio ||\r\n      description.includes('python') ||\r\n      description.includes('fastapi') ||\r\n      description.includes('django');\r\n    const isHelloWorld = description.includes('hello') && description.includes('world');\r\n    const isRestAPI = description.includes('rest api') || description.includes('api');\r\n\r\n    if (isGradio) {\r\n      // Create a Gradio application\r\n      return await this.createGradioApp(task, workDir);\r\n    } else if (isPython && isRestAPI) {\r\n      // Create a Python REST API (FastAPI)\r\n      return await this.createPythonRestAPI(task, workDir);\r\n    } else if (isRestAPI) {\r\n      // Create a REST API application\r\n      const projectName = 'rest-api';\r\n      const projectDir = `${workDir}/${projectName}`;\r\n      await Deno.mkdir(projectDir, { recursive: true });\r\n\r\n      // Create main API file\r\n      const apiCode = `const express = require('express');\r\nconst app = express();\r\nconst port = process.env.PORT || 3000;\r\n\r\n// Middleware\r\napp.use(express.json());\r\napp.use(express.urlencoded({ extended: true }));\r\n\r\n// Health check endpoint\r\napp.get('/health', (req, res) => {\r\n  res.json({ \r\n    status: 'healthy',\r\n    service: 'REST API',\r\n    swarmId: '${this.swarmId.id}',\r\n    created: '${new Date().toISOString()}'\r\n  });\r\n});\r\n\r\n// Sample endpoints\r\napp.get('/api/v1/items', (req, res) => {\r\n  res.json({\r\n    items: [\r\n      { id: 1, name: 'Item 1', description: 'First item' },\r\n      { id: 2, name: 'Item 2', description: 'Second item' }\r\n    ],\r\n    total: 2\r\n  });\r\n});\r\n\r\napp.get('/api/v1/items/:id', (req, res) => {\r\n  const id = parseInt(req.params.id);\r\n  res.json({\r\n    id,\r\n    name: \\`Item \\${id}\\`,\r\n    description: \\`Description for item \\${id}\\`\r\n  });\r\n});\r\n\r\napp.post('/api/v1/items', (req, res) => {\r\n  const newItem = {\r\n    id: Date.now(),\r\n    ...req.body,\r\n    createdAt: new Date().toISOString()\r\n  };\r\n  res.status(201).json(newItem);\r\n});\r\n\r\napp.put('/api/v1/items/:id', (req, res) => {\r\n  const id = parseInt(req.params.id);\r\n  const updatedItem = {\r\n    id,\r\n    ...req.body,\r\n    updatedAt: new Date().toISOString()\r\n  };\r\n  res.json(updatedItem);\r\n});\r\n\r\napp.delete('/api/v1/items/:id', (req, res) => {\r\n  const id = parseInt(req.params.id);\r\n  res.json({ message: \\`Item \\${id} deleted successfully\\` });\r\n});\r\n\r\n// Error handling middleware\r\napp.use((err, req, res, next) => {\r\n  console.error(err.stack);\r\n  res.status(500).json({ error: 'Internal server error' });\r\n});\r\n\r\n// Start server\r\napp.listen(port, () => {\r\n  console.log(\\`REST API server running on port \\${port}\\`);\r\n  console.log('Created by Claude Flow Swarm');\r\n});\r\n\r\nmodule.exports = app;\r\n`;\r\n\r\n      await fs.writeFile(`${projectDir}/server.js`, apiCode);\r\n\r\n      // Create package.json\r\n      const packageJson = {\r\n        name: projectName,\r\n        version: '1.0.0',\r\n        description: 'REST API created by Claude Flow Swarm',\r\n        main: 'server.js',\r\n        scripts: {\r\n          start: 'node server.js',\r\n          dev: 'nodemon server.js',\r\n          test: 'jest',\r\n        },\r\n        keywords: ['rest', 'api', 'swarm', 'claude-flow'],\r\n        author: 'Claude Flow Swarm',\r\n        license: 'MIT',\r\n        dependencies: {\r\n          express: '^4.18.2',\r\n        },\r\n        devDependencies: {\r\n          nodemon: '^3.0.1',\r\n          jest: '^29.7.0',\r\n          supertest: '^6.3.3',\r\n        },\r\n        swarmMetadata: {\r\n          swarmId: this.swarmId.id,\r\n          taskId: task.id.id,\r\n          agentId: agent.id.id,\r\n          created: new Date().toISOString(),\r\n        },\r\n      };\r\n\r\n      await fs.writeFile(`${projectDir}/package.json`, JSON.stringify(packageJson, null, 2));\r\n\r\n      // Create README\r\n      const readme = `# REST API\r\n\r\nThis REST API was created by the Claude Flow Swarm system.\r\n\r\n## Swarm Details\r\n- Swarm ID: ${this.swarmId.id}\r\n- Task: ${task.name}\r\n- Agent: ${agent.name}\r\n- Generated: ${new Date().toISOString()}\r\n\r\n## Installation\r\n\r\n\\`\\`\\`bash\r\nnpm install\r\n\\`\\`\\`\r\n\r\n## Usage\r\n\r\nStart the server:\r\n\\`\\`\\`bash\r\nnpm start\r\n\\`\\`\\`\r\n\r\nDevelopment mode with auto-reload:\r\n\\`\\`\\`bash\r\nnpm run dev\r\n\\`\\`\\`\r\n\r\n## API Endpoints\r\n\r\n- \\`GET /health\\` - Health check\r\n- \\`GET /api/v1/items\\` - Get all items\r\n- \\`GET /api/v1/items/:id\\` - Get item by ID\r\n- \\`POST /api/v1/items\\` - Create new item\r\n- \\`PUT /api/v1/items/:id\\` - Update item\r\n- \\`DELETE /api/v1/items/:id\\` - Delete item\r\n\r\n## Description\r\n${task.description}\r\n\r\n---\r\nCreated by Claude Flow Swarm\r\n`;\r\n\r\n      await fs.writeFile(`${projectDir}/README.md`, readme);\r\n\r\n      // Create .gitignore\r\n      const gitignore = `node_modules/\r\n.env\r\n*.log\r\n.DS_Store\r\ncoverage/\r\n`;\r\n\r\n      await fs.writeFile(`${projectDir}/.gitignore`, gitignore);\r\n\r\n      return {\r\n        success: true,\r\n        output: {\r\n          message: 'REST API created successfully',\r\n          location: projectDir,\r\n          files: ['server.js', 'package.json', 'README.md', '.gitignore'],\r\n        },\r\n        artifacts: {\r\n          mainFile: `${projectDir}/server.js`,\r\n          packageFile: `${projectDir}/package.json`,\r\n          readmeFile: `${projectDir}/README.md`,\r\n        },\r\n      };\r\n    } else if (isHelloWorld) {\r\n      // Create a simple hello world application\r\n      const projectDir = `${workDir}/hello-world`;\r\n      await Deno.mkdir(projectDir, { recursive: true });\r\n\r\n      // Create main application file\r\n      const mainCode = `#!/usr/bin/env node\r\n\r\n// Hello World Application\r\n// Generated by Claude Flow Swarm\r\n\r\nconsole.log('Hello, World!');\r\nconsole.log('This application was created by the Claude Flow Swarm system.');\r\nconsole.log('Swarm ID: ${this.swarmId.id}');\r\nconsole.log('Task: ${task.name}');\r\nconsole.log('Generated at: ${new Date().toISOString()}');\r\n\r\n// Export for testing\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = { message: 'Hello, World!' };\r\n}\r\n`;\r\n\r\n      await fs.writeFile(`${projectDir}/index.js`, mainCode);\r\n\r\n      // Create package.json\r\n      const packageJson = {\r\n        name: 'hello-world',\r\n        version: '1.0.0',\r\n        description: 'Hello World application created by Claude Flow Swarm',\r\n        main: 'index.js',\r\n        scripts: {\r\n          start: 'node index.js',\r\n          test: 'node test.js',\r\n        },\r\n        keywords: ['hello-world', 'swarm', 'claude-flow'],\r\n        author: 'Claude Flow Swarm',\r\n        license: 'MIT',\r\n      };\r\n\r\n      await fs.writeFile(`${projectDir}/package.json`, JSON.stringify(packageJson, null, 2));\r\n\r\n      // Create README\r\n      const readme = `# Hello World\r\n\r\nThis application was created by the Claude Flow Swarm system.\r\n\r\n## Swarm Details\r\n- Swarm ID: ${this.swarmId.id}\r\n- Task: ${task.name}\r\n- Generated: ${new Date().toISOString()}\r\n\r\n## Usage\r\n\r\n\\`\\`\\`bash\r\nnpm start\r\n\\`\\`\\`\r\n\r\n## Description\r\n${task.description}\r\n`;\r\n\r\n      await fs.writeFile(`${projectDir}/README.md`, readme);\r\n\r\n      return {\r\n        success: true,\r\n        output: {\r\n          message: 'Hello World application created successfully',\r\n          location: projectDir,\r\n          files: ['index.js', 'package.json', 'README.md'],\r\n        },\r\n        artifacts: {\r\n          mainFile: `${projectDir}/index.js`,\r\n          packageFile: `${projectDir}/package.json`,\r\n          readmeFile: `${projectDir}/README.md`,\r\n        },\r\n      };\r\n    }\r\n\r\n    // For other code generation tasks, create a basic structure\r\n    const projectDir = `${workDir}/generated-code`;\r\n    await Deno.mkdir(projectDir, { recursive: true });\r\n\r\n    const code = `// Generated code for: ${task.name}\r\n// ${task.description}\r\n\r\nfunction main() {\r\n  console.log('Executing task: ${task.name}');\r\n  // Implementation would go here\r\n}\r\n\r\nmain();\r\n`;\r\n\r\n    await fs.writeFile(`${projectDir}/main.js`, code);\r\n\r\n    return {\r\n      success: true,\r\n      output: {\r\n        message: 'Code generated successfully',\r\n        location: projectDir,\r\n        files: ['main.js'],\r\n      },\r\n    };\r\n  }\r\n\r\n  private async executeAnalysisTask(\r\n    task: TaskDefinition,\r\n    workDir: string,\r\n    agent: AgentState,\r\n  ): Promise<any> {\r\n    this.logger.info('Executing analysis task', { taskId: task.id.id });\r\n\r\n    const analysisDir = `${workDir}/analysis`;\r\n    await Deno.mkdir(analysisDir, { recursive: true });\r\n\r\n    const analysis = {\r\n      task: task.name,\r\n      description: task.description,\r\n      timestamp: new Date().toISOString(),\r\n      findings: [\r\n        'Analysis point 1: Task objectives are clear',\r\n        'Analysis point 2: Resources are allocated',\r\n        'Analysis point 3: Implementation path is defined',\r\n      ],\r\n      recommendations: [\r\n        'Proceed with implementation',\r\n        'Monitor progress regularly',\r\n        'Adjust resources as needed',\r\n      ],\r\n    };\r\n\r\n    await fs.writeFile(`${analysisDir}/analysis-report.json`, JSON.stringify(analysis, null, 2));\r\n\r\n    return {\r\n      success: true,\r\n      output: analysis,\r\n      artifacts: {\r\n        report: `${analysisDir}/analysis-report.json`,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async executeDocumentationTask(\r\n    task: TaskDefinition,\r\n    workDir: string,\r\n    agent: AgentState,\r\n  ): Promise<any> {\r\n    this.logger.info('Executing documentation task', { taskId: task.id.id });\r\n\r\n    const docsDir = `${workDir}/docs`;\r\n    await Deno.mkdir(docsDir, { recursive: true });\r\n\r\n    const documentation = `# ${task.name}\r\n\r\n${task.description}\r\n\r\n## Overview\r\nThis documentation was generated by the Claude Flow Swarm system.\r\n\r\n## Details\r\n- Task ID: ${task.id.id}\r\n- Generated: ${new Date().toISOString()}\r\n- Swarm ID: ${this.swarmId.id}\r\n\r\n## Instructions\r\n${task.instructions}\r\n\r\n## Implementation Notes\r\n- This is an automated documentation generated by the swarm\r\n- Further details would be added based on actual implementation\r\n`;\r\n\r\n    await fs.writeFile(`${docsDir}/documentation.md`, documentation);\r\n\r\n    return {\r\n      success: true,\r\n      output: {\r\n        message: 'Documentation created successfully',\r\n        location: docsDir,\r\n        files: ['documentation.md'],\r\n      },\r\n      artifacts: {\r\n        documentation: `${docsDir}/documentation.md`,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async executeTestingTask(\r\n    task: TaskDefinition,\r\n    workDir: string,\r\n    agent: AgentState,\r\n  ): Promise<any> {\r\n    this.logger.info('Executing testing task', { taskId: task.id.id });\r\n\r\n    const testDir = `${workDir}/tests`;\r\n    await Deno.mkdir(testDir, { recursive: true });\r\n\r\n    const testCode = `// Test suite for: ${task.name}\r\n// ${task.description}\r\n\r\nconst assert = require('assert');\r\n\r\ndescribe('${task.name}', () => {\r\n  it('should pass basic test', () => {\r\n    assert.strictEqual(1 + 1, 2);\r\n  });\r\n  \r\n  it('should validate implementation', () => {\r\n    // Test implementation would go here\r\n    assert.ok(true, 'Implementation validated');\r\n  });\r\n});\r\n\r\nconsole.log('Tests completed for: ${task.name}');\r\n`;\r\n\r\n    await fs.writeFile(`${testDir}/test.js`, testCode);\r\n\r\n    return {\r\n      success: true,\r\n      output: {\r\n        message: 'Test suite created successfully',\r\n        location: testDir,\r\n        files: ['test.js'],\r\n        testsPassed: 2,\r\n        testsFailed: 0,\r\n      },\r\n      artifacts: {\r\n        testFile: `${testDir}/test.js`,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async executeGenericTask(\r\n    task: TaskDefinition,\r\n    workDir: string,\r\n    agent: AgentState,\r\n  ): Promise<any> {\r\n    this.logger.info('Executing generic task', { taskId: task.id.id });\r\n\r\n    const outputDir = `${workDir}/output`;\r\n    await Deno.mkdir(outputDir, { recursive: true });\r\n\r\n    const output = {\r\n      task: task.name,\r\n      type: task.type,\r\n      description: task.description,\r\n      status: 'completed',\r\n      timestamp: new Date().toISOString(),\r\n      result: 'Task executed successfully',\r\n    };\r\n\r\n    await fs.writeFile(`${outputDir}/result.json`, JSON.stringify(output, null, 2));\r\n\r\n    return {\r\n      success: true,\r\n      output,\r\n      artifacts: {\r\n        result: `${outputDir}/result.json`,\r\n      },\r\n    };\r\n  }\r\n\r\n  private assessTaskQuality(task: TaskDefinition, result: any): number {\r\n    // Implementation needed - assess task quality\r\n    return 0.8;\r\n  }\r\n\r\n  private updateAgentMetrics(agent: AgentState, task: TaskDefinition): void {\r\n    // Update agent performance metrics\r\n    const executionTime = task.completedAt!.getTime() - (task.startedAt?.getTime() || 0);\r\n\r\n    agent.metrics.averageExecutionTime =\r\n      (agent.metrics.averageExecutionTime * agent.metrics.tasksCompleted + executionTime) /\r\n      (agent.metrics.tasksCompleted + 1);\r\n\r\n    agent.metrics.successRate =\r\n      agent.metrics.tasksCompleted / (agent.metrics.tasksCompleted + agent.metrics.tasksFailed);\r\n  }\r\n\r\n  private async processDependentTasks(task: TaskDefinition): Promise<void> {\r\n    // Implementation needed - process tasks that depend on this one\r\n  }\r\n\r\n  private isRecoverableError(error: any): boolean {\r\n    // Implementation needed - determine if error is recoverable\r\n    return true;\r\n  }\r\n\r\n  private isRetryableError(error: any): boolean {\r\n    // Implementation needed - determine if error is retryable\r\n    return true;\r\n  }\r\n\r\n  private async handleTaskFailureCascade(task: TaskDefinition): Promise<void> {\r\n    // Implementation needed - handle failure cascade\r\n  }\r\n\r\n  private async reassignTask(taskId: string): Promise<void> {\r\n    // Implementation needed - reassign task to different agent\r\n  }\r\n\r\n  private processHeartbeats(): void {\r\n    const now = new Date();\r\n    const timeout = this.config.monitoring.heartbeatInterval * 10; // Increased multiplier for long-running Claude tasks\r\n\r\n    for (const agent of this.agents.values()) {\r\n      if (agent.status === 'offline' || agent.status === 'terminated') {\r\n        continue;\r\n      }\r\n\r\n      const timeSinceHeartbeat = now.getTime() - agent.lastHeartbeat.getTime();\r\n      if (timeSinceHeartbeat > timeout) {\r\n        this.logger.warn('Agent heartbeat timeout', {\r\n          agentId: agent.id.id,\r\n          timeSinceHeartbeat,\r\n        });\r\n        agent.status = 'error';\r\n        agent.health = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  private updateSwarmMetrics(): void {\r\n    // Implementation needed - update swarm-level metrics\r\n  }\r\n\r\n  private performCleanup(): void {\r\n    // Implementation needed - perform periodic cleanup\r\n  }\r\n\r\n  private checkObjectiveCompletion(): void {\r\n    // Implementation needed - check if objectives are complete\r\n  }\r\n\r\n  private checkObjectiveFailure(task: TaskDefinition): void {\r\n    // Implementation needed - check if objective has failed\r\n  }\r\n\r\n  private handleAgentError(agentId: string, error: any): void {\r\n    const agent = this.agents.get(agentId);\r\n    if (agent) {\r\n      agent.status = 'error';\r\n      agent.health = 0;\r\n      this.logger.error('Agent error', { agentId, error });\r\n\r\n      // Track error in JSON output if enabled\r\n      if (this.jsonOutputAggregator) {\r\n        this.jsonOutputAggregator.addAgentError(\r\n          agentId,\r\n          error instanceof Error ? error.message : String(error),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // ===== JSON OUTPUT METHODS =====\r\n\r\n  /**\r\n   * Enable JSON output collection for non-interactive mode\r\n   */\r\n  enableJsonOutput(objective: string): void {\r\n    if (!this.jsonOutputAggregator) {\r\n      this.jsonOutputAggregator = new SwarmJsonOutputAggregator(\r\n        this.swarmId.id,\r\n        objective,\r\n        this.config,\r\n      );\r\n      this.logger.info('JSON output aggregation enabled', { swarmId: this.swarmId.id });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the final JSON output for the swarm\r\n   */\r\n  getJsonOutput(\r\n    status: 'completed' | 'failed' | 'timeout' | 'cancelled' = 'completed',\r\n  ): string | null {\r\n    if (!this.jsonOutputAggregator) {\r\n      return null;\r\n    }\r\n    return this.jsonOutputAggregator.getJsonOutput(status);\r\n  }\r\n\r\n  /**\r\n   * Save JSON output to file\r\n   */\r\n  async saveJsonOutput(\r\n    filePath: string,\r\n    status: 'completed' | 'failed' | 'timeout' | 'cancelled' = 'completed',\r\n  ): Promise<void> {\r\n    if (!this.jsonOutputAggregator) {\r\n      throw new Error('JSON output aggregation not enabled');\r\n    }\r\n    await this.jsonOutputAggregator.saveToFile(filePath, status);\r\n  }\r\n\r\n  /**\r\n   * Track agent activity in JSON output\r\n   */\r\n  private trackAgentInJsonOutput(agent: AgentState): void {\r\n    if (this.jsonOutputAggregator) {\r\n      this.jsonOutputAggregator.addAgent(agent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track task activity in JSON output\r\n   */\r\n  private trackTaskInJsonOutput(task: TaskDefinition): void {\r\n    if (this.jsonOutputAggregator) {\r\n      this.jsonOutputAggregator.addTask(task);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add output to JSON aggregator\r\n   */\r\n  private addOutputToJsonAggregator(agentId: string, output: string): void {\r\n    if (this.jsonOutputAggregator) {\r\n      this.jsonOutputAggregator.addAgentOutput(agentId, output);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add insight to JSON aggregator\r\n   */\r\n  addInsight(insight: string): void {\r\n    if (this.jsonOutputAggregator) {\r\n      this.jsonOutputAggregator.addInsight(insight);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add artifact to JSON aggregator\r\n   */\r\n  addArtifact(key: string, artifact: any): void {\r\n    if (this.jsonOutputAggregator) {\r\n      this.jsonOutputAggregator.addArtifact(key, artifact);\r\n    }\r\n  }\r\n}\r\n"],"names":["EventEmitter","promises","fs","Logger","generateId","SWARM_CONSTANTS","AutoStrategy","getClaudeFlowRoot","getClaudeFlowBin","SwarmJsonOutputAggregator","SwarmCoordinator","logger","config","swarmId","agents","Map","tasks","objectives","_isRunning","status","startTime","endTime","metrics","events","lastHeartbeat","Date","jsonOutputAggregator","heartbeatTimer","monitoringTimer","cleanupTimer","executionIntervals","autoStrategy","logLevel","logging","level","logFormat","format","logDestination","destination","component","generateSwarmId","mergeWithDefaults","initializeMetrics","setupEventHandlers","info","id","mode","strategy","initialize","Error","validation","validateConfiguration","valid","errors","map","e","message","join","initializeSubsystems","startBackgroundProcesses","emitSwarmEvent","timestamp","type","source","data","broadcast","processed","error","shutdown","stopBackgroundProcesses","stopAllAgents","completeRunningTasks","saveState","duration","getTime","pause","agent","values","pauseAgent","resume","resumeAgent","createObjective","name","description","requirements","objectiveId","objective","minAgents","maxAgents","agentTypes","determineRequiredAgentTypes","estimatedDuration","maxDuration","qualityThreshold","reviewCoverage","testCoverage","reliabilityTarget","constraints","minQuality","requiredApprovals","allowedFailures","Math","floor","recoveryTime","milestones","dependencies","progress","initializeProgress","createdAt","decompositionResult","decomposeObjective","convertDependenciesToTaskDependencies","analyzeDependencies","set","taskCount","length","executeObjective","get","startedAt","ensureRequiredAgents","scheduleInitialTasks","startTaskExecutionLoop","registerAgent","capabilities","agentId","instance","getNextInstanceNumber","agentState","codeGeneration","codeReview","testing","documentation","research","analysis","webSearch","apiIntegration","fileSystem","terminalAccess","languages","frameworks","domains","tools","maxConcurrentTasks","maxMemoryUsage","DEFAULT_MEMORY_LIMIT","maxExecutionTime","DEFAULT_TASK_TIMEOUT","reliability","speed","quality","tasksCompleted","tasksFailed","averageExecutionTime","successRate","cpuUsage","memoryUsage","diskUsage","networkUsage","codeQuality","bugRate","userSatisfaction","totalUptime","lastActivity","responseTime","workload","health","autonomyLevel","learningEnabled","adaptationEnabled","maxTasksPerHour","timeoutThreshold","reportingInterval","heartbeatInterval","DEFAULT_HEARTBEAT_INTERVAL","permissions","getDefaultPermissions","trustedAgents","expertise","preferences","environment","runtime","version","workingDirectory","tempDirectory","logDirectory","apiEndpoints","credentials","availableTools","toolConfigs","endpoints","taskHistory","errorHistory","childAgents","collaborators","trackAgentInJsonOutput","initializeAgentCapabilities","startAgent","Object","keys","unregisterAgent","stopAgent","currentTask","reassignTask","delete","initializeAgentEnvironment","startAgentHeartbeat","push","String","stack","context","severity","resolved","cancelTask","stopAgentHeartbeat","cleanupAgentEnvironment","createTask","instructions","options","taskId","sequence","size","priority","task","getRequiredCapabilities","getRequiredTools","getRequiredPermissions","dependents","conflicts","maxRetries","MAX_RETRIES","timeoutAfter","input","examples","updatedAt","attempts","statusHistory","from","to","reason","triggeredBy","trackTaskInJsonOutput","assignTask","selectAgentForTask","assignedTo","assignedAt","agentName","startTaskExecution","attempt","attemptNumber","resourcesUsed","result","executeTaskWithAgent","completeTask","failTask","completedAt","output","artifacts","metadata","assessTaskQuality","completeness","accuracy","executionTime","validated","currentAttempt","undefined","updateAgentMetrics","processDependentTasks","warn","code","recoverable","isRecoverableError","retryable","isRetryableError","shouldRetry","retryDelay","pow","setTimeout","catch","retryError","handleTaskFailureCascade","availableAgents","Array","filter","agentCanHandleTask","scoredAgents","score","calculateAgentScore","sort","a","b","capabilityMatch","calculateCapabilityMatch","performanceScore","workloadScore","requiredCapabilities","matches","total","capability","agentHasCapability","caps","includes","agentType","minReliability","now","namespace","coordinationStrategy","agentSelection","taskScheduling","loadBalancing","faultTolerance","communication","maxTasks","resourceLimits","memory","cpu","DEFAULT_CPU_LIMIT","disk","DEFAULT_DISK_LIMIT","DEFAULT_QUALITY_THRESHOLD","reviewRequired","testingRequired","monitoring","metricsEnabled","loggingEnabled","tracingEnabled","metricsInterval","healthCheckInterval","retentionPeriod","maxLogSize","maxMetricPoints","alertingEnabled","alertThresholds","errorRate","exportEnabled","exportFormat","exportDestination","partitions","read","write","share","persistent","backupEnabled","distributed","consistency","cacheEnabled","compressionEnabled","security","authenticationRequired","authorizationRequired","encryptionEnabled","defaultPermissions","adminRoles","auditEnabled","auditLevel","inputValidation","outputSanitization","performance","maxConcurrency","defaultTimeout","cacheSize","cacheTtl","optimizationEnabled","adaptiveScheduling","predictiveLoading","resourcePooling","connectionPooling","memoryPooling","throughput","latency","efficiency","averageQuality","defectRate","reworkRate","resourceUtilization","costEfficiency","agentUtilization","agentSatisfaction","collaborationEffectiveness","scheduleVariance","deadlineAdherence","totalTasks","completedTasks","failedTasks","runningTasks","estimatedCompletion","timeRemaining","percentComplete","passedReviews","passedTests","costSpent","activeAgents","idleAgents","busyAgents","on","updateSwarmMetrics","checkObjectiveCompletion","checkObjectiveFailure","handleAgentError","event","slice","emit","emitSwarmEvents","success","onSwarmEvent","handler","offSwarmEvent","off","filterEvents","predicate","correlateEvents","correlationId","getSwarmId","getStatus","getAgents","getAgent","getTasks","getTask","getObjectives","getObjective","getMetrics","getEvents","isRunning","getUptime","getSwarmStatus","t","completed","failed","warnings","validatedAt","validator","setInterval","processHeartbeats","performCleanup","clearInterval","interval","clear","stopPromises","Promise","allSettled","timeout","deadline","some","resolve","getAgentTypeInstructions","getAgentCapabilities","targetDirMatch","match","targetDir","targetPath","startsWith","eachAgentPattern","requestsParallelAgents","test","createTaskForObjective","title","charAt","toUpperCase","task1","task2","task3","task4","params","forEach","deps","dependsOn","targetDirPatterns","objectiveTargetDir","pattern","initialTasks","count","executionInterval","queuedTasks","debug","suitableAgents","agentIndex","findIndex","splice","pendingTasks","taskDependenciesMet","round","allTasks","completedTaskIds","every","dep","depId","agentsOfType","taskName","extractTargetDirectory","ClaudeFlowExecutor","executor","claudeFlowPath","enableSparc","verbose","timeoutMinutes","taskTimeoutMinutes","executeTask","outputLength","JSON","stringify","createExecutionPrompt","prompt","patterns","descMatch","inputMatch","replace","executeClaudeTask","instanceId","claudeArgs","Deno","mkdir","recursive","enhancedPrompt","checkCommand","Command","args","stdout","stderr","checkResult","command","cwd","process","env","toObject","CLAUDE_INSTANCE_ID","CLAUDE_SWARM_MODE","CLAUDE_SWARM_ID","CLAUDE_TASK_ID","CLAUDE_AGENT_ID","CLAUDE_WORKING_DIRECTORY","CLAUDE_FLOW_MEMORY_ENABLED","CLAUDE_FLOW_MEMORY_NAMESPACE","stdin","child","spawn","TextDecoder","decode","errorOutput","determineToolsForTask","Set","add","simulateTaskExecution","workDir","original","executeCodeGenerationTask","executeAnalysisTask","executeDocumentationTask","executeTestingTask","executeGenericTask","toLowerCase","isGradio","isPython","isHelloWorld","isRestAPI","createGradioApp","createPythonRestAPI","projectName","projectDir","apiCode","toISOString","writeFile","packageJson","main","scripts","start","dev","keywords","author","license","express","devDependencies","nodemon","jest","supertest","swarmMetadata","created","readme","gitignore","location","files","mainFile","packageFile","readmeFile","mainCode","analysisDir","findings","recommendations","report","docsDir","testDir","testCode","testsPassed","testsFailed","testFile","outputDir","timeSinceHeartbeat","addAgentError","enableJsonOutput","getJsonOutput","saveJsonOutput","filePath","saveToFile","addAgent","addTask","addOutputToJsonAggregator","addAgentOutput","addInsight","insight","addArtifact","key","artifact"],"mappings":"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"}