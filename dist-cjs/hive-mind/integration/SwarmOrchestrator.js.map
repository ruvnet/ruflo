{
  "version": 3,
  "sources": ["../../../src/hive-mind/integration/SwarmOrchestrator.ts"],
  "sourcesContent": ["/**\n * SwarmOrchestrator Class\n *\n * Orchestrates task distribution, agent coordination, and\n * execution strategies within the Hive Mind swarm.\n */\n\nimport { EventEmitter } from 'events';\nimport { HiveMind } from '../core/HiveMind.js';\nimport { Agent } from '../core/Agent.js';\nimport { DatabaseManager } from '../core/DatabaseManager.js';\nimport { MCPToolWrapper } from './MCPToolWrapper.js';\nimport {\n  Task,\n  TaskStrategy,\n  ExecutionPlan,\n  OrchestrationResult,\n  TaskAssignment,\n} from '../types.js';\n\nexport class SwarmOrchestrator extends EventEmitter {\n  private hiveMind: HiveMind;\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private executionPlans: Map<string, ExecutionPlan>;\n  private taskAssignments: Map<string, TaskAssignment[]>;\n  private activeExecutions: Map<string, any>;\n  private isActive: boolean = false;\n\n  constructor(hiveMind: HiveMind) {\n    super();\n    this.hiveMind = hiveMind;\n    this.executionPlans = new Map();\n    this.taskAssignments = new Map();\n    this.activeExecutions = new Map();\n  }\n\n  /**\n   * Initialize the orchestrator\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n    await this.mcpWrapper.initialize();\n\n    // Start orchestration loops\n    this.startTaskDistributor();\n    this.startProgressMonitor();\n    this.startLoadBalancer();\n\n    this.isActive = true;\n    this.emit('initialized');\n  }\n\n  /**\n   * Submit a task for orchestration\n   */\n  async submitTask(task: Task): Promise<void> {\n    // Create execution plan based on strategy\n    const plan = await this.createExecutionPlan(task);\n    this.executionPlans.set(task.id, plan);\n\n    // Orchestrate task using MCP tools\n    const orchestrationResult = await this.mcpWrapper.orchestrateTask({\n      task: task.description,\n      priority: task.priority,\n      strategy: task.strategy,\n      dependencies: task.dependencies,\n    });\n\n    if (orchestrationResult.success) {\n      // Start task execution\n      await this.executeTask(task, plan);\n    } else {\n      this.emit('orchestrationError', { task, error: orchestrationResult.error });\n    }\n  }\n\n  /**\n   * Create execution plan for a task\n   */\n  private async createExecutionPlan(task: Task): Promise<ExecutionPlan> {\n    const strategy = this.getStrategyImplementation(task.strategy);\n\n    // Analyze task complexity\n    const analysis = await this.analyzeTaskComplexity(task);\n\n    // Determine phases based on strategy and complexity\n    const phases = strategy.determinePhases(task, analysis);\n\n    // Create assignments for each phase\n    const phaseAssignments = await Promise.all(\n      phases.map((phase) => this.createPhaseAssignments(task, phase, analysis)),\n    );\n\n    return {\n      taskId: task.id,\n      strategy: task.strategy,\n      phases,\n      phaseAssignments,\n      dependencies: task.dependencies,\n      checkpoints: this.createCheckpoints(phases),\n      parallelizable: strategy.isParallelizable(task),\n      estimatedDuration: analysis.estimatedDuration,\n      resourceRequirements: analysis.resourceRequirements,\n    };\n  }\n\n  /**\n   * Execute task according to plan\n   */\n  private async executeTask(task: Task, plan: ExecutionPlan): Promise<void> {\n    const execution = {\n      taskId: task.id,\n      plan,\n      startTime: Date.now(),\n      currentPhase: 0,\n      phaseResults: [],\n      status: 'executing',\n    };\n\n    this.activeExecutions.set(task.id, execution);\n\n    try {\n      // Execute phases according to strategy\n      if (plan.parallelizable) {\n        await this.executeParallel(task, plan, execution);\n      } else {\n        await this.executeSequential(task, plan, execution);\n      }\n\n      // Mark task as completed\n      execution.status = 'completed';\n      await this.completeTask(task, execution);\n    } catch (error) {\n      execution.status = 'failed';\n      execution.error = error;\n      await this.handleTaskFailure(task, execution, error);\n    } finally {\n      this.activeExecutions.delete(task.id);\n    }\n  }\n\n  /**\n   * Execute phases in parallel\n   */\n  private async executeParallel(task: Task, plan: ExecutionPlan, execution: any): Promise<void> {\n    const parallelPhases = plan.phases.filter((_, index) =>\n      plan.phaseAssignments[index].some((a) => a.canRunParallel),\n    );\n\n    const results = await Promise.all(\n      parallelPhases.map((phase) => this.executePhase(task, phase, plan, execution)),\n    );\n\n    execution.phaseResults = results;\n  }\n\n  /**\n   * Execute phases sequentially\n   */\n  private async executeSequential(task: Task, plan: ExecutionPlan, execution: any): Promise<void> {\n    for (let i = 0; i < plan.phases.length; i++) {\n      const phase = plan.phases[i];\n      execution.currentPhase = i;\n\n      const result = await this.executePhase(task, phase, plan, execution);\n      execution.phaseResults.push(result);\n\n      // Check checkpoint\n      if (plan.checkpoints[i]) {\n        await this.evaluateCheckpoint(task, plan.checkpoints[i], execution);\n      }\n    }\n  }\n\n  /**\n   * Execute a single phase\n   */\n  private async executePhase(\n    task: Task,\n    phase: string,\n    plan: ExecutionPlan,\n    execution: any,\n  ): Promise<any> {\n    const phaseIndex = plan.phases.indexOf(phase);\n    const assignments = plan.phaseAssignments[phaseIndex];\n\n    // Assign agents to phase tasks\n    const agentAssignments = await this.assignAgentsToPhase(task, phase, assignments);\n\n    // Execute phase tasks\n    const phaseResults = await Promise.all(\n      agentAssignments.map((assignment) => this.executeAssignment(task, phase, assignment)),\n    );\n\n    // Aggregate phase results\n    return this.aggregatePhaseResults(phase, phaseResults);\n  }\n\n  /**\n   * Assign agents to phase tasks\n   */\n  private async assignAgentsToPhase(\n    task: Task,\n    phase: string,\n    assignments: TaskAssignment[],\n  ): Promise<any[]> {\n    const agentAssignments = [];\n\n    for (const assignment of assignments) {\n      // Find suitable agent\n      const agent = await this.findSuitableAgent(assignment.requiredCapabilities);\n\n      if (agent) {\n        await this.assignTaskToAgent(task.id, agent.id);\n        agentAssignments.push({\n          agent,\n          assignment,\n          phase,\n        });\n      } else {\n        // Queue for later assignment\n        this.queueAssignment(task.id, assignment);\n      }\n    }\n\n    return agentAssignments;\n  }\n\n  /**\n   * Execute a specific assignment\n   */\n  private async executeAssignment(task: Task, phase: string, assignment: any): Promise<any> {\n    const { agent, assignment: taskAssignment } = assignment;\n\n    // Send execution command to agent\n    await agent.assignTask(task.id, {\n      phase,\n      role: taskAssignment.role,\n      responsibilities: taskAssignment.responsibilities,\n      expectedOutput: taskAssignment.expectedOutput,\n    });\n\n    // Wait for completion or timeout\n    return this.waitForAgentCompletion(agent, task.id, taskAssignment.timeout);\n  }\n\n  /**\n   * Assign task to a specific agent\n   */\n  async assignTaskToAgent(taskId: string, agentId: string): Promise<void> {\n    // Update database\n    const task = await this.db.getTask(taskId);\n    const assignedAgents = JSON.parse(task.assigned_agents || '[]');\n\n    if (!assignedAgents.includes(agentId)) {\n      assignedAgents.push(agentId);\n      await this.db.updateTask(taskId, {\n        assigned_agents: JSON.stringify(assignedAgents),\n        status: 'assigned',\n      });\n    }\n\n    // Update agent\n    await this.db.updateAgent(agentId, {\n      current_task_id: taskId,\n      status: 'busy',\n    });\n\n    this.emit('taskAssigned', { taskId, agentId });\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(taskId: string): Promise<void> {\n    const execution = this.activeExecutions.get(taskId);\n\n    if (execution) {\n      execution.status = 'cancelled';\n\n      // Notify assigned agents\n      const task = await this.db.getTask(taskId);\n      const assignedAgents = JSON.parse(task.assigned_agents || '[]');\n\n      for (const agentId of assignedAgents) {\n        await this.notifyAgentTaskCancelled(agentId, taskId);\n      }\n    }\n\n    this.activeExecutions.delete(taskId);\n    this.executionPlans.delete(taskId);\n\n    this.emit('taskCancelled', { taskId });\n  }\n\n  /**\n   * Rebalance agent assignments\n   */\n  async rebalance(): Promise<void> {\n    // Get current load distribution\n    const loadDistribution = await this.analyzeLoadDistribution();\n\n    // Use MCP tool for load balancing\n    const balanceResult = await this.mcpWrapper.loadBalance({\n      tasks: loadDistribution.unassignedTasks,\n    });\n\n    if (balanceResult.success && balanceResult.data.reassignments) {\n      await this.applyReassignments(balanceResult.data.reassignments);\n    }\n\n    this.emit('rebalanced', { loadDistribution });\n  }\n\n  /**\n   * Strategy implementations\n   */\n  private getStrategyImplementation(strategy: TaskStrategy): any {\n    const strategies = {\n      parallel: {\n        determinePhases: (task: Task) => ['preparation', 'parallel-execution', 'aggregation'],\n        isParallelizable: () => true,\n        maxConcurrency: 5,\n      },\n      sequential: {\n        determinePhases: (task: Task) => ['analysis', 'planning', 'execution', 'validation'],\n        isParallelizable: () => false,\n        maxConcurrency: 1,\n      },\n      adaptive: {\n        determinePhases: (task: Task, analysis: any) => {\n          if (analysis.complexity === 'high') {\n            return ['deep-analysis', 'planning', 'phased-execution', 'integration', 'validation'];\n          }\n          return ['quick-analysis', 'execution', 'validation'];\n        },\n        isParallelizable: (task: Task) => !task.requireConsensus,\n        maxConcurrency: 3,\n      },\n      consensus: {\n        determinePhases: () => ['proposal', 'discussion', 'voting', 'execution', 'ratification'],\n        isParallelizable: () => false,\n        maxConcurrency: 1,\n      },\n    };\n\n    return strategies[strategy] || strategies.adaptive;\n  }\n\n  /**\n   * Analyze task complexity\n   */\n  private async analyzeTaskComplexity(task: Task): Promise<any> {\n    const analysis = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'task_complexity',\n      metadata: {\n        description: task.description,\n        priority: task.priority,\n        dependencies: task.dependencies.length,\n        requiresConsensus: task.requireConsensus,\n      },\n    });\n\n    return {\n      complexity: analysis.data?.complexity || 'medium',\n      estimatedDuration: analysis.data?.estimatedDuration || 3600000,\n      resourceRequirements: analysis.data?.resourceRequirements || {\n        minAgents: 1,\n        maxAgents: task.maxAgents,\n        capabilities: task.requiredCapabilities,\n      },\n    };\n  }\n\n  /**\n   * Create phase assignments\n   */\n  private async createPhaseAssignments(\n    task: Task,\n    phase: string,\n    analysis: any,\n  ): Promise<TaskAssignment[]> {\n    const assignments: TaskAssignment[] = [];\n\n    // Define assignments based on phase\n    switch (phase) {\n      case 'analysis':\n      case 'deep-analysis':\n        assignments.push({\n          role: 'analyst',\n          requiredCapabilities: ['data_analysis', 'pattern_recognition'],\n          responsibilities: ['Analyze task requirements', 'Identify patterns', 'Assess complexity'],\n          expectedOutput: 'Analysis report',\n          timeout: 300000, // 5 minutes\n          canRunParallel: false,\n        });\n        break;\n\n      case 'planning':\n        assignments.push({\n          role: 'architect',\n          requiredCapabilities: ['system_design', 'architecture_patterns'],\n          responsibilities: ['Design solution', 'Create implementation plan', 'Define interfaces'],\n          expectedOutput: 'Implementation plan',\n          timeout: 600000, // 10 minutes\n          canRunParallel: false,\n        });\n        break;\n\n      case 'execution':\n      case 'parallel-execution':\n        // Multiple execution assignments based on complexity\n        const executionCount = Math.min(analysis.resourceRequirements.maxAgents, 3);\n        for (let i = 0; i < executionCount; i++) {\n          assignments.push({\n            role: 'executor',\n            requiredCapabilities: task.requiredCapabilities,\n            responsibilities: ['Implement solution', 'Execute plan', 'Handle errors'],\n            expectedOutput: 'Execution results',\n            timeout: 1800000, // 30 minutes\n            canRunParallel: true,\n          });\n        }\n        break;\n\n      case 'validation':\n        assignments.push({\n          role: 'validator',\n          requiredCapabilities: ['quality_assurance', 'test_generation'],\n          responsibilities: ['Validate results', 'Run tests', 'Ensure quality'],\n          expectedOutput: 'Validation report',\n          timeout: 600000, // 10 minutes\n          canRunParallel: false,\n        });\n        break;\n\n      case 'consensus':\n      case 'voting':\n        assignments.push({\n          role: 'consensus-coordinator',\n          requiredCapabilities: ['consensus_building'],\n          responsibilities: ['Coordinate voting', 'Collect opinions', 'Determine consensus'],\n          expectedOutput: 'Consensus decision',\n          timeout: 300000, // 5 minutes\n          canRunParallel: false,\n        });\n        break;\n    }\n\n    return assignments;\n  }\n\n  /**\n   * Create execution checkpoints\n   */\n  private createCheckpoints(phases: string[]): any[] {\n    return phases.map((phase, index) => ({\n      phase,\n      index,\n      requiredProgress: Math.round(((index + 1) / phases.length) * 100),\n      validationCriteria: this.getValidationCriteria(phase),\n      failureThreshold: 0.3,\n    }));\n  }\n\n  /**\n   * Get validation criteria for a phase\n   */\n  private getValidationCriteria(phase: string): any[] {\n    const criteria: Record<string, any[]> = {\n      analysis: [\n        { name: 'completeness', weight: 0.4 },\n        { name: 'accuracy', weight: 0.6 },\n      ],\n      planning: [\n        { name: 'feasibility', weight: 0.5 },\n        { name: 'completeness', weight: 0.5 },\n      ],\n      execution: [\n        { name: 'correctness', weight: 0.7 },\n        { name: 'performance', weight: 0.3 },\n      ],\n      validation: [\n        { name: 'test_coverage', weight: 0.5 },\n        { name: 'quality_score', weight: 0.5 },\n      ],\n    };\n\n    return criteria[phase] || [{ name: 'completion', weight: 1.0 }];\n  }\n\n  /**\n   * Find suitable agent for capabilities\n   */\n  private async findSuitableAgent(requiredCapabilities: string[]): Promise<Agent | null> {\n    const agents = await this.hiveMind.getAgents();\n\n    // Filter available agents with required capabilities\n    const suitableAgents = agents.filter(\n      (agent) =>\n        agent.status === 'idle' &&\n        requiredCapabilities.every((cap) => agent.capabilities.includes(cap)),\n    );\n\n    if (suitableAgents.length === 0) {\n      return null;\n    }\n\n    // Select best agent based on performance history\n    return this.selectBestAgent(suitableAgents, requiredCapabilities);\n  }\n\n  /**\n   * Select best agent from candidates\n   */\n  private async selectBestAgent(agents: Agent[], capabilities: string[]): Promise<Agent> {\n    // Simple selection - in production would use performance metrics\n    const scores = await Promise.all(\n      agents.map(async (agent) => {\n        const performance = await this.db.getAgentPerformance(agent.id);\n        return {\n          agent,\n          score: performance?.successRate || 0.5,\n        };\n      }),\n    );\n\n    scores.sort((a, b) => b.score - a.score);\n    return scores[0].agent;\n  }\n\n  /**\n   * Wait for agent to complete task\n   */\n  private async waitForAgentCompletion(\n    agent: Agent,\n    taskId: string,\n    timeout: number,\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Agent ${agent.id} timeout on task ${taskId}`));\n      }, timeout);\n\n      const checkCompletion = async () => {\n        const agentState = await this.db.getAgent(agent.id);\n\n        if (agentState.current_task_id !== taskId) {\n          clearTimeout(timer);\n          clearInterval(interval);\n\n          // Get task result\n          const task = await this.db.getTask(taskId);\n          resolve(task.result ? JSON.parse(task.result) : {});\n        }\n      };\n\n      const interval = setInterval(checkCompletion, 1000);\n    });\n  }\n\n  /**\n   * Aggregate results from phase execution\n   */\n  private aggregatePhaseResults(phase: string, results: any[]): any {\n    return {\n      phase,\n      results,\n      summary: this.summarizeResults(results),\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Summarize phase results\n   */\n  private summarizeResults(results: any[]): any {\n    const successful = results.filter((r) => r.success).length;\n    const total = results.length;\n\n    return {\n      successRate: total > 0 ? successful / total : 0,\n      totalExecutions: total,\n      aggregatedData: results.map((r) => r.data).filter(Boolean),\n    };\n  }\n\n  /**\n   * Queue assignment for later\n   */\n  private queueAssignment(taskId: string, assignment: TaskAssignment): void {\n    if (!this.taskAssignments.has(taskId)) {\n      this.taskAssignments.set(taskId, []);\n    }\n\n    this.taskAssignments.get(taskId)!.push(assignment);\n    this.emit('assignmentQueued', { taskId, assignment });\n  }\n\n  /**\n   * Evaluate checkpoint\n   */\n  private async evaluateCheckpoint(task: Task, checkpoint: any, execution: any): Promise<void> {\n    const phaseResult = execution.phaseResults[checkpoint.index];\n\n    if (!phaseResult) return;\n\n    let score = 0;\n    for (const criterion of checkpoint.validationCriteria) {\n      const criterionScore = this.evaluateCriterion(phaseResult, criterion);\n      score += criterionScore * criterion.weight;\n    }\n\n    if (score < checkpoint.failureThreshold) {\n      throw new Error(`Checkpoint failed at phase ${checkpoint.phase}: score ${score}`);\n    }\n\n    this.emit('checkpointPassed', { task, checkpoint, score });\n  }\n\n  /**\n   * Evaluate validation criterion\n   */\n  private evaluateCriterion(result: any, criterion: any): number {\n    // Simplified evaluation - in production would be more sophisticated\n    if (result.summary && result.summary.successRate !== undefined) {\n      return result.summary.successRate;\n    }\n    return 0.7; // Default passing score\n  }\n\n  /**\n   * Complete task execution\n   */\n  private async completeTask(task: Task, execution: any): Promise<void> {\n    const finalResult = {\n      success: true,\n      executionTime: Date.now() - execution.startTime,\n      phases: execution.phaseResults,\n      summary: this.createExecutionSummary(execution),\n    };\n\n    await this.db.updateTask(task.id, {\n      status: 'completed',\n      result: JSON.stringify(finalResult),\n      progress: 100,\n      completed_at: new Date(),\n    });\n\n    this.emit('taskCompleted', { task, result: finalResult });\n  }\n\n  /**\n   * Handle task failure\n   */\n  private async handleTaskFailure(task: Task, execution: any, error: any): Promise<void> {\n    await this.db.updateTask(task.id, {\n      status: 'failed',\n      error: error.message,\n      completed_at: new Date(),\n    });\n\n    this.emit('taskFailed', { task, error });\n  }\n\n  /**\n   * Create execution summary\n   */\n  private createExecutionSummary(execution: any): any {\n    const phaseCount = execution.phaseResults.length;\n    const successfulPhases = execution.phaseResults.filter(\n      (r) => r.summary?.successRate > 0.5,\n    ).length;\n\n    return {\n      totalPhases: phaseCount,\n      successfulPhases,\n      overallSuccess: phaseCount > 0 ? successfulPhases / phaseCount : 0,\n      executionTime: Date.now() - execution.startTime,\n    };\n  }\n\n  /**\n   * Notify agent of task cancellation\n   */\n  private async notifyAgentTaskCancelled(agentId: string, taskId: string): Promise<void> {\n    // Send cancellation message to agent\n    await this.db.createCommunication({\n      from_agent_id: 'orchestrator',\n      to_agent_id: agentId,\n      swarm_id: this.hiveMind.id,\n      message_type: 'task_cancellation',\n      content: JSON.stringify({ taskId, reason: 'User cancelled' }),\n      priority: 'urgent',\n    });\n  }\n\n  /**\n   * Analyze load distribution\n   */\n  private async analyzeLoadDistribution(): Promise<any> {\n    const agents = await this.hiveMind.getAgents();\n    const tasks = await this.db.getActiveTasks(this.hiveMind.id);\n\n    const busyAgents = agents.filter((a) => a.status === 'busy');\n    const idleAgents = agents.filter((a) => a.status === 'idle');\n    const unassignedTasks = tasks.filter(\n      (t) => !t.assigned_agents || JSON.parse(t.assigned_agents).length === 0,\n    );\n\n    return {\n      totalAgents: agents.length,\n      busyAgents: busyAgents.length,\n      idleAgents: idleAgents.length,\n      activeTasks: tasks.length,\n      unassignedTasks: unassignedTasks.map((t) => ({\n        id: t.id,\n        priority: t.priority,\n        requiredCapabilities: JSON.parse(t.required_capabilities || '[]'),\n      })),\n      loadFactor: agents.length > 0 ? busyAgents.length / agents.length : 0,\n    };\n  }\n\n  /**\n   * Apply load balancing reassignments\n   */\n  private async applyReassignments(reassignments: any[]): Promise<void> {\n    for (const reassignment of reassignments) {\n      await this.reassignTask(reassignment.taskId, reassignment.fromAgent, reassignment.toAgent);\n    }\n  }\n\n  /**\n   * Reassign task from one agent to another\n   */\n  private async reassignTask(\n    taskId: string,\n    fromAgentId: string,\n    toAgentId: string,\n  ): Promise<void> {\n    // Update task assignment\n    await this.db.reassignTask(taskId, toAgentId);\n\n    // Update agent states\n    await this.db.updateAgent(fromAgentId, {\n      current_task_id: null,\n      status: 'idle',\n    });\n\n    await this.db.updateAgent(toAgentId, {\n      current_task_id: taskId,\n      status: 'busy',\n    });\n\n    // Notify agents\n    await this.notifyAgentReassignment(fromAgentId, toAgentId, taskId);\n  }\n\n  /**\n   * Notify agents of reassignment\n   */\n  private async notifyAgentReassignment(\n    fromAgentId: string,\n    toAgentId: string,\n    taskId: string,\n  ): Promise<void> {\n    // Notify source agent\n    await this.db.createCommunication({\n      from_agent_id: 'orchestrator',\n      to_agent_id: fromAgentId,\n      swarm_id: this.hiveMind.id,\n      message_type: 'task_reassignment',\n      content: JSON.stringify({ taskId, reassignedTo: toAgentId }),\n      priority: 'high',\n    });\n\n    // Notify target agent\n    const task = await this.db.getTask(taskId);\n    const plan = this.executionPlans.get(taskId);\n\n    await this.db.createCommunication({\n      from_agent_id: 'orchestrator',\n      to_agent_id: toAgentId,\n      swarm_id: this.hiveMind.id,\n      message_type: 'task_assignment',\n      content: JSON.stringify({\n        taskId,\n        task: task.description,\n        executionPlan: plan,\n      }),\n      priority: 'high',\n    });\n  }\n\n  /**\n   * Start task distributor loop\n   */\n  private startTaskDistributor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Check for queued assignments\n        for (const [taskId, assignments] of this.taskAssignments) {\n          for (const assignment of assignments) {\n            const agent = await this.findSuitableAgent(assignment.requiredCapabilities);\n            if (agent) {\n              await this.assignTaskToAgent(taskId, agent.id);\n              // Remove from queue\n              const remaining = assignments.filter((a) => a !== assignment);\n              if (remaining.length === 0) {\n                this.taskAssignments.delete(taskId);\n              } else {\n                this.taskAssignments.set(taskId, remaining);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 5000); // Every 5 seconds\n  }\n\n  /**\n   * Start progress monitor loop\n   */\n  private startProgressMonitor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Monitor active executions\n        for (const [taskId, execution] of this.activeExecutions) {\n          const task = await this.db.getTask(taskId);\n\n          if (task.status === 'in_progress') {\n            const progress = this.calculateProgress(execution);\n\n            if (progress !== task.progress) {\n              await this.db.updateTask(taskId, { progress });\n              this.emit('progressUpdate', { taskId, progress });\n            }\n          }\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 2000); // Every 2 seconds\n  }\n\n  /**\n   * Start load balancer loop\n   */\n  private startLoadBalancer(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        const load = await this.analyzeLoadDistribution();\n\n        // Trigger rebalancing if needed\n        if (\n          load.loadFactor > 0.8 &&\n          load.idleAgents.length > 0 &&\n          load.unassignedTasks.length > 0\n        ) {\n          await this.rebalance();\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 30000); // Every 30 seconds\n  }\n\n  /**\n   * Calculate task progress\n   */\n  private calculateProgress(execution: any): number {\n    if (!execution.plan || !execution.plan.phases) return 0;\n\n    const totalPhases = execution.plan.phases.length;\n    const completedPhases = execution.currentPhase;\n\n    return Math.round((completedPhases / totalPhases) * 100);\n  }\n\n  /**\n   * Shutdown orchestrator\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Cancel all active executions\n    for (const taskId of this.activeExecutions.keys()) {\n      await this.cancelTask(taskId);\n    }\n\n    this.emit('shutdown');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
