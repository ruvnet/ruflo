{"version":3,"sources":["../../../src/neural/NeuralDomainMapper.ts"],"sourcesContent":["/**\r\n * Neural Domain Mapper - GNN-style Domain Relationship Mapping\r\n * \r\n * Implements Graph Neural Network (GNN) architecture for mapping and analyzing\r\n * domain relationships, calculating cohesion scores, identifying cross-domain\r\n * dependencies, and providing predictive boundary optimization.\r\n * \r\n * This class enables advanced domain analysis and relationship mapping for\r\n * the Claude Flow orchestration system, supporting dynamic domain boundaries\r\n * and intelligent task routing based on learned patterns.\r\n * \r\n * @author Claude Flow Neural Team\r\n * @version 2.0.0\r\n * @since 2024-12-01\r\n */\r\n\r\nimport type {\r\n  Pattern,\r\n  TrainingData,\r\n  Prediction,\r\n  Adaptation,\r\n  AgenticHookContext,\r\n  PerformanceMetric,\r\n  PatternStore,\r\n  TrainingState,\r\n} from '../services/agentic-flow-hooks/types.js';\r\nimport { EventEmitter } from 'events';\r\n\r\n// ===== Core Types =====\r\n\r\n/**\r\n * Represents a domain node in the neural network graph\r\n */\r\nexport interface DomainNode {\r\n  /** Unique identifier for the domain */\r\n  id: string;\r\n  /** Human-readable domain name */\r\n  name: string;\r\n  /** Domain type classification */\r\n  type: 'functional' | 'technical' | 'business' | 'integration' | 'data' | 'ui' | 'api';\r\n  /** Node features vector for neural processing */\r\n  features: number[];\r\n  /** Domain-specific metadata */\r\n  metadata: {\r\n    size: number;\r\n    complexity: number;\r\n    stability: number;\r\n    dependencies: string[];\r\n    lastUpdated: number;\r\n    version: string;\r\n  };\r\n  /** Current activation state */\r\n  activation: number;\r\n  /** Learning parameters */\r\n  embedding: number[];\r\n}\r\n\r\n/**\r\n * Represents an edge connection between domains\r\n */\r\nexport interface DomainEdge {\r\n  /** Source domain ID */\r\n  source: string;\r\n  /** Target domain ID */\r\n  target: string;\r\n  /** Edge weight representing relationship strength */\r\n  weight: number;\r\n  /** Type of relationship */\r\n  type: 'dependency' | 'communication' | 'data-flow' | 'inheritance' | 'composition' | 'aggregation';\r\n  /** Edge features for neural processing */\r\n  features: number[];\r\n  /** Relationship metadata */\r\n  metadata: {\r\n    frequency: number;\r\n    latency: number;\r\n    reliability: number;\r\n    bandwidth: number;\r\n    direction: 'bidirectional' | 'unidirectional';\r\n  };\r\n}\r\n\r\n/**\r\n * Graph structure containing domains and their relationships\r\n */\r\nexport interface DomainGraph {\r\n  /** Collection of domain nodes */\r\n  nodes: Map<string, DomainNode>;\r\n  /** Collection of domain edges */\r\n  edges: Map<string, DomainEdge>;\r\n  /** Graph-level metadata */\r\n  metadata: {\r\n    created: number;\r\n    lastTraining: number;\r\n    version: string;\r\n    cohesionScore: number;\r\n    totalNodes: number;\r\n    totalEdges: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Domain cohesion analysis result\r\n */\r\nexport interface CohesionAnalysis {\r\n  /** Overall cohesion score (0-1) */\r\n  overallScore: number;\r\n  /** Per-domain cohesion scores */\r\n  domainScores: Map<string, number>;\r\n  /** Cohesion factors breakdown */\r\n  factors: {\r\n    structural: number;\r\n    functional: number;\r\n    behavioral: number;\r\n    semantic: number;\r\n  };\r\n  /** Identified weak points */\r\n  weakPoints: Array<{\r\n    domainId: string;\r\n    score: number;\r\n    reason: string;\r\n    suggestions: string[];\r\n  }>;\r\n  /** Optimization recommendations */\r\n  recommendations: Array<{\r\n    type: 'restructure' | 'merge' | 'split' | 'strengthen';\r\n    target: string[];\r\n    impact: number;\r\n    confidence: number;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Cross-domain dependency analysis result\r\n */\r\nexport interface DependencyAnalysis {\r\n  /** Dependency graph */\r\n  graph: Map<string, string[]>;\r\n  /** Circular dependencies detected */\r\n  circularDependencies: string[][];\r\n  /** Critical paths */\r\n  criticalPaths: Array<{\r\n    path: string[];\r\n    risk: number;\r\n    impact: number;\r\n  }>;\r\n  /** Dependency metrics */\r\n  metrics: {\r\n    averageInDegree: number;\r\n    averageOutDegree: number;\r\n    maxDepth: number;\r\n    cyclomaticComplexity: number;\r\n  };\r\n  /** Optimization suggestions */\r\n  optimizations: Array<{\r\n    type: 'break-cycle' | 'reduce-coupling' | 'add-abstraction';\r\n    affected: string[];\r\n    benefit: number;\r\n    effort: number;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Boundary optimization configuration\r\n */\r\nexport interface BoundaryOptimization {\r\n  /** Proposed boundary changes */\r\n  proposals: Array<{\r\n    id: string;\r\n    type: 'merge' | 'split' | 'relocate' | 'abstract';\r\n    domains: string[];\r\n    newBoundary?: {\r\n      nodes: string[];\r\n      edges: DomainEdge[];\r\n    };\r\n    metrics: {\r\n      cohesionImprovement: number;\r\n      couplingReduction: number;\r\n      performanceImpact: number;\r\n      maintainabilityImpact: number;\r\n    };\r\n    confidence: number;\r\n  }>;\r\n  /** Overall optimization score */\r\n  optimizationScore: number;\r\n  /** Implementation priority */\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n}\r\n\r\n/**\r\n * GNN layer configuration\r\n */\r\nexport interface GNNLayerConfig {\r\n  /** Layer type */\r\n  type: 'gcn' | 'gat' | 'sage' | 'gin' | 'transformer';\r\n  /** Input feature dimension */\r\n  inputDim: number;\r\n  /** Output feature dimension */\r\n  outputDim: number;\r\n  /** Number of attention heads (for GAT) */\r\n  numHeads?: number;\r\n  /** Dropout rate */\r\n  dropout: number;\r\n  /** Activation function */\r\n  activation: 'relu' | 'tanh' | 'sigmoid' | 'gelu' | 'swish';\r\n  /** Normalization */\r\n  normalization?: 'batch' | 'layer' | 'graph';\r\n}\r\n\r\n/**\r\n * Neural Domain Mapper training configuration\r\n */\r\nexport interface TrainingConfig {\r\n  /** Learning rate */\r\n  learningRate: number;\r\n  /** Batch size */\r\n  batchSize: number;\r\n  /** Number of epochs */\r\n  epochs: number;\r\n  /** Optimizer type */\r\n  optimizer: 'adam' | 'sgd' | 'rmsprop' | 'adamw';\r\n  /** Loss function */\r\n  lossFunction: 'mse' | 'cross-entropy' | 'contrastive' | 'triplet';\r\n  /** Regularization */\r\n  regularization: {\r\n    l1: number;\r\n    l2: number;\r\n    dropout: number;\r\n  };\r\n  /** Early stopping */\r\n  earlyStoping: {\r\n    enabled: boolean;\r\n    patience: number;\r\n    minDelta: number;\r\n  };\r\n  /** Validation split */\r\n  validationSplit: number;\r\n}\r\n\r\n// ===== Main Class =====\r\n\r\n/**\r\n * Neural Domain Mapper - Advanced GNN-based domain relationship analysis\r\n * \r\n * This class implements a sophisticated Graph Neural Network architecture\r\n * for analyzing and optimizing domain relationships in complex systems.\r\n * It provides capabilities for:\r\n * \r\n * 1. Converting domain structures to graph representations\r\n * 2. Calculating domain cohesion scores using multiple metrics\r\n * 3. Identifying and analyzing cross-domain dependencies\r\n * 4. Providing predictive boundary optimization suggestions\r\n * 5. Training on domain relationship patterns\r\n * 6. Making inferences about optimal domain organization\r\n */\r\nexport class NeuralDomainMapper extends EventEmitter {\r\n  private graph: DomainGraph;\r\n  private layers: GNNLayerConfig[];\r\n  private trainingConfig: TrainingConfig;\r\n  private trainingState: TrainingState;\r\n  private patternStore: PatternStore;\r\n  private isTraining: boolean = false;\r\n  private modelVersion: string = '1.0.0';\r\n  private weights: Map<string, number[]> = new Map();\r\n  private biases: Map<string, number[]> = new Map();\r\n\r\n  /**\r\n   * Initialize the Neural Domain Mapper\r\n   * \r\n   * @param config Training configuration\r\n   * @param patternStore Pattern storage system\r\n   */\r\n  constructor(\r\n    config: Partial<TrainingConfig> = {},\r\n    patternStore?: PatternStore\r\n  ) {\r\n    super();\r\n    \r\n    this.trainingConfig = {\r\n      learningRate: 0.001,\r\n      batchSize: 32,\r\n      epochs: 100,\r\n      optimizer: 'adam',\r\n      lossFunction: 'mse',\r\n      regularization: {\r\n        l1: 0.0001,\r\n        l2: 0.0001,\r\n        dropout: 0.1,\r\n      },\r\n      earlyStoping: {\r\n        enabled: true,\r\n        patience: 10,\r\n        minDelta: 0.001,\r\n      },\r\n      validationSplit: 0.2,\r\n      ...config,\r\n    };\r\n\r\n    this.graph = {\r\n      nodes: new Map(),\r\n      edges: new Map(),\r\n      metadata: {\r\n        created: Date.now(),\r\n        lastTraining: 0,\r\n        version: this.modelVersion,\r\n        cohesionScore: 0,\r\n        totalNodes: 0,\r\n        totalEdges: 0,\r\n      },\r\n    };\r\n\r\n    this.layers = [\r\n      {\r\n        type: 'gcn',\r\n        inputDim: 64,\r\n        outputDim: 128,\r\n        dropout: 0.1,\r\n        activation: 'relu',\r\n        normalization: 'batch',\r\n      },\r\n      {\r\n        type: 'gat',\r\n        inputDim: 128,\r\n        outputDim: 64,\r\n        numHeads: 8,\r\n        dropout: 0.1,\r\n        activation: 'relu',\r\n        normalization: 'layer',\r\n      },\r\n      {\r\n        type: 'gcn',\r\n        inputDim: 64,\r\n        outputDim: 32,\r\n        dropout: 0.05,\r\n        activation: 'tanh',\r\n      },\r\n    ];\r\n\r\n    this.trainingState = {\r\n      epoch: 0,\r\n      loss: Infinity,\r\n      accuracy: 0,\r\n      learningRate: this.trainingConfig.learningRate,\r\n      optimizer: this.trainingConfig.optimizer,\r\n      checkpoints: [],\r\n    };\r\n\r\n    this.patternStore = patternStore || this.createDefaultPatternStore();\r\n    this.initializeWeights();\r\n  }\r\n\r\n  // ===== Domain to Graph Conversion =====\r\n\r\n  /**\r\n   * Convert domain structure to graph format\r\n   * \r\n   * @param domains Domain definitions\r\n   * @param relationships Domain relationships\r\n   * @returns Constructed domain graph\r\n   */\r\n  public convertToGraph(\r\n    domains: Array<{\r\n      id: string;\r\n      name: string;\r\n      type: DomainNode['type'];\r\n      metadata: any;\r\n    }>,\r\n    relationships: Array<{\r\n      source: string;\r\n      target: string;\r\n      type: DomainEdge['type'];\r\n      weight?: number;\r\n      metadata?: any;\r\n    }>\r\n  ): DomainGraph {\r\n    // Clear existing graph\r\n    this.graph.nodes.clear();\r\n    this.graph.edges.clear();\r\n\r\n    // Convert domains to nodes\r\n    for (const domain of domains) {\r\n      const node: DomainNode = {\r\n        id: domain.id,\r\n        name: domain.name,\r\n        type: domain.type,\r\n        features: this.extractDomainFeatures(domain),\r\n        metadata: {\r\n          size: domain.metadata?.size || 1,\r\n          complexity: domain.metadata?.complexity || 0.5,\r\n          stability: domain.metadata?.stability || 0.8,\r\n          dependencies: domain.metadata?.dependencies || [],\r\n          lastUpdated: domain.metadata?.lastUpdated || Date.now(),\r\n          version: domain.metadata?.version || '1.0.0',\r\n        },\r\n        activation: 0,\r\n        embedding: this.initializeNodeEmbedding(domain.id),\r\n      };\r\n      \r\n      this.graph.nodes.set(domain.id, node);\r\n    }\r\n\r\n    // Convert relationships to edges\r\n    for (const rel of relationships) {\r\n      const edgeId = `${rel.source}->${rel.target}`;\r\n      const edge: DomainEdge = {\r\n        source: rel.source,\r\n        target: rel.target,\r\n        weight: rel.weight || 1.0,\r\n        type: rel.type,\r\n        features: this.extractEdgeFeatures(rel),\r\n        metadata: {\r\n          frequency: rel.metadata?.frequency || 1,\r\n          latency: rel.metadata?.latency || 100,\r\n          reliability: rel.metadata?.reliability || 0.99,\r\n          bandwidth: rel.metadata?.bandwidth || 1000,\r\n          direction: rel.metadata?.direction || 'unidirectional',\r\n        },\r\n      };\r\n      \r\n      this.graph.edges.set(edgeId, edge);\r\n    }\r\n\r\n    // Update graph metadata\r\n    this.graph.metadata.totalNodes = this.graph.nodes.size;\r\n    this.graph.metadata.totalEdges = this.graph.edges.size;\r\n    this.graph.metadata.lastTraining = 0; // Reset training timestamp\r\n\r\n    this.emit('graph-updated', this.graph);\r\n    return this.graph;\r\n  }\r\n\r\n  /**\r\n   * Extract numerical features from domain definition\r\n   */\r\n  private extractDomainFeatures(domain: any): number[] {\r\n    const features: number[] = [];\r\n    \r\n    // Type encoding (one-hot)\r\n    const types = ['functional', 'technical', 'business', 'integration', 'data', 'ui', 'api'];\r\n    const typeEncoding = types.map(t => t === domain.type ? 1 : 0);\r\n    features.push(...typeEncoding);\r\n    \r\n    // Metadata features\r\n    features.push(\r\n      domain.metadata?.size || 1,\r\n      domain.metadata?.complexity || 0.5,\r\n      domain.metadata?.stability || 0.8,\r\n      (domain.metadata?.dependencies?.length || 0) / 10, // Normalized dependency count\r\n      Math.min((Date.now() - (domain.metadata?.lastUpdated || Date.now())) / (1000 * 60 * 60 * 24), 1), // Age in days, capped at 1\r\n    );\r\n    \r\n    // Pad to standard feature size\r\n    while (features.length < 64) {\r\n      features.push(0);\r\n    }\r\n    \r\n    return features.slice(0, 64); // Ensure consistent size\r\n  }\r\n\r\n  /**\r\n   * Extract numerical features from edge definition\r\n   */\r\n  private extractEdgeFeatures(relationship: any): number[] {\r\n    const features: number[] = [];\r\n    \r\n    // Type encoding\r\n    const types = ['dependency', 'communication', 'data-flow', 'inheritance', 'composition', 'aggregation'];\r\n    const typeEncoding = types.map(t => t === relationship.type ? 1 : 0);\r\n    features.push(...typeEncoding);\r\n    \r\n    // Metadata features\r\n    features.push(\r\n      relationship.metadata?.frequency || 1,\r\n      relationship.metadata?.latency || 100,\r\n      relationship.metadata?.reliability || 0.99,\r\n      relationship.metadata?.bandwidth || 1000,\r\n      relationship.metadata?.direction === 'bidirectional' ? 1 : 0,\r\n    );\r\n    \r\n    // Pad to standard feature size\r\n    while (features.length < 32) {\r\n      features.push(0);\r\n    }\r\n    \r\n    return features.slice(0, 32);\r\n  }\r\n\r\n  // ===== Domain Cohesion Analysis =====\r\n\r\n  /**\r\n   * Calculate comprehensive domain cohesion scores\r\n   * \r\n   * @returns Detailed cohesion analysis\r\n   */\r\n  public async calculateDomainCohesion(): Promise<CohesionAnalysis> {\r\n    const domainScores = new Map<string, number>();\r\n    const weakPoints: Array<{\r\n      domainId: string;\r\n      score: number;\r\n      reason: string;\r\n      suggestions: string[];\r\n    }> = [];\r\n\r\n    let totalStructural = 0;\r\n    let totalFunctional = 0;\r\n    let totalBehavioral = 0;\r\n    let totalSemantic = 0;\r\n\r\n    // Calculate per-domain cohesion\r\n    for (const [domainId, node] of this.graph.nodes) {\r\n      const structural = this.calculateStructuralCohesion(domainId);\r\n      const functional = this.calculateFunctionalCohesion(domainId);\r\n      const behavioral = this.calculateBehavioralCohesion(domainId);\r\n      const semantic = this.calculateSemanticCohesion(domainId);\r\n      \r\n      const domainScore = (structural + functional + behavioral + semantic) / 4;\r\n      domainScores.set(domainId, domainScore);\r\n      \r\n      totalStructural += structural;\r\n      totalFunctional += functional;\r\n      totalBehavioral += behavioral;\r\n      totalSemantic += semantic;\r\n      \r\n      // Identify weak points\r\n      if (domainScore < 0.6) {\r\n        const suggestions = this.generateCohesionSuggestions(domainId, {\r\n          structural,\r\n          functional,\r\n          behavioral,\r\n          semantic,\r\n        });\r\n        \r\n        weakPoints.push({\r\n          domainId,\r\n          score: domainScore,\r\n          reason: this.identifyWeaknessReason(structural, functional, behavioral, semantic),\r\n          suggestions,\r\n        });\r\n      }\r\n    }\r\n\r\n    const nodeCount = this.graph.nodes.size;\r\n    const overallScore = Array.from(domainScores.values()).reduce((sum, score) => sum + score, 0) / nodeCount;\r\n    \r\n    const analysis: CohesionAnalysis = {\r\n      overallScore,\r\n      domainScores,\r\n      factors: {\r\n        structural: totalStructural / nodeCount,\r\n        functional: totalFunctional / nodeCount,\r\n        behavioral: totalBehavioral / nodeCount,\r\n        semantic: totalSemantic / nodeCount,\r\n      },\r\n      weakPoints,\r\n      recommendations: await this.generateCohesionRecommendations(domainScores, weakPoints),\r\n    };\r\n\r\n    // Update graph metadata\r\n    this.graph.metadata.cohesionScore = overallScore;\r\n    \r\n    this.emit('cohesion-calculated', analysis);\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * Calculate structural cohesion based on graph connectivity\r\n   */\r\n  private calculateStructuralCohesion(domainId: string): number {\r\n    const node = this.graph.nodes.get(domainId);\r\n    if (!node) return 0;\r\n\r\n    const outgoingEdges = Array.from(this.graph.edges.values()).filter(e => e.source === domainId);\r\n    const incomingEdges = Array.from(this.graph.edges.values()).filter(e => e.target === domainId);\r\n    \r\n    const totalEdges = outgoingEdges.length + incomingEdges.length;\r\n    const maxPossibleEdges = (this.graph.nodes.size - 1) * 2; // Bidirectional\r\n    \r\n    const connectivity = totalEdges / maxPossibleEdges;\r\n    \r\n    // Consider edge weights\r\n    const weightedConnectivity = (\r\n      outgoingEdges.reduce((sum, e) => sum + e.weight, 0) +\r\n      incomingEdges.reduce((sum, e) => sum + e.weight, 0)\r\n    ) / (totalEdges || 1);\r\n    \r\n    return Math.min((connectivity + weightedConnectivity) / 2, 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate functional cohesion based on domain purpose alignment\r\n   */\r\n  private calculateFunctionalCohesion(domainId: string): number {\r\n    const node = this.graph.nodes.get(domainId);\r\n    if (!node) return 0;\r\n\r\n    // Analyze connected domains for functional similarity\r\n    const connectedDomains = this.getConnectedDomains(domainId);\r\n    const sameTypePenalty = connectedDomains.filter(d => d.type === node.type).length / (connectedDomains.length || 1);\r\n    \r\n    // Consider domain complexity and size alignment\r\n    const avgComplexity = connectedDomains.reduce((sum, d) => sum + d.metadata.complexity, 0) / (connectedDomains.length || 1);\r\n    const complexityAlignment = 1 - Math.abs(node.metadata.complexity - avgComplexity);\r\n    \r\n    return (sameTypePenalty * 0.6 + complexityAlignment * 0.4);\r\n  }\r\n\r\n  /**\r\n   * Calculate behavioral cohesion based on interaction patterns\r\n   */\r\n  private calculateBehavioralCohesion(domainId: string): number {\r\n    const relatedEdges = Array.from(this.graph.edges.values()).filter(\r\n      e => e.source === domainId || e.target === domainId\r\n    );\r\n    \r\n    if (relatedEdges.length === 0) return 0.5; // Neutral for isolated domains\r\n    \r\n    // Analyze interaction frequency and reliability\r\n    const avgFrequency = relatedEdges.reduce((sum, e) => sum + e.metadata.frequency, 0) / relatedEdges.length;\r\n    const avgReliability = relatedEdges.reduce((sum, e) => sum + e.metadata.reliability, 0) / relatedEdges.length;\r\n    const avgLatency = relatedEdges.reduce((sum, e) => sum + e.metadata.latency, 0) / relatedEdges.length;\r\n    \r\n    // Normalize and combine metrics\r\n    const frequencyScore = Math.min(avgFrequency / 10, 1); // Assume 10 is high frequency\r\n    const reliabilityScore = avgReliability;\r\n    const latencyScore = Math.max(0, 1 - avgLatency / 1000); // Assume 1000ms is poor latency\r\n    \r\n    return (frequencyScore + reliabilityScore + latencyScore) / 3;\r\n  }\r\n\r\n  /**\r\n   * Calculate semantic cohesion based on domain naming and metadata\r\n   */\r\n  private calculateSemanticCohesion(domainId: string): number {\r\n    const node = this.graph.nodes.get(domainId);\r\n    if (!node) return 0;\r\n\r\n    const connectedDomains = this.getConnectedDomains(domainId);\r\n    \r\n    // Analyze naming similarity (simplified semantic analysis)\r\n    let semanticScore = 0;\r\n    for (const connectedDomain of connectedDomains) {\r\n      const nameSimilarity = this.calculateNameSimilarity(node.name, connectedDomain.name);\r\n      const typeSimilarity = node.type === connectedDomain.type ? 1 : 0.5;\r\n      semanticScore += (nameSimilarity + typeSimilarity) / 2;\r\n    }\r\n    \r\n    return connectedDomains.length > 0 ? semanticScore / connectedDomains.length : 0.5;\r\n  }\r\n\r\n  /**\r\n   * Get domains connected to the specified domain\r\n   */\r\n  private getConnectedDomains(domainId: string): DomainNode[] {\r\n    const connectedIds = new Set<string>();\r\n    \r\n    for (const edge of this.graph.edges.values()) {\r\n      if (edge.source === domainId) {\r\n        connectedIds.add(edge.target);\r\n      } else if (edge.target === domainId) {\r\n        connectedIds.add(edge.source);\r\n      }\r\n    }\r\n    \r\n    return Array.from(connectedIds)\r\n      .map(id => this.graph.nodes.get(id))\r\n      .filter(Boolean) as DomainNode[];\r\n  }\r\n\r\n  /**\r\n   * Calculate name similarity between two domain names\r\n   */\r\n  private calculateNameSimilarity(name1: string, name2: string): number {\r\n    const words1 = name1.toLowerCase().split(/[\\s\\-_]+/);\r\n    const words2 = name2.toLowerCase().split(/[\\s\\-_]+/);\r\n    \r\n    const commonWords = words1.filter(w => words2.includes(w));\r\n    const totalWords = new Set([...words1, ...words2]).size;\r\n    \r\n    return totalWords > 0 ? commonWords.length / totalWords : 0;\r\n  }\r\n\r\n  // ===== Cross-Domain Dependency Analysis =====\r\n\r\n  /**\r\n   * Identify and analyze cross-domain dependencies\r\n   * \r\n   * @returns Comprehensive dependency analysis\r\n   */\r\n  public async identifyCrossDomainDependencies(): Promise<DependencyAnalysis> {\r\n    const dependencyGraph = new Map<string, string[]>();\r\n    const circularDependencies: string[][] = [];\r\n    const criticalPaths: Array<{\r\n      path: string[];\r\n      risk: number;\r\n      impact: number;\r\n    }> = [];\r\n\r\n    // Build dependency graph\r\n    for (const [nodeId] of this.graph.nodes) {\r\n      const dependencies: string[] = [];\r\n      \r\n      for (const edge of this.graph.edges.values()) {\r\n        if (edge.source === nodeId && edge.type === 'dependency') {\r\n          dependencies.push(edge.target);\r\n        }\r\n      }\r\n      \r\n      dependencyGraph.set(nodeId, dependencies);\r\n    }\r\n\r\n    // Detect circular dependencies\r\n    const visited = new Set<string>();\r\n    const recursionStack = new Set<string>();\r\n\r\n    const detectCircularDFS = (nodeId: string, path: string[]): void => {\r\n      visited.add(nodeId);\r\n      recursionStack.add(nodeId);\r\n      path.push(nodeId);\r\n\r\n      const dependencies = dependencyGraph.get(nodeId) || [];\r\n      for (const depId of dependencies) {\r\n        if (!visited.has(depId)) {\r\n          detectCircularDFS(depId, [...path]);\r\n        } else if (recursionStack.has(depId)) {\r\n          // Found circular dependency\r\n          const cycleStart = path.indexOf(depId);\r\n          const cycle = path.slice(cycleStart);\r\n          circularDependencies.push([...cycle, depId]);\r\n        }\r\n      }\r\n\r\n      recursionStack.delete(nodeId);\r\n    };\r\n\r\n    for (const [nodeId] of this.graph.nodes) {\r\n      if (!visited.has(nodeId)) {\r\n        detectCircularDFS(nodeId, []);\r\n      }\r\n    }\r\n\r\n    // Identify critical paths\r\n    const calculateRisk = (path: string[]): number => {\r\n      let totalRisk = 0;\r\n      for (let i = 0; i < path.length - 1; i++) {\r\n        const edgeId = `${path[i]}->${path[i + 1]}`;\r\n        const edge = this.graph.edges.get(edgeId);\r\n        if (edge) {\r\n          // Risk based on reliability (inverted) and criticality\r\n          const reliability = edge.metadata.reliability;\r\n          const criticality = 1 - reliability;\r\n          totalRisk += criticality;\r\n        }\r\n      }\r\n      return totalRisk / (path.length - 1);\r\n    };\r\n\r\n    const calculateImpact = (path: string[]): number => {\r\n      // Impact based on number of affected domains\r\n      const affectedDomains = new Set<string>();\r\n      \r\n      for (const nodeId of path) {\r\n        // Find all domains that depend on nodes in this path\r\n        for (const [depId, deps] of dependencyGraph) {\r\n          if (deps.includes(nodeId)) {\r\n            affectedDomains.add(depId);\r\n          }\r\n        }\r\n      }\r\n      \r\n      return affectedDomains.size / this.graph.nodes.size;\r\n    };\r\n\r\n    // Find longest dependency chains as critical paths\r\n    const findLongestPaths = (nodeId: string, visited: Set<string>, path: string[]): void => {\r\n      if (path.length > 3) { // Consider paths longer than 3 as potentially critical\r\n        const risk = calculateRisk(path);\r\n        const impact = calculateImpact(path);\r\n        \r\n        if (risk > 0.3 || impact > 0.2) {\r\n          criticalPaths.push({\r\n            path: [...path],\r\n            risk,\r\n            impact,\r\n          });\r\n        }\r\n      }\r\n\r\n      const dependencies = dependencyGraph.get(nodeId) || [];\r\n      for (const depId of dependencies) {\r\n        if (!visited.has(depId)) {\r\n          visited.add(depId);\r\n          findLongestPaths(depId, visited, [...path, depId]);\r\n          visited.delete(depId);\r\n        }\r\n      }\r\n    };\r\n\r\n    for (const [nodeId] of this.graph.nodes) {\r\n      const visited = new Set([nodeId]);\r\n      findLongestPaths(nodeId, visited, [nodeId]);\r\n    }\r\n\r\n    // Calculate metrics\r\n    const inDegrees = new Map<string, number>();\r\n    const outDegrees = new Map<string, number>();\r\n    \r\n    for (const [nodeId] of this.graph.nodes) {\r\n      inDegrees.set(nodeId, 0);\r\n      outDegrees.set(nodeId, 0);\r\n    }\r\n    \r\n    for (const deps of dependencyGraph.values()) {\r\n      outDegrees.set(nodeId, deps.length);\r\n      for (const depId of deps) {\r\n        inDegrees.set(depId, (inDegrees.get(depId) || 0) + 1);\r\n      }\r\n    }\r\n\r\n    const averageInDegree = Array.from(inDegrees.values()).reduce((sum, deg) => sum + deg, 0) / this.graph.nodes.size;\r\n    const averageOutDegree = Array.from(outDegrees.values()).reduce((sum, deg) => sum + deg, 0) / this.graph.nodes.size;\r\n    \r\n    // Calculate maximum depth\r\n    const calculateMaxDepth = (nodeId: string, visited: Set<string>): number => {\r\n      if (visited.has(nodeId)) return 0;\r\n      visited.add(nodeId);\r\n      \r\n      const dependencies = dependencyGraph.get(nodeId) || [];\r\n      if (dependencies.length === 0) return 1;\r\n      \r\n      const depths = dependencies.map(depId => calculateMaxDepth(depId, new Set(visited)));\r\n      return 1 + Math.max(...depths, 0);\r\n    };\r\n\r\n    const depths = Array.from(this.graph.nodes.keys()).map(nodeId => calculateMaxDepth(nodeId, new Set()));\r\n    const maxDepth = Math.max(...depths, 0);\r\n\r\n    // Cyclomatic complexity (simplified)\r\n    const cyclomaticComplexity = this.graph.edges.size - this.graph.nodes.size + 2;\r\n\r\n    const analysis: DependencyAnalysis = {\r\n      graph: dependencyGraph,\r\n      circularDependencies,\r\n      criticalPaths: criticalPaths.sort((a, b) => (b.risk + b.impact) - (a.risk + a.impact)).slice(0, 10),\r\n      metrics: {\r\n        averageInDegree,\r\n        averageOutDegree,\r\n        maxDepth,\r\n        cyclomaticComplexity,\r\n      },\r\n      optimizations: await this.generateDependencyOptimizations(\r\n        dependencyGraph,\r\n        circularDependencies,\r\n        criticalPaths\r\n      ),\r\n    };\r\n\r\n    this.emit('dependencies-analyzed', analysis);\r\n    return analysis;\r\n  }\r\n\r\n  // ===== Predictive Boundary Optimization =====\r\n\r\n  /**\r\n   * Provide predictive boundary optimization suggestions\r\n   * \r\n   * @returns Boundary optimization recommendations\r\n   */\r\n  public async provideBoundaryOptimization(): Promise<BoundaryOptimization> {\r\n    const proposals: BoundaryOptimization['proposals'] = [];\r\n    \r\n    // Analyze current boundaries and identify optimization opportunities\r\n    const cohesionAnalysis = await this.calculateDomainCohesion();\r\n    const dependencyAnalysis = await this.identifyCrossDomainDependencies();\r\n    \r\n    // Generate merge proposals for highly coupled domains\r\n    await this.generateMergeProposals(proposals, cohesionAnalysis, dependencyAnalysis);\r\n    \r\n    // Generate split proposals for low-cohesion domains\r\n    await this.generateSplitProposals(proposals, cohesionAnalysis, dependencyAnalysis);\r\n    \r\n    // Generate relocation proposals for misplaced functionality\r\n    await this.generateRelocationProposals(proposals, cohesionAnalysis, dependencyAnalysis);\r\n    \r\n    // Generate abstraction proposals for common patterns\r\n    await this.generateAbstractionProposals(proposals, cohesionAnalysis, dependencyAnalysis);\r\n    \r\n    // Calculate overall optimization score\r\n    const optimizationScore = this.calculateOptimizationScore(proposals);\r\n    \r\n    // Determine priority based on current system health\r\n    const priority = this.determinePriority(cohesionAnalysis, dependencyAnalysis, optimizationScore);\r\n    \r\n    const optimization: BoundaryOptimization = {\r\n      proposals: proposals.sort((a, b) => b.confidence - a.confidence).slice(0, 20),\r\n      optimizationScore,\r\n      priority,\r\n    };\r\n\r\n    this.emit('optimization-generated', optimization);\r\n    return optimization;\r\n  }\r\n\r\n  // ===== Training Methods =====\r\n\r\n  /**\r\n   * Train the neural network on domain relationship patterns\r\n   * \r\n   * @param trainingData Training dataset\r\n   * @param validationData Validation dataset\r\n   * @returns Training results\r\n   */\r\n  public async train(\r\n    trainingData: TrainingData,\r\n    validationData?: TrainingData\r\n  ): Promise<{\r\n    finalAccuracy: number;\r\n    trainingHistory: Array<{\r\n      epoch: number;\r\n      loss: number;\r\n      accuracy: number;\r\n      validationLoss?: number;\r\n      validationAccuracy?: number;\r\n    }>;\r\n    bestModel: {\r\n      weights: Map<string, number[]>;\r\n      biases: Map<string, number[]>;\r\n    };\r\n  }> {\r\n    if (this.isTraining) {\r\n      throw new Error('Training already in progress');\r\n    }\r\n\r\n    this.isTraining = true;\r\n    this.emit('training-started', { trainingData, validationData });\r\n\r\n    try {\r\n      const trainingHistory: Array<{\r\n        epoch: number;\r\n        loss: number;\r\n        accuracy: number;\r\n        validationLoss?: number;\r\n        validationAccuracy?: number;\r\n      }> = [];\r\n\r\n      let bestAccuracy = 0;\r\n      let bestWeights = new Map(this.weights);\r\n      let bestBiases = new Map(this.biases);\r\n      let patienceCounter = 0;\r\n\r\n      // Training loop\r\n      for (let epoch = 0; epoch < this.trainingConfig.epochs; epoch++) {\r\n        this.trainingState.epoch = epoch;\r\n        \r\n        // Forward pass and backpropagation\r\n        const { loss, accuracy } = await this.trainEpoch(trainingData);\r\n        \r\n        // Validation\r\n        let validationLoss: number | undefined;\r\n        let validationAccuracy: number | undefined;\r\n        \r\n        if (validationData) {\r\n          const validationResults = await this.validateModel(validationData);\r\n          validationLoss = validationResults.loss;\r\n          validationAccuracy = validationResults.accuracy;\r\n        }\r\n\r\n        // Update training state\r\n        this.trainingState.loss = loss;\r\n        this.trainingState.accuracy = accuracy;\r\n        this.trainingState.validationLoss = validationLoss;\r\n        this.trainingState.validationAccuracy = validationAccuracy;\r\n\r\n        const epochResult = {\r\n          epoch,\r\n          loss,\r\n          accuracy,\r\n          validationLoss,\r\n          validationAccuracy,\r\n        };\r\n        trainingHistory.push(epochResult);\r\n\r\n        // Check for improvement\r\n        const currentAccuracy = validationAccuracy || accuracy;\r\n        if (currentAccuracy > bestAccuracy + this.trainingConfig.earlyStoping.minDelta) {\r\n          bestAccuracy = currentAccuracy;\r\n          bestWeights = new Map(this.weights);\r\n          bestBiases = new Map(this.biases);\r\n          patienceCounter = 0;\r\n        } else {\r\n          patienceCounter++;\r\n        }\r\n\r\n        // Early stopping\r\n        if (\r\n          this.trainingConfig.earlyStoping.enabled &&\r\n          patienceCounter >= this.trainingConfig.earlyStoping.patience\r\n        ) {\r\n          console.log(`Early stopping at epoch ${epoch}`);\r\n          break;\r\n        }\r\n\r\n        // Learning rate scheduling\r\n        if (epoch > 0 && epoch % 20 === 0) {\r\n          this.trainingConfig.learningRate *= 0.9;\r\n          this.trainingState.learningRate = this.trainingConfig.learningRate;\r\n        }\r\n\r\n        this.emit('epoch-completed', epochResult);\r\n      }\r\n\r\n      // Restore best model\r\n      this.weights = bestWeights;\r\n      this.biases = bestBiases;\r\n      \r\n      // Update graph metadata\r\n      this.graph.metadata.lastTraining = Date.now();\r\n\r\n      const result = {\r\n        finalAccuracy: bestAccuracy,\r\n        trainingHistory,\r\n        bestModel: {\r\n          weights: bestWeights,\r\n          biases: bestBiases,\r\n        },\r\n      };\r\n\r\n      this.emit('training-completed', result);\r\n      return result;\r\n\r\n    } finally {\r\n      this.isTraining = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Train a single epoch\r\n   */\r\n  private async trainEpoch(trainingData: TrainingData): Promise<{\r\n    loss: number;\r\n    accuracy: number;\r\n  }> {\r\n    const batchSize = this.trainingConfig.batchSize;\r\n    let totalLoss = 0;\r\n    let correct = 0;\r\n    let total = 0;\r\n\r\n    // Shuffle training data\r\n    const indices = Array.from({ length: trainingData.inputs.length }, (_, i) => i);\r\n    this.shuffleArray(indices);\r\n\r\n    // Process batches\r\n    for (let i = 0; i < indices.length; i += batchSize) {\r\n      const batchIndices = indices.slice(i, i + batchSize);\r\n      const batchInputs = batchIndices.map(idx => trainingData.inputs[idx]);\r\n      const batchTargets = batchIndices.map(idx => trainingData.outputs[idx]);\r\n\r\n      const { loss, accuracy } = await this.processBatch(batchInputs, batchTargets);\r\n      \r\n      totalLoss += loss;\r\n      correct += accuracy * batchIndices.length;\r\n      total += batchIndices.length;\r\n    }\r\n\r\n    return {\r\n      loss: totalLoss / Math.ceil(indices.length / batchSize),\r\n      accuracy: correct / total,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Process a single batch\r\n   */\r\n  private async processBatch(\r\n    inputs: any[],\r\n    targets: any[]\r\n  ): Promise<{ loss: number; accuracy: number }> {\r\n    // Forward pass\r\n    const predictions = inputs.map(input => this.forwardPass(input));\r\n    \r\n    // Calculate loss\r\n    const loss = this.calculateLoss(predictions, targets);\r\n    \r\n    // Calculate accuracy\r\n    const accuracy = this.calculateAccuracy(predictions, targets);\r\n    \r\n    // Backward pass\r\n    await this.backwardPass(inputs, predictions, targets);\r\n    \r\n    return { loss, accuracy };\r\n  }\r\n\r\n  /**\r\n   * Forward pass through the network\r\n   */\r\n  private forwardPass(input: any): number[] {\r\n    let activation = this.preprocessInput(input);\r\n    \r\n    // Process through each layer\r\n    for (let i = 0; i < this.layers.length; i++) {\r\n      const layerConfig = this.layers[i];\r\n      const weights = this.weights.get(`layer_${i}`) || [];\r\n      const biases = this.biases.get(`layer_${i}`) || [];\r\n      \r\n      activation = this.processLayer(activation, weights, biases, layerConfig);\r\n    }\r\n    \r\n    return activation;\r\n  }\r\n\r\n  /**\r\n   * Backward pass for gradient calculation and weight updates\r\n   */\r\n  private async backwardPass(\r\n    inputs: any[],\r\n    predictions: number[][],\r\n    targets: any[]\r\n  ): Promise<void> {\r\n    // Calculate output gradients\r\n    const outputGradients = this.calculateOutputGradients(predictions, targets);\r\n    \r\n    // Backpropagate through layers\r\n    let gradients = outputGradients;\r\n    \r\n    for (let i = this.layers.length - 1; i >= 0; i--) {\r\n      const layerConfig = this.layers[i];\r\n      const weights = this.weights.get(`layer_${i}`) || [];\r\n      const biases = this.biases.get(`layer_${i}`) || [];\r\n      \r\n      const { weightGradients, biasGradients, inputGradients } = \r\n        this.calculateLayerGradients(gradients, weights, biases, layerConfig);\r\n      \r\n      // Update weights and biases\r\n      this.updateWeights(`layer_${i}`, weights, weightGradients);\r\n      this.updateBiases(`layer_${i}`, biases, biasGradients);\r\n      \r\n      gradients = inputGradients;\r\n    }\r\n  }\r\n\r\n  // ===== Inference Methods =====\r\n\r\n  /**\r\n   * Make predictions using the trained model\r\n   * \r\n   * @param input Input data for prediction\r\n   * @returns Prediction results\r\n   */\r\n  public async predict(input: any): Promise<Prediction> {\r\n    if (this.isTraining) {\r\n      throw new Error('Cannot make predictions during training');\r\n    }\r\n\r\n    const output = this.forwardPass(input);\r\n    const confidence = this.calculatePredictionConfidence(output);\r\n    \r\n    // Generate alternatives using dropout or ensemble\r\n    const alternatives = await this.generateAlternativePredictions(input, 5);\r\n    \r\n    const prediction: Prediction = {\r\n      input,\r\n      output,\r\n      confidence,\r\n      alternatives,\r\n    };\r\n\r\n    this.emit('prediction-made', prediction);\r\n    return prediction;\r\n  }\r\n\r\n  /**\r\n   * Analyze domain relationships and suggest optimizations\r\n   * \r\n   * @param domains Domain configuration to analyze\r\n   * @returns Analysis results with optimization suggestions\r\n   */\r\n  public async analyzeDomains(domains: DomainGraph): Promise<{\r\n    cohesion: CohesionAnalysis;\r\n    dependencies: DependencyAnalysis;\r\n    optimization: BoundaryOptimization;\r\n    recommendations: string[];\r\n  }> {\r\n    // Update internal graph\r\n    this.graph = { ...domains };\r\n    \r\n    // Perform comprehensive analysis\r\n    const [cohesion, dependencies, optimization] = await Promise.all([\r\n      this.calculateDomainCohesion(),\r\n      this.identifyCrossDomainDependencies(),\r\n      this.provideBoundaryOptimization(),\r\n    ]);\r\n    \r\n    // Generate high-level recommendations\r\n    const recommendations = this.generateHighLevelRecommendations(\r\n      cohesion,\r\n      dependencies,\r\n      optimization\r\n    );\r\n    \r\n    const analysis = {\r\n      cohesion,\r\n      dependencies,\r\n      optimization,\r\n      recommendations,\r\n    };\r\n\r\n    this.emit('domains-analyzed', analysis);\r\n    return analysis;\r\n  }\r\n\r\n  // ===== Helper Methods =====\r\n\r\n  private createDefaultPatternStore(): PatternStore {\r\n    const patterns = new Map<string, Pattern>();\r\n    \r\n    return {\r\n      add: (pattern: Pattern) => patterns.set(pattern.id, pattern),\r\n      get: (id: string) => patterns.get(id),\r\n      findSimilar: (pattern: Partial<Pattern>, threshold: number) => {\r\n        return Array.from(patterns.values()).filter(p => \r\n          this.calculatePatternSimilarity(p, pattern) >= threshold\r\n        );\r\n      },\r\n      getByType: (type: Pattern['type']) => {\r\n        return Array.from(patterns.values()).filter(p => p.type === type);\r\n      },\r\n      prune: (maxAge: number) => {\r\n        const cutoff = Date.now() - maxAge;\r\n        for (const [id, pattern] of patterns) {\r\n          if (Date.now() - maxAge > cutoff) {\r\n            patterns.delete(id);\r\n          }\r\n        }\r\n      },\r\n      export: () => Array.from(patterns.values()),\r\n      import: (importedPatterns: Pattern[]) => {\r\n        for (const pattern of importedPatterns) {\r\n          patterns.set(pattern.id, pattern);\r\n        }\r\n      },\r\n    };\r\n  }\r\n\r\n  private initializeNodeEmbedding(nodeId: string): number[] {\r\n    return Array.from({ length: 32 }, () => (Math.random() - 0.5) * 0.1);\r\n  }\r\n\r\n  private initializeWeights(): void {\r\n    for (let i = 0; i < this.layers.length; i++) {\r\n      const layer = this.layers[i];\r\n      const inputDim = i === 0 ? 64 : this.layers[i - 1].outputDim;\r\n      const outputDim = layer.outputDim;\r\n      \r\n      // Xavier/Glorot initialization\r\n      const limit = Math.sqrt(6 / (inputDim + outputDim));\r\n      const weights = Array.from(\r\n        { length: inputDim * outputDim },\r\n        () => (Math.random() - 0.5) * 2 * limit\r\n      );\r\n      \r\n      const biases = Array.from({ length: outputDim }, () => 0);\r\n      \r\n      this.weights.set(`layer_${i}`, weights);\r\n      this.biases.set(`layer_${i}`, biases);\r\n    }\r\n  }\r\n\r\n  private shuffleArray<T>(array: T[]): void {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n  }\r\n\r\n  private preprocessInput(input: any): number[] {\r\n    // Convert input to numerical features\r\n    if (typeof input === 'object' && input.features) {\r\n      return input.features;\r\n    }\r\n    \r\n    // Default preprocessing\r\n    return Array.from({ length: 64 }, () => 0);\r\n  }\r\n\r\n  private processLayer(\r\n    input: number[],\r\n    weights: number[],\r\n    biases: number[],\r\n    config: GNNLayerConfig\r\n  ): number[] {\r\n    // Matrix multiplication: input * weights + biases\r\n    const output = new Array(config.outputDim).fill(0);\r\n    \r\n    for (let i = 0; i < config.outputDim; i++) {\r\n      let sum = biases[i] || 0;\r\n      for (let j = 0; j < input.length; j++) {\r\n        const weightIndex = j * config.outputDim + i;\r\n        sum += input[j] * (weights[weightIndex] || 0);\r\n      }\r\n      output[i] = this.applyActivation(sum, config.activation);\r\n    }\r\n    \r\n    // Apply dropout during training\r\n    if (this.isTraining && config.dropout > 0) {\r\n      for (let i = 0; i < output.length; i++) {\r\n        if (Math.random() < config.dropout) {\r\n          output[i] = 0;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return output;\r\n  }\r\n\r\n  private applyActivation(x: number, activation: string): number {\r\n    switch (activation) {\r\n      case 'relu':\r\n        return Math.max(0, x);\r\n      case 'tanh':\r\n        return Math.tanh(x);\r\n      case 'sigmoid':\r\n        return 1 / (1 + Math.exp(-x));\r\n      case 'gelu':\r\n        return 0.5 * x * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3))));\r\n      case 'swish':\r\n        return x / (1 + Math.exp(-x));\r\n      default:\r\n        return x;\r\n    }\r\n  }\r\n\r\n  private calculateLoss(predictions: number[][], targets: any[]): number {\r\n    let totalLoss = 0;\r\n    \r\n    for (let i = 0; i < predictions.length; i++) {\r\n      const pred = predictions[i];\r\n      const target = Array.isArray(targets[i]) ? targets[i] : [targets[i]];\r\n      \r\n      // Mean squared error\r\n      for (let j = 0; j < Math.min(pred.length, target.length); j++) {\r\n        const diff = pred[j] - target[j];\r\n        totalLoss += diff * diff;\r\n      }\r\n    }\r\n    \r\n    return totalLoss / predictions.length;\r\n  }\r\n\r\n  private calculateAccuracy(predictions: number[][], targets: any[]): number {\r\n    let correct = 0;\r\n    \r\n    for (let i = 0; i < predictions.length; i++) {\r\n      const pred = predictions[i];\r\n      const target = Array.isArray(targets[i]) ? targets[i] : [targets[i]];\r\n      \r\n      // Simple threshold-based accuracy for regression\r\n      let sampleCorrect = true;\r\n      for (let j = 0; j < Math.min(pred.length, target.length); j++) {\r\n        if (Math.abs(pred[j] - target[j]) > 0.1) {\r\n          sampleCorrect = false;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      if (sampleCorrect) correct++;\r\n    }\r\n    \r\n    return correct / predictions.length;\r\n  }\r\n\r\n  private calculateOutputGradients(predictions: number[][], targets: any[]): number[][] {\r\n    const gradients: number[][] = [];\r\n    \r\n    for (let i = 0; i < predictions.length; i++) {\r\n      const pred = predictions[i];\r\n      const target = Array.isArray(targets[i]) ? targets[i] : [targets[i]];\r\n      const sampleGradients: number[] = [];\r\n      \r\n      for (let j = 0; j < pred.length; j++) {\r\n        const targetVal = j < target.length ? target[j] : 0;\r\n        sampleGradients.push(2 * (pred[j] - targetVal));\r\n      }\r\n      \r\n      gradients.push(sampleGradients);\r\n    }\r\n    \r\n    return gradients;\r\n  }\r\n\r\n  private calculateLayerGradients(\r\n    outputGradients: number[][],\r\n    weights: number[],\r\n    biases: number[],\r\n    config: GNNLayerConfig\r\n  ): {\r\n    weightGradients: number[];\r\n    biasGradients: number[];\r\n    inputGradients: number[][];\r\n  } {\r\n    // Simplified gradient calculation\r\n    const weightGradients = new Array(weights.length).fill(0);\r\n    const biasGradients = new Array(biases.length).fill(0);\r\n    const inputGradients: number[][] = [];\r\n    \r\n    // This is a simplified implementation\r\n    // In practice, you'd need proper matrix operations and chain rule application\r\n    \r\n    for (let i = 0; i < outputGradients.length; i++) {\r\n      const sampleInputGradients = new Array(config.inputDim).fill(0);\r\n      \r\n      for (let j = 0; j < outputGradients[i].length; j++) {\r\n        const grad = outputGradients[i][j];\r\n        \r\n        // Bias gradients\r\n        biasGradients[j] += grad;\r\n        \r\n        // Weight and input gradients would require activation functions and inputs\r\n        // This is simplified for demonstration\r\n      }\r\n      \r\n      inputGradients.push(sampleInputGradients);\r\n    }\r\n    \r\n    return { weightGradients, biasGradients, inputGradients };\r\n  }\r\n\r\n  private updateWeights(layerId: string, weights: number[], gradients: number[]): void {\r\n    const lr = this.trainingState.learningRate;\r\n    const l2 = this.trainingConfig.regularization.l2;\r\n    \r\n    for (let i = 0; i < weights.length && i < gradients.length; i++) {\r\n      weights[i] -= lr * (gradients[i] + l2 * weights[i]);\r\n    }\r\n    \r\n    this.weights.set(layerId, weights);\r\n  }\r\n\r\n  private updateBiases(layerId: string, biases: number[], gradients: number[]): void {\r\n    const lr = this.trainingState.learningRate;\r\n    \r\n    for (let i = 0; i < biases.length && i < gradients.length; i++) {\r\n      biases[i] -= lr * gradients[i];\r\n    }\r\n    \r\n    this.biases.set(layerId, biases);\r\n  }\r\n\r\n  private async validateModel(validationData: TrainingData): Promise<{\r\n    loss: number;\r\n    accuracy: number;\r\n  }> {\r\n    const predictions = validationData.inputs.map(input => this.forwardPass(input));\r\n    const loss = this.calculateLoss(predictions, validationData.outputs);\r\n    const accuracy = this.calculateAccuracy(predictions, validationData.outputs);\r\n    \r\n    return { loss, accuracy };\r\n  }\r\n\r\n  private calculatePredictionConfidence(output: number[]): number {\r\n    // Calculate confidence based on output certainty\r\n    const maxVal = Math.max(...output);\r\n    const minVal = Math.min(...output);\r\n    const range = maxVal - minVal;\r\n    \r\n    // Higher range indicates more confident prediction\r\n    return Math.min(range, 1);\r\n  }\r\n\r\n  private async generateAlternativePredictions(\r\n    input: any,\r\n    count: number\r\n  ): Promise<Array<{ output: any; confidence: number }>> {\r\n    const alternatives: Array<{ output: any; confidence: number }> = [];\r\n    \r\n    // Generate alternatives using noise injection\r\n    for (let i = 0; i < count; i++) {\r\n      const noisyInput = this.addNoiseToInput(input, 0.1);\r\n      const output = this.forwardPass(noisyInput);\r\n      const confidence = this.calculatePredictionConfidence(output);\r\n      \r\n      alternatives.push({ output, confidence });\r\n    }\r\n    \r\n    return alternatives.sort((a, b) => b.confidence - a.confidence);\r\n  }\r\n\r\n  private addNoiseToInput(input: any, noiseLevel: number): any {\r\n    if (typeof input === 'object' && input.features) {\r\n      const noisyFeatures = input.features.map((f: number) => \r\n        f + (Math.random() - 0.5) * noiseLevel\r\n      );\r\n      return { ...input, features: noisyFeatures };\r\n    }\r\n    \r\n    return input;\r\n  }\r\n\r\n  private calculatePatternSimilarity(p1: Pattern, p2: Partial<Pattern>): number {\r\n    // Simplified similarity calculation\r\n    let similarity = 0;\r\n    let factors = 0;\r\n    \r\n    if (p1.type === p2.type) {\r\n      similarity += 0.3;\r\n    }\r\n    factors++;\r\n    \r\n    if (p2.confidence !== undefined) {\r\n      similarity += 1 - Math.abs(p1.confidence - p2.confidence);\r\n      factors++;\r\n    }\r\n    \r\n    return similarity / factors;\r\n  }\r\n\r\n  // Additional helper methods would be implemented here for:\r\n  // - generateCohesionSuggestions\r\n  // - identifyWeaknessReason\r\n  // - generateCohesionRecommendations\r\n  // - generateDependencyOptimizations\r\n  // - generateMergeProposals\r\n  // - generateSplitProposals\r\n  // - generateRelocationProposals\r\n  // - generateAbstractionProposals\r\n  // - calculateOptimizationScore\r\n  // - determinePriority\r\n  // - generateHighLevelRecommendations\r\n\r\n  /**\r\n   * Get current model statistics\r\n   */\r\n  public getModelStats(): {\r\n    graphSize: { nodes: number; edges: number };\r\n    trainingState: TrainingState;\r\n    modelVersion: string;\r\n    lastTraining: number;\r\n    cohesionScore: number;\r\n  } {\r\n    return {\r\n      graphSize: {\r\n        nodes: this.graph.nodes.size,\r\n        edges: this.graph.edges.size,\r\n      },\r\n      trainingState: { ...this.trainingState },\r\n      modelVersion: this.modelVersion,\r\n      lastTraining: this.graph.metadata.lastTraining,\r\n      cohesionScore: this.graph.metadata.cohesionScore,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Export model state for persistence\r\n   */\r\n  public exportModel(): {\r\n    graph: DomainGraph;\r\n    weights: Record<string, number[]>;\r\n    biases: Record<string, number[]>;\r\n    trainingState: TrainingState;\r\n    config: TrainingConfig;\r\n  } {\r\n    return {\r\n      graph: this.graph,\r\n      weights: Object.fromEntries(this.weights),\r\n      biases: Object.fromEntries(this.biases),\r\n      trainingState: this.trainingState,\r\n      config: this.trainingConfig,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Import model state from persistence\r\n   */\r\n  public importModel(modelData: {\r\n    graph: DomainGraph;\r\n    weights: Record<string, number[]>;\r\n    biases: Record<string, number[]>;\r\n    trainingState: TrainingState;\r\n    config: TrainingConfig;\r\n  }): void {\r\n    this.graph = modelData.graph;\r\n    this.weights = new Map(Object.entries(modelData.weights));\r\n    this.biases = new Map(Object.entries(modelData.biases));\r\n    this.trainingState = modelData.trainingState;\r\n    this.trainingConfig = { ...this.trainingConfig, ...modelData.config };\r\n    \r\n    this.emit('model-imported', modelData);\r\n  }\r\n\r\n  // Stub implementations for remaining methods\r\n  private generateCohesionSuggestions(domainId: string, factors: any): string[] {\r\n    return ['Improve structural cohesion', 'Enhance functional alignment'];\r\n  }\r\n\r\n  private identifyWeaknessReason(structural: number, functional: number, behavioral: number, semantic: number): string {\r\n    const lowest = Math.min(structural, functional, behavioral, semantic);\r\n    if (lowest === structural) return 'Poor structural cohesion';\r\n    if (lowest === functional) return 'Low functional alignment';\r\n    if (lowest === behavioral) return 'Inconsistent behavior patterns';\r\n    return 'Weak semantic relationships';\r\n  }\r\n\r\n  private async generateCohesionRecommendations(domainScores: Map<string, number>, weakPoints: any[]): Promise<CohesionAnalysis['recommendations']> {\r\n    return [\r\n      {\r\n        type: 'restructure',\r\n        target: ['domain1', 'domain2'],\r\n        impact: 0.3,\r\n        confidence: 0.8,\r\n      },\r\n    ];\r\n  }\r\n\r\n  private async generateDependencyOptimizations(dependencyGraph: any, circularDependencies: any, criticalPaths: any): Promise<DependencyAnalysis['optimizations']> {\r\n    return [\r\n      {\r\n        type: 'break-cycle',\r\n        affected: ['domain1', 'domain2'],\r\n        benefit: 0.5,\r\n        effort: 0.3,\r\n      },\r\n    ];\r\n  }\r\n\r\n  private async generateMergeProposals(proposals: any[], cohesionAnalysis: any, dependencyAnalysis: any): Promise<void> {\r\n    // Implementation would analyze highly coupled domains for merge opportunities\r\n  }\r\n\r\n  private async generateSplitProposals(proposals: any[], cohesionAnalysis: any, dependencyAnalysis: any): Promise<void> {\r\n    // Implementation would identify large, low-cohesion domains for splitting\r\n  }\r\n\r\n  private async generateRelocationProposals(proposals: any[], cohesionAnalysis: any, dependencyAnalysis: any): Promise<void> {\r\n    // Implementation would suggest moving functionality between domains\r\n  }\r\n\r\n  private async generateAbstractionProposals(proposals: any[], cohesionAnalysis: any, dependencyAnalysis: any): Promise<void> {\r\n    // Implementation would identify common patterns for abstraction\r\n  }\r\n\r\n  private calculateOptimizationScore(proposals: any[]): number {\r\n    return proposals.reduce((score, p) => score + p.confidence * 0.1, 0);\r\n  }\r\n\r\n  private determinePriority(cohesionAnalysis: any, dependencyAnalysis: any, optimizationScore: number): 'low' | 'medium' | 'high' | 'critical' {\r\n    if (cohesionAnalysis.overallScore < 0.3) return 'critical';\r\n    if (optimizationScore > 0.7) return 'high';\r\n    if (optimizationScore > 0.4) return 'medium';\r\n    return 'low';\r\n  }\r\n\r\n  private generateHighLevelRecommendations(cohesion: any, dependencies: any, optimization: any): string[] {\r\n    const recommendations = [];\r\n    \r\n    if (cohesion.overallScore < 0.6) {\r\n      recommendations.push('Consider domain restructuring to improve cohesion');\r\n    }\r\n    \r\n    if (dependencies.circularDependencies.length > 0) {\r\n      recommendations.push('Address circular dependencies to improve maintainability');\r\n    }\r\n    \r\n    if (optimization.priority === 'high' || optimization.priority === 'critical') {\r\n      recommendations.push('Implement boundary optimizations to improve system architecture');\r\n    }\r\n    \r\n    return recommendations;\r\n  }\r\n}\r\n\r\n// ===== Export Types =====\r\n\r\nexport type {\r\n  DomainNode,\r\n  DomainEdge,\r\n  DomainGraph,\r\n  CohesionAnalysis,\r\n  DependencyAnalysis,\r\n  BoundaryOptimization,\r\n  GNNLayerConfig,\r\n  TrainingConfig,\r\n};"],"names":["EventEmitter","NeuralDomainMapper","graph","layers","trainingConfig","trainingState","patternStore","isTraining","modelVersion","weights","Map","biases","config","learningRate","batchSize","epochs","optimizer","lossFunction","regularization","l1","l2","dropout","earlyStoping","enabled","patience","minDelta","validationSplit","nodes","edges","metadata","created","Date","now","lastTraining","version","cohesionScore","totalNodes","totalEdges","type","inputDim","outputDim","activation","normalization","numHeads","epoch","loss","Infinity","accuracy","checkpoints","createDefaultPatternStore","initializeWeights","convertToGraph","domains","relationships","clear","domain","node","id","name","features","extractDomainFeatures","size","complexity","stability","dependencies","lastUpdated","embedding","initializeNodeEmbedding","set","rel","edgeId","source","target","edge","weight","extractEdgeFeatures","frequency","latency","reliability","bandwidth","direction","emit","types","typeEncoding","map","t","push","length","Math","min","slice","relationship","calculateDomainCohesion","domainScores","weakPoints","totalStructural","totalFunctional","totalBehavioral","totalSemantic","domainId","structural","calculateStructuralCohesion","functional","calculateFunctionalCohesion","behavioral","calculateBehavioralCohesion","semantic","calculateSemanticCohesion","domainScore","suggestions","generateCohesionSuggestions","score","reason","identifyWeaknessReason","nodeCount","overallScore","Array","from","values","reduce","sum","analysis","factors","recommendations","generateCohesionRecommendations","get","outgoingEdges","filter","e","incomingEdges","maxPossibleEdges","connectivity","weightedConnectivity","connectedDomains","getConnectedDomains","sameTypePenalty","d","avgComplexity","complexityAlignment","abs","relatedEdges","avgFrequency","avgReliability","avgLatency","frequencyScore","reliabilityScore","latencyScore","max","semanticScore","connectedDomain","nameSimilarity","calculateNameSimilarity","typeSimilarity","connectedIds","Set","add","Boolean","name1","name2","words1","toLowerCase","split","words2","commonWords","w","includes","totalWords","identifyCrossDomainDependencies","dependencyGraph","circularDependencies","criticalPaths","nodeId","visited","recursionStack","detectCircularDFS","path","depId","has","cycleStart","indexOf","cycle","delete","calculateRisk","totalRisk","i","criticality","calculateImpact","affectedDomains","deps","findLongestPaths","risk","impact","inDegrees","outDegrees","averageInDegree","deg","averageOutDegree","calculateMaxDepth","depths","keys","maxDepth","cyclomaticComplexity","sort","a","b","metrics","optimizations","generateDependencyOptimizations","provideBoundaryOptimization","proposals","cohesionAnalysis","dependencyAnalysis","generateMergeProposals","generateSplitProposals","generateRelocationProposals","generateAbstractionProposals","optimizationScore","calculateOptimizationScore","priority","determinePriority","optimization","confidence","train","trainingData","validationData","Error","trainingHistory","bestAccuracy","bestWeights","bestBiases","patienceCounter","trainEpoch","validationLoss","validationAccuracy","validationResults","validateModel","epochResult","currentAccuracy","console","log","result","finalAccuracy","bestModel","totalLoss","correct","total","indices","inputs","_","shuffleArray","batchIndices","batchInputs","idx","batchTargets","outputs","processBatch","ceil","targets","predictions","input","forwardPass","calculateLoss","calculateAccuracy","backwardPass","preprocessInput","layerConfig","processLayer","outputGradients","calculateOutputGradients","gradients","weightGradients","biasGradients","inputGradients","calculateLayerGradients","updateWeights","updateBiases","predict","output","calculatePredictionConfidence","alternatives","generateAlternativePredictions","prediction","analyzeDomains","cohesion","Promise","all","generateHighLevelRecommendations","patterns","pattern","findSimilar","threshold","p","calculatePatternSimilarity","getByType","prune","maxAge","cutoff","export","import","importedPatterns","random","layer","limit","sqrt","array","j","floor","fill","weightIndex","applyActivation","x","tanh","exp","PI","pow","pred","isArray","diff","sampleCorrect","sampleGradients","targetVal","sampleInputGradients","grad","layerId","lr","maxVal","minVal","range","count","noisyInput","addNoiseToInput","noiseLevel","noisyFeatures","f","p1","p2","similarity","undefined","getModelStats","graphSize","exportModel","Object","fromEntries","importModel","modelData","entries","lowest","affected","benefit","effort"],"mappings":"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"}