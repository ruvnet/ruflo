{
  "version": 3,
  "sources": ["../../src/swarm/prompt-copier.ts"],
  "sourcesContent": ["import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { createHash } from 'crypto';\nimport type { Worker } from 'worker_threads';\nimport { EventEmitter } from 'events';\nimport { logger } from '../core/logger.js';\n\nexport interface CopyOptions {\n  source: string;\n  destination: string;\n  backup?: boolean;\n  overwrite?: boolean;\n  verify?: boolean;\n  preservePermissions?: boolean;\n  excludePatterns?: string[];\n  includePatterns?: string[];\n  parallel?: boolean;\n  maxWorkers?: number;\n  dryRun?: boolean;\n  conflictResolution?: 'skip' | 'overwrite' | 'backup' | 'merge';\n  progressCallback?: (progress: CopyProgress) => void;\n}\n\nexport interface CopyProgress {\n  total: number;\n  completed: number;\n  failed: number;\n  skipped: number;\n  currentFile?: string;\n  percentage: number;\n}\n\nexport interface CopyResult {\n  success: boolean;\n  totalFiles: number;\n  copiedFiles: number;\n  failedFiles: number;\n  skippedFiles: number;\n  backupLocation?: string;\n  errors: CopyError[];\n  duration: number;\n}\n\nexport interface CopyError {\n  file: string;\n  error: string;\n  phase: 'read' | 'write' | 'verify' | 'backup';\n}\n\nexport interface FileInfo {\n  path: string;\n  relativePath: string;\n  size: number;\n  hash?: string;\n  permissions?: number;\n}\n\nexport class PromptCopier extends EventEmitter {\n  private options: Required<CopyOptions>;\n  private fileQueue: FileInfo[] = [];\n  private copiedFiles: Set<string> = new Set();\n  private errors: CopyError[] = [];\n  private backupMap: Map<string, string> = new Map();\n  private rollbackStack: Array<() => Promise<void>> = [];\n\n  constructor(options: CopyOptions) {\n    super();\n    this.options = {\n      ...options,\n      backup: options.backup ?? true,\n      overwrite: options.overwrite ?? false,\n      verify: options.verify ?? true,\n      preservePermissions: options.preservePermissions ?? true,\n      excludePatterns: options.excludePatterns ?? [],\n      includePatterns: options.includePatterns ?? ['*.md', '*.txt', '*.prompt', '*.prompts'],\n      parallel: options.parallel ?? true,\n      maxWorkers: options.maxWorkers ?? 4,\n      dryRun: options.dryRun ?? false,\n      conflictResolution: options.conflictResolution ?? 'backup',\n      progressCallback: options.progressCallback ?? (() => {}),\n    };\n  }\n\n  async copy(): Promise<CopyResult> {\n    const startTime = Date.now();\n\n    try {\n      // Phase 1: Discovery\n      logger.info('Starting prompt discovery phase...');\n      await this.discoverFiles();\n\n      if (this.fileQueue.length === 0) {\n        return {\n          success: true,\n          totalFiles: 0,\n          copiedFiles: 0,\n          failedFiles: 0,\n          skippedFiles: 0,\n          duration: Date.now() - startTime,\n          errors: [],\n        };\n      }\n\n      // Phase 2: Pre-flight checks\n      if (!this.options.dryRun) {\n        await this.ensureDestinationDirectories();\n      }\n\n      // Phase 3: Copy files\n      logger.info(`Copying ${this.fileQueue.length} files...`);\n      if (this.options.parallel) {\n        await this.copyFilesParallel();\n      } else {\n        await this.copyFilesSequential();\n      }\n\n      // Phase 4: Verification\n      if (this.options.verify && !this.options.dryRun) {\n        await this.verifyFiles();\n      }\n\n      const duration = Date.now() - startTime;\n      const result: CopyResult = {\n        success: this.errors.length === 0,\n        totalFiles: this.fileQueue.length,\n        copiedFiles: this.copiedFiles.size,\n        failedFiles: this.errors.length,\n        skippedFiles: this.fileQueue.length - this.copiedFiles.size - this.errors.length,\n        errors: this.errors,\n        duration,\n      };\n\n      if (this.backupMap.size > 0) {\n        result.backupLocation = await this.createBackupManifest();\n      }\n\n      logger.info(`Copy completed in ${duration}ms`, result);\n      return result;\n    } catch (error) {\n      logger.error('Copy operation failed', error);\n\n      if (!this.options.dryRun) {\n        await this.rollback();\n      }\n\n      throw error;\n    }\n  }\n\n  private async discoverFiles(): Promise<void> {\n    const sourceStats = await fs.stat(this.options.source);\n\n    if (!sourceStats.isDirectory()) {\n      throw new Error(`Source path ${this.options.source} is not a directory`);\n    }\n\n    await this.scanDirectory(this.options.source, '');\n\n    // Sort by size for better parallel distribution\n    this.fileQueue.sort((a, b) => b.size - a.size);\n  }\n\n  private async scanDirectory(dirPath: string, relativePath: string): Promise<void> {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dirPath, entry.name);\n      const relPath = path.join(relativePath, entry.name);\n\n      if (entry.isDirectory()) {\n        await this.scanDirectory(fullPath, relPath);\n      } else if (entry.isFile() && this.shouldIncludeFile(relPath)) {\n        const stats = await fs.stat(fullPath);\n        this.fileQueue.push({\n          path: fullPath,\n          relativePath: relPath,\n          size: stats.size,\n          permissions: stats.mode,\n        });\n      }\n    }\n  }\n\n  private shouldIncludeFile(filePath: string): boolean {\n    // Check exclude patterns first\n    for (const pattern of this.options.excludePatterns) {\n      if (this.matchPattern(filePath, pattern)) {\n        return false;\n      }\n    }\n\n    // Check include patterns\n    if (this.options.includePatterns.length === 0) {\n      return true;\n    }\n\n    for (const pattern of this.options.includePatterns) {\n      if (this.matchPattern(filePath, pattern)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private matchPattern(filePath: string, pattern: string): boolean {\n    // Simple glob pattern matching\n    const regex = pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*').replace(/\\?/g, '.');\n\n    return new RegExp(regex).test(filePath);\n  }\n\n  private async ensureDestinationDirectories(): Promise<void> {\n    const directories = new Set<string>();\n\n    for (const file of this.fileQueue) {\n      const destDir = path.dirname(path.join(this.options.destination, file.relativePath));\n      directories.add(destDir);\n    }\n\n    // Create directories in order (parent first)\n    const sortedDirs = Array.from(directories).sort((a, b) => a.length - b.length);\n\n    for (const dir of sortedDirs) {\n      await fs.mkdir(dir, { recursive: true });\n    }\n  }\n\n  private async copyFilesSequential(): Promise<void> {\n    let completed = 0;\n\n    for (const file of this.fileQueue) {\n      try {\n        await this.copyFile(file);\n        completed++;\n        this.reportProgress(completed);\n      } catch (error) {\n        this.errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'write',\n        });\n      }\n    }\n  }\n\n  private async copyFilesParallel(): Promise<void> {\n    const workerCount = Math.min(this.options.maxWorkers, this.fileQueue.length);\n    const chunkSize = Math.ceil(this.fileQueue.length / workerCount);\n    const workers: Promise<void>[] = [];\n\n    for (let i = 0; i < workerCount; i++) {\n      const start = i * chunkSize;\n      const end = Math.min(start + chunkSize, this.fileQueue.length);\n      const chunk = this.fileQueue.slice(start, end);\n\n      if (chunk.length > 0) {\n        workers.push(this.processChunk(chunk, i));\n      }\n    }\n\n    await Promise.all(workers);\n  }\n\n  private async processChunk(files: FileInfo[], workerId: number): Promise<void> {\n    for (const file of files) {\n      try {\n        await this.copyFile(file);\n        this.copiedFiles.add(file.path);\n        this.reportProgress(this.copiedFiles.size);\n      } catch (error) {\n        this.errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'write',\n        });\n      }\n    }\n  }\n\n  private async copyFile(file: FileInfo): Promise<void> {\n    const destPath = path.join(this.options.destination, file.relativePath);\n\n    if (this.options.dryRun) {\n      logger.info(`[DRY RUN] Would copy ${file.path} to ${destPath}`);\n      return;\n    }\n\n    // Check for conflicts\n    const destExists = await this.fileExists(destPath);\n\n    if (destExists) {\n      switch (this.options.conflictResolution) {\n        case 'skip':\n          logger.info(`Skipping existing file: ${destPath}`);\n          return;\n\n        case 'backup':\n          await this.backupFile(destPath);\n          break;\n\n        case 'merge':\n          await this.mergeFiles(file.path, destPath);\n          return;\n\n        case 'overwrite':\n          // Continue with copy\n          break;\n      }\n    }\n\n    // Calculate source hash if verification is enabled\n    if (this.options.verify) {\n      file.hash = await this.calculateFileHash(file.path);\n    }\n\n    // Copy the file\n    await fs.copyFile(file.path, destPath);\n\n    // Preserve permissions if requested\n    if (this.options.preservePermissions && file.permissions) {\n      await fs.chmod(destPath, file.permissions);\n    }\n\n    // Add to rollback stack\n    this.rollbackStack.push(async () => {\n      if (destExists && this.backupMap.has(destPath)) {\n        // Restore from backup\n        const backupPath = this.backupMap.get(destPath)!;\n        await fs.copyFile(backupPath, destPath);\n      } else {\n        // Remove the copied file\n        await fs.unlink(destPath);\n      }\n    });\n\n    this.copiedFiles.add(file.path);\n  }\n\n  private async backupFile(filePath: string): Promise<void> {\n    const backupDir = path.join(this.options.destination, '.prompt-backups');\n    await fs.mkdir(backupDir, { recursive: true });\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupName = `${path.basename(filePath)}.${timestamp}.bak`;\n    const backupPath = path.join(backupDir, backupName);\n\n    await fs.copyFile(filePath, backupPath);\n    this.backupMap.set(filePath, backupPath);\n  }\n\n  private async mergeFiles(sourcePath: string, destPath: string): Promise<void> {\n    // Simple merge strategy: append source to destination with separator\n    const sourceContent = await fs.readFile(sourcePath, 'utf-8');\n    const destContent = await fs.readFile(destPath, 'utf-8');\n\n    const separator = '\\n\\n--- MERGED CONTENT ---\\n\\n';\n    const mergedContent = destContent + separator + sourceContent;\n\n    await this.backupFile(destPath);\n    await fs.writeFile(destPath, mergedContent, 'utf-8');\n  }\n\n  private async verifyFiles(): Promise<void> {\n    logger.info('Verifying copied files...');\n\n    for (const file of this.fileQueue) {\n      if (!this.copiedFiles.has(file.path)) continue;\n\n      try {\n        const destPath = path.join(this.options.destination, file.relativePath);\n\n        // Verify file exists\n        if (!(await this.fileExists(destPath))) {\n          throw new Error('Destination file not found');\n        }\n\n        // Verify size\n        const destStats = await fs.stat(destPath);\n        const sourceStats = await fs.stat(file.path);\n\n        if (destStats.size !== sourceStats.size) {\n          throw new Error(`Size mismatch: ${destStats.size} != ${sourceStats.size}`);\n        }\n\n        // Verify hash if available\n        if (file.hash) {\n          const destHash = await this.calculateFileHash(destPath);\n          if (destHash !== file.hash) {\n            throw new Error(`Hash mismatch: ${destHash} != ${file.hash}`);\n          }\n        }\n      } catch (error) {\n        this.errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'verify',\n        });\n      }\n    }\n  }\n\n  private async calculateFileHash(filePath: string): Promise<string> {\n    const content = await fs.readFile(filePath);\n    return createHash('sha256').update(content).digest('hex');\n  }\n\n  private async fileExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async createBackupManifest(): Promise<string> {\n    const manifestPath = path.join(\n      this.options.destination,\n      '.prompt-backups',\n      `manifest-${Date.now()}.json`,\n    );\n\n    const manifest = {\n      timestamp: new Date().toISOString(),\n      source: this.options.source,\n      destination: this.options.destination,\n      backups: Array.from(this.backupMap.entries()).map(([original, backup]) => ({\n        original,\n        backup,\n      })),\n    };\n\n    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));\n    return manifestPath;\n  }\n\n  private async rollback(): Promise<void> {\n    logger.warn('Rolling back changes...');\n\n    // Execute rollback operations in reverse order\n    for (let i = this.rollbackStack.length - 1; i >= 0; i--) {\n      try {\n        await this.rollbackStack[i]();\n      } catch (error) {\n        logger.error(`Rollback operation ${i} failed:`, error);\n      }\n    }\n\n    // Clean up backup directory if empty\n    try {\n      const backupDir = path.join(this.options.destination, '.prompt-backups');\n      const entries = await fs.readdir(backupDir);\n      if (entries.length === 0) {\n        await fs.rmdir(backupDir);\n      }\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n\n  private reportProgress(completed: number): void {\n    const progress: CopyProgress = {\n      total: this.fileQueue.length,\n      completed,\n      failed: this.errors.length,\n      skipped: this.fileQueue.length - completed - this.errors.length,\n      percentage: Math.round((completed / this.fileQueue.length) * 100),\n    };\n\n    this.emit('progress', progress);\n    this.options.progressCallback(progress);\n  }\n\n  // Utility method to restore from backup\n  async restoreFromBackup(manifestPath: string): Promise<void> {\n    const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));\n\n    for (const { original, backup } of manifest.backups) {\n      try {\n        await fs.copyFile(backup, original);\n        logger.info(`Restored ${original} from ${backup}`);\n      } catch (error) {\n        logger.error(`Failed to restore ${original}:`, error);\n      }\n    }\n  }\n}\n\n// Export convenience function\nexport async function copyPrompts(options: CopyOptions): Promise<CopyResult> {\n  const copier = new PromptCopier(options);\n  return copier.copy();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,WAAsB;AACtB,oBAA2B;AAE3B,oBAA6B;AAC7B,oBAAuB;AAoDhB,MAAM,qBAAqB,2BAAa;AAAA,EAzD/C,OAyD+C;AAAA;AAAA;AAAA,EACrC;AAAA,EACA,YAAwB,CAAC;AAAA,EACzB,cAA2B,oBAAI,IAAI;AAAA,EACnC,SAAsB,CAAC;AAAA,EACvB,YAAiC,oBAAI,IAAI;AAAA,EACzC,gBAA4C,CAAC;AAAA,EAErD,YAAY,SAAsB;AAChC,UAAM;AACN,SAAK,UAAU;AAAA,MACb,GAAG;AAAA,MACH,QAAQ,QAAQ,UAAU;AAAA,MAC1B,WAAW,QAAQ,aAAa;AAAA,MAChC,QAAQ,QAAQ,UAAU;AAAA,MAC1B,qBAAqB,QAAQ,uBAAuB;AAAA,MACpD,iBAAiB,QAAQ,mBAAmB,CAAC;AAAA,MAC7C,iBAAiB,QAAQ,mBAAmB,CAAC,QAAQ,SAAS,YAAY,WAAW;AAAA,MACrF,UAAU,QAAQ,YAAY;AAAA,MAC9B,YAAY,QAAQ,cAAc;AAAA,MAClC,QAAQ,QAAQ,UAAU;AAAA,MAC1B,oBAAoB,QAAQ,sBAAsB;AAAA,MAClD,kBAAkB,QAAQ,qBAAqB,MAAM;AAAA,MAAC;AAAA,IACxD;AAAA,EACF;AAAA,EAEA,MAAM,OAA4B;AAChC,UAAM,YAAY,KAAK,IAAI;AAE3B,QAAI;AAEF,2BAAO,KAAK,oCAAoC;AAChD,YAAM,KAAK,cAAc;AAEzB,UAAI,KAAK,UAAU,WAAW,GAAG;AAC/B,eAAO;AAAA,UACL,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,aAAa;AAAA,UACb,aAAa;AAAA,UACb,cAAc;AAAA,UACd,UAAU,KAAK,IAAI,IAAI;AAAA,UACvB,QAAQ,CAAC;AAAA,QACX;AAAA,MACF;AAGA,UAAI,CAAC,KAAK,QAAQ,QAAQ;AACxB,cAAM,KAAK,6BAA6B;AAAA,MAC1C;AAGA,2BAAO,KAAK,WAAW,KAAK,UAAU,MAAM,WAAW;AACvD,UAAI,KAAK,QAAQ,UAAU;AACzB,cAAM,KAAK,kBAAkB;AAAA,MAC/B,OAAO;AACL,cAAM,KAAK,oBAAoB;AAAA,MACjC;AAGA,UAAI,KAAK,QAAQ,UAAU,CAAC,KAAK,QAAQ,QAAQ;AAC/C,cAAM,KAAK,YAAY;AAAA,MACzB;AAEA,YAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,YAAM,SAAqB;AAAA,QACzB,SAAS,KAAK,OAAO,WAAW;AAAA,QAChC,YAAY,KAAK,UAAU;AAAA,QAC3B,aAAa,KAAK,YAAY;AAAA,QAC9B,aAAa,KAAK,OAAO;AAAA,QACzB,cAAc,KAAK,UAAU,SAAS,KAAK,YAAY,OAAO,KAAK,OAAO;AAAA,QAC1E,QAAQ,KAAK;AAAA,QACb;AAAA,MACF;AAEA,UAAI,KAAK,UAAU,OAAO,GAAG;AAC3B,eAAO,iBAAiB,MAAM,KAAK,qBAAqB;AAAA,MAC1D;AAEA,2BAAO,KAAK,qBAAqB,QAAQ,MAAM,MAAM;AACrD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,2BAAO,MAAM,yBAAyB,KAAK;AAE3C,UAAI,CAAC,KAAK,QAAQ,QAAQ;AACxB,cAAM,KAAK,SAAS;AAAA,MACtB;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,gBAA+B;AAC3C,UAAM,cAAc,MAAM,GAAG,KAAK,KAAK,QAAQ,MAAM;AAErD,QAAI,CAAC,YAAY,YAAY,GAAG;AAC9B,YAAM,IAAI,MAAM,eAAe,KAAK,QAAQ,MAAM,qBAAqB;AAAA,IACzE;AAEA,UAAM,KAAK,cAAc,KAAK,QAAQ,QAAQ,EAAE;AAGhD,SAAK,UAAU,KAAK,CAAC,GAAG,MAAM,EAAE,OAAO,EAAE,IAAI;AAAA,EAC/C;AAAA,EAEA,MAAc,cAAc,SAAiB,cAAqC;AAChF,UAAM,UAAU,MAAM,GAAG,QAAQ,SAAS,EAAE,eAAe,KAAK,CAAC;AAEjE,eAAW,SAAS,SAAS;AAC3B,YAAM,WAAW,KAAK,KAAK,SAAS,MAAM,IAAI;AAC9C,YAAM,UAAU,KAAK,KAAK,cAAc,MAAM,IAAI;AAElD,UAAI,MAAM,YAAY,GAAG;AACvB,cAAM,KAAK,cAAc,UAAU,OAAO;AAAA,MAC5C,WAAW,MAAM,OAAO,KAAK,KAAK,kBAAkB,OAAO,GAAG;AAC5D,cAAM,QAAQ,MAAM,GAAG,KAAK,QAAQ;AACpC,aAAK,UAAU,KAAK;AAAA,UAClB,MAAM;AAAA,UACN,cAAc;AAAA,UACd,MAAM,MAAM;AAAA,UACZ,aAAa,MAAM;AAAA,QACrB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,kBAAkB,UAA2B;AAEnD,eAAW,WAAW,KAAK,QAAQ,iBAAiB;AAClD,UAAI,KAAK,aAAa,UAAU,OAAO,GAAG;AACxC,eAAO;AAAA,MACT;AAAA,IACF;AAGA,QAAI,KAAK,QAAQ,gBAAgB,WAAW,GAAG;AAC7C,aAAO;AAAA,IACT;AAEA,eAAW,WAAW,KAAK,QAAQ,iBAAiB;AAClD,UAAI,KAAK,aAAa,UAAU,OAAO,GAAG;AACxC,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa,UAAkB,SAA0B;AAE/D,UAAM,QAAQ,QAAQ,QAAQ,OAAO,KAAK,EAAE,QAAQ,OAAO,IAAI,EAAE,QAAQ,OAAO,GAAG;AAEnF,WAAO,IAAI,OAAO,KAAK,EAAE,KAAK,QAAQ;AAAA,EACxC;AAAA,EAEA,MAAc,+BAA8C;AAC1D,UAAM,cAAc,oBAAI,IAAY;AAEpC,eAAW,QAAQ,KAAK,WAAW;AACjC,YAAM,UAAU,KAAK,QAAQ,KAAK,KAAK,KAAK,QAAQ,aAAa,KAAK,YAAY,CAAC;AACnF,kBAAY,IAAI,OAAO;AAAA,IACzB;AAGA,UAAM,aAAa,MAAM,KAAK,WAAW,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,MAAM;AAE7E,eAAW,OAAO,YAAY;AAC5B,YAAM,GAAG,MAAM,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,IACzC;AAAA,EACF;AAAA,EAEA,MAAc,sBAAqC;AACjD,QAAI,YAAY;AAEhB,eAAW,QAAQ,KAAK,WAAW;AACjC,UAAI;AACF,cAAM,KAAK,SAAS,IAAI;AACxB;AACA,aAAK,eAAe,SAAS;AAAA,MAC/B,SAAS,OAAO;AACd,aAAK,OAAO,KAAK;AAAA,UACf,MAAM,KAAK;AAAA,UACX,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC5D,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,oBAAmC;AAC/C,UAAM,cAAc,KAAK,IAAI,KAAK,QAAQ,YAAY,KAAK,UAAU,MAAM;AAC3E,UAAM,YAAY,KAAK,KAAK,KAAK,UAAU,SAAS,WAAW;AAC/D,UAAM,UAA2B,CAAC;AAElC,aAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,YAAM,QAAQ,IAAI;AAClB,YAAM,MAAM,KAAK,IAAI,QAAQ,WAAW,KAAK,UAAU,MAAM;AAC7D,YAAM,QAAQ,KAAK,UAAU,MAAM,OAAO,GAAG;AAE7C,UAAI,MAAM,SAAS,GAAG;AACpB,gBAAQ,KAAK,KAAK,aAAa,OAAO,CAAC,CAAC;AAAA,MAC1C;AAAA,IACF;AAEA,UAAM,QAAQ,IAAI,OAAO;AAAA,EAC3B;AAAA,EAEA,MAAc,aAAa,OAAmB,UAAiC;AAC7E,eAAW,QAAQ,OAAO;AACxB,UAAI;AACF,cAAM,KAAK,SAAS,IAAI;AACxB,aAAK,YAAY,IAAI,KAAK,IAAI;AAC9B,aAAK,eAAe,KAAK,YAAY,IAAI;AAAA,MAC3C,SAAS,OAAO;AACd,aAAK,OAAO,KAAK;AAAA,UACf,MAAM,KAAK;AAAA,UACX,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC5D,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,SAAS,MAA+B;AACpD,UAAM,WAAW,KAAK,KAAK,KAAK,QAAQ,aAAa,KAAK,YAAY;AAEtE,QAAI,KAAK,QAAQ,QAAQ;AACvB,2BAAO,KAAK,wBAAwB,KAAK,IAAI,OAAO,QAAQ,EAAE;AAC9D;AAAA,IACF;AAGA,UAAM,aAAa,MAAM,KAAK,WAAW,QAAQ;AAEjD,QAAI,YAAY;AACd,cAAQ,KAAK,QAAQ,oBAAoB;AAAA,QACvC,KAAK;AACH,+BAAO,KAAK,2BAA2B,QAAQ,EAAE;AACjD;AAAA,QAEF,KAAK;AACH,gBAAM,KAAK,WAAW,QAAQ;AAC9B;AAAA,QAEF,KAAK;AACH,gBAAM,KAAK,WAAW,KAAK,MAAM,QAAQ;AACzC;AAAA,QAEF,KAAK;AAEH;AAAA,MACJ;AAAA,IACF;AAGA,QAAI,KAAK,QAAQ,QAAQ;AACvB,WAAK,OAAO,MAAM,KAAK,kBAAkB,KAAK,IAAI;AAAA,IACpD;AAGA,UAAM,GAAG,SAAS,KAAK,MAAM,QAAQ;AAGrC,QAAI,KAAK,QAAQ,uBAAuB,KAAK,aAAa;AACxD,YAAM,GAAG,MAAM,UAAU,KAAK,WAAW;AAAA,IAC3C;AAGA,SAAK,cAAc,KAAK,YAAY;AAClC,UAAI,cAAc,KAAK,UAAU,IAAI,QAAQ,GAAG;AAE9C,cAAM,aAAa,KAAK,UAAU,IAAI,QAAQ;AAC9C,cAAM,GAAG,SAAS,YAAY,QAAQ;AAAA,MACxC,OAAO;AAEL,cAAM,GAAG,OAAO,QAAQ;AAAA,MAC1B;AAAA,IACF,CAAC;AAED,SAAK,YAAY,IAAI,KAAK,IAAI;AAAA,EAChC;AAAA,EAEA,MAAc,WAAW,UAAiC;AACxD,UAAM,YAAY,KAAK,KAAK,KAAK,QAAQ,aAAa,iBAAiB;AACvE,UAAM,GAAG,MAAM,WAAW,EAAE,WAAW,KAAK,CAAC;AAE7C,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY,EAAE,QAAQ,SAAS,GAAG;AAC/D,UAAM,aAAa,GAAG,KAAK,SAAS,QAAQ,CAAC,IAAI,SAAS;AAC1D,UAAM,aAAa,KAAK,KAAK,WAAW,UAAU;AAElD,UAAM,GAAG,SAAS,UAAU,UAAU;AACtC,SAAK,UAAU,IAAI,UAAU,UAAU;AAAA,EACzC;AAAA,EAEA,MAAc,WAAW,YAAoB,UAAiC;AAE5E,UAAM,gBAAgB,MAAM,GAAG,SAAS,YAAY,OAAO;AAC3D,UAAM,cAAc,MAAM,GAAG,SAAS,UAAU,OAAO;AAEvD,UAAM,YAAY;AAClB,UAAM,gBAAgB,cAAc,YAAY;AAEhD,UAAM,KAAK,WAAW,QAAQ;AAC9B,UAAM,GAAG,UAAU,UAAU,eAAe,OAAO;AAAA,EACrD;AAAA,EAEA,MAAc,cAA6B;AACzC,yBAAO,KAAK,2BAA2B;AAEvC,eAAW,QAAQ,KAAK,WAAW;AACjC,UAAI,CAAC,KAAK,YAAY,IAAI,KAAK,IAAI;AAAG;AAEtC,UAAI;AACF,cAAM,WAAW,KAAK,KAAK,KAAK,QAAQ,aAAa,KAAK,YAAY;AAGtE,YAAI,CAAE,MAAM,KAAK,WAAW,QAAQ,GAAI;AACtC,gBAAM,IAAI,MAAM,4BAA4B;AAAA,QAC9C;AAGA,cAAM,YAAY,MAAM,GAAG,KAAK,QAAQ;AACxC,cAAM,cAAc,MAAM,GAAG,KAAK,KAAK,IAAI;AAE3C,YAAI,UAAU,SAAS,YAAY,MAAM;AACvC,gBAAM,IAAI,MAAM,kBAAkB,UAAU,IAAI,OAAO,YAAY,IAAI,EAAE;AAAA,QAC3E;AAGA,YAAI,KAAK,MAAM;AACb,gBAAM,WAAW,MAAM,KAAK,kBAAkB,QAAQ;AACtD,cAAI,aAAa,KAAK,MAAM;AAC1B,kBAAM,IAAI,MAAM,kBAAkB,QAAQ,OAAO,KAAK,IAAI,EAAE;AAAA,UAC9D;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,aAAK,OAAO,KAAK;AAAA,UACf,MAAM,KAAK;AAAA,UACX,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC5D,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,kBAAkB,UAAmC;AACjE,UAAM,UAAU,MAAM,GAAG,SAAS,QAAQ;AAC1C,eAAO,0BAAW,QAAQ,EAAE,OAAO,OAAO,EAAE,OAAO,KAAK;AAAA,EAC1D;AAAA,EAEA,MAAc,WAAW,UAAoC;AAC3D,QAAI;AACF,YAAM,GAAG,OAAO,QAAQ;AACxB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAc,uBAAwC;AACpD,UAAM,eAAe,KAAK;AAAA,MACxB,KAAK,QAAQ;AAAA,MACb;AAAA,MACA,YAAY,KAAK,IAAI,CAAC;AAAA,IACxB;AAEA,UAAM,WAAW;AAAA,MACf,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,QAAQ,KAAK,QAAQ;AAAA,MACrB,aAAa,KAAK,QAAQ;AAAA,MAC1B,SAAS,MAAM,KAAK,KAAK,UAAU,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,UAAU,MAAM,OAAO;AAAA,QACzE;AAAA,QACA;AAAA,MACF,EAAE;AAAA,IACJ;AAEA,UAAM,GAAG,UAAU,cAAc,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AAClE,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,WAA0B;AACtC,yBAAO,KAAK,yBAAyB;AAGrC,aAAS,IAAI,KAAK,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;AACvD,UAAI;AACF,cAAM,KAAK,cAAc,CAAC,EAAE;AAAA,MAC9B,SAAS,OAAO;AACd,6BAAO,MAAM,sBAAsB,CAAC,YAAY,KAAK;AAAA,MACvD;AAAA,IACF;AAGA,QAAI;AACF,YAAM,YAAY,KAAK,KAAK,KAAK,QAAQ,aAAa,iBAAiB;AACvE,YAAM,UAAU,MAAM,GAAG,QAAQ,SAAS;AAC1C,UAAI,QAAQ,WAAW,GAAG;AACxB,cAAM,GAAG,MAAM,SAAS;AAAA,MAC1B;AAAA,IACF,QAAQ;AAAA,IAER;AAAA,EACF;AAAA,EAEQ,eAAe,WAAyB;AAC9C,UAAM,WAAyB;AAAA,MAC7B,OAAO,KAAK,UAAU;AAAA,MACtB;AAAA,MACA,QAAQ,KAAK,OAAO;AAAA,MACpB,SAAS,KAAK,UAAU,SAAS,YAAY,KAAK,OAAO;AAAA,MACzD,YAAY,KAAK,MAAO,YAAY,KAAK,UAAU,SAAU,GAAG;AAAA,IAClE;AAEA,SAAK,KAAK,YAAY,QAAQ;AAC9B,SAAK,QAAQ,iBAAiB,QAAQ;AAAA,EACxC;AAAA;AAAA,EAGA,MAAM,kBAAkB,cAAqC;AAC3D,UAAM,WAAW,KAAK,MAAM,MAAM,GAAG,SAAS,cAAc,OAAO,CAAC;AAEpE,eAAW,EAAE,UAAU,OAAO,KAAK,SAAS,SAAS;AACnD,UAAI;AACF,cAAM,GAAG,SAAS,QAAQ,QAAQ;AAClC,6BAAO,KAAK,YAAY,QAAQ,SAAS,MAAM,EAAE;AAAA,MACnD,SAAS,OAAO;AACd,6BAAO,MAAM,qBAAqB,QAAQ,KAAK,KAAK;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AACF;AAGA,eAAsB,YAAY,SAA2C;AAC3E,QAAM,SAAS,IAAI,aAAa,OAAO;AACvC,SAAO,OAAO,KAAK;AACrB;AAHsB;",
  "names": []
}
