{
  "version": 3,
  "sources": ["../../src/coordination/background-executor.ts"],
  "sourcesContent": ["import { spawn, ChildProcess } from 'node:child_process';\nimport { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nexport interface BackgroundTask {\n  id: string;\n  type: 'claude-spawn' | 'script' | 'command';\n  command: string;\n  args: string[];\n  options?: {\n    cwd?: string;\n    env?: Record<string, string>;\n    timeout?: number;\n    retries?: number;\n    detached?: boolean;\n  };\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  pid?: number;\n  output?: string;\n  error?: string;\n  startTime?: Date;\n  endTime?: Date;\n  retryCount: number;\n}\n\nexport interface BackgroundExecutorConfig {\n  maxConcurrentTasks: number;\n  defaultTimeout: number;\n  logPath: string;\n  enablePersistence: boolean;\n  checkInterval: number;\n  cleanupInterval: number;\n  maxRetries: number;\n}\n\nexport class BackgroundExecutor extends EventEmitter {\n  private logger: Logger;\n  private config: BackgroundExecutorConfig;\n  private tasks: Map<string, BackgroundTask>;\n  private processes: Map<string, ChildProcess>;\n  private queue: string[];\n  private isRunning: boolean = false;\n  private checkTimer?: NodeJS.Timeout;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  constructor(config: Partial<BackgroundExecutorConfig> = {}) {\n    super();\n    this.logger = new Logger('BackgroundExecutor');\n    this.config = {\n      maxConcurrentTasks: 5,\n      defaultTimeout: 300000, // 5 minutes\n      logPath: './background-tasks',\n      enablePersistence: true,\n      checkInterval: 1000, // 1 second\n      cleanupInterval: 60000, // 1 minute\n      maxRetries: 3,\n      ...config,\n    };\n\n    this.tasks = new Map();\n    this.processes = new Map();\n    this.queue = [];\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) return;\n\n    this.logger.info('Starting background executor...');\n    this.isRunning = true;\n\n    // Create log directory\n    if (this.config.enablePersistence) {\n      await fs.mkdir(this.config.logPath, { recursive: true });\n    }\n\n    // Start background processing\n    this.checkTimer = setInterval(() => {\n      this.processQueue();\n      this.checkRunningTasks();\n    }, this.config.checkInterval);\n\n    // Start cleanup timer\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupCompletedTasks();\n    }, this.config.cleanupInterval);\n\n    this.emit('executor:started');\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n\n    this.logger.info('Stopping background executor...');\n    this.isRunning = false;\n\n    // Clear timers\n    if (this.checkTimer) {\n      clearInterval(this.checkTimer);\n      this.checkTimer = undefined;\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n\n    // Kill all running processes\n    for (const [taskId, process] of this.processes) {\n      this.logger.warn(`Killing process for task ${taskId}`);\n      process.kill('SIGTERM');\n    }\n\n    this.emit('executor:stopped');\n  }\n\n  async submitTask(\n    type: BackgroundTask['type'],\n    command: string,\n    args: string[] = [],\n    options: BackgroundTask['options'] = {},\n  ): Promise<string> {\n    const taskId = generateId('bgtask');\n    const task: BackgroundTask = {\n      id: taskId,\n      type,\n      command,\n      args,\n      options: {\n        timeout: this.config.defaultTimeout,\n        retries: this.config.maxRetries,\n        ...options,\n      },\n      status: 'pending',\n      retryCount: 0,\n    };\n\n    this.tasks.set(taskId, task);\n    this.queue.push(taskId);\n\n    if (this.config.enablePersistence) {\n      await this.saveTaskState(task);\n    }\n\n    this.logger.info(`Submitted background task: ${taskId} - ${command}`);\n    this.emit('task:submitted', task);\n\n    // Process immediately if possible\n    this.processQueue();\n\n    return taskId;\n  }\n\n  async submitClaudeTask(\n    prompt: string,\n    tools: string[] = [],\n    options: Partial<{\n      cwd: string;\n      env: Record<string, string>;\n      timeout: number;\n      model?: string;\n      maxTokens?: number;\n    }> = {},\n  ): Promise<string> {\n    // Build claude command arguments\n    const args = ['-p', prompt];\n\n    if (tools.length > 0) {\n      args.push('--allowedTools', tools.join(','));\n    }\n\n    if (options.model) {\n      args.push('--model', options.model);\n    }\n\n    if (options.maxTokens) {\n      args.push('--max-tokens', options.maxTokens.toString());\n    }\n\n    args.push('--dangerously-skip-permissions');\n\n    return this.submitTask('claude-spawn', 'claude', args, {\n      ...options,\n      detached: true, // Run in background\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (!this.isRunning) return;\n\n    // Check how many tasks are running\n    const runningTasks = Array.from(this.tasks.values()).filter(\n      (t) => t.status === 'running',\n    ).length;\n\n    const availableSlots = this.config.maxConcurrentTasks - runningTasks;\n\n    // Process pending tasks\n    for (let i = 0; i < availableSlots && this.queue.length > 0; i++) {\n      const taskId = this.queue.shift();\n      if (!taskId) continue;\n\n      const task = this.tasks.get(taskId);\n      if (!task || task.status !== 'pending') continue;\n\n      await this.executeTask(task);\n    }\n  }\n\n  private async executeTask(task: BackgroundTask): Promise<void> {\n    try {\n      task.status = 'running';\n      task.startTime = new Date();\n\n      this.logger.info(`Executing task ${task.id}: ${task.command} ${task.args.join(' ')}`);\n\n      // Create log files for task\n      const logDir = path.join(this.config.logPath, task.id);\n      if (this.config.enablePersistence) {\n        await fs.mkdir(logDir, { recursive: true });\n      }\n\n      // Spawn process\n      const process = spawn(task.command, task.args, {\n        cwd: task.options?.cwd,\n        env: { ...process.env, ...task.options?.env },\n        detached: task.options?.detached,\n        stdio: ['ignore', 'pipe', 'pipe'],\n      });\n\n      task.pid = process.pid;\n      this.processes.set(task.id, process);\n\n      // Collect output\n      let stdout = '';\n      let stderr = '';\n\n      process.stdout?.on('data', (data) => {\n        stdout += data.toString();\n        this.emit('task:output', { taskId: task.id, data: data.toString() });\n      });\n\n      process.stderr?.on('data', (data) => {\n        stderr += data.toString();\n        this.emit('task:error', { taskId: task.id, data: data.toString() });\n      });\n\n      // Handle process completion\n      process.on('close', async (code) => {\n        task.endTime = new Date();\n        task.output = stdout;\n        task.error = stderr;\n\n        if (code === 0) {\n          task.status = 'completed';\n          this.logger.info(`Task ${task.id} completed successfully`);\n          this.emit('task:completed', task);\n        } else {\n          task.status = 'failed';\n          this.logger.error(`Task ${task.id} failed with code ${code}`);\n\n          // Retry logic\n          if (task.retryCount < (task.options?.retries || 0)) {\n            task.retryCount++;\n            task.status = 'pending';\n            this.queue.push(task.id);\n            this.logger.info(\n              `Retrying task ${task.id} (${task.retryCount}/${task.options?.retries})`,\n            );\n            this.emit('task:retry', task);\n          } else {\n            this.emit('task:failed', task);\n          }\n        }\n\n        this.processes.delete(task.id);\n\n        if (this.config.enablePersistence) {\n          await this.saveTaskOutput(task);\n        }\n      });\n\n      // Set timeout if specified\n      if (task.options?.timeout) {\n        setTimeout(() => {\n          if (this.processes.has(task.id)) {\n            this.logger.warn(`Task ${task.id} timed out after ${task.options?.timeout}ms`);\n            process.kill('SIGTERM');\n          }\n        }, task.options.timeout);\n      }\n\n      // For detached processes, unref to allow main process to exit\n      if (task.options?.detached) {\n        process.unref();\n      }\n\n      this.emit('task:started', task);\n\n      if (this.config.enablePersistence) {\n        await this.saveTaskState(task);\n      }\n    } catch (error) {\n      task.status = 'failed';\n      task.error = String(error);\n      task.endTime = new Date();\n\n      this.logger.error(`Failed to execute task ${task.id}:`, error);\n      this.emit('task:failed', task);\n\n      if (this.config.enablePersistence) {\n        await this.saveTaskState(task);\n      }\n    }\n  }\n\n  private checkRunningTasks(): void {\n    // Check for hung or timed out tasks\n    const now = Date.now();\n\n    for (const [taskId, task] of this.tasks) {\n      if (task.status !== 'running' || !task.startTime) continue;\n\n      const runtime = now - task.startTime.getTime();\n      const timeout = task.options?.timeout || this.config.defaultTimeout;\n\n      if (runtime > timeout) {\n        const process = this.processes.get(taskId);\n        if (process) {\n          this.logger.warn(`Killing timed out task ${taskId}`);\n          process.kill('SIGTERM');\n\n          // Force kill after 5 seconds\n          setTimeout(() => {\n            if (this.processes.has(taskId)) {\n              process.kill('SIGKILL');\n            }\n          }, 5000);\n        }\n      }\n    }\n  }\n\n  private cleanupCompletedTasks(): void {\n    const cutoffTime = Date.now() - 3600000; // 1 hour\n\n    for (const [taskId, task] of this.tasks) {\n      if (task.status === 'completed' || task.status === 'failed') {\n        if (task.endTime && task.endTime.getTime() < cutoffTime) {\n          this.tasks.delete(taskId);\n          this.logger.debug(`Cleaned up old task: ${taskId}`);\n        }\n      }\n    }\n  }\n\n  private async saveTaskState(task: BackgroundTask): Promise<void> {\n    if (!this.config.enablePersistence) return;\n\n    try {\n      const taskFile = path.join(this.config.logPath, task.id, 'task.json');\n      await fs.writeFile(taskFile, JSON.stringify(task, null, 2));\n    } catch (error) {\n      this.logger.error(`Failed to save task state for ${task.id}:`, error);\n    }\n  }\n\n  private async saveTaskOutput(task: BackgroundTask): Promise<void> {\n    if (!this.config.enablePersistence) return;\n\n    try {\n      const logDir = path.join(this.config.logPath, task.id);\n\n      if (task.output) {\n        await fs.writeFile(path.join(logDir, 'stdout.log'), task.output);\n      }\n\n      if (task.error) {\n        await fs.writeFile(path.join(logDir, 'stderr.log'), task.error);\n      }\n\n      // Save final task state\n      await this.saveTaskState(task);\n    } catch (error) {\n      this.logger.error(`Failed to save task output for ${task.id}:`, error);\n    }\n  }\n\n  // Public API methods\n  getTask(taskId: string): BackgroundTask | undefined {\n    return this.tasks.get(taskId);\n  }\n\n  getTasks(status?: BackgroundTask['status']): BackgroundTask[] {\n    const tasks = Array.from(this.tasks.values());\n    return status ? tasks.filter((t) => t.status === status) : tasks;\n  }\n\n  async waitForTask(taskId: string, timeout?: number): Promise<BackgroundTask> {\n    return new Promise((resolve, reject) => {\n      const task = this.tasks.get(taskId);\n      if (!task) {\n        reject(new Error('Task not found'));\n        return;\n      }\n\n      if (task.status === 'completed' || task.status === 'failed') {\n        resolve(task);\n        return;\n      }\n\n      const timeoutHandle = timeout\n        ? setTimeout(() => {\n            reject(new Error('Wait timeout'));\n          }, timeout)\n        : undefined;\n\n      const checkTask = () => {\n        const currentTask = this.tasks.get(taskId);\n        if (!currentTask) {\n          if (timeoutHandle) clearTimeout(timeoutHandle);\n          reject(new Error('Task disappeared'));\n          return;\n        }\n\n        if (currentTask.status === 'completed' || currentTask.status === 'failed') {\n          if (timeoutHandle) clearTimeout(timeoutHandle);\n          resolve(currentTask);\n        } else {\n          setTimeout(checkTask, 100);\n        }\n      };\n\n      checkTask();\n    });\n  }\n\n  async killTask(taskId: string): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) {\n      throw new Error('Task not found');\n    }\n\n    const process = this.processes.get(taskId);\n    if (process) {\n      this.logger.info(`Killing task ${taskId}`);\n      process.kill('SIGTERM');\n\n      // Force kill after 5 seconds\n      setTimeout(() => {\n        if (this.processes.has(taskId)) {\n          process.kill('SIGKILL');\n        }\n      }, 5000);\n    }\n\n    task.status = 'failed';\n    task.error = 'Task killed by user';\n    task.endTime = new Date();\n\n    this.emit('task:killed', task);\n  }\n\n  getStatus(): {\n    running: number;\n    pending: number;\n    completed: number;\n    failed: number;\n    queueLength: number;\n  } {\n    const tasks = Array.from(this.tasks.values());\n    return {\n      running: tasks.filter((t) => t.status === 'running').length,\n      pending: tasks.filter((t) => t.status === 'pending').length,\n      completed: tasks.filter((t) => t.status === 'completed').length,\n      failed: tasks.filter((t) => t.status === 'failed').length,\n      queueLength: this.queue.length,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
