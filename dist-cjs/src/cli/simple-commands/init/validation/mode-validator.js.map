{"version":3,"sources":["../../../../../../src/cli/simple-commands/init/validation/mode-validator.js"],"sourcesContent":["import { promises as fs } from 'fs';\r\n// mode-validator.js - SPARC mode functionality testing\r\n\r\nexport class ModeValidator {\r\n  constructor(workingDir) {\r\n    this.workingDir = workingDir;\r\n  }\r\n\r\n  /**\r\n   * Test all SPARC modes for basic functionality\r\n   */\r\n  async testAllModes() {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      modes: {},\r\n    };\r\n\r\n    try {\r\n      // First, check if SPARC is initialized\r\n      const sparcInitialized = await this.checkSparcInitialization();\r\n      if (!sparcInitialized.initialized) {\r\n        result.warnings.push('SPARC not initialized - mode testing skipped');\r\n        return result;\r\n      }\r\n\r\n      // Get available modes\r\n      const availableModes = await this.getAvailableModes();\r\n      if (availableModes.length === 0) {\r\n        result.warnings.push('No SPARC modes found for testing');\r\n        return result;\r\n      }\r\n\r\n      // Test each mode\r\n      for (const mode of availableModes) {\r\n        const modeTest = await this.testMode(mode);\r\n        result.modes[mode] = modeTest;\r\n\r\n        if (!modeTest.success) {\r\n          result.success = false;\r\n          result.errors.push(`Mode ${mode} failed testing: ${modeTest.error}`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Mode testing failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Test a specific SPARC mode\r\n   */\r\n  async testMode(modeName) {\r\n    const result = {\r\n      success: true,\r\n      error: null,\r\n      checks: {\r\n        accessible: false,\r\n        configValid: false,\r\n        executable: false,\r\n      },\r\n    };\r\n\r\n    try {\r\n      // Test 1: Check if mode is accessible via CLI\r\n      const accessTest = await this.testModeAccess(modeName);\r\n      result.checks.accessible = accessTest.success;\r\n      if (!accessTest.success) {\r\n        result.success = false;\r\n        result.error = accessTest.error;\r\n        return result;\r\n      }\r\n\r\n      // Test 2: Validate mode configuration\r\n      const configTest = await this.testModeConfig(modeName);\r\n      result.checks.configValid = configTest.success;\r\n      if (!configTest.success) {\r\n        result.success = false;\r\n        result.error = configTest.error;\r\n        return result;\r\n      }\r\n\r\n      // Test 3: Test mode execution (dry run)\r\n      const execTest = await this.testModeExecution(modeName);\r\n      result.checks.executable = execTest.success;\r\n      if (!execTest.success) {\r\n        result.success = false;\r\n        result.error = execTest.error;\r\n        return result;\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.error = error.message;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if SPARC is properly initialized\r\n   */\r\n  async checkSparcInitialization() {\r\n    const result = {\r\n      initialized: false,\r\n      hasRoomodes: false,\r\n      hasExecutable: false,\r\n      error: null,\r\n    };\r\n\r\n    try {\r\n      // Check for .roomodes file\r\n      try {\r\n        const stat = await Deno.stat(`${this.workingDir}/.roomodes`);\r\n        result.hasRoomodes = stat.isFile;\r\n      } catch {\r\n        result.error = '.roomodes file not found';\r\n      }\r\n\r\n      // Check for claude-flow executable\r\n      try {\r\n        const stat = await Deno.stat(`${this.workingDir}/claude-flow`);\r\n        result.hasExecutable = stat.isFile;\r\n      } catch {\r\n        result.error = 'claude-flow executable not found';\r\n      }\r\n\r\n      result.initialized = result.hasRoomodes && result.hasExecutable;\r\n    } catch (error) {\r\n      result.error = error.message;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get list of available SPARC modes\r\n   */\r\n  async getAvailableModes() {\r\n    const modes = [];\r\n\r\n    try {\r\n      // Try to get modes from .roomodes\r\n      const roomodesPath = `${this.workingDir}/.roomodes`;\r\n      const content = await fs.readFile(roomodesPath, 'utf8');\r\n      const config = JSON.parse(content);\r\n\r\n      if (config.modes && typeof config.modes === 'object') {\r\n        modes.push(...Object.keys(config.modes));\r\n      }\r\n    } catch (error) {\r\n      // Fallback to common modes\r\n      modes.push(\r\n        'architect',\r\n        'code',\r\n        'tdd',\r\n        'spec-pseudocode',\r\n        'integration',\r\n        'debug',\r\n        'docs-writer',\r\n      );\r\n    }\r\n\r\n    return modes;\r\n  }\r\n\r\n  /**\r\n   * Test if a mode is accessible via CLI\r\n   */\r\n  async testModeAccess(modeName) {\r\n    const result = {\r\n      success: false,\r\n      error: null,\r\n    };\r\n\r\n    try {\r\n      // Test with sparc info command\r\n      const command = new Deno.Command('./claude-flow', {\r\n        args: ['sparc', 'info', modeName],\r\n        cwd: this.workingDir,\r\n        stdout: 'piped',\r\n        stderr: 'piped',\r\n      });\r\n\r\n      const { success, stdout, stderr } = await command.output();\r\n\r\n      if (success) {\r\n        result.success = true;\r\n      } else {\r\n        const errorOutput = new TextDecoder().decode(stderr);\r\n        result.error = `Mode not accessible: ${errorOutput}`;\r\n      }\r\n    } catch (error) {\r\n      result.error = `Failed to test mode access: ${error.message}`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Test mode configuration validity\r\n   */\r\n  async testModeConfig(modeName) {\r\n    const result = {\r\n      success: false,\r\n      error: null,\r\n    };\r\n\r\n    try {\r\n      // Read .roomodes and validate mode config\r\n      const roomodesPath = `${this.workingDir}/.roomodes`;\r\n      const content = await fs.readFile(roomodesPath, 'utf8');\r\n      const config = JSON.parse(content);\r\n\r\n      if (!config.modes || !config.modes[modeName]) {\r\n        result.error = `Mode ${modeName} not found in configuration`;\r\n        return result;\r\n      }\r\n\r\n      const modeConfig = config.modes[modeName];\r\n\r\n      // Basic validation\r\n      if (typeof modeConfig !== 'object') {\r\n        result.error = `Invalid configuration for mode ${modeName}`;\r\n        return result;\r\n      }\r\n\r\n      // Check for required fields\r\n      const requiredFields = ['description'];\r\n      for (const field of requiredFields) {\r\n        if (!modeConfig[field]) {\r\n          result.error = `Mode ${modeName} missing required field: ${field}`;\r\n          return result;\r\n        }\r\n      }\r\n\r\n      result.success = true;\r\n    } catch (error) {\r\n      result.error = `Configuration validation failed: ${error.message}`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Test mode execution with a safe dry run\r\n   */\r\n  async testModeExecution(modeName) {\r\n    const result = {\r\n      success: false,\r\n      error: null,\r\n    };\r\n\r\n    try {\r\n      // Test with a safe, non-destructive command\r\n      const command = new Deno.Command('./claude-flow', {\r\n        args: ['sparc', 'run', modeName, 'test validation', '--dry-run'],\r\n        cwd: this.workingDir,\r\n        stdout: 'piped',\r\n        stderr: 'piped',\r\n      });\r\n\r\n      const { success, stdout, stderr } = await command.output();\r\n\r\n      if (success) {\r\n        result.success = true;\r\n      } else {\r\n        // Check if it's just because --dry-run isn't supported\r\n        const errorOutput = new TextDecoder().decode(stderr);\r\n        if (errorOutput.includes('dry-run') || errorOutput.includes('unknown flag')) {\r\n          // Try without dry-run but with a safe test task\r\n          const testCommand = new Deno.Command('./claude-flow', {\r\n            args: ['sparc', 'modes'],\r\n            cwd: this.workingDir,\r\n            stdout: 'piped',\r\n            stderr: 'piped',\r\n          });\r\n\r\n          const testResult = await testCommand.output();\r\n          if (testResult.success) {\r\n            const output = new TextDecoder().decode(testResult.stdout);\r\n            result.success = output.includes(modeName);\r\n            if (!result.success) {\r\n              result.error = `Mode ${modeName} not listed in available modes`;\r\n            }\r\n          } else {\r\n            result.error = `Mode execution test failed: ${errorOutput}`;\r\n          }\r\n        } else {\r\n          result.error = `Mode execution failed: ${errorOutput}`;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      result.error = `Execution test failed: ${error.message}`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Test SPARC workflow functionality\r\n   */\r\n  async testWorkflowFunctionality() {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      workflows: {},\r\n    };\r\n\r\n    try {\r\n      // Check for workflow files\r\n      const workflowDir = `${this.workingDir}/.roo/workflows`;\r\n\r\n      try {\r\n        const entries = [];\r\n        for await (const entry of Deno.readDir(workflowDir)) {\r\n          if (entry.isFile && entry.name.endsWith('.json')) {\r\n            entries.push(entry.name);\r\n          }\r\n        }\r\n\r\n        // Test each workflow file\r\n        for (const workflowFile of entries) {\r\n          const workflowTest = await this.testWorkflowFile(workflowFile);\r\n          result.workflows[workflowFile] = workflowTest;\r\n\r\n          if (!workflowTest.success) {\r\n            result.warnings.push(`Workflow ${workflowFile} has issues: ${workflowTest.error}`);\r\n          }\r\n        }\r\n\r\n        if (entries.length === 0) {\r\n          result.warnings.push('No workflow files found');\r\n        }\r\n      } catch {\r\n        result.warnings.push('Workflow directory not accessible');\r\n      }\r\n    } catch (error) {\r\n      result.errors.push(`Workflow testing failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Test a specific workflow file\r\n   */\r\n  async testWorkflowFile(filename) {\r\n    const result = {\r\n      success: true,\r\n      error: null,\r\n    };\r\n\r\n    try {\r\n      const workflowPath = `${this.workingDir}/.roo/workflows/${filename}`;\r\n      const content = await fs.readFile(workflowPath, 'utf8');\r\n\r\n      // Parse JSON\r\n      const workflow = JSON.parse(content);\r\n\r\n      // Basic validation\r\n      if (typeof workflow !== 'object' || workflow === null) {\r\n        result.success = false;\r\n        result.error = 'Workflow must be a JSON object';\r\n        return result;\r\n      }\r\n\r\n      // Check for recommended fields\r\n      const recommendedFields = ['name', 'description', 'steps'];\r\n      for (const field of recommendedFields) {\r\n        if (!(field in workflow)) {\r\n          result.success = false;\r\n          result.error = `Missing recommended field: ${field}`;\r\n          return result;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.error = `Workflow validation failed: ${error.message}`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"],"names":["promises","fs","ModeValidator","workingDir","testAllModes","result","success","errors","warnings","modes","sparcInitialized","checkSparcInitialization","initialized","push","availableModes","getAvailableModes","length","mode","modeTest","testMode","error","message","modeName","checks","accessible","configValid","executable","accessTest","testModeAccess","configTest","testModeConfig","execTest","testModeExecution","hasRoomodes","hasExecutable","stat","Deno","isFile","roomodesPath","content","readFile","config","JSON","parse","Object","keys","command","Command","args","cwd","stdout","stderr","output","errorOutput","TextDecoder","decode","modeConfig","requiredFields","field","includes","testCommand","testResult","testWorkflowFunctionality","workflows","workflowDir","entries","entry","readDir","name","endsWith","workflowFile","workflowTest","testWorkflowFile","filename","workflowPath","workflow","recommendedFields"],"mappings":"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"}