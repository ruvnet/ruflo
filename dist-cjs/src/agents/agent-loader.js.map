{"version":3,"sources":["../../../src/agents/agent-loader.ts"],"sourcesContent":["/**\r\n * Dynamic Agent Loader - Reads agent definitions from .claude/agents/ directory\r\n * This is the single source of truth for all agent types in the system\r\n */\r\n\r\nimport { readFileSync, existsSync } from 'node:fs';\r\nimport { glob } from 'glob';\r\nimport { resolve, dirname } from 'node:path';\r\nimport { parse as parseYaml } from 'yaml';\r\n\r\n// Legacy agent type mapping for backward compatibility\r\nconst LEGACY_AGENT_MAPPING = {\r\n  analyst: 'code-analyzer',\r\n  coordinator: 'task-orchestrator', \r\n  optimizer: 'perf-analyzer',\r\n  documenter: 'api-docs',\r\n  monitor: 'performance-benchmarker',\r\n  specialist: 'system-architect',\r\n  architect: 'system-architect',\r\n} as const;\r\n\r\n/**\r\n * Resolve legacy agent types to current equivalents\r\n */\r\nfunction resolveLegacyAgentType(legacyType: string): string {\r\n  return LEGACY_AGENT_MAPPING[legacyType as keyof typeof LEGACY_AGENT_MAPPING] || legacyType;\r\n}\r\n\r\nexport interface AgentDefinition {\r\n  name: string;\r\n  type?: string;\r\n  color?: string;\r\n  description: string;\r\n  capabilities?: string[];\r\n  priority?: 'low' | 'medium' | 'high' | 'critical';\r\n  hooks?: {\r\n    pre?: string;\r\n    post?: string;\r\n  };\r\n  content?: string; // The markdown content after frontmatter\r\n}\r\n\r\nexport interface AgentCategory {\r\n  name: string;\r\n  agents: AgentDefinition[];\r\n}\r\n\r\nclass AgentLoader {\r\n  private agentCache: Map<string, AgentDefinition> = new Map();\r\n  private categoriesCache: AgentCategory[] = [];\r\n  private lastLoadTime = 0;\r\n  private cacheExpiry = 60000; // 1 minute cache\r\n\r\n  /**\r\n   * Get the .claude/agents directory path\r\n   */\r\n  private getAgentsDirectory(): string {\r\n    // Start from current working directory and walk up to find .claude/agents\r\n    let currentDir = process.cwd();\r\n    \r\n    while (currentDir !== '/') {\r\n      const claudeAgentsPath = resolve(currentDir, '.claude', 'agents');\r\n      if (existsSync(claudeAgentsPath)) {\r\n        return claudeAgentsPath;\r\n      }\r\n      currentDir = dirname(currentDir);\r\n    }\r\n    \r\n    // Fallback to relative path\r\n    return resolve(process.cwd(), '.claude', 'agents');\r\n  }\r\n\r\n  /**\r\n   * Parse agent definition from markdown file\r\n   */\r\n  private parseAgentFile(filePath: string): AgentDefinition | null {\r\n    try {\r\n      const content = readFileSync(filePath, 'utf-8');\r\n      \r\n      // Split frontmatter and content\r\n      const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\r\n      if (!frontmatterMatch) {\r\n        console.warn(`No frontmatter found in ${filePath}`);\r\n        return null;\r\n      }\r\n\r\n      const [, yamlContent, markdownContent] = frontmatterMatch;\r\n      const frontmatter = parseYaml(yamlContent);\r\n\r\n      if (!frontmatter.name || !frontmatter.metadata?.description) {\r\n        console.warn(`Missing required fields (name, metadata.description) in ${filePath}`);\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        name: frontmatter.name,\r\n        type: frontmatter.type,\r\n        color: frontmatter.color,\r\n        description: frontmatter.metadata.description,\r\n        capabilities: frontmatter.metadata.capabilities || frontmatter.capabilities || [],\r\n        priority: frontmatter.priority || 'medium',\r\n        hooks: frontmatter.hooks,\r\n        content: markdownContent.trim(),\r\n      };\r\n    } catch (error) {\r\n      console.error(`Error parsing agent file ${filePath}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load all agent definitions from .claude/agents directory\r\n   */\r\n  private async loadAgents(): Promise<void> {\r\n    const agentsDir = this.getAgentsDirectory();\r\n    \r\n    if (!existsSync(agentsDir)) {\r\n      console.warn(`Agents directory not found: ${agentsDir}`);\r\n      return;\r\n    }\r\n\r\n    // Find all .md files in the agents directory\r\n    const agentFiles = await glob('**/*.md', {\r\n      cwd: agentsDir,\r\n      ignore: ['**/README.md', '**/MIGRATION_SUMMARY.md'],\r\n      absolute: true,\r\n    });\r\n\r\n    // Clear cache\r\n    this.agentCache.clear();\r\n    this.categoriesCache = [];\r\n\r\n    // Track categories\r\n    const categoryMap = new Map<string, AgentDefinition[]>();\r\n\r\n    // Parse each agent file\r\n    for (const filePath of agentFiles) {\r\n      const agent = this.parseAgentFile(filePath);\r\n      if (agent) {\r\n        this.agentCache.set(agent.name, agent);\r\n        \r\n        // Determine category from file path\r\n        const relativePath = filePath.replace(agentsDir, '');\r\n        const pathParts = relativePath.split('/');\r\n        const category = pathParts[1] || 'uncategorized'; // First directory after agents/\r\n        \r\n        if (!categoryMap.has(category)) {\r\n          categoryMap.set(category, []);\r\n        }\r\n        categoryMap.get(category)!.push(agent);\r\n      }\r\n    }\r\n\r\n    // Build categories array\r\n    this.categoriesCache = Array.from(categoryMap.entries()).map(([name, agents]) => ({\r\n      name,\r\n      agents: agents.sort((a, b) => a.name.localeCompare(b.name)),\r\n    }));\r\n\r\n    this.lastLoadTime = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Check if cache needs refresh\r\n   */\r\n  private needsRefresh(): boolean {\r\n    return Date.now() - this.lastLoadTime > this.cacheExpiry;\r\n  }\r\n\r\n  /**\r\n   * Ensure agents are loaded and cache is fresh\r\n   */\r\n  private async ensureLoaded(): Promise<void> {\r\n    if (this.agentCache.size === 0 || this.needsRefresh()) {\r\n      await this.loadAgents();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all available agent types\r\n   */\r\n  async getAvailableAgentTypes(): Promise<string[]> {\r\n    await this.ensureLoaded();\r\n    const currentTypes = Array.from(this.agentCache.keys());\r\n    const legacyTypes = Object.keys(LEGACY_AGENT_MAPPING);\r\n    // Return both current types and legacy types, removing duplicates\r\n    const combined = [...currentTypes, ...legacyTypes];\r\n    const uniqueTypes = Array.from(new Set(combined));\r\n    return uniqueTypes.sort();\r\n  }\r\n\r\n  /**\r\n   * Get agent definition by name\r\n   */\r\n  async getAgent(name: string): Promise<AgentDefinition | null> {\r\n    await this.ensureLoaded();\r\n    // First try the original name, then try the legacy mapping\r\n    return this.agentCache.get(name) || this.agentCache.get(resolveLegacyAgentType(name)) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all agent definitions\r\n   */\r\n  async getAllAgents(): Promise<AgentDefinition[]> {\r\n    await this.ensureLoaded();\r\n    return Array.from(this.agentCache.values()).sort((a, b) => a.name.localeCompare(b.name));\r\n  }\r\n\r\n  /**\r\n   * Get agents organized by category\r\n   */\r\n  async getAgentCategories(): Promise<AgentCategory[]> {\r\n    await this.ensureLoaded();\r\n    return this.categoriesCache;\r\n  }\r\n\r\n  /**\r\n   * Search agents by capabilities, description, or name\r\n   */\r\n  async searchAgents(query: string): Promise<AgentDefinition[]> {\r\n    await this.ensureLoaded();\r\n    const lowerQuery = query.toLowerCase();\r\n    \r\n    return Array.from(this.agentCache.values()).filter(agent => {\r\n      return (\r\n        agent.name.toLowerCase().includes(lowerQuery) ||\r\n        agent.description.toLowerCase().includes(lowerQuery) ||\r\n        agent.capabilities?.some(cap => cap.toLowerCase().includes(lowerQuery)) ||\r\n        false\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if an agent type is valid\r\n   */\r\n  async isValidAgentType(name: string): Promise<boolean> {\r\n    await this.ensureLoaded();\r\n    // First try the original name, then try the legacy mapping\r\n    return this.agentCache.has(name) || this.agentCache.has(resolveLegacyAgentType(name));\r\n  }\r\n\r\n  /**\r\n   * Get agents by category name\r\n   */\r\n  async getAgentsByCategory(category: string): Promise<AgentDefinition[]> {\r\n    const categories = await this.getAgentCategories();\r\n    const found = categories.find(cat => cat.name === category);\r\n    return found?.agents || [];\r\n  }\r\n\r\n  /**\r\n   * Force refresh the agent cache\r\n   */\r\n  async refresh(): Promise<void> {\r\n    this.lastLoadTime = 0; // Force reload\r\n    await this.loadAgents();\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const agentLoader = new AgentLoader();\r\n\r\n// Convenience functions\r\nexport const getAvailableAgentTypes = () => agentLoader.getAvailableAgentTypes();\r\nexport const getAgent = (name: string) => agentLoader.getAgent(name);\r\nexport const getAllAgents = () => agentLoader.getAllAgents();\r\nexport const getAgentCategories = () => agentLoader.getAgentCategories();\r\nexport const searchAgents = (query: string) => agentLoader.searchAgents(query);\r\nexport const isValidAgentType = (name: string) => agentLoader.isValidAgentType(name);\r\nexport const getAgentsByCategory = (category: string) => agentLoader.getAgentsByCategory(category);\r\nexport const refreshAgents = () => agentLoader.refresh();\r\n\r\n// Export legacy mapping utilities\r\nexport { resolveLegacyAgentType, LEGACY_AGENT_MAPPING };"],"names":["readFileSync","existsSync","glob","resolve","dirname","parse","parseYaml","LEGACY_AGENT_MAPPING","analyst","coordinator","optimizer","documenter","monitor","specialist","architect","resolveLegacyAgentType","legacyType","AgentLoader","agentCache","Map","categoriesCache","lastLoadTime","cacheExpiry","getAgentsDirectory","currentDir","process","cwd","claudeAgentsPath","parseAgentFile","filePath","content","frontmatterMatch","match","console","warn","yamlContent","markdownContent","frontmatter","name","metadata","description","type","color","capabilities","priority","hooks","trim","error","loadAgents","agentsDir","agentFiles","ignore","absolute","clear","categoryMap","agent","set","relativePath","replace","pathParts","split","category","has","get","push","Array","from","entries","map","agents","sort","a","b","localeCompare","Date","now","needsRefresh","ensureLoaded","size","getAvailableAgentTypes","currentTypes","keys","legacyTypes","Object","combined","uniqueTypes","Set","getAgent","getAllAgents","values","getAgentCategories","searchAgents","query","lowerQuery","toLowerCase","filter","includes","some","cap","isValidAgentType","getAgentsByCategory","categories","found","find","cat","refresh","agentLoader","refreshAgents"],"mappings":"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"}