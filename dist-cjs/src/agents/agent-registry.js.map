{"version":3,"sources":["../../../src/agents/agent-registry.ts"],"sourcesContent":["/**\r\n * Agent Registry with Memory Integration\r\n * Provides persistent storage and coordination for agent management\r\n */\r\n\r\nimport type { DistributedMemorySystem } from '../memory/distributed-memory.js';\r\nimport type { AgentState, AgentType, AgentStatus } from '../swarm/types.js';\r\nimport { EventEmitter } from 'node:events';\r\n\r\nexport interface AgentRegistryEntry {\r\n  agent: AgentState;\r\n  createdAt: Date;\r\n  lastUpdated: Date;\r\n  tags: string[];\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface AgentQuery {\r\n  type?: AgentType;\r\n  status?: AgentStatus;\r\n  tags?: string[];\r\n  healthThreshold?: number;\r\n  namePattern?: string;\r\n  createdAfter?: Date;\r\n  lastActiveAfter?: Date;\r\n}\r\n\r\nexport interface AgentStatistics {\r\n  totalAgents: number;\r\n  byType: Record<AgentType, number>;\r\n  byStatus: Record<AgentStatus, number>;\r\n  averageHealth: number;\r\n  activeAgents: number;\r\n  totalUptime: number;\r\n  tasksCompleted: number;\r\n  successRate: number;\r\n}\r\n\r\n/**\r\n * Centralized agent registry with persistent storage\r\n */\r\nexport class AgentRegistry extends EventEmitter {\r\n  private memory: DistributedMemorySystem;\r\n  private namespace: string;\r\n  private cache = new Map<string, AgentRegistryEntry>();\r\n  private cacheExpiry = 60000; // 1 minute\r\n  private lastCacheUpdate = 0;\r\n\r\n  constructor(memory: DistributedMemorySystem, namespace: string = 'agents') {\r\n    super();\r\n    this.memory = memory;\r\n    this.namespace = namespace;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    await this.loadFromMemory();\r\n    this.emit('registry:initialized');\r\n  }\r\n\r\n  /**\r\n   * Register a new agent in the registry\r\n   */\r\n  async registerAgent(agent: AgentState, tags: string[] = []): Promise<void> {\r\n    const entry: AgentRegistryEntry = {\r\n      agent,\r\n      createdAt: new Date(),\r\n      lastUpdated: new Date(),\r\n      tags: [...tags, agent.type, agent.status],\r\n      metadata: {\r\n        registeredBy: 'agent-manager',\r\n        version: '1.0.0',\r\n      },\r\n    };\r\n\r\n    // Store in memory\r\n    const key = this.getAgentKey(agent.id.id);\r\n    await this.memory.store(key, entry, {\r\n      type: 'agent-registry',\r\n      tags: entry.tags,\r\n      partition: this.namespace,\r\n    });\r\n\r\n    // Update cache\r\n    this.cache.set(agent.id.id, entry);\r\n\r\n    this.emit('agent:registered', { agentId: agent.id.id, agent });\r\n  }\r\n\r\n  /**\r\n   * Update agent information in registry\r\n   */\r\n  async updateAgent(agentId: string, updates: Partial<AgentState>): Promise<void> {\r\n    const entry = await this.getAgentEntry(agentId);\r\n    if (!entry) {\r\n      throw new Error(`Agent ${agentId} not found in registry`);\r\n    }\r\n\r\n    // Merge updates\r\n    entry.agent = { ...entry.agent, ...updates };\r\n    entry.lastUpdated = new Date();\r\n    entry.tags = [\r\n      entry.agent.type,\r\n      entry.agent.status,\r\n      ...entry.tags.filter((t) => t !== entry.agent.type && t !== entry.agent.status),\r\n    ];\r\n\r\n    // Store updated entry\r\n    const key = this.getAgentKey(agentId);\r\n    await this.memory.store(key, entry, {\r\n      type: 'agent-registry',\r\n      tags: entry.tags,\r\n      partition: this.namespace,\r\n    });\r\n\r\n    // Update cache\r\n    this.cache.set(agentId, entry);\r\n\r\n    this.emit('agent:updated', { agentId, agent: entry.agent });\r\n  }\r\n\r\n  /**\r\n   * Remove agent from registry\r\n   */\r\n  async unregisterAgent(agentId: string, preserveHistory: boolean = true): Promise<void> {\r\n    const entry = await this.getAgentEntry(agentId);\r\n    if (!entry) {\r\n      return; // Already removed\r\n    }\r\n\r\n    if (preserveHistory) {\r\n      // Move to archived partition\r\n      const archiveKey = this.getArchiveKey(agentId);\r\n      await this.memory.store(\r\n        archiveKey,\r\n        {\r\n          ...entry,\r\n          archivedAt: new Date(),\r\n          reason: 'agent_removed',\r\n        },\r\n        {\r\n          type: 'agent-archive',\r\n          tags: [...entry.tags, 'archived'],\r\n          partition: 'archived',\r\n        },\r\n      );\r\n    }\r\n\r\n    // Remove from active registry\r\n    const key = this.getAgentKey(agentId);\r\n    await this.memory.deleteEntry(key);\r\n\r\n    // Remove from cache\r\n    this.cache.delete(agentId);\r\n\r\n    this.emit('agent:unregistered', { agentId, preserved: preserveHistory });\r\n  }\r\n\r\n  /**\r\n   * Get agent by ID\r\n   */\r\n  async getAgent(agentId: string): Promise<AgentState | null> {\r\n    const entry = await this.getAgentEntry(agentId);\r\n    return entry?.agent || null;\r\n  }\r\n\r\n  /**\r\n   * Get agent entry with metadata\r\n   */\r\n  async getAgentEntry(agentId: string): Promise<AgentRegistryEntry | null> {\r\n    // Check cache first\r\n    if (this.cache.has(agentId) && this.isCacheValid()) {\r\n      return this.cache.get(agentId) || null;\r\n    }\r\n\r\n    // Load from memory\r\n    const key = this.getAgentKey(agentId);\r\n    const memoryEntry = await this.memory.retrieve(key);\r\n\r\n    if (memoryEntry && memoryEntry.value) {\r\n      // Convert MemoryEntry to AgentRegistryEntry\r\n      const registryEntry: AgentRegistryEntry = memoryEntry.value as AgentRegistryEntry;\r\n      this.cache.set(agentId, registryEntry);\r\n      return registryEntry;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Query agents by criteria\r\n   */\r\n  async queryAgents(query: AgentQuery = {}): Promise<AgentState[]> {\r\n    await this.refreshCacheIfNeeded();\r\n\r\n    let agents = Array.from(this.cache.values()).map((entry) => entry.agent);\r\n\r\n    // Apply filters\r\n    if (query.type) {\r\n      agents = agents.filter((agent) => agent.type === query.type);\r\n    }\r\n\r\n    if (query.status) {\r\n      agents = agents.filter((agent) => agent.status === query.status);\r\n    }\r\n\r\n    if (query.healthThreshold !== undefined) {\r\n      agents = agents.filter((agent) => agent.health >= query.healthThreshold!);\r\n    }\r\n\r\n    if (query.namePattern) {\r\n      const pattern = new RegExp(query.namePattern, 'i');\r\n      agents = agents.filter((agent) => pattern.test(agent.name));\r\n    }\r\n\r\n    if (query.tags && query.tags.length > 0) {\r\n      const entries = Array.from(this.cache.values());\r\n      const matchingEntries = entries.filter((entry) =>\r\n        query.tags!.some((tag) => entry.tags.includes(tag)),\r\n      );\r\n      agents = matchingEntries.map((entry) => entry.agent);\r\n    }\r\n\r\n    if (query.createdAfter) {\r\n      const entries = Array.from(this.cache.values());\r\n      const matchingEntries = entries.filter((entry) => entry.createdAt >= query.createdAfter!);\r\n      agents = matchingEntries.map((entry) => entry.agent);\r\n    }\r\n\r\n    if (query.lastActiveAfter) {\r\n      agents = agents.filter((agent) => agent.metrics.lastActivity >= query.lastActiveAfter!);\r\n    }\r\n\r\n    return agents;\r\n  }\r\n\r\n  /**\r\n   * Get all registered agents\r\n   */\r\n  async getAllAgents(): Promise<AgentState[]> {\r\n    return this.queryAgents();\r\n  }\r\n\r\n  /**\r\n   * Get agents by type\r\n   */\r\n  async getAgentsByType(type: AgentType): Promise<AgentState[]> {\r\n    return this.queryAgents({ type });\r\n  }\r\n\r\n  /**\r\n   * Get agents by status\r\n   */\r\n  async getAgentsByStatus(status: AgentStatus): Promise<AgentState[]> {\r\n    return this.queryAgents({ status });\r\n  }\r\n\r\n  /**\r\n   * Get healthy agents\r\n   */\r\n  async getHealthyAgents(threshold: number = 0.7): Promise<AgentState[]> {\r\n    return this.queryAgents({ healthThreshold: threshold });\r\n  }\r\n\r\n  /**\r\n   * Get registry statistics\r\n   */\r\n  async getStatistics(): Promise<AgentStatistics> {\r\n    const agents = await this.getAllAgents();\r\n\r\n    const stats: AgentStatistics = {\r\n      totalAgents: agents.length,\r\n      byType: {} as Record<AgentType, number>,\r\n      byStatus: {} as Record<AgentStatus, number>,\r\n      averageHealth: 0,\r\n      activeAgents: 0,\r\n      totalUptime: 0,\r\n      tasksCompleted: 0,\r\n      successRate: 0,\r\n    };\r\n\r\n    if (agents.length === 0) {\r\n      return stats;\r\n    }\r\n\r\n    // Count by type and status\r\n    for (const agent of agents) {\r\n      stats.byType[agent.type] = (stats.byType[agent.type] || 0) + 1;\r\n      stats.byStatus[agent.status] = (stats.byStatus[agent.status] || 0) + 1;\r\n\r\n      if (agent.status === 'idle' || agent.status === 'busy') {\r\n        stats.activeAgents++;\r\n      }\r\n\r\n      stats.totalUptime += agent.metrics.totalUptime;\r\n      stats.tasksCompleted += agent.metrics.tasksCompleted;\r\n    }\r\n\r\n    // Calculate averages\r\n    stats.averageHealth = agents.reduce((sum, agent) => sum + agent.health, 0) / agents.length;\r\n\r\n    const totalTasks = agents.reduce(\r\n      (sum, agent) => sum + agent.metrics.tasksCompleted + agent.metrics.tasksFailed,\r\n      0,\r\n    );\r\n\r\n    if (totalTasks > 0) {\r\n      stats.successRate = stats.tasksCompleted / totalTasks;\r\n    }\r\n\r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * Search agents by capabilities\r\n   */\r\n  async searchByCapabilities(requiredCapabilities: string[]): Promise<AgentState[]> {\r\n    const agents = await this.getAllAgents();\r\n\r\n    return agents.filter((agent) => {\r\n      const capabilities = [\r\n        ...agent.capabilities.languages,\r\n        ...agent.capabilities.frameworks,\r\n        ...agent.capabilities.domains,\r\n        ...agent.capabilities.tools,\r\n      ];\r\n\r\n      return requiredCapabilities.every((required) =>\r\n        capabilities.some((cap) => cap.toLowerCase().includes(required.toLowerCase())),\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find best agent for task\r\n   */\r\n  async findBestAgent(\r\n    taskType: string,\r\n    requiredCapabilities: string[] = [],\r\n    preferredAgent?: string,\r\n  ): Promise<AgentState | null> {\r\n    let candidates = await this.getHealthyAgents(0.5);\r\n\r\n    // Filter by capabilities if specified\r\n    if (requiredCapabilities.length > 0) {\r\n      candidates = await this.searchByCapabilities(requiredCapabilities);\r\n    }\r\n\r\n    // Prefer specific agent if available and healthy\r\n    if (preferredAgent) {\r\n      const preferred = candidates.find(\r\n        (agent) => agent.id.id === preferredAgent || agent.name === preferredAgent,\r\n      );\r\n      if (preferred) return preferred;\r\n    }\r\n\r\n    // Filter by availability\r\n    candidates = candidates.filter(\r\n      (agent) =>\r\n        agent.status === 'idle' &&\r\n        agent.workload < 0.8 &&\r\n        agent.capabilities.maxConcurrentTasks > 0,\r\n    );\r\n\r\n    if (candidates.length === 0) return null;\r\n\r\n    // Score candidates\r\n    const scored = candidates.map((agent) => ({\r\n      agent,\r\n      score: this.calculateAgentScore(agent, taskType, requiredCapabilities),\r\n    }));\r\n\r\n    // Sort by score (highest first)\r\n    scored.sort((a, b) => b.score - a.score);\r\n\r\n    return scored[0]?.agent || null;\r\n  }\r\n\r\n  /**\r\n   * Store agent coordination data\r\n   */\r\n  async storeCoordinationData(agentId: string, data: any): Promise<void> {\r\n    const key = `coordination:${agentId}`;\r\n    await this.memory.store(\r\n      key,\r\n      {\r\n        agentId,\r\n        data,\r\n        timestamp: new Date(),\r\n      },\r\n      {\r\n        type: 'agent-coordination',\r\n        tags: ['coordination', agentId],\r\n        partition: this.namespace,\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retrieve agent coordination data\r\n   */\r\n  async getCoordinationData(agentId: string): Promise<any> {\r\n    const key = `coordination:${agentId}`;\r\n    const result = await this.memory.retrieve(key);\r\n    return result?.value || null;\r\n  }\r\n\r\n  // === PRIVATE METHODS ===\r\n\r\n  private async loadFromMemory(): Promise<void> {\r\n    try {\r\n      const entries = await this.memory.query({\r\n        type: 'state' as const,\r\n        namespace: this.namespace,\r\n      });\r\n\r\n      this.cache.clear();\r\n      for (const entry of entries) {\r\n        if (entry.value && entry.value.agent) {\r\n          this.cache.set(entry.value.agent.id.id, entry.value);\r\n        }\r\n      }\r\n\r\n      this.lastCacheUpdate = Date.now();\r\n    } catch (error) {\r\n      console.warn('Failed to load agent registry from memory:', error);\r\n    }\r\n  }\r\n\r\n  private async refreshCacheIfNeeded(): Promise<void> {\r\n    if (!this.isCacheValid()) {\r\n      await this.loadFromMemory();\r\n    }\r\n  }\r\n\r\n  private isCacheValid(): boolean {\r\n    return Date.now() - this.lastCacheUpdate < this.cacheExpiry;\r\n  }\r\n\r\n  private getAgentKey(agentId: string): string {\r\n    return `agent:${agentId}`;\r\n  }\r\n\r\n  private getArchiveKey(agentId: string): string {\r\n    return `archived:${agentId}:${Date.now()}`;\r\n  }\r\n\r\n  private calculateAgentScore(\r\n    agent: AgentState,\r\n    taskType: string,\r\n    requiredCapabilities: string[],\r\n  ): number {\r\n    let score = 0;\r\n\r\n    // Base health score (0-40 points)\r\n    score += agent.health * 40;\r\n\r\n    // Success rate score (0-30 points)\r\n    score += agent.metrics.successRate * 30;\r\n\r\n    // Availability score (0-20 points)\r\n    const availability = 1 - agent.workload;\r\n    score += availability * 20;\r\n\r\n    // Capability match score (0-10 points)\r\n    if (requiredCapabilities.length > 0) {\r\n      const agentCaps = [\r\n        ...agent.capabilities.languages,\r\n        ...agent.capabilities.frameworks,\r\n        ...agent.capabilities.domains,\r\n        ...agent.capabilities.tools,\r\n      ];\r\n\r\n      const matches = requiredCapabilities.filter((required) =>\r\n        agentCaps.some((cap) => cap.toLowerCase().includes(required.toLowerCase())),\r\n      );\r\n\r\n      score += (matches.length / requiredCapabilities.length) * 10;\r\n    }\r\n\r\n    return score;\r\n  }\r\n}\r\n"],"names":["EventEmitter","AgentRegistry","memory","namespace","cache","Map","cacheExpiry","lastCacheUpdate","initialize","loadFromMemory","emit","registerAgent","agent","tags","entry","createdAt","Date","lastUpdated","type","status","metadata","registeredBy","version","key","getAgentKey","id","store","partition","set","agentId","updateAgent","updates","getAgentEntry","Error","filter","t","unregisterAgent","preserveHistory","archiveKey","getArchiveKey","archivedAt","reason","deleteEntry","delete","preserved","getAgent","has","isCacheValid","get","memoryEntry","retrieve","value","registryEntry","queryAgents","query","refreshCacheIfNeeded","agents","Array","from","values","map","healthThreshold","undefined","health","namePattern","pattern","RegExp","test","name","length","entries","matchingEntries","some","tag","includes","createdAfter","lastActiveAfter","metrics","lastActivity","getAllAgents","getAgentsByType","getAgentsByStatus","getHealthyAgents","threshold","getStatistics","stats","totalAgents","byType","byStatus","averageHealth","activeAgents","totalUptime","tasksCompleted","successRate","reduce","sum","totalTasks","tasksFailed","searchByCapabilities","requiredCapabilities","capabilities","languages","frameworks","domains","tools","every","required","cap","toLowerCase","findBestAgent","taskType","preferredAgent","candidates","preferred","find","workload","maxConcurrentTasks","scored","score","calculateAgentScore","sort","a","b","storeCoordinationData","data","timestamp","getCoordinationData","result","clear","now","error","console","warn","availability","agentCaps","matches"],"mappings":"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"}