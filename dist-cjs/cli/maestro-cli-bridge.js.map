{
  "version": 3,
  "sources": ["../../src/cli/maestro-cli-bridge.ts"],
  "sourcesContent": ["/**\n * Maestro CLI Bridge - Optimization Implementation\n * \n * This bridge provides optimized CLI integration for the Maestro specifications-driven\n * development framework, implementing performance enhancements and intelligent features\n * while maintaining compatibility with existing infrastructure.\n * \n * Key optimizations:\n * - Parallel dependency initialization with caching\n * - Performance monitoring integration\n * - Configuration validation and management\n * - Intelligent error handling and recovery\n */\n\nimport { join } from 'path';\nimport chalk from 'chalk';\nimport { EventEmitter } from 'events';\n\n// Core infrastructure\nimport { Config } from '../utils/types.js';\nimport { SystemError } from '../utils/errors.js';\nimport { IEventBus } from '../core/event-bus.js';\nimport { ILogger } from '../core/logger.js';\nimport { IMemoryManager } from '../memory/manager.js';\nimport { AgentManager } from '../agents/agent-manager.js';\nimport { Orchestrator } from '../core/orchestrator.js';\n\n// Maestro system\nimport { MaestroSwarmCoordinator, MaestroSwarmConfig } from '../maestro/maestro-swarm-coordinator.js';\n\n// Performance monitoring\nimport { agenticHookManager } from '../services/agentic-flow-hooks/index.js';\n\nexport interface MaestroCLIBridgeConfig {\n  enablePerformanceMonitoring: boolean;\n  initializationTimeout: number;\n  cacheEnabled: boolean;\n  logLevel: 'debug' | 'info' | 'warn' | 'error';\n}\n\nexport interface PerformanceMetrics {\n  operation: string;\n  duration: number;\n  success: boolean;\n  timestamp: number;\n  memoryUsage?: number;\n  error?: string;\n}\n\n/**\n * CLI Bridge for optimized Maestro integration\n */\nexport class MaestroCLIBridge {\n  private swarmCoordinator?: MaestroSwarmCoordinator;\n  private initializationCache: Map<string, any> = new Map();\n  private configCache?: Config;\n  private performanceMetrics: PerformanceMetrics[] = [];\n  private initialized: boolean = false;\n\n  constructor(\n    private bridgeConfig: Partial<MaestroCLIBridgeConfig> = {}\n  ) {\n    // Set default configuration\n    this.bridgeConfig = {\n      enablePerformanceMonitoring: true,\n      initializationTimeout: 30000, // 30 seconds\n      cacheEnabled: true,\n      logLevel: 'info',\n      ...this.bridgeConfig\n    };\n  }\n\n  /**\n   * Initialize orchestrator with parallel dependency loading and caching\n   */\n  async initializeOrchestrator(): Promise<MaestroSwarmCoordinator> {\n    const startTime = Date.now();\n\n    try {\n      if (this.swarmCoordinator && this.initialized) {\n        console.log(chalk.green('\u2705 Using cached Maestro swarm coordinator'));\n        return this.swarmCoordinator;\n      }\n\n      console.log(chalk.blue('\uD83D\uDE80 Initializing Maestro orchestrator...'));\n\n      // Parallel initialization with caching\n      const [config, eventBus, logger, memoryManager, agentManager, mainOrchestrator] = \n        await Promise.all([\n          this.getOrCreateConfig(),\n          this.getOrCreateEventBus(),\n          this.getOrCreateLogger(),\n          this.getOrCreateMemoryManager(),\n          this.getOrCreateAgentManager(),\n          this.getOrCreateMainOrchestrator()\n        ]);\n\n      // Create optimized Maestro configuration\n      const maestroConfig = this.getOptimizedMaestroConfig();\n\n      // Initialize native swarm coordinator\n      this.swarmCoordinator = new MaestroSwarmCoordinator(\n        maestroConfig,\n        eventBus,\n        logger\n      );\n\n      // Initialize native hive mind swarm with performance monitoring\n      await this.executeWithMonitoring('swarm_init', async () => {\n        const swarmId = await this.swarmCoordinator!.initialize();\n        console.log(chalk.green(`\u2705 Native hive mind swarm initialized: ${swarmId}`));\n      });\n\n      this.initialized = true;\n      const duration = Date.now() - startTime;\n      \n      console.log(chalk.green(`\u2705 Maestro orchestrator ready (${duration}ms)`));\n      \n      // Report performance metrics\n      await this.reportPerformanceMetric('orchestrator_init', duration, true);\n\n      return this.swarmCoordinator;\n\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      await this.reportPerformanceMetric('orchestrator_init', duration, false, error instanceof Error ? error.message : String(error));\n      \n      console.error(chalk.red(`\u274C Failed to initialize Maestro orchestrator: ${error instanceof Error ? error.message : String(error)}`));\n      throw error;\n    }\n  }\n\n  /**\n   * Execute operation with performance monitoring\n   */\n  async executeWithMonitoring<T>(\n    operation: string,\n    fn: () => Promise<T>,\n    context?: Record<string, any>\n  ): Promise<T> {\n    if (!this.bridgeConfig.enablePerformanceMonitoring) {\n      return await fn();\n    }\n\n    const startTime = Date.now();\n    const startMemory = process.memoryUsage().heapUsed;\n\n    try {\n      // Execute pre-operation hooks\n      await this.executePerformanceHook('performance-metric', {\n        metric: `${operation}_start`,\n        value: startTime,\n        unit: 'timestamp',\n        context: { operation, ...context }\n      });\n\n      const result = await fn();\n      \n      const endTime = Date.now();\n      const endMemory = process.memoryUsage().heapUsed;\n      const duration = endTime - startTime;\n      const memoryDelta = endMemory - startMemory;\n\n      // Record metrics\n      await this.reportPerformanceMetric(operation, duration, true, undefined, memoryDelta);\n\n      // Execute post-operation hooks\n      await this.executePerformanceHook('performance-metric', {\n        metric: `${operation}_complete`,\n        value: duration,\n        unit: 'milliseconds',\n        context: { \n          operation, \n          success: true, \n          memoryDelta: memoryDelta / 1024 / 1024, // MB\n          ...context \n        }\n      });\n\n      return result;\n\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const memoryDelta = process.memoryUsage().heapUsed - startMemory;\n\n      await this.reportPerformanceMetric(operation, duration, false, error instanceof Error ? error.message : String(error), memoryDelta);\n\n      // Execute error hooks\n      await this.executePerformanceHook('performance-metric', {\n        metric: `${operation}_error`,\n        value: duration,\n        unit: 'milliseconds',\n        context: { \n          operation, \n          success: false, \n          error: error instanceof Error ? error.message : String(error),\n          memoryDelta: memoryDelta / 1024 / 1024, // MB\n          ...context \n        }\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get optimized Maestro configuration\n   */\n  private getOptimizedMaestroConfig(): MaestroSwarmConfig {\n    return {\n      hiveMindConfig: {\n        name: 'maestro-specs-driven-swarm',\n        topology: 'specs-driven',\n        queenMode: 'strategic',\n        maxAgents: 8,\n        consensusThreshold: 0.66,\n        memoryTTL: 86400000,\n        autoSpawn: true,\n        enableConsensus: true,\n        enableMemory: true,\n        enableCommunication: true\n      },\n      enableConsensusValidation: true,\n      enableLivingDocumentation: true,\n      enableSteeringIntegration: true,\n      specsDirectory: join(process.cwd(), 'docs', 'maestro', 'specs'),\n      steeringDirectory: join(process.cwd(), 'docs', 'maestro', 'steering')\n    };\n  }\n\n  /**\n   * Cached configuration management\n   */\n  private async getOrCreateConfig(): Promise<Config> {\n    const cacheKey = 'config';\n    \n    if (this.bridgeConfig.cacheEnabled && this.initializationCache.has(cacheKey)) {\n      return this.initializationCache.get(cacheKey);\n    }\n\n    // Create basic configuration - in a real implementation, this would load from file\n    const config: Config = {\n      env: (process.env.NODE_ENV as 'development' | 'production' | 'test') || 'development',\n      logLevel: this.bridgeConfig.logLevel || 'info',\n      enableMetrics: this.bridgeConfig.enablePerformanceMonitoring || true\n    };\n\n    if (this.bridgeConfig.cacheEnabled) {\n      this.initializationCache.set(cacheKey, config);\n    }\n\n    return config;\n  }\n\n  /**\n   * Cached event bus creation\n   */\n  private async getOrCreateEventBus(): Promise<IEventBus> {\n    const cacheKey = 'eventBus';\n    \n    if (this.bridgeConfig.cacheEnabled && this.initializationCache.has(cacheKey)) {\n      return this.initializationCache.get(cacheKey);\n    }\n\n    // Create simple event bus implementation\n    const eventBus: IEventBus = new EventEmitter() as any;\n\n    if (this.bridgeConfig.cacheEnabled) {\n      this.initializationCache.set(cacheKey, eventBus);\n    }\n\n    return eventBus;\n  }\n\n  /**\n   * Cached logger creation\n   */\n  private async getOrCreateLogger(): Promise<ILogger> {\n    const cacheKey = 'logger';\n    \n    if (this.bridgeConfig.cacheEnabled && this.initializationCache.has(cacheKey)) {\n      return this.initializationCache.get(cacheKey);\n    }\n\n    // Create simple logger implementation\n    const logger: ILogger = {\n      debug: (message: string, ...args: any[]) => {\n        if (this.bridgeConfig.logLevel === 'debug') {\n          console.log(chalk.gray(`[DEBUG] ${message}`), ...args);\n        }\n      },\n      info: (message: string, ...args: any[]) => {\n        console.log(chalk.blue(`[INFO] ${message}`), ...args);\n      },\n      warn: (message: string, ...args: any[]) => {\n        console.log(chalk.yellow(`[WARN] ${message}`), ...args);\n      },\n      error: (message: string, ...args: any[]) => {\n        console.log(chalk.red(`[ERROR] ${message}`), ...args);\n      },\n      configure: async (config: any) => { /* no-op */ },\n      level: this.bridgeConfig.logLevel\n    };\n\n    if (this.bridgeConfig.cacheEnabled) {\n      this.initializationCache.set(cacheKey, logger);\n    }\n\n    return logger;\n  }\n\n  /**\n   * Cached memory manager creation\n   */\n  private async getOrCreateMemoryManager(): Promise<IMemoryManager> {\n    const cacheKey = 'memoryManager';\n    \n    if (this.bridgeConfig.cacheEnabled && this.initializationCache.has(cacheKey)) {\n      return this.initializationCache.get(cacheKey);\n    }\n\n    // Create simple memory manager implementation\n    const memoryManager: IMemoryManager = {\n      initialize: async () => {},\n      shutdown: async () => {},\n      createBank: async (agentId: string) => `bank-${agentId}`,\n      closeBank: async (bankId: string) => {},\n      store: async (entry: any) => {},\n      retrieve: async (id: string) => undefined,\n      query: async (query: any) => [],\n      update: async (id: string, updates: any) => {},\n      delete: async (id: string) => {},\n      getHealthStatus: async () => ({ healthy: true }),\n      performMaintenance: async () => {}\n    };\n\n    if (this.bridgeConfig.cacheEnabled) {\n      this.initializationCache.set(cacheKey, memoryManager);\n    }\n\n    return memoryManager;\n  }\n\n  /**\n   * Cached agent manager creation\n   */\n  private async getOrCreateAgentManager(): Promise<AgentManager> {\n    const cacheKey = 'agentManager';\n    \n    if (this.bridgeConfig.cacheEnabled && this.initializationCache.has(cacheKey)) {\n      return this.initializationCache.get(cacheKey);\n    }\n\n    // Create agent manager - this would integrate with existing system\n    const config = await this.getOrCreateConfig();\n    const eventBus = await this.getOrCreateEventBus();\n    const logger = await this.getOrCreateLogger();\n    const memoryManager = await this.getOrCreateMemoryManager();\n    \n    const agentManager = new AgentManager(\n      { maxAgents: 10 }, // AgentManagerConfig\n      logger,\n      eventBus,\n      memoryManager as any // Cast to DistributedMemorySystem\n    );\n\n    if (this.bridgeConfig.cacheEnabled) {\n      this.initializationCache.set(cacheKey, agentManager);\n    }\n\n    return agentManager;\n  }\n\n  /**\n   * Cached main orchestrator creation\n   */\n  private async getOrCreateMainOrchestrator(): Promise<Orchestrator> {\n    const cacheKey = 'mainOrchestrator';\n    \n    if (this.bridgeConfig.cacheEnabled && this.initializationCache.has(cacheKey)) {\n      return this.initializationCache.get(cacheKey);\n    }\n\n    // Create main orchestrator with required parameters\n    const config = await this.getOrCreateConfig();\n    const eventBus = await this.getOrCreateEventBus();\n    const logger = await this.getOrCreateLogger();\n    const memoryManager = await this.getOrCreateMemoryManager();\n    \n    // Create mock dependencies for orchestrator\n    const mockTerminalManager = {} as any;\n    const mockCoordinationManager = {} as any;\n    const mockMCPServer = {} as any;\n    \n    const orchestrator = new Orchestrator(\n      config,\n      mockTerminalManager,\n      memoryManager,\n      mockCoordinationManager,\n      mockMCPServer,\n      eventBus,\n      logger\n    );\n\n    if (this.bridgeConfig.cacheEnabled) {\n      this.initializationCache.set(cacheKey, orchestrator);\n    }\n\n    return orchestrator;\n  }\n\n  /**\n   * Execute performance hooks\n   */\n  private async executePerformanceHook(type: string, data: any): Promise<void> {\n    try {\n      await agenticHookManager.executeHooks(type as any, data, {\n        sessionId: `maestro-cli-${Date.now()}`,\n        timestamp: Date.now(),\n        correlationId: `maestro-performance`,\n        metadata: { source: 'maestro-cli-bridge' },\n        memory: { namespace: 'maestro', provider: 'memory', cache: new Map() },\n        neural: { modelId: 'default', patterns: null as any, training: null as any },\n        performance: { metrics: new Map(), bottlenecks: [], optimizations: [] }\n      } as any);\n    } catch (error) {\n      // Don't let hook failures break the main operation\n      console.warn(chalk.yellow(`\u26A0\uFE0F  Performance hook failed: ${error instanceof Error ? error.message : String(error)}`));\n    }\n  }\n\n  /**\n   * Report performance metrics\n   */\n  private async reportPerformanceMetric(\n    operation: string,\n    duration: number,\n    success: boolean,\n    error?: string,\n    memoryUsage?: number\n  ): Promise<void> {\n    const metric: PerformanceMetrics = {\n      operation,\n      duration,\n      success,\n      timestamp: Date.now(),\n      memoryUsage,\n      error\n    };\n\n    this.performanceMetrics.push(metric);\n\n    // Keep only last 100 metrics\n    if (this.performanceMetrics.length > 100) {\n      this.performanceMetrics.shift();\n    }\n\n    // Log performance information\n    if (this.bridgeConfig.logLevel === 'debug') {\n      const memoryInfo = memoryUsage ? ` (${(memoryUsage / 1024 / 1024).toFixed(2)}MB)` : '';\n      console.log(\n        chalk.gray(\n          `[PERF] ${operation}: ${duration}ms ${success ? '\u2713' : '\u2717'}${memoryInfo}`\n        )\n      );\n    }\n  }\n\n  /**\n   * Get performance summary\n   */\n  getPerformanceSummary(): any {\n    const successful = this.performanceMetrics.filter(m => m.success);\n    const failed = this.performanceMetrics.filter(m => !m.success);\n    \n    const avgDuration = successful.length > 0 \n      ? successful.reduce((sum, m) => sum + m.duration, 0) / successful.length\n      : 0;\n\n    return {\n      totalOperations: this.performanceMetrics.length,\n      successfulOperations: successful.length,\n      failedOperations: failed.length,\n      successRate: this.performanceMetrics.length > 0 \n        ? (successful.length / this.performanceMetrics.length) * 100\n        : 0,\n      averageDuration: Math.round(avgDuration),\n      recentMetrics: this.performanceMetrics.slice(-10)\n    };\n  }\n\n  /**\n   * Validate configuration and environment\n   */\n  async validateConfiguration(): Promise<{ valid: boolean; issues: string[] }> {\n    const issues: string[] = [];\n\n    try {\n      // Check Node.js version\n      const nodeVersion = process.versions.node;\n      const majorVersion = parseInt(nodeVersion.split('.')[0]);\n      if (majorVersion < 16) {\n        issues.push(`Node.js version ${nodeVersion} is not supported. Minimum required: 16.0.0`);\n      }\n\n      // Check available memory\n      const memoryUsage = process.memoryUsage();\n      const availableMemory = memoryUsage.heapTotal;\n      if (availableMemory < 100 * 1024 * 1024) { // 100MB\n        issues.push('Low available memory detected. Maestro requires at least 100MB heap space');\n      }\n\n      // Check file system permissions\n      const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs');\n      try {\n        const fs = await import('fs/promises');\n        await fs.access(specsDir, fs.constants.F_OK);\n      } catch {\n        // Directory doesn't exist, which is fine - it will be created\n      }\n\n      return {\n        valid: issues.length === 0,\n        issues\n      };\n\n    } catch (error) {\n      issues.push(`Configuration validation failed: ${error instanceof Error ? error.message : String(error)}`);\n      return { valid: false, issues };\n    }\n  }\n\n  /**\n   * Clear caches and reset state\n   */\n  clearCache(): void {\n    this.initializationCache.clear();\n    this.configCache = undefined;\n    this.initialized = false;\n    console.log(chalk.gray('\uD83E\uDDF9 Maestro CLI bridge cache cleared'));\n  }\n\n  /**\n   * Shutdown and cleanup resources\n   */\n  async shutdown(): Promise<void> {\n    if (this.swarmCoordinator) {\n      await this.swarmCoordinator.shutdown();\n    }\n    \n    this.clearCache();\n    this.performanceMetrics = [];\n    \n    console.log(chalk.green('\u2705 Maestro CLI bridge shutdown complete'));\n  }\n}"],
  "mappings": "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",
  "names": ["chalk"]
}
