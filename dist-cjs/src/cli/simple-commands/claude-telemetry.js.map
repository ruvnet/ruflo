{"version":3,"sources":["../../../../src/cli/simple-commands/claude-telemetry.js"],"sourcesContent":["#!/usr/bin/env node\r\n\r\n/**\r\n * Claude Code Telemetry Integration\r\n * Captures real token usage from Claude Code CLI\r\n */\r\n\r\nimport { spawn } from 'child_process';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport os from 'os';\r\nimport readline from 'readline';\r\nimport { trackTokens } from './token-tracker.js';\r\n\r\n// Claude session data locations (platform-specific)\r\nconst CLAUDE_DATA_PATHS = [\r\n  path.join(os.homedir(), '.claude', 'sessions'),\r\n  path.join(os.homedir(), '.config', 'claude', 'sessions'),\r\n  path.join(os.homedir(), 'Library', 'Application Support', 'Claude', 'sessions'),\r\n];\r\n\r\n/**\r\n * Parse Claude session JSONL files for token usage\r\n */\r\nasync function parseClaudeSessionData(sessionId) {\r\n  for (const dataPath of CLAUDE_DATA_PATHS) {\r\n    try {\r\n      const sessionFile = path.join(dataPath, `${sessionId}.jsonl`);\r\n      const exists = await fs.access(sessionFile).then(() => true).catch(() => false);\r\n      \r\n      if (!exists) continue;\r\n      \r\n      const content = await fs.readFile(sessionFile, 'utf-8');\r\n      const lines = content.trim().split('\\n');\r\n      \r\n      let totalInput = 0;\r\n      let totalOutput = 0;\r\n      \r\n      for (const line of lines) {\r\n        try {\r\n          const data = JSON.parse(line);\r\n          if (data.usage) {\r\n            totalInput += data.usage.input_tokens || 0;\r\n            totalOutput += data.usage.output_tokens || 0;\r\n          }\r\n        } catch (e) {\r\n          // Skip invalid JSON lines\r\n        }\r\n      }\r\n      \r\n      return { inputTokens: totalInput, outputTokens: totalOutput };\r\n    } catch (error) {\r\n      // Continue to next path\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Extract token usage from Claude CLI output\r\n */\r\nfunction parseClaudeOutput(output) {\r\n  const tokenRegex = /(\\d+)\\s+tokens?\\s+\\((input|output|total)\\)/gi;\r\n  const costRegex = /\\$(\\d+\\.\\d+)/g;\r\n  \r\n  const tokens = { input: 0, output: 0, total: 0 };\r\n  const costs = [];\r\n  \r\n  let match;\r\n  while ((match = tokenRegex.exec(output)) !== null) {\r\n    const count = parseInt(match[1]);\r\n    const type = match[2].toLowerCase();\r\n    tokens[type] = count;\r\n  }\r\n  \r\n  while ((match = costRegex.exec(output)) !== null) {\r\n    costs.push(parseFloat(match[1]));\r\n  }\r\n  \r\n  return { tokens, costs };\r\n}\r\n\r\n/**\r\n * Wrap Claude CLI execution with telemetry\r\n */\r\nexport async function runClaudeWithTelemetry(args, options = {}) {\r\n  const sessionId = options.sessionId || `claude-${Date.now()}`;\r\n  const agentType = options.agentType || 'claude-cli';\r\n  const command = args.join(' ');\r\n  \r\n  // Enable telemetry environment variables\r\n  const env = {\r\n    ...process.env,\r\n    CLAUDE_CODE_ENABLE_TELEMETRY: '1',\r\n    OTEL_METRICS_EXPORTER: process.env.OTEL_METRICS_EXPORTER || 'console',\r\n    OTEL_LOGS_EXPORTER: process.env.OTEL_LOGS_EXPORTER || 'console',\r\n  };\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    const claude = spawn('claude', args, {\r\n      env,\r\n      stdio: ['inherit', 'pipe', 'pipe']\r\n    });\r\n    \r\n    let stdout = '';\r\n    let stderr = '';\r\n    \r\n    // Create readline interface for real-time output\r\n    const rlOut = readline.createInterface({\r\n      input: claude.stdout,\r\n      terminal: false\r\n    });\r\n    \r\n    const rlErr = readline.createInterface({\r\n      input: claude.stderr,\r\n      terminal: false\r\n    });\r\n    \r\n    rlOut.on('line', (line) => {\r\n      console.log(line);\r\n      stdout += line + '\\n';\r\n      \r\n      // Look for token usage in real-time\r\n      const usage = parseClaudeOutput(line);\r\n      if (usage.tokens.input > 0 || usage.tokens.output > 0) {\r\n        trackTokens({\r\n          sessionId,\r\n          agentType,\r\n          command,\r\n          inputTokens: usage.tokens.input,\r\n          outputTokens: usage.tokens.output,\r\n          metadata: { costs: usage.costs }\r\n        }).catch(console.error);\r\n      }\r\n    });\r\n    \r\n    rlErr.on('line', (line) => {\r\n      console.error(line);\r\n      stderr += line + '\\n';\r\n    });\r\n    \r\n    claude.on('exit', async (code) => {\r\n      // Try to parse session data after completion\r\n      const sessionData = await parseClaudeSessionData(sessionId);\r\n      if (sessionData) {\r\n        await trackTokens({\r\n          sessionId,\r\n          agentType,\r\n          command,\r\n          inputTokens: sessionData.inputTokens,\r\n          outputTokens: sessionData.outputTokens,\r\n          metadata: { source: 'session_file' }\r\n        });\r\n      }\r\n      \r\n      // Also parse full output for any missed tokens\r\n      const fullUsage = parseClaudeOutput(stdout + stderr);\r\n      if (fullUsage.tokens.input > 0 || fullUsage.tokens.output > 0) {\r\n        await trackTokens({\r\n          sessionId,\r\n          agentType,\r\n          command,\r\n          inputTokens: fullUsage.tokens.input,\r\n          outputTokens: fullUsage.tokens.output,\r\n          metadata: { source: 'output_parse', costs: fullUsage.costs }\r\n        });\r\n      }\r\n      \r\n      resolve({ code, stdout, stderr });\r\n    });\r\n    \r\n    claude.on('error', reject);\r\n  });\r\n}\r\n\r\n/**\r\n * Monitor Claude session for token usage\r\n */\r\nexport async function monitorClaudeSession(sessionId, interval = 5000) {\r\n  console.log(`ðŸ“Š Monitoring Claude session: ${sessionId}`);\r\n  console.log(`   Checking every ${interval / 1000} seconds for token updates...\\n`);\r\n  \r\n  let lastTokens = { input: 0, output: 0 };\r\n  \r\n  const monitor = setInterval(async () => {\r\n    const data = await parseClaudeSessionData(sessionId);\r\n    \r\n    if (data) {\r\n      const inputDiff = data.inputTokens - lastTokens.input;\r\n      const outputDiff = data.outputTokens - lastTokens.output;\r\n      \r\n      if (inputDiff > 0 || outputDiff > 0) {\r\n        console.log(`ðŸ”„ Token Update Detected:`);\r\n        console.log(`   Input:  +${inputDiff} (Total: ${data.inputTokens})`);\r\n        console.log(`   Output: +${outputDiff} (Total: ${data.outputTokens})`);\r\n        \r\n        await trackTokens({\r\n          sessionId,\r\n          agentType: 'claude-monitor',\r\n          command: 'session_monitor',\r\n          inputTokens: inputDiff,\r\n          outputTokens: outputDiff,\r\n          metadata: { \r\n            totalInput: data.inputTokens,\r\n            totalOutput: data.outputTokens \r\n          }\r\n        });\r\n        \r\n        lastTokens = data;\r\n      }\r\n    }\r\n  }, interval);\r\n  \r\n  // Return stop function\r\n  return () => {\r\n    clearInterval(monitor);\r\n    console.log(`\\nâœ… Stopped monitoring session: ${sessionId}`);\r\n  };\r\n}\r\n\r\n/**\r\n * Extract token usage from /cost command\r\n */\r\nexport async function extractCostCommand() {\r\n  return new Promise((resolve, reject) => {\r\n    const claude = spawn('claude', ['/cost'], {\r\n      stdio: ['pipe', 'pipe', 'pipe']\r\n    });\r\n    \r\n    claude.stdin.write('\\n');\r\n    claude.stdin.end();\r\n    \r\n    let output = '';\r\n    \r\n    claude.stdout.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n    \r\n    claude.stderr.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n    \r\n    claude.on('exit', () => {\r\n      const usage = parseClaudeOutput(output);\r\n      resolve(usage);\r\n    });\r\n    \r\n    claude.on('error', reject);\r\n  });\r\n}\r\n\r\n// CLI interface\r\nif (import.meta.url === `file://${process.argv[1]}`) {\r\n  const command = process.argv[2];\r\n  \r\n  switch (command) {\r\n    case 'wrap':\r\n      // Wrap Claude command with telemetry\r\n      const claudeArgs = process.argv.slice(3);\r\n      runClaudeWithTelemetry(claudeArgs)\r\n        .then(result => process.exit(result.code))\r\n        .catch(error => {\r\n          console.error('Error:', error);\r\n          process.exit(1);\r\n        });\r\n      break;\r\n      \r\n    case 'monitor':\r\n      // Monitor a session\r\n      const sessionId = process.argv[3] || 'current';\r\n      const stopMonitor = await monitorClaudeSession(sessionId);\r\n      \r\n      // Handle graceful shutdown\r\n      process.on('SIGINT', () => {\r\n        stopMonitor();\r\n        process.exit(0);\r\n      });\r\n      break;\r\n      \r\n    case 'cost':\r\n      // Extract current session cost\r\n      const costData = await extractCostCommand();\r\n      console.log('\\nðŸ“Š Current Session Usage:');\r\n      console.log(`   Input Tokens:  ${costData.tokens.input || 0}`);\r\n      console.log(`   Output Tokens: ${costData.tokens.output || 0}`);\r\n      console.log(`   Total Tokens:  ${costData.tokens.total || 0}`);\r\n      if (costData.costs.length > 0) {\r\n        console.log(`   Estimated Cost: $${costData.costs[0]}`);\r\n      }\r\n      break;\r\n      \r\n    default:\r\n      console.log(`\r\nClaude Telemetry Integration\r\n\r\nUsage:\r\n  claude-telemetry wrap <claude-args>    Run Claude with telemetry\r\n  claude-telemetry monitor [session-id]  Monitor session for tokens\r\n  claude-telemetry cost                  Get current session cost\r\n\r\nExamples:\r\n  claude-telemetry wrap chat \"Hello\"\r\n  claude-telemetry monitor claude-123456\r\n  claude-telemetry cost\r\n`);\r\n  }\r\n}"],"names":["spawn","fs","path","os","readline","trackTokens","CLAUDE_DATA_PATHS","join","homedir","parseClaudeSessionData","sessionId","dataPath","sessionFile","exists","access","then","catch","content","readFile","lines","trim","split","totalInput","totalOutput","line","data","JSON","parse","usage","input_tokens","output_tokens","e","inputTokens","outputTokens","error","parseClaudeOutput","output","tokenRegex","costRegex","tokens","input","total","costs","match","exec","count","parseInt","type","toLowerCase","push","parseFloat","runClaudeWithTelemetry","args","options","Date","now","agentType","command","env","process","CLAUDE_CODE_ENABLE_TELEMETRY","OTEL_METRICS_EXPORTER","OTEL_LOGS_EXPORTER","Promise","resolve","reject","claude","stdio","stdout","stderr","rlOut","createInterface","terminal","rlErr","on","console","log","metadata","code","sessionData","source","fullUsage","monitorClaudeSession","interval","lastTokens","monitor","setInterval","inputDiff","outputDiff","clearInterval","extractCostCommand","stdin","write","end","toString","url","argv","claudeArgs","slice","result","exit","stopMonitor","costData","length"],"mappings":"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"}