{
  "version": 3,
  "sources": ["../../src/coordination/advanced-task-executor.ts"],
  "sourcesContent": ["import { getErrorMessage, getErrorStack } from '../utils/type-guards.js';\n/**\n * Advanced task executor with timeout handling, retry logic, and resource management\n */\n\nimport { EventEmitter } from 'node:events';\nimport { spawn, ChildProcess } from 'node:child_process';\nimport type {\n  TaskDefinition,\n  TaskResult,\n  TaskStatus,\n  AgentState,\n  TaskError,\n} from '../swarm/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport { CircuitBreaker, CircuitBreakerManager } from './circuit-breaker.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface TaskExecutorConfig {\n  maxConcurrentTasks: number;\n  defaultTimeout: number;\n  retryAttempts: number;\n  retryBackoffBase: number;\n  retryBackoffMax: number;\n  resourceLimits: {\n    memory: number;\n    cpu: number;\n    disk: number;\n  };\n  enableCircuitBreaker: boolean;\n  enableResourceMonitoring: boolean;\n  killTimeout: number;\n}\n\nexport interface ExecutionContext {\n  taskId: string;\n  agentId: string;\n  process?: ChildProcess;\n  startTime: Date;\n  timeout?: NodeJS.Timeout;\n  resources: ResourceUsage;\n  circuitBreaker?: CircuitBreaker;\n}\n\nexport interface ResourceUsage {\n  memory: number;\n  cpu: number;\n  disk: number;\n  network: number;\n  lastUpdated: Date;\n}\n\nexport interface TaskExecutionResult {\n  success: boolean;\n  result?: TaskResult;\n  error?: TaskError;\n  executionTime: number;\n  resourcesUsed: ResourceUsage;\n  retryCount: number;\n}\n\n/**\n * Advanced task executor with comprehensive timeout and resource management\n */\nexport class AdvancedTaskExecutor extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: TaskExecutorConfig;\n  private runningTasks = new Map<string, ExecutionContext>();\n  private circuitBreakerManager: CircuitBreakerManager;\n  private resourceMonitor?: NodeJS.Timeout;\n  private queuedTasks: TaskDefinition[] = [];\n  private isShuttingDown = false;\n\n  constructor(config: Partial<TaskExecutorConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      maxConcurrentTasks: 10,\n      defaultTimeout: 300000, // 5 minutes\n      retryAttempts: 3,\n      retryBackoffBase: 1000,\n      retryBackoffMax: 30000,\n      resourceLimits: {\n        memory: 512 * 1024 * 1024, // 512MB\n        cpu: 1.0, // 1 CPU core\n        disk: 1024 * 1024 * 1024, // 1GB\n      },\n      enableCircuitBreaker: true,\n      enableResourceMonitoring: true,\n      killTimeout: 5000,\n      ...config,\n    };\n\n    // Initialize circuit breaker manager\n    this.circuitBreakerManager = new CircuitBreakerManager(\n      {\n        failureThreshold: 5,\n        successThreshold: 3,\n        timeout: 60000, // 1 minute\n        halfOpenLimit: 2,\n      },\n      this.logger,\n      this.eventBus,\n    );\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    // Handle process events\n    process.on('SIGTERM', () => this.gracefulShutdown());\n    process.on('SIGINT', () => this.gracefulShutdown());\n\n    // Handle circuit breaker events\n    this.eventBus.on('circuitbreaker:state-change', (event) => {\n      this.logger.info('Circuit breaker state changed', event);\n      this.emit('circuit-breaker-changed', event);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing advanced task executor', {\n      maxConcurrentTasks: this.config.maxConcurrentTasks,\n      defaultTimeout: this.config.defaultTimeout,\n      resourceLimits: this.config.resourceLimits,\n    });\n\n    if (this.config.enableResourceMonitoring) {\n      this.startResourceMonitoring();\n    }\n\n    this.emit('executor-initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down task executor');\n    this.isShuttingDown = true;\n\n    // Stop resource monitoring\n    if (this.resourceMonitor) {\n      clearInterval(this.resourceMonitor);\n    }\n\n    // Cancel all running tasks\n    const cancelPromises = Array.from(this.runningTasks.values()).map((ctx) =>\n      this.cancelTask(ctx.taskId, 'Shutdown requested'),\n    );\n\n    await Promise.all(cancelPromises);\n\n    this.emit('executor-shutdown');\n  }\n\n  /**\n   * Execute a task with comprehensive error handling and resource management\n   */\n  async executeTask(\n    task: TaskDefinition,\n    agent: AgentState,\n    options: {\n      timeout?: number;\n      retryAttempts?: number;\n      priority?: number;\n    } = {},\n  ): Promise<TaskExecutionResult> {\n    const startTime = Date.now();\n    let retryCount = 0;\n    const maxRetries = options.retryAttempts ?? this.config.retryAttempts;\n    const timeout = options.timeout ?? this.config.defaultTimeout;\n\n    this.logger.info('Starting task execution', {\n      taskId: task.id.id,\n      agentId: agent.id.id,\n      type: task.type,\n      timeout,\n      maxRetries,\n    });\n\n    // Check if we have capacity\n    if (this.runningTasks.size >= this.config.maxConcurrentTasks) {\n      this.queuedTasks.push(task);\n      this.logger.info('Task queued due to capacity limits', {\n        taskId: task.id.id,\n        queueSize: this.queuedTasks.length,\n      });\n\n      // Wait for capacity\n      await this.waitForCapacity();\n    }\n\n    while (retryCount <= maxRetries) {\n      try {\n        const result = await this.executeSingleAttempt(task, agent, timeout, retryCount);\n\n        this.logger.info('Task completed successfully', {\n          taskId: task.id.id,\n          executionTime: Date.now() - startTime,\n          retryCount,\n        });\n\n        return {\n          success: true,\n          result: result.result,\n          executionTime: Date.now() - startTime,\n          resourcesUsed: result.resourcesUsed,\n          retryCount,\n        };\n      } catch (error) {\n        retryCount++;\n\n        this.logger.warn('Task attempt failed', {\n          taskId: task.id.id,\n          attempt: retryCount,\n          maxRetries,\n          error: getErrorMessage(error),\n        });\n\n        // Check if we should retry\n        if (retryCount > maxRetries) {\n          const taskError: TaskError = {\n            type: 'execution_failed',\n            message: getErrorMessage(error),\n            stack: getErrorStack(error),\n            context: {\n              retryCount,\n              maxRetries,\n              taskType: task.type,\n            },\n            recoverable: false,\n            retryable: false,\n          };\n\n          return {\n            success: false,\n            error: taskError,\n            executionTime: Date.now() - startTime,\n            resourcesUsed: this.getDefaultResourceUsage(),\n            retryCount,\n          };\n        }\n\n        // Calculate backoff delay\n        const backoffDelay = Math.min(\n          this.config.retryBackoffBase * Math.pow(2, retryCount - 1),\n          this.config.retryBackoffMax,\n        );\n\n        this.logger.info('Retrying task after backoff', {\n          taskId: task.id.id,\n          backoffDelay,\n          attempt: retryCount + 1,\n        });\n\n        await this.delay(backoffDelay);\n      }\n    }\n\n    // This should never be reached, but TypeScript requires it\n    throw new Error('Unexpected end of retry loop');\n  }\n\n  private async executeSingleAttempt(\n    task: TaskDefinition,\n    agent: AgentState,\n    timeout: number,\n    retryCount: number,\n  ): Promise<{ result: TaskResult; resourcesUsed: ResourceUsage }> {\n    const executionContext: ExecutionContext = {\n      taskId: task.id.id,\n      agentId: agent.id.id,\n      startTime: new Date(),\n      resources: this.getDefaultResourceUsage(),\n    };\n\n    this.runningTasks.set(task.id.id, executionContext);\n\n    try {\n      // Set up timeout\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        executionContext.timeout = setTimeout(() => {\n          reject(new Error(`Task timeout after ${timeout}ms`));\n        }, timeout);\n      });\n\n      // Set up circuit breaker if enabled\n      if (this.config.enableCircuitBreaker) {\n        executionContext.circuitBreaker = this.circuitBreakerManager.getBreaker(\n          `agent-${agent.id.id}`,\n        );\n      }\n\n      // Execute task with circuit breaker protection\n      const executionPromise =\n        this.config.enableCircuitBreaker && executionContext.circuitBreaker\n          ? executionContext.circuitBreaker.execute(() =>\n              this.performTaskExecution(task, agent, executionContext),\n            )\n          : this.performTaskExecution(task, agent, executionContext);\n\n      // Race between execution and timeout\n      const result = await Promise.race([executionPromise, timeoutPromise]);\n\n      // Clear timeout\n      if (executionContext.timeout) {\n        clearTimeout(executionContext.timeout);\n      }\n\n      return result;\n    } finally {\n      // Cleanup\n      this.runningTasks.delete(task.id.id);\n\n      // Process queued tasks\n      this.processQueuedTasks();\n    }\n  }\n\n  private async performTaskExecution(\n    task: TaskDefinition,\n    agent: AgentState,\n    context: ExecutionContext,\n  ): Promise<{ result: TaskResult; resourcesUsed: ResourceUsage }> {\n    const startTime = Date.now();\n\n    // Create task execution command\n    const command = this.buildExecutionCommand(task, agent);\n\n    this.logger.debug('Executing task command', {\n      taskId: task.id.id,\n      command: command.cmd,\n      args: command.args,\n    });\n\n    // Spawn process\n    const childProcess = spawn(command.cmd, command.args, {\n      stdio: ['pipe', 'pipe', 'pipe'],\n      env: {\n        ...process.env,\n        ...command.env,\n        TASK_ID: task.id.id,\n        AGENT_ID: agent.id.id,\n        TASK_TYPE: task.type,\n      },\n    });\n\n    context.process = childProcess;\n\n    // Collect output\n    let stdout = '';\n    let stderr = '';\n\n    childProcess.stdout?.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    childProcess.stderr?.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    // Send input if provided\n    if (task.input && childProcess.stdin) {\n      childProcess.stdin.write(\n        JSON.stringify({\n          task: task,\n          agent: agent,\n          input: task.input,\n        }),\n      );\n      childProcess.stdin.end();\n    }\n\n    // Wait for process completion\n    const exitCode = await new Promise<number>((resolve, reject) => {\n      childProcess.on('exit', (code) => {\n        resolve(code ?? 0);\n      });\n\n      childProcess.on('error', (error) => {\n        reject(new Error(`Process error: ${getErrorMessage(error)}`));\n      });\n    });\n\n    const executionTime = Date.now() - startTime;\n\n    // Parse result\n    let taskResult: TaskResult;\n\n    if (exitCode === 0) {\n      try {\n        const output = JSON.parse(stdout);\n        taskResult = {\n          output: output.result || output,\n          artifacts: output.artifacts || {},\n          metadata: output.metadata || {},\n          quality: output.quality || 0.8,\n          completeness: output.completeness || 1.0,\n          accuracy: output.accuracy || 0.9,\n          executionTime,\n          resourcesUsed: context.resources,\n          validated: false,\n        };\n      } catch (error) {\n        taskResult = {\n          output: stdout,\n          artifacts: {},\n          metadata: { stderr },\n          quality: 0.5,\n          completeness: 1.0,\n          accuracy: 0.7,\n          executionTime,\n          resourcesUsed: context.resources,\n          validated: false,\n        };\n      }\n    } else {\n      throw new Error(`Task execution failed with exit code ${exitCode}: ${stderr}`);\n    }\n\n    return {\n      result: taskResult,\n      resourcesUsed: context.resources,\n    };\n  }\n\n  private buildExecutionCommand(\n    task: TaskDefinition,\n    agent: AgentState,\n  ): {\n    cmd: string;\n    args: string[];\n    env: Record<string, string>;\n  } {\n    // This would be customized based on task type and agent capabilities\n    // For now, return a default Claude execution command\n\n    const cmd = 'deno';\n    const args = [\n      'run',\n      '--allow-all',\n      '--no-check',\n      './src/cli/commands/task-executor.ts',\n      '--task-type',\n      task.type,\n      '--agent-type',\n      agent.type,\n    ];\n\n    const env = {\n      TASK_TIMEOUT: (task.constraints.timeoutAfter || this.config.defaultTimeout).toString(),\n      MEMORY_LIMIT: this.config.resourceLimits.memory.toString(),\n      CPU_LIMIT: this.config.resourceLimits.cpu.toString(),\n    };\n\n    return { cmd, args, env };\n  }\n\n  private async cancelTask(taskId: string, reason: string): Promise<void> {\n    const context = this.runningTasks.get(taskId);\n    if (!context) {\n      return;\n    }\n\n    this.logger.info('Cancelling task', { taskId, reason });\n\n    // Clear timeout\n    if (context.timeout) {\n      clearTimeout(context.timeout);\n    }\n\n    // Kill process if running\n    if (context.process && !context.process.killed) {\n      context.process.kill('SIGTERM');\n\n      // Force kill after timeout\n      setTimeout(() => {\n        if (context.process && !context.process.killed) {\n          context.process.kill('SIGKILL');\n        }\n      }, this.config.killTimeout);\n    }\n\n    // Remove from running tasks\n    this.runningTasks.delete(taskId);\n\n    this.emit('task-cancelled', { taskId, reason });\n  }\n\n  private startResourceMonitoring(): void {\n    this.resourceMonitor = setInterval(() => {\n      this.updateResourceUsage();\n    }, 5000); // Update every 5 seconds\n  }\n\n  private async updateResourceUsage(): Promise<void> {\n    for (const [taskId, context] of this.runningTasks) {\n      if (context.process) {\n        try {\n          const usage = await this.getProcessResourceUsage(context.process.pid);\n          context.resources = {\n            ...usage,\n            lastUpdated: new Date(),\n          };\n\n          // Check resource limits\n          this.checkResourceLimits(taskId, context);\n        } catch (error) {\n          this.logger.warn('Failed to get resource usage', {\n            taskId,\n            error: getErrorMessage(error),\n          });\n        }\n      }\n    }\n  }\n\n  private async getProcessResourceUsage(pid: number | undefined): Promise<ResourceUsage> {\n    if (!pid) {\n      throw new Error('Process ID is undefined');\n    }\n    // In a real implementation, this would use system APIs\n    // For now, return mock data\n    return {\n      memory: Math.random() * this.config.resourceLimits.memory,\n      cpu: Math.random() * 100,\n      disk: Math.random() * this.config.resourceLimits.disk,\n      network: Math.random() * 1024 * 1024,\n      lastUpdated: new Date(),\n    };\n  }\n\n  private checkResourceLimits(taskId: string, context: ExecutionContext): void {\n    const { memory, cpu } = context.resources;\n    const limits = this.config.resourceLimits;\n\n    if (memory > limits.memory) {\n      this.logger.warn('Task exceeding memory limit', {\n        taskId,\n        current: memory,\n        limit: limits.memory,\n      });\n\n      this.cancelTask(taskId, 'Memory limit exceeded');\n    }\n\n    if (cpu > limits.cpu * 100) {\n      // CPU is in percentage\n      this.logger.warn('Task exceeding CPU limit', {\n        taskId,\n        current: cpu,\n        limit: limits.cpu * 100,\n      });\n    }\n  }\n\n  private getDefaultResourceUsage(): ResourceUsage {\n    return {\n      memory: 0,\n      cpu: 0,\n      disk: 0,\n      network: 0,\n      lastUpdated: new Date(),\n    };\n  }\n\n  private async waitForCapacity(): Promise<void> {\n    return new Promise((resolve) => {\n      const check = () => {\n        if (this.runningTasks.size < this.config.maxConcurrentTasks) {\n          resolve();\n        } else {\n          setTimeout(check, 1000);\n        }\n      };\n      check();\n    });\n  }\n\n  private processQueuedTasks(): void {\n    while (this.queuedTasks.length > 0 && this.runningTasks.size < this.config.maxConcurrentTasks) {\n      const task = this.queuedTasks.shift();\n      if (task) {\n        this.emit('task-dequeued', { taskId: task.id.id });\n      }\n    }\n  }\n\n  private async delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  private async gracefulShutdown(): Promise<void> {\n    this.logger.info('Received shutdown signal, initiating graceful shutdown');\n    await this.shutdown();\n    process.exit(0);\n  }\n\n  // Public API methods\n\n  getRunningTasks(): string[] {\n    return Array.from(this.runningTasks.keys());\n  }\n\n  getTaskContext(taskId: string): ExecutionContext | undefined {\n    return this.runningTasks.get(taskId);\n  }\n\n  getQueuedTasks(): TaskDefinition[] {\n    return [...this.queuedTasks];\n  }\n\n  getExecutorStats(): {\n    runningTasks: number;\n    queuedTasks: number;\n    maxConcurrentTasks: number;\n    totalCapacity: number;\n    resourceLimits: typeof this.config.resourceLimits;\n    circuitBreakers: Record<string, any>;\n  } {\n    return {\n      runningTasks: this.runningTasks.size,\n      queuedTasks: this.queuedTasks.length,\n      maxConcurrentTasks: this.config.maxConcurrentTasks,\n      totalCapacity: this.config.maxConcurrentTasks,\n      resourceLimits: this.config.resourceLimits,\n      circuitBreakers: this.circuitBreakerManager.getAllMetrics(),\n    };\n  }\n\n  async forceKillTask(taskId: string): Promise<void> {\n    await this.cancelTask(taskId, 'Force killed by user');\n  }\n\n  updateConfig(newConfig: Partial<TaskExecutorConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.logger.info('Task executor configuration updated', { newConfig });\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
