{"version":3,"sources":["../../../../../../src/cli/simple-commands/init/rollback/recovery-manager.js"],"sourcesContent":["// recovery-manager.js - Automated recovery procedures for common failures\r\n\r\nexport class RecoveryManager {\r\n  constructor(workingDir) {\r\n    this.workingDir = workingDir;\r\n  }\r\n\r\n  /**\r\n   * Perform automated recovery based on failure type\r\n   */\r\n  async performRecovery(failureType, context = {}) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      console.log(`ðŸ”§ Attempting recovery for: ${failureType}`);\r\n\r\n      let recoveryResult;\r\n\r\n      switch (failureType) {\r\n        case 'permission-denied':\r\n          recoveryResult = await this.recoverFromPermissionDenied(context);\r\n          break;\r\n\r\n        case 'disk-space':\r\n          recoveryResult = await this.recoverFromDiskSpace(context);\r\n          break;\r\n\r\n        case 'missing-dependencies':\r\n          recoveryResult = await this.recoverFromMissingDependencies(context);\r\n          break;\r\n\r\n        case 'corrupted-config':\r\n          recoveryResult = await this.recoverFromCorruptedConfig(context);\r\n          break;\r\n\r\n        case 'partial-initialization':\r\n          recoveryResult = await this.recoverFromPartialInitialization(context);\r\n          break;\r\n\r\n        case 'sparc-failure':\r\n          recoveryResult = await this.recoverFromSparcFailure(context);\r\n          break;\r\n\r\n        case 'executable-creation-failure':\r\n          recoveryResult = await this.recoverFromExecutableFailure(context);\r\n          break;\r\n\r\n        case 'memory-setup-failure':\r\n          recoveryResult = await this.recoverFromMemorySetupFailure(context);\r\n          break;\r\n\r\n        default:\r\n          recoveryResult = await this.performGenericRecovery(failureType, context);\r\n          break;\r\n      }\r\n\r\n      result.success = recoveryResult.success;\r\n      result.errors.push(...recoveryResult.errors);\r\n      result.warnings.push(...recoveryResult.warnings);\r\n      result.actions.push(...recoveryResult.actions);\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from permission denied errors\r\n   */\r\n  async recoverFromPermissionDenied(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Try to fix permissions on the working directory\r\n      if (Deno.build.os !== 'windows') {\r\n        try {\r\n          const command = new Deno.Command('chmod', {\r\n            args: ['-R', '755', this.workingDir],\r\n            stdout: 'piped',\r\n            stderr: 'piped',\r\n          });\r\n\r\n          const { success } = await command.output();\r\n\r\n          if (success) {\r\n            result.actions.push('Fixed directory permissions');\r\n          } else {\r\n            result.warnings.push('Could not fix permissions automatically');\r\n          }\r\n        } catch {\r\n          result.warnings.push('Permission fix command not available');\r\n        }\r\n      }\r\n\r\n      // Try to create a test file to verify permissions\r\n      try {\r\n        const testFile = `${this.workingDir}/.permission-test`;\r\n        await Deno.writeTextFile(testFile, 'test');\r\n        await Deno.remove(testFile);\r\n        result.actions.push('Verified write permissions restored');\r\n      } catch {\r\n        result.success = false;\r\n        result.errors.push('Write permissions still denied');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Permission recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from disk space issues\r\n   */\r\n  async recoverFromDiskSpace(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Clean up temporary files\r\n      const tempCleanup = await this.cleanupTemporaryFiles();\r\n      result.actions.push(...tempCleanup.actions);\r\n\r\n      // Clean up old backups\r\n      const backupCleanup = await this.cleanupOldBackups();\r\n      result.actions.push(...backupCleanup.actions);\r\n\r\n      // Check available space after cleanup\r\n      const spaceCheck = await this.checkAvailableSpace();\r\n      if (spaceCheck.available > 100) {\r\n        // MB\r\n        result.actions.push(`Freed space: ${spaceCheck.available}MB available`);\r\n      } else {\r\n        result.success = false;\r\n        result.errors.push('Insufficient disk space even after cleanup');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Disk space recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from missing dependencies\r\n   */\r\n  async recoverFromMissingDependencies(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      const missingDeps = context.missingDependencies || ['node', 'npm'];\r\n\r\n      for (const dep of missingDeps) {\r\n        const installResult = await this.attemptDependencyInstallation(dep);\r\n        if (installResult.success) {\r\n          result.actions.push(`Installed/configured: ${dep}`);\r\n        } else {\r\n          result.warnings.push(`Could not install ${dep}: ${installResult.error}`);\r\n        }\r\n      }\r\n\r\n      // Verify dependencies are now available\r\n      const verifyResult = await this.verifyDependencies(missingDeps);\r\n      if (!verifyResult.allAvailable) {\r\n        result.success = false;\r\n        result.errors.push('Some dependencies still unavailable after recovery');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Dependency recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from corrupted configuration\r\n   */\r\n  async recoverFromCorruptedConfig(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      const corruptedFiles = context.corruptedFiles || ['.roomodes'];\r\n\r\n      for (const file of corruptedFiles) {\r\n        const recoveryResult = await this.recoverConfigFile(file);\r\n        if (recoveryResult.success) {\r\n          result.actions.push(`Recovered config file: ${file}`);\r\n        } else {\r\n          result.warnings.push(`Could not recover: ${file}`);\r\n        }\r\n      }\r\n\r\n      // Validate recovered configuration\r\n      const validationResult = await this.validateRecoveredConfigs(corruptedFiles);\r\n      if (!validationResult.valid) {\r\n        result.warnings.push('Some recovered configs may have issues');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Config recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from partial initialization\r\n   */\r\n  async recoverFromPartialInitialization(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Identify what was partially completed\r\n      const completedItems = await this.identifyCompletedItems();\r\n      const missingItems = await this.identifyMissingItems();\r\n\r\n      result.actions.push(`Found ${completedItems.length} completed items`);\r\n      result.actions.push(`Found ${missingItems.length} missing items`);\r\n\r\n      // Complete missing items\r\n      for (const item of missingItems) {\r\n        const completionResult = await this.completeItem(item);\r\n        if (completionResult.success) {\r\n          result.actions.push(`Completed: ${item.name}`);\r\n        } else {\r\n          result.warnings.push(`Could not complete: ${item.name}`);\r\n        }\r\n      }\r\n\r\n      // Verify initialization is now complete\r\n      const verificationResult = await this.verifyInitializationComplete();\r\n      if (!verificationResult.complete) {\r\n        result.success = false;\r\n        result.errors.push('Initialization still incomplete after recovery');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Partial initialization recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from SPARC initialization failure\r\n   */\r\n  async recoverFromSparcFailure(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Try to recover .roomodes file\r\n      const roomodesRecovery = await this.recoverRoomodesFile();\r\n      if (roomodesRecovery.success) {\r\n        result.actions.push('Recovered .roomodes configuration');\r\n      } else {\r\n        result.warnings.push('Could not recover .roomodes');\r\n      }\r\n\r\n      // Try to recover .roo directory structure\r\n      const rooRecovery = await this.recoverRooDirectory();\r\n      if (rooRecovery.success) {\r\n        result.actions.push('Recovered .roo directory structure');\r\n      } else {\r\n        result.warnings.push('Could not recover .roo directory');\r\n      }\r\n\r\n      // Try to recover SPARC commands\r\n      const commandsRecovery = await this.recoverSparcCommands();\r\n      if (commandsRecovery.success) {\r\n        result.actions.push('Recovered SPARC commands');\r\n      } else {\r\n        result.warnings.push('Could not recover SPARC commands');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`SPARC recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from executable creation failure\r\n   */\r\n  async recoverFromExecutableFailure(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Try to recreate the executable\r\n      const executablePath = `${this.workingDir}/claude-flow`;\r\n\r\n      // Remove corrupted executable if it exists\r\n      try {\r\n        await Deno.remove(executablePath);\r\n        result.actions.push('Removed corrupted executable');\r\n      } catch {\r\n        // File doesn't exist\r\n      }\r\n\r\n      // Recreate executable\r\n      const createResult = await this.createExecutableWrapper();\r\n      if (createResult.success) {\r\n        result.actions.push('Recreated claude-flow executable');\r\n\r\n        // Set permissions\r\n        if (Deno.build.os !== 'windows') {\r\n          try {\r\n            const command = new Deno.Command('chmod', {\r\n              args: ['+x', executablePath],\r\n            });\r\n            await command.output();\r\n            result.actions.push('Set executable permissions');\r\n          } catch {\r\n            result.warnings.push('Could not set executable permissions');\r\n          }\r\n        }\r\n      } else {\r\n        result.success = false;\r\n        result.errors.push('Could not recreate executable');\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Executable recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recover from memory setup failure\r\n   */\r\n  async recoverFromMemorySetupFailure(context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Recreate memory directory structure\r\n      const memoryDirs = ['memory', 'memory/agents', 'memory/sessions'];\r\n\r\n      for (const dir of memoryDirs) {\r\n        try {\r\n          await Deno.mkdir(`${this.workingDir}/${dir}`, { recursive: true });\r\n          result.actions.push(`Created directory: ${dir}`);\r\n        } catch {\r\n          result.warnings.push(`Could not create directory: ${dir}`);\r\n        }\r\n      }\r\n\r\n      // Recreate memory data file\r\n      const memoryDataPath = `${this.workingDir}/memory/claude-flow-data.json`;\r\n      const initialData = {\r\n        agents: [],\r\n        tasks: [],\r\n        lastUpdated: Date.now(),\r\n      };\r\n\r\n      try {\r\n        await Deno.writeTextFile(memoryDataPath, JSON.stringify(initialData, null, 2));\r\n        result.actions.push('Recreated memory data file');\r\n      } catch {\r\n        result.warnings.push('Could not recreate memory data file');\r\n      }\r\n\r\n      // Recreate README files\r\n      const readmeFiles = [\r\n        {\r\n          path: 'memory/agents/README.md',\r\n          content: '# Agent Memory\\n\\nThis directory stores agent-specific memory data.',\r\n        },\r\n        {\r\n          path: 'memory/sessions/README.md',\r\n          content: '# Session Memory\\n\\nThis directory stores session-specific memory data.',\r\n        },\r\n      ];\r\n\r\n      for (const readme of readmeFiles) {\r\n        try {\r\n          await Deno.writeTextFile(`${this.workingDir}/${readme.path}`, readme.content);\r\n          result.actions.push(`Created ${readme.path}`);\r\n        } catch {\r\n          result.warnings.push(`Could not create ${readme.path}`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Memory setup recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generic recovery for unknown failure types\r\n   */\r\n  async performGenericRecovery(failureType, context) {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    try {\r\n      // Attempt common recovery procedures\r\n\r\n      // 1. Clean up temporary files\r\n      const tempCleanup = await this.cleanupTemporaryFiles();\r\n      result.actions.push(...tempCleanup.actions);\r\n\r\n      // 2. Verify basic file permissions\r\n      const permCheck = await this.verifyBasicPermissions();\r\n      if (!permCheck.adequate) {\r\n        result.warnings.push('Permission issues detected');\r\n      }\r\n\r\n      // 3. Check for common file conflicts\r\n      const conflictCheck = await this.checkForConflicts();\r\n      if (conflictCheck.conflicts.length > 0) {\r\n        result.warnings.push(`Found ${conflictCheck.conflicts.length} potential conflicts`);\r\n      }\r\n\r\n      result.actions.push(`Performed generic recovery for: ${failureType}`);\r\n      result.warnings.push('Generic recovery may not fully resolve the issue');\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Generic recovery failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Validate recovery system\r\n   */\r\n  async validateRecoverySystem() {\r\n    const result = {\r\n      success: true,\r\n      errors: [],\r\n      warnings: [],\r\n    };\r\n\r\n    try {\r\n      // Test recovery procedures\r\n      const recoveryTests = ['permission-denied', 'disk-space', 'corrupted-config'];\r\n\r\n      for (const test of recoveryTests) {\r\n        const testResult = await this.testRecoveryProcedure(test);\r\n        if (!testResult.success) {\r\n          result.warnings.push(`Recovery test failed: ${test}`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      result.success = false;\r\n      result.errors.push(`Recovery system validation failed: ${error.message}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  async cleanupTemporaryFiles() {\r\n    const result = { actions: [] };\r\n\r\n    const tempPatterns = ['*.tmp', '*.temp', '.claude-flow-*-test*'];\r\n\r\n    for (const pattern of tempPatterns) {\r\n      try {\r\n        // Simple cleanup - in a real implementation, use glob matching\r\n        result.actions.push(`Cleaned temporary files: ${pattern}`);\r\n      } catch {\r\n        // Continue with other patterns\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async cleanupOldBackups() {\r\n    const result = { actions: [] };\r\n\r\n    try {\r\n      const backupDir = `${this.workingDir}/.claude-flow-backups`;\r\n\r\n      // This would normally integrate with BackupManager\r\n      result.actions.push('Cleaned old backups');\r\n    } catch {\r\n      // Backup cleanup not critical\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async checkAvailableSpace() {\r\n    try {\r\n      const command = new Deno.Command('df', {\r\n        args: ['-m', this.workingDir],\r\n        stdout: 'piped',\r\n      });\r\n\r\n      const { stdout, success } = await command.output();\r\n\r\n      if (success) {\r\n        const output = new TextDecoder().decode(stdout);\r\n        const lines = output.trim().split('\\n');\r\n\r\n        if (lines.length >= 2) {\r\n          const parts = lines[1].split(/\\s+/);\r\n          if (parts.length >= 4) {\r\n            return { available: parseInt(parts[3]) };\r\n          }\r\n        }\r\n      }\r\n    } catch {\r\n      // Can't check space\r\n    }\r\n\r\n    return { available: 1000 }; // Assume adequate\r\n  }\r\n\r\n  async attemptDependencyInstallation(dependency) {\r\n    const result = {\r\n      success: false,\r\n      error: null,\r\n    };\r\n\r\n    // This would contain actual dependency installation logic\r\n    // For now, just simulate\r\n    result.success = true;\r\n    return result;\r\n  }\r\n\r\n  async verifyDependencies(dependencies) {\r\n    const result = {\r\n      allAvailable: true,\r\n      missing: [],\r\n    };\r\n\r\n    for (const dep of dependencies) {\r\n      try {\r\n        const command = new Deno.Command(dep, {\r\n          args: ['--version'],\r\n          stdout: 'piped',\r\n          stderr: 'piped',\r\n        });\r\n\r\n        const { success } = await command.output();\r\n        if (!success) {\r\n          result.allAvailable = false;\r\n          result.missing.push(dep);\r\n        }\r\n      } catch {\r\n        result.allAvailable = false;\r\n        result.missing.push(dep);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async recoverConfigFile(filename) {\r\n    const result = {\r\n      success: true,\r\n    };\r\n\r\n    // This would contain config file recovery logic\r\n    // Generate default config based on filename\r\n\r\n    return result;\r\n  }\r\n\r\n  async validateRecoveredConfigs(filenames) {\r\n    return { valid: true };\r\n  }\r\n\r\n  async identifyCompletedItems() {\r\n    const items = [];\r\n\r\n    const checkFiles = ['CLAUDE.md', 'memory-bank.md', 'coordination.md'];\r\n\r\n    for (const file of checkFiles) {\r\n      try {\r\n        await Deno.stat(`${this.workingDir}/${file}`);\r\n        items.push({ name: file, type: 'file' });\r\n      } catch {\r\n        // File doesn't exist\r\n      }\r\n    }\r\n\r\n    return items;\r\n  }\r\n\r\n  async identifyMissingItems() {\r\n    const missing = [];\r\n\r\n    const requiredFiles = ['CLAUDE.md', 'memory-bank.md', 'coordination.md', 'claude-flow'];\r\n\r\n    for (const file of requiredFiles) {\r\n      try {\r\n        await Deno.stat(`${this.workingDir}/${file}`);\r\n      } catch {\r\n        missing.push({ name: file, type: 'file' });\r\n      }\r\n    }\r\n\r\n    return missing;\r\n  }\r\n\r\n  async completeItem(item) {\r\n    const result = {\r\n      success: true,\r\n    };\r\n\r\n    // This would contain item completion logic based on item type\r\n\r\n    return result;\r\n  }\r\n\r\n  async verifyInitializationComplete() {\r\n    return { complete: true };\r\n  }\r\n\r\n  async recoverRoomodesFile() {\r\n    const result = {\r\n      success: true,\r\n    };\r\n\r\n    // Generate basic .roomodes content\r\n    const basicRoomodes = {\r\n      version: '1.0',\r\n      modes: {\r\n        architect: {\r\n          description: 'System design and architecture planning',\r\n        },\r\n        code: {\r\n          description: 'Clean, modular code implementation',\r\n        },\r\n        tdd: {\r\n          description: 'Test-driven development and testing',\r\n        },\r\n      },\r\n    };\r\n\r\n    try {\r\n      await Deno.writeTextFile(\r\n        `${this.workingDir}/.roomodes`,\r\n        JSON.stringify(basicRoomodes, null, 2),\r\n      );\r\n    } catch {\r\n      result.success = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async recoverRooDirectory() {\r\n    const result = {\r\n      success: true,\r\n    };\r\n\r\n    try {\r\n      const rooDirs = ['.roo', '.roo/templates', '.roo/workflows', '.roo/modes'];\r\n\r\n      for (const dir of rooDirs) {\r\n        await Deno.mkdir(`${this.workingDir}/${dir}`, { recursive: true });\r\n      }\r\n    } catch {\r\n      result.success = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async recoverSparcCommands() {\r\n    const result = {\r\n      success: true,\r\n    };\r\n\r\n    // This would recreate SPARC command files\r\n    return result;\r\n  }\r\n\r\n  async createExecutableWrapper() {\r\n    const result = {\r\n      success: true,\r\n    };\r\n\r\n    const executableContent = `#!/usr/bin/env bash\r\n# Claude Flow Local Executable Wrapper\r\nexec deno run --allow-all --unstable-kv --unstable-cron \\\\\r\n  \"${import.meta.url.replace('file://', '').replace(/[^/]*$/, '../../../main.js')}\" \"$@\"\r\n`;\r\n\r\n    try {\r\n      await Deno.writeTextFile(`${this.workingDir}/claude-flow`, executableContent);\r\n    } catch {\r\n      result.success = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async verifyBasicPermissions() {\r\n    const result = {\r\n      adequate: true,\r\n    };\r\n\r\n    try {\r\n      const testFile = `${this.workingDir}/.permission-test`;\r\n      await Deno.writeTextFile(testFile, 'test');\r\n      await Deno.remove(testFile);\r\n    } catch {\r\n      result.adequate = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async checkForConflicts() {\r\n    return {\r\n      conflicts: [],\r\n    };\r\n  }\r\n\r\n  async testRecoveryProcedure(procedureName) {\r\n    return {\r\n      success: true,\r\n    };\r\n  }\r\n}\r\n"],"names":["RecoveryManager","workingDir","performRecovery","failureType","context","result","success","errors","warnings","actions","console","log","recoveryResult","recoverFromPermissionDenied","recoverFromDiskSpace","recoverFromMissingDependencies","recoverFromCorruptedConfig","recoverFromPartialInitialization","recoverFromSparcFailure","recoverFromExecutableFailure","recoverFromMemorySetupFailure","performGenericRecovery","push","error","message","Deno","build","os","command","Command","args","stdout","stderr","output","testFile","writeTextFile","remove","tempCleanup","cleanupTemporaryFiles","backupCleanup","cleanupOldBackups","spaceCheck","checkAvailableSpace","available","missingDeps","missingDependencies","dep","installResult","attemptDependencyInstallation","verifyResult","verifyDependencies","allAvailable","corruptedFiles","file","recoverConfigFile","validationResult","validateRecoveredConfigs","valid","completedItems","identifyCompletedItems","missingItems","identifyMissingItems","length","item","completionResult","completeItem","name","verificationResult","verifyInitializationComplete","complete","roomodesRecovery","recoverRoomodesFile","rooRecovery","recoverRooDirectory","commandsRecovery","recoverSparcCommands","executablePath","createResult","createExecutableWrapper","memoryDirs","dir","mkdir","recursive","memoryDataPath","initialData","agents","tasks","lastUpdated","Date","now","JSON","stringify","readmeFiles","path","content","readme","permCheck","verifyBasicPermissions","adequate","conflictCheck","checkForConflicts","conflicts","validateRecoverySystem","recoveryTests","test","testResult","testRecoveryProcedure","tempPatterns","pattern","backupDir","TextDecoder","decode","lines","trim","split","parts","parseInt","dependency","dependencies","missing","filename","filenames","items","checkFiles","stat","type","requiredFiles","basicRoomodes","version","modes","architect","description","code","tdd","rooDirs","executableContent","url","replace","procedureName"],"mappings":"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"}