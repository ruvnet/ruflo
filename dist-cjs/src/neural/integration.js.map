{"version":3,"sources":["../../../src/neural/integration.ts"],"sourcesContent":["/**\r\n * Neural Domain Mapper Integration Module\r\n * \r\n * Provides integration between NeuralDomainMapper and the existing\r\n * Claude Flow neural hooks system, enabling seamless domain analysis\r\n * and optimization within the broader orchestration framework.\r\n * \r\n * @author Claude Flow Neural Team\r\n * @version 2.0.0\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { NeuralDomainMapper, type DomainGraph, type CohesionAnalysis, type DependencyAnalysis, type BoundaryOptimization } from './NeuralDomainMapper.js';\r\nimport type {\r\n  AgenticHookContext,\r\n  NeuralHookPayload,\r\n  Pattern,\r\n  TrainingData,\r\n  Prediction,\r\n  SideEffect,\r\n} from '../services/agentic-flow-hooks/types.js';\r\nimport { agenticHookManager } from '../services/agentic-flow-hooks/hook-manager.js';\r\n\r\n/**\r\n * Domain mapping integration configuration\r\n */\r\nexport interface DomainMapperIntegrationConfig {\r\n  /** Enable automatic domain analysis on pattern detection */\r\n  enableAutoAnalysis: boolean;\r\n  /** Enable domain boundary optimization suggestions */\r\n  enableOptimizationSuggestions: boolean;\r\n  /** Enable continuous learning from domain changes */\r\n  enableContinuousLearning: boolean;\r\n  /** Minimum confidence threshold for suggestions */\r\n  confidenceThreshold: number;\r\n  /** Analysis frequency in milliseconds */\r\n  analysisInterval: number;\r\n  /** Maximum number of optimization proposals */\r\n  maxOptimizationProposals: number;\r\n}\r\n\r\n/**\r\n * Domain analysis result with context\r\n */\r\nexport interface DomainAnalysisResult {\r\n  /** Analysis timestamp */\r\n  timestamp: number;\r\n  /** Session correlation ID */\r\n  correlationId: string;\r\n  /** Domain graph analyzed */\r\n  graph: DomainGraph;\r\n  /** Cohesion analysis results */\r\n  cohesion: CohesionAnalysis;\r\n  /** Dependency analysis results */\r\n  dependencies: DependencyAnalysis;\r\n  /** Boundary optimization suggestions */\r\n  optimization: BoundaryOptimization;\r\n  /** Generated patterns from analysis */\r\n  patterns: Pattern[];\r\n  /** Performance metrics */\r\n  metrics: {\r\n    analysisTime: number;\r\n    nodesAnalyzed: number;\r\n    edgesAnalyzed: number;\r\n    patternsDetected: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Neural Domain Mapper Integration Class\r\n * \r\n * This class provides seamless integration between the NeuralDomainMapper\r\n * and the existing Claude Flow neural hooks system. It automatically\r\n * analyzes domain structures, generates optimization suggestions, and\r\n * learns from domain relationship patterns.\r\n */\r\nexport class NeuralDomainMapperIntegration extends EventEmitter {\r\n  private domainMapper: NeuralDomainMapper;\r\n  private config: DomainMapperIntegrationConfig;\r\n  private analysisHistory: DomainAnalysisResult[] = [];\r\n  private activeAnalysis: Map<string, Promise<DomainAnalysisResult>> = new Map();\r\n  private learningPatterns: Pattern[] = [];\r\n  private isInitialized: boolean = false;\r\n\r\n  constructor(\r\n    domainMapper?: NeuralDomainMapper,\r\n    config: Partial<DomainMapperIntegrationConfig> = {}\r\n  ) {\r\n    super();\r\n\r\n    this.config = {\r\n      enableAutoAnalysis: true,\r\n      enableOptimizationSuggestions: true,\r\n      enableContinuousLearning: true,\r\n      confidenceThreshold: 0.7,\r\n      analysisInterval: 30000, // 30 seconds\r\n      maxOptimizationProposals: 10,\r\n      ...config,\r\n    };\r\n\r\n    this.domainMapper = domainMapper || new NeuralDomainMapper();\r\n    \r\n    // Set up event listeners\r\n    this.setupEventListeners();\r\n  }\r\n\r\n  /**\r\n   * Initialize the integration system\r\n   */\r\n  public async initialize(): Promise<void> {\r\n    if (this.isInitialized) {\r\n      return;\r\n    }\r\n\r\n    // Register neural hooks for domain analysis\r\n    this.registerDomainAnalysisHooks();\r\n\r\n    // Set up periodic analysis if enabled\r\n    if (this.config.enableAutoAnalysis) {\r\n      this.setupPeriodicAnalysis();\r\n    }\r\n\r\n    this.isInitialized = true;\r\n    this.emit('integration-initialized');\r\n  }\r\n\r\n  /**\r\n   * Analyze domains and integrate with neural hooks system\r\n   */\r\n  public async analyzeDomains(\r\n    domains: DomainGraph,\r\n    context: AgenticHookContext\r\n  ): Promise<DomainAnalysisResult> {\r\n    const correlationId = context.correlationId;\r\n    \r\n    // Check if analysis is already in progress for this correlation ID\r\n    if (this.activeAnalysis.has(correlationId)) {\r\n      return await this.activeAnalysis.get(correlationId)!;\r\n    }\r\n\r\n    const analysisPromise = this.performDomainAnalysis(domains, context);\r\n    this.activeAnalysis.set(correlationId, analysisPromise);\r\n\r\n    try {\r\n      const result = await analysisPromise;\r\n      \r\n      // Store analysis history\r\n      this.analysisHistory.push(result);\r\n      \r\n      // Keep only last 100 analyses\r\n      if (this.analysisHistory.length > 100) {\r\n        this.analysisHistory.shift();\r\n      }\r\n\r\n      // Generate side effects for the hooks system\r\n      await this.generateHookSideEffects(result, context);\r\n\r\n      // Learn from the analysis if continuous learning is enabled\r\n      if (this.config.enableContinuousLearning) {\r\n        await this.learnFromAnalysis(result, context);\r\n      }\r\n\r\n      this.emit('domain-analysis-completed', result);\r\n      return result;\r\n\r\n    } finally {\r\n      this.activeAnalysis.delete(correlationId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Train the domain mapper on historical patterns\r\n   */\r\n  public async trainOnPatterns(\r\n    patterns: Pattern[],\r\n    context: AgenticHookContext\r\n  ): Promise<{\r\n    trainingAccuracy: number;\r\n    patternsProcessed: number;\r\n    newInsights: string[];\r\n  }> {\r\n    // Convert patterns to training data\r\n    const trainingData = this.convertPatternsToTrainingData(patterns);\r\n    \r\n    if (trainingData.inputs.length === 0) {\r\n      return {\r\n        trainingAccuracy: 0,\r\n        patternsProcessed: 0,\r\n        newInsights: ['No suitable training data found in patterns'],\r\n      };\r\n    }\r\n\r\n    // Train the domain mapper\r\n    const trainingResult = await this.domainMapper.train(trainingData);\r\n    \r\n    // Analyze what was learned\r\n    const newInsights = this.extractTrainingInsights(trainingResult, patterns);\r\n\r\n    // Store learning patterns for future reference\r\n    this.learningPatterns.push(...patterns.slice(-50)); // Keep last 50 patterns\r\n\r\n    const result = {\r\n      trainingAccuracy: trainingResult.finalAccuracy,\r\n      patternsProcessed: patterns.length,\r\n      newInsights,\r\n    };\r\n\r\n    this.emit('training-completed', result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get optimization suggestions based on current domain state\r\n   */\r\n  public async getOptimizationSuggestions(\r\n    context: AgenticHookContext\r\n  ): Promise<{\r\n    suggestions: BoundaryOptimization;\r\n    applicability: number;\r\n    prioritizedActions: Array<{\r\n      action: string;\r\n      priority: 'low' | 'medium' | 'high' | 'critical';\r\n      impact: number;\r\n      effort: number;\r\n    }>;\r\n  }> {\r\n    // Get current optimization suggestions\r\n    const optimization = await this.domainMapper.provideBoundaryOptimization();\r\n    \r\n    // Calculate applicability based on context\r\n    const applicability = this.calculateOptimizationApplicability(optimization, context);\r\n    \r\n    // Generate prioritized actions\r\n    const prioritizedActions = this.generatePrioritizedActions(optimization);\r\n\r\n    const result = {\r\n      suggestions: optimization,\r\n      applicability,\r\n      prioritizedActions,\r\n    };\r\n\r\n    this.emit('optimization-suggestions-generated', result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Predict domain relationship outcomes\r\n   */\r\n  public async predictDomainRelationships(\r\n    proposedChanges: {\r\n      newDomains?: Array<{ id: string; name: string; type: string }>;\r\n      removedDomains?: string[];\r\n      newRelationships?: Array<{ source: string; target: string; type: string }>;\r\n      removedRelationships?: Array<{ source: string; target: string }>;\r\n    },\r\n    context: AgenticHookContext\r\n  ): Promise<{\r\n    predictions: Prediction[];\r\n    riskAssessment: {\r\n      overallRisk: number;\r\n      riskFactors: Array<{\r\n        factor: string;\r\n        risk: number;\r\n        mitigation: string;\r\n      }>;\r\n    };\r\n    recommendations: string[];\r\n  }> {\r\n    // Create prediction input from proposed changes\r\n    const predictionInput = this.createPredictionInput(proposedChanges);\r\n    \r\n    // Make predictions\r\n    const predictions = await Promise.all(\r\n      predictionInput.map(input => this.domainMapper.predict(input))\r\n    );\r\n\r\n    // Assess risks\r\n    const riskAssessment = this.assessChangeRisks(proposedChanges, predictions);\r\n\r\n    // Generate recommendations\r\n    const recommendations = this.generateChangeRecommendations(\r\n      proposedChanges,\r\n      predictions,\r\n      riskAssessment\r\n    );\r\n\r\n    const result = {\r\n      predictions,\r\n      riskAssessment,\r\n      recommendations,\r\n    };\r\n\r\n    this.emit('domain-predictions-generated', result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get integration statistics\r\n   */\r\n  public getIntegrationStats(): {\r\n    analysesPerformed: number;\r\n    averageAnalysisTime: number;\r\n    patternsLearned: number;\r\n    optimizationsSuggested: number;\r\n    accuracyTrend: number[];\r\n    lastAnalysis: number;\r\n  } {\r\n    const totalAnalyses = this.analysisHistory.length;\r\n    const avgTime = totalAnalyses > 0 \r\n      ? this.analysisHistory.reduce((sum, a) => sum + a.metrics.analysisTime, 0) / totalAnalyses \r\n      : 0;\r\n    \r\n    const optimizationsSuggested = this.analysisHistory.reduce(\r\n      (sum, a) => sum + a.optimization.proposals.length, 0\r\n    );\r\n\r\n    const accuracyTrend = this.analysisHistory\r\n      .slice(-10)\r\n      .map(a => a.cohesion.overallScore);\r\n\r\n    return {\r\n      analysesPerformed: totalAnalyses,\r\n      averageAnalysisTime: avgTime,\r\n      patternsLearned: this.learningPatterns.length,\r\n      optimizationsSuggested,\r\n      accuracyTrend,\r\n      lastAnalysis: totalAnalyses > 0 ? this.analysisHistory[totalAnalyses - 1].timestamp : 0,\r\n    };\r\n  }\r\n\r\n  // ===== Private Methods =====\r\n\r\n  private setupEventListeners(): void {\r\n    this.domainMapper.on('graph-updated', (graph: DomainGraph) => {\r\n      this.emit('graph-updated', graph);\r\n    });\r\n\r\n    this.domainMapper.on('cohesion-calculated', (analysis: CohesionAnalysis) => {\r\n      this.emit('cohesion-calculated', analysis);\r\n    });\r\n\r\n    this.domainMapper.on('dependencies-analyzed', (analysis: DependencyAnalysis) => {\r\n      this.emit('dependencies-analyzed', analysis);\r\n    });\r\n\r\n    this.domainMapper.on('optimization-generated', (optimization: BoundaryOptimization) => {\r\n      this.emit('optimization-generated', optimization);\r\n    });\r\n\r\n    this.domainMapper.on('training-completed', (result: any) => {\r\n      this.emit('mapper-training-completed', result);\r\n    });\r\n  }\r\n\r\n  private registerDomainAnalysisHooks(): void {\r\n    // Register hook for neural pattern detection\r\n    agenticHookManager.register({\r\n      id: 'domain-mapper-pattern-analysis',\r\n      type: 'neural-pattern-detected',\r\n      priority: 80,\r\n      handler: async (payload: NeuralHookPayload, context: AgenticHookContext) => {\r\n        if (!this.config.enableAutoAnalysis || !payload.patterns?.length) {\r\n          return { continue: true };\r\n        }\r\n\r\n        // Check if patterns are domain-related\r\n        const domainPatterns = payload.patterns.filter(p => \r\n          this.isDomainRelatedPattern(p)\r\n        );\r\n\r\n        if (domainPatterns.length === 0) {\r\n          return { continue: true };\r\n        }\r\n\r\n        const sideEffects: SideEffect[] = [];\r\n\r\n        // Trigger domain analysis based on patterns\r\n        try {\r\n          const domainGraph = await this.extractDomainGraphFromPatterns(domainPatterns);\r\n          if (domainGraph) {\r\n            const analysisResult = await this.analyzeDomains(domainGraph, context);\r\n            \r\n            // Generate suggestions if confidence is high enough\r\n            if (analysisResult.optimization.optimizationScore >= this.config.confidenceThreshold) {\r\n              sideEffects.push({\r\n                type: 'notification',\r\n                action: 'emit',\r\n                data: {\r\n                  event: 'domain:optimization-suggested',\r\n                  data: analysisResult.optimization,\r\n                },\r\n              });\r\n            }\r\n\r\n            // Store analysis results\r\n            sideEffects.push({\r\n              type: 'memory',\r\n              action: 'store',\r\n              data: {\r\n                key: `domain:analysis:${context.correlationId}`,\r\n                value: analysisResult,\r\n                ttl: 3600, // 1 hour\r\n              },\r\n            });\r\n          }\r\n        } catch (error) {\r\n          sideEffects.push({\r\n            type: 'log',\r\n            action: 'write',\r\n            data: {\r\n              level: 'error',\r\n              message: 'Domain analysis failed',\r\n              error: error.message,\r\n            },\r\n          });\r\n        }\r\n\r\n        return {\r\n          continue: true,\r\n          sideEffects,\r\n        };\r\n      },\r\n    });\r\n\r\n    // Register hook for neural training completion\r\n    agenticHookManager.register({\r\n      id: 'domain-mapper-training-integration',\r\n      type: 'post-neural-train',\r\n      priority: 90,\r\n      handler: async (payload: NeuralHookPayload, context: AgenticHookContext) => {\r\n        if (!this.config.enableContinuousLearning) {\r\n          return { continue: true };\r\n        }\r\n\r\n        // Extract domain-relevant training data\r\n        if (payload.trainingData) {\r\n          const domainTrainingData = this.extractDomainTrainingData(payload.trainingData);\r\n          if (domainTrainingData.inputs.length > 0) {\r\n            // Retrain domain mapper with new data\r\n            try {\r\n              await this.domainMapper.train(domainTrainingData);\r\n              \r\n              return {\r\n                continue: true,\r\n                sideEffects: [{\r\n                  type: 'log',\r\n                  action: 'write',\r\n                  data: {\r\n                    level: 'info',\r\n                    message: 'Domain mapper updated with new training data',\r\n                    dataSize: domainTrainingData.inputs.length,\r\n                  },\r\n                }],\r\n              };\r\n            } catch (error) {\r\n              return {\r\n                continue: true,\r\n                sideEffects: [{\r\n                  type: 'log',\r\n                  action: 'write',\r\n                  data: {\r\n                    level: 'warning',\r\n                    message: 'Failed to update domain mapper',\r\n                    error: error.message,\r\n                  },\r\n                }],\r\n              };\r\n            }\r\n          }\r\n        }\r\n\r\n        return { continue: true };\r\n      },\r\n    });\r\n  }\r\n\r\n  private setupPeriodicAnalysis(): void {\r\n    setInterval(async () => {\r\n      try {\r\n        // Check if there are recent patterns to analyze\r\n        const recentPatterns = context.neural.patterns.getByType('behavior')\r\n          .filter(p => Date.now() - (p.context.timestamp || 0) < this.config.analysisInterval * 2);\r\n\r\n        if (recentPatterns.length > 0) {\r\n          const mockContext: AgenticHookContext = {\r\n            sessionId: 'periodic-analysis',\r\n            timestamp: Date.now(),\r\n            correlationId: `periodic-${Date.now()}`,\r\n            metadata: { source: 'periodic-analysis' },\r\n            memory: {\r\n              namespace: 'domain-analysis',\r\n              provider: 'default',\r\n              cache: new Map(),\r\n            },\r\n            neural: {\r\n              modelId: 'domain-mapper',\r\n              patterns: context.neural.patterns,\r\n              training: context.neural.training,\r\n            },\r\n            performance: {\r\n              metrics: new Map(),\r\n              bottlenecks: [],\r\n              optimizations: [],\r\n            },\r\n          };\r\n\r\n          // Perform periodic analysis\r\n          await this.trainOnPatterns(recentPatterns, mockContext);\r\n        }\r\n      } catch (error) {\r\n        this.emit('error', { type: 'periodic-analysis', error });\r\n      }\r\n    }, this.config.analysisInterval);\r\n  }\r\n\r\n  private async performDomainAnalysis(\r\n    domains: DomainGraph,\r\n    context: AgenticHookContext\r\n  ): Promise<DomainAnalysisResult> {\r\n    const startTime = Date.now();\r\n\r\n    // Perform comprehensive domain analysis\r\n    const analysis = await this.domainMapper.analyzeDomains(domains);\r\n\r\n    // Extract patterns from analysis results\r\n    const patterns = this.extractPatternsFromAnalysis(analysis, context);\r\n\r\n    const analysisTime = Date.now() - startTime;\r\n\r\n    return {\r\n      timestamp: Date.now(),\r\n      correlationId: context.correlationId,\r\n      graph: domains,\r\n      cohesion: analysis.cohesion,\r\n      dependencies: analysis.dependencies,\r\n      optimization: analysis.optimization,\r\n      patterns,\r\n      metrics: {\r\n        analysisTime,\r\n        nodesAnalyzed: domains.nodes.size,\r\n        edgesAnalyzed: domains.edges.size,\r\n        patternsDetected: patterns.length,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async generateHookSideEffects(\r\n    result: DomainAnalysisResult,\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    const sideEffects: SideEffect[] = [];\r\n\r\n    // Generate optimization notifications if applicable\r\n    if (result.optimization.optimizationScore >= this.config.confidenceThreshold) {\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'domain:optimization-available',\r\n          data: {\r\n            score: result.optimization.optimizationScore,\r\n            priority: result.optimization.priority,\r\n            proposalCount: result.optimization.proposals.length,\r\n          },\r\n        },\r\n      });\r\n    }\r\n\r\n    // Store detected patterns\r\n    for (const pattern of result.patterns) {\r\n      sideEffects.push({\r\n        type: 'neural',\r\n        action: 'store-pattern',\r\n        data: { pattern },\r\n      });\r\n    }\r\n\r\n    // Store performance metrics\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'update',\r\n      data: {\r\n        name: 'domain.analysis.time',\r\n        value: result.metrics.analysisTime,\r\n      },\r\n    });\r\n\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'update',\r\n      data: {\r\n        name: 'domain.cohesion.score',\r\n        value: result.cohesion.overallScore,\r\n      },\r\n    });\r\n\r\n    // Execute side effects through the hook system\r\n    for (const effect of sideEffects) {\r\n      try {\r\n        await this.executeSideEffect(effect, context);\r\n      } catch (error) {\r\n        this.emit('error', { type: 'side-effect', effect, error });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async learnFromAnalysis(\r\n    result: DomainAnalysisResult,\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    // Convert analysis results to training data\r\n    const learningData = this.convertAnalysisToTrainingData(result);\r\n    \r\n    if (learningData.inputs.length > 0) {\r\n      try {\r\n        await this.domainMapper.train(learningData);\r\n        this.emit('continuous-learning-completed', {\r\n          dataSize: learningData.inputs.length,\r\n          correlationId: context.correlationId,\r\n        });\r\n      } catch (error) {\r\n        this.emit('error', { type: 'continuous-learning', error });\r\n      }\r\n    }\r\n  }\r\n\r\n  private convertPatternsToTrainingData(patterns: Pattern[]): TrainingData {\r\n    const inputs: any[] = [];\r\n    const outputs: any[] = [];\r\n    const labels: string[] = [];\r\n\r\n    for (const pattern of patterns) {\r\n      if (this.isDomainRelatedPattern(pattern)) {\r\n        // Extract features from pattern context\r\n        const features = this.extractFeaturesFromPattern(pattern);\r\n        if (features.length > 0) {\r\n          inputs.push({ features });\r\n          \r\n          // Create target based on pattern type and confidence\r\n          const target = this.createTargetFromPattern(pattern);\r\n          outputs.push(target);\r\n          labels.push(pattern.type);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      inputs,\r\n      outputs,\r\n      labels,\r\n      batchSize: Math.min(32, inputs.length),\r\n      epochs: Math.max(1, Math.min(10, inputs.length / 10)),\r\n    };\r\n  }\r\n\r\n  private isDomainRelatedPattern(pattern: Pattern): boolean {\r\n    // Check if pattern context contains domain-related information\r\n    return !!(\r\n      pattern.context.domain ||\r\n      pattern.context.domainId ||\r\n      pattern.context.relationship ||\r\n      pattern.context.boundary ||\r\n      pattern.type === 'behavior' && pattern.context.component\r\n    );\r\n  }\r\n\r\n  private extractFeaturesFromPattern(pattern: Pattern): number[] {\r\n    const features: number[] = [];\r\n    \r\n    // Pattern type encoding\r\n    const types = ['success', 'failure', 'optimization', 'behavior'];\r\n    features.push(...types.map(t => t === pattern.type ? 1 : 0));\r\n    \r\n    // Confidence and occurrence features\r\n    features.push(pattern.confidence, Math.log(pattern.occurrences + 1) / 10);\r\n    \r\n    // Context features (simplified)\r\n    features.push(\r\n      pattern.context.complexity || 0.5,\r\n      pattern.context.size || 1,\r\n      pattern.context.frequency || 1,\r\n    );\r\n\r\n    // Pad to consistent size\r\n    while (features.length < 32) {\r\n      features.push(0);\r\n    }\r\n\r\n    return features.slice(0, 32);\r\n  }\r\n\r\n  private createTargetFromPattern(pattern: Pattern): number[] {\r\n    // Create target vector based on pattern characteristics\r\n    const target = [\r\n      pattern.confidence, // Quality score\r\n      pattern.type === 'success' ? 1 : 0, // Success indicator\r\n      pattern.type === 'failure' ? 1 : 0, // Failure indicator\r\n      Math.min(pattern.occurrences / 100, 1), // Frequency score\r\n    ];\r\n\r\n    return target;\r\n  }\r\n\r\n  private extractTrainingInsights(trainingResult: any, patterns: Pattern[]): string[] {\r\n    const insights: string[] = [];\r\n\r\n    if (trainingResult.finalAccuracy > 0.8) {\r\n      insights.push('High accuracy achieved - domain patterns are well understood');\r\n    } else if (trainingResult.finalAccuracy > 0.6) {\r\n      insights.push('Moderate accuracy - some domain patterns may need more data');\r\n    } else {\r\n      insights.push('Low accuracy - domain patterns are complex or insufficient data');\r\n    }\r\n\r\n    // Analyze pattern types\r\n    const patternTypes = new Map<string, number>();\r\n    patterns.forEach(p => {\r\n      patternTypes.set(p.type, (patternTypes.get(p.type) || 0) + 1);\r\n    });\r\n\r\n    const dominantType = Array.from(patternTypes.entries())\r\n      .sort((a, b) => b[1] - a[1])[0];\r\n\r\n    if (dominantType) {\r\n      insights.push(`Primary learning focus: ${dominantType[0]} patterns (${dominantType[1]} samples)`);\r\n    }\r\n\r\n    return insights;\r\n  }\r\n\r\n  // Additional helper methods would be implemented here for the remaining functionality\r\n  // These are simplified stubs for the core functionality\r\n\r\n  private async extractDomainGraphFromPatterns(patterns: Pattern[]): Promise<DomainGraph | null> {\r\n    // Extract domain structure from patterns - simplified implementation\r\n    return null;\r\n  }\r\n\r\n  private extractDomainTrainingData(trainingData: TrainingData): TrainingData {\r\n    // Filter and extract domain-relevant training data\r\n    return {\r\n      inputs: [],\r\n      outputs: [],\r\n      batchSize: 1,\r\n      epochs: 1,\r\n    };\r\n  }\r\n\r\n  private extractPatternsFromAnalysis(analysis: any, context: AgenticHookContext): Pattern[] {\r\n    // Extract patterns from analysis results\r\n    return [];\r\n  }\r\n\r\n  private async executeSideEffect(effect: SideEffect, context: AgenticHookContext): Promise<void> {\r\n    // Execute side effect through appropriate system\r\n  }\r\n\r\n  private convertAnalysisToTrainingData(result: DomainAnalysisResult): TrainingData {\r\n    // Convert analysis results to training data for continuous learning\r\n    return {\r\n      inputs: [],\r\n      outputs: [],\r\n      batchSize: 1,\r\n      epochs: 1,\r\n    };\r\n  }\r\n\r\n  private calculateOptimizationApplicability(optimization: BoundaryOptimization, context: AgenticHookContext): number {\r\n    return optimization.optimizationScore;\r\n  }\r\n\r\n  private generatePrioritizedActions(optimization: BoundaryOptimization): Array<{\r\n    action: string;\r\n    priority: 'low' | 'medium' | 'high' | 'critical';\r\n    impact: number;\r\n    effort: number;\r\n  }> {\r\n    return optimization.proposals.map(p => ({\r\n      action: `${p.type} domains: ${p.domains.join(', ')}`,\r\n      priority: p.confidence > 0.8 ? 'high' : p.confidence > 0.6 ? 'medium' : 'low',\r\n      impact: p.metrics.cohesionImprovement + p.metrics.couplingReduction,\r\n      effort: p.metrics.performanceImpact,\r\n    }));\r\n  }\r\n\r\n  private createPredictionInput(proposedChanges: any): any[] {\r\n    return [];\r\n  }\r\n\r\n  private assessChangeRisks(proposedChanges: any, predictions: Prediction[]): {\r\n    overallRisk: number;\r\n    riskFactors: Array<{ factor: string; risk: number; mitigation: string }>;\r\n  } {\r\n    return {\r\n      overallRisk: 0.5,\r\n      riskFactors: [],\r\n    };\r\n  }\r\n\r\n  private generateChangeRecommendations(\r\n    proposedChanges: any,\r\n    predictions: Prediction[],\r\n    riskAssessment: any\r\n  ): string[] {\r\n    return ['Consider gradual implementation', 'Monitor domain cohesion metrics'];\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create and initialize a domain mapper integration\r\n */\r\nexport async function createDomainMapperIntegration(\r\n  config: Partial<DomainMapperIntegrationConfig> = {}\r\n): Promise<NeuralDomainMapperIntegration> {\r\n  const integration = new NeuralDomainMapperIntegration(undefined, config);\r\n  await integration.initialize();\r\n  return integration;\r\n}\r\n\r\n/**\r\n * Export types for external use\r\n */\r\nexport type {\r\n  DomainMapperIntegrationConfig,\r\n  DomainAnalysisResult,\r\n};"],"names":["EventEmitter","NeuralDomainMapper","agenticHookManager","NeuralDomainMapperIntegration","domainMapper","config","analysisHistory","activeAnalysis","Map","learningPatterns","isInitialized","enableAutoAnalysis","enableOptimizationSuggestions","enableContinuousLearning","confidenceThreshold","analysisInterval","maxOptimizationProposals","setupEventListeners","initialize","registerDomainAnalysisHooks","setupPeriodicAnalysis","emit","analyzeDomains","domains","context","correlationId","has","get","analysisPromise","performDomainAnalysis","set","result","push","length","shift","generateHookSideEffects","learnFromAnalysis","delete","trainOnPatterns","patterns","trainingData","convertPatternsToTrainingData","inputs","trainingAccuracy","patternsProcessed","newInsights","trainingResult","train","extractTrainingInsights","slice","finalAccuracy","getOptimizationSuggestions","optimization","provideBoundaryOptimization","applicability","calculateOptimizationApplicability","prioritizedActions","generatePrioritizedActions","suggestions","predictDomainRelationships","proposedChanges","predictionInput","createPredictionInput","predictions","Promise","all","map","input","predict","riskAssessment","assessChangeRisks","recommendations","generateChangeRecommendations","getIntegrationStats","totalAnalyses","avgTime","reduce","sum","a","metrics","analysisTime","optimizationsSuggested","proposals","accuracyTrend","cohesion","overallScore","analysesPerformed","averageAnalysisTime","patternsLearned","lastAnalysis","timestamp","on","graph","analysis","register","id","type","priority","handler","payload","continue","domainPatterns","filter","p","isDomainRelatedPattern","sideEffects","domainGraph","extractDomainGraphFromPatterns","analysisResult","optimizationScore","action","data","event","key","value","ttl","error","level","message","domainTrainingData","extractDomainTrainingData","dataSize","setInterval","recentPatterns","neural","getByType","Date","now","mockContext","sessionId","metadata","source","memory","namespace","provider","cache","modelId","training","performance","bottlenecks","optimizations","startTime","extractPatternsFromAnalysis","dependencies","nodesAnalyzed","nodes","size","edgesAnalyzed","edges","patternsDetected","score","proposalCount","pattern","name","effect","executeSideEffect","learningData","convertAnalysisToTrainingData","outputs","labels","features","extractFeaturesFromPattern","target","createTargetFromPattern","batchSize","Math","min","epochs","max","domain","domainId","relationship","boundary","component","types","t","confidence","log","occurrences","complexity","frequency","insights","patternTypes","forEach","dominantType","Array","from","entries","sort","b","join","impact","cohesionImprovement","couplingReduction","effort","performanceImpact","overallRisk","riskFactors","createDomainMapperIntegration","integration","undefined"],"mappings":"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"}