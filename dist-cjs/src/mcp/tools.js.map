{"version":3,"sources":["../../../src/mcp/tools.ts"],"sourcesContent":["/**\n * Enhanced Tool registry for MCP with capability negotiation and discovery\n */\n\nimport type { MCPTool, MCPCapabilities, MCPProtocolVersion, MCPToolFilterConfig } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError } from '../utils/errors.js';\nimport { EventEmitter } from 'node:events';\nimport { IToolFilter, ToolFilterStats, createToolFilter } from './tool-filter.js';\n\nexport interface ToolCapability {\n  name: string;\n  version: string;\n  description: string;\n  category: string;\n  tags: string[];\n  requiredPermissions?: string[];\n  supportedProtocolVersions: MCPProtocolVersion[];\n  dependencies?: string[];\n  deprecated?: boolean;\n  deprecationMessage?: string;\n}\n\nexport interface ToolMetrics {\n  name: string;\n  totalInvocations: number;\n  successfulInvocations: number;\n  failedInvocations: number;\n  averageExecutionTime: number;\n  lastInvoked?: Date;\n  totalExecutionTime: number;\n}\n\nexport interface ToolDiscoveryQuery {\n  category?: string;\n  tags?: string[];\n  capabilities?: string[];\n  protocolVersion?: MCPProtocolVersion;\n  includeDeprecated?: boolean;\n  permissions?: string[];\n}\n\n/**\n * Enhanced Tool registry implementation with capability negotiation\n */\nexport class ToolRegistry extends EventEmitter {\n  private tools = new Map<string, MCPTool>();\n  private capabilities = new Map<string, ToolCapability>();\n  private metrics = new Map<string, ToolMetrics>();\n  private categories = new Set<string>();\n  private tags = new Set<string>();\n  private toolFilter?: IToolFilter;\n\n  constructor(private logger: ILogger, toolFilterConfig?: MCPToolFilterConfig) {\n    super();\n    if (toolFilterConfig?.enabled) {\n      this.toolFilter = createToolFilter(toolFilterConfig, logger);\n    }\n  }\n\n  /**\n   * Sets or updates the tool filter configuration\n   */\n  setToolFilter(config: MCPToolFilterConfig): void {\n    this.toolFilter = createToolFilter(config, this.logger);\n    this.emit('filterUpdated', { config });\n  }\n\n  /**\n   * Registers a new tool with enhanced capability information\n   */\n  register(tool: MCPTool, capability?: ToolCapability): void {\n    if (this.tools.has(tool.name)) {\n      throw new MCPError(`Tool already registered: ${tool.name}`);\n    }\n\n    // Validate tool schema\n    this.validateTool(tool);\n\n    // Register tool\n    this.tools.set(tool.name, tool);\n\n    // Register capability if provided\n    if (capability) {\n      this.registerCapability(tool.name, capability);\n    } else {\n      // Create default capability\n      const defaultCapability: ToolCapability = {\n        name: tool.name,\n        version: '1.0.0',\n        description: tool.description,\n        category: this.extractCategory(tool.name),\n        tags: this.extractTags(tool),\n        supportedProtocolVersions: [{ major: 2024, minor: 11, patch: 5 }],\n      };\n      this.registerCapability(tool.name, defaultCapability);\n    }\n\n    // Initialize metrics\n    this.metrics.set(tool.name, {\n      name: tool.name,\n      totalInvocations: 0,\n      successfulInvocations: 0,\n      failedInvocations: 0,\n      averageExecutionTime: 0,\n      totalExecutionTime: 0,\n    });\n\n    this.logger.debug('Tool registered', { name: tool.name });\n    this.emit('toolRegistered', { name: tool.name, capability });\n  }\n\n  /**\n   * Unregisters a tool\n   */\n  unregister(name: string): void {\n    if (!this.tools.has(name)) {\n      throw new MCPError(`Tool not found: ${name}`);\n    }\n\n    this.tools.delete(name);\n    this.logger.debug('Tool unregistered', { name });\n  }\n\n  /**\n   * Gets a tool by name\n   */\n  getTool(name: string): MCPTool | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Lists all registered tools (with filtering applied)\n   */\n  listTools(): Array<{ name: string; description: string }> {\n    let tools = Array.from(this.tools.values());\n\n    if (this.toolFilter) {\n      tools = this.toolFilter.filterTools(tools);\n    }\n\n    return tools.map((tool) => ({\n      name: tool.name,\n      description: tool.description,\n    }));\n  }\n\n  /**\n   * Gets the number of registered tools (after filtering)\n   */\n  getToolCount(): number {\n    if (this.toolFilter) {\n      return this.toolFilter.filterTools(Array.from(this.tools.values())).length;\n    }\n    return this.tools.size;\n  }\n\n  /**\n   * Gets the total number of registered tools (before filtering)\n   */\n  getTotalToolCount(): number {\n    return this.tools.size;\n  }\n\n  /**\n   * Gets filter statistics\n   */\n  getFilterStats(): ToolFilterStats | null {\n    return this.toolFilter?.getFilterStats() ?? null;\n  }\n\n  /**\n   * Executes a tool with metrics tracking\n   */\n  async executeTool(name: string, input: unknown, context?: any): Promise<unknown> {\n    const tool = this.tools.get(name);\n    if (!tool) {\n      throw new MCPError(`Tool not found: ${name}`);\n    }\n\n    const startTime = Date.now();\n    const metrics = this.metrics.get(name);\n\n    this.logger.debug('Executing tool', { name, input });\n\n    try {\n      // Validate input against schema\n      this.validateInput(tool, input);\n\n      // Check tool capabilities and permissions\n      await this.checkToolCapabilities(name, context);\n\n      // Execute tool handler\n      const result = await tool.handler(input, context);\n\n      // Update success metrics\n      if (metrics) {\n        const executionTime = Date.now() - startTime;\n        metrics.totalInvocations++;\n        metrics.successfulInvocations++;\n        metrics.totalExecutionTime += executionTime;\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\n        metrics.lastInvoked = new Date();\n      }\n\n      this.logger.debug('Tool executed successfully', {\n        name,\n        executionTime: Date.now() - startTime,\n      });\n      this.emit('toolExecuted', { name, success: true, executionTime: Date.now() - startTime });\n\n      return result;\n    } catch (error) {\n      // Update failure metrics\n      if (metrics) {\n        const executionTime = Date.now() - startTime;\n        metrics.totalInvocations++;\n        metrics.failedInvocations++;\n        metrics.totalExecutionTime += executionTime;\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\n        metrics.lastInvoked = new Date();\n      }\n\n      this.logger.error('Tool execution failed', {\n        name,\n        error,\n        executionTime: Date.now() - startTime,\n      });\n      this.emit('toolExecuted', {\n        name,\n        success: false,\n        error,\n        executionTime: Date.now() - startTime,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Validates tool definition\n   */\n  private validateTool(tool: MCPTool): void {\n    if (!tool.name || typeof tool.name !== 'string') {\n      throw new MCPError('Tool name must be a non-empty string');\n    }\n\n    if (!tool.description || typeof tool.description !== 'string') {\n      throw new MCPError('Tool description must be a non-empty string');\n    }\n\n    if (typeof tool.handler !== 'function') {\n      throw new MCPError('Tool handler must be a function');\n    }\n\n    if (!tool.inputSchema || typeof tool.inputSchema !== 'object') {\n      throw new MCPError('Tool inputSchema must be an object');\n    }\n\n    // Validate tool name format (namespace/name)\n    if (!tool.name.includes('/')) {\n      throw new MCPError('Tool name must be in format: namespace/name');\n    }\n  }\n\n  /**\n   * Validates input against tool schema\n   */\n  private validateInput(tool: MCPTool, input: unknown): void {\n    // Simple validation - in production, use a JSON Schema validator\n    const schema = tool.inputSchema as any;\n\n    if (schema.type === 'object' && schema.properties) {\n      if (typeof input !== 'object' || input === null) {\n        throw new MCPError('Input must be an object');\n      }\n\n      const inputObj = input as Record<string, unknown>;\n\n      // Check required properties\n      if (schema.required && Array.isArray(schema.required)) {\n        for (const prop of schema.required) {\n          if (!(prop in inputObj)) {\n            throw new MCPError(`Missing required property: ${prop}`);\n          }\n        }\n      }\n\n      // Check property types\n      for (const [prop, propSchema] of Object.entries(schema.properties)) {\n        if (prop in inputObj) {\n          const value = inputObj[prop];\n          const expectedType = (propSchema as any).type;\n\n          if (expectedType && !this.checkType(value, expectedType)) {\n            throw new MCPError(`Invalid type for property ${prop}: expected ${expectedType}`);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks if a value matches a JSON Schema type\n   */\n  private checkType(value: unknown, type: string): boolean {\n    switch (type) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number';\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'object':\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n      case 'array':\n        return Array.isArray(value);\n      case 'null':\n        return value === null;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Register tool capability information\n   */\n  private registerCapability(toolName: string, capability: ToolCapability): void {\n    this.capabilities.set(toolName, capability);\n    this.categories.add(capability.category);\n    capability.tags.forEach((tag) => this.tags.add(tag));\n  }\n\n  /**\n   * Extract category from tool name\n   */\n  private extractCategory(toolName: string): string {\n    const parts = toolName.split('/');\n    return parts.length > 1 ? parts[0] : 'general';\n  }\n\n  /**\n   * Extract tags from tool definition\n   */\n  private extractTags(tool: MCPTool): string[] {\n    const tags: string[] = [];\n\n    // Extract from description\n    if (tool.description.toLowerCase().includes('file')) tags.push('filesystem');\n    if (tool.description.toLowerCase().includes('search')) tags.push('search');\n    if (tool.description.toLowerCase().includes('memory')) tags.push('memory');\n    if (tool.description.toLowerCase().includes('swarm')) tags.push('swarm');\n    if (tool.description.toLowerCase().includes('task')) tags.push('orchestration');\n\n    return tags.length > 0 ? tags : ['general'];\n  }\n\n  /**\n   * Check tool capabilities and permissions\n   */\n  private async checkToolCapabilities(toolName: string, context?: any): Promise<void> {\n    const capability = this.capabilities.get(toolName);\n    if (!capability) {\n      return; // No capability checks needed\n    }\n\n    // Check if tool is deprecated\n    if (capability.deprecated) {\n      this.logger.warn('Using deprecated tool', {\n        name: toolName,\n        message: capability.deprecationMessage,\n      });\n    }\n\n    // Check required permissions\n    if (capability.requiredPermissions && context?.permissions) {\n      const hasAllPermissions = capability.requiredPermissions.every((permission) =>\n        context.permissions.includes(permission),\n      );\n\n      if (!hasAllPermissions) {\n        throw new MCPError(\n          `Insufficient permissions for tool ${toolName}. Required: ${capability.requiredPermissions.join(', ')}`,\n        );\n      }\n    }\n\n    // Check protocol version compatibility\n    if (context?.protocolVersion) {\n      const isCompatible = capability.supportedProtocolVersions.some((version) =>\n        this.isProtocolVersionCompatible(context.protocolVersion, version),\n      );\n\n      if (!isCompatible) {\n        throw new MCPError(\n          `Tool ${toolName} is not compatible with protocol version ${context.protocolVersion.major}.${context.protocolVersion.minor}.${context.protocolVersion.patch}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Check protocol version compatibility\n   */\n  private isProtocolVersionCompatible(\n    client: MCPProtocolVersion,\n    supported: MCPProtocolVersion,\n  ): boolean {\n    if (client.major !== supported.major) {\n      return false;\n    }\n\n    if (client.minor > supported.minor) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Discover tools based on query criteria\n   */\n  discoverTools(\n    query: ToolDiscoveryQuery = {},\n  ): Array<{ tool: MCPTool; capability: ToolCapability }> {\n    const results: Array<{ tool: MCPTool; capability: ToolCapability }> = [];\n\n    for (const [name, tool] of this.tools) {\n      const capability = this.capabilities.get(name);\n      if (!capability) continue;\n\n      // Filter by category\n      if (query.category && capability.category !== query.category) {\n        continue;\n      }\n\n      // Filter by tags\n      if (query.tags && !query.tags.some((tag) => capability.tags.includes(tag))) {\n        continue;\n      }\n\n      // Filter by capabilities\n      if (query.capabilities && !query.capabilities.every((cap) => capability.tags.includes(cap))) {\n        continue;\n      }\n\n      // Filter by protocol version\n      if (query.protocolVersion) {\n        const isCompatible = capability.supportedProtocolVersions.some((version) =>\n          this.isProtocolVersionCompatible(query.protocolVersion!, version),\n        );\n        if (!isCompatible) continue;\n      }\n\n      // Filter deprecated tools\n      if (!query.includeDeprecated && capability.deprecated) {\n        continue;\n      }\n\n      // Filter by permissions\n      if (query.permissions && capability.requiredPermissions) {\n        const hasAllPermissions = capability.requiredPermissions.every((permission) =>\n          query.permissions!.includes(permission),\n        );\n        if (!hasAllPermissions) continue;\n      }\n\n      results.push({ tool, capability });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get tool capability information\n   */\n  getToolCapability(name: string): ToolCapability | undefined {\n    return this.capabilities.get(name);\n  }\n\n  /**\n   * Get tool metrics\n   */\n  getToolMetrics(name?: string): ToolMetrics | ToolMetrics[] {\n    if (name) {\n      const metrics = this.metrics.get(name);\n      if (!metrics) {\n        throw new MCPError(`Metrics not found for tool: ${name}`);\n      }\n      return metrics;\n    }\n\n    return Array.from(this.metrics.values());\n  }\n\n  /**\n   * Get all available categories\n   */\n  getCategories(): string[] {\n    return Array.from(this.categories);\n  }\n\n  /**\n   * Get all available tags\n   */\n  getTags(): string[] {\n    return Array.from(this.tags);\n  }\n\n  /**\n   * Reset metrics for a tool or all tools\n   */\n  resetMetrics(toolName?: string): void {\n    if (toolName) {\n      const metrics = this.metrics.get(toolName);\n      if (metrics) {\n        Object.assign(metrics, {\n          totalInvocations: 0,\n          successfulInvocations: 0,\n          failedInvocations: 0,\n          averageExecutionTime: 0,\n          totalExecutionTime: 0,\n          lastInvoked: undefined,\n        });\n      }\n    } else {\n      for (const metrics of this.metrics.values()) {\n        Object.assign(metrics, {\n          totalInvocations: 0,\n          successfulInvocations: 0,\n          failedInvocations: 0,\n          averageExecutionTime: 0,\n          totalExecutionTime: 0,\n          lastInvoked: undefined,\n        });\n      }\n    }\n\n    this.emit('metricsReset', { toolName });\n  }\n\n  /**\n   * Get comprehensive registry statistics\n   */\n  getRegistryStats(): {\n    totalTools: number;\n    toolsByCategory: Record<string, number>;\n    toolsByTag: Record<string, number>;\n    totalInvocations: number;\n    successRate: number;\n    averageExecutionTime: number;\n  } {\n    const stats = {\n      totalTools: this.tools.size,\n      toolsByCategory: {} as Record<string, number>,\n      toolsByTag: {} as Record<string, number>,\n      totalInvocations: 0,\n      successRate: 0,\n      averageExecutionTime: 0,\n    };\n\n    // Count by category\n    for (const capability of this.capabilities.values()) {\n      stats.toolsByCategory[capability.category] =\n        (stats.toolsByCategory[capability.category] || 0) + 1;\n\n      for (const tag of capability.tags) {\n        stats.toolsByTag[tag] = (stats.toolsByTag[tag] || 0) + 1;\n      }\n    }\n\n    // Calculate execution stats\n    let totalExecutionTime = 0;\n    let totalSuccessful = 0;\n\n    for (const metrics of this.metrics.values()) {\n      stats.totalInvocations += metrics.totalInvocations;\n      totalSuccessful += metrics.successfulInvocations;\n      totalExecutionTime += metrics.totalExecutionTime;\n    }\n\n    if (stats.totalInvocations > 0) {\n      stats.successRate = (totalSuccessful / stats.totalInvocations) * 100;\n      stats.averageExecutionTime = totalExecutionTime / stats.totalInvocations;\n    }\n\n    return stats;\n  }\n}\n"],"names":["MCPError","EventEmitter","createToolFilter","ToolRegistry","tools","Map","capabilities","metrics","categories","Set","tags","toolFilter","logger","toolFilterConfig","enabled","setToolFilter","config","emit","register","tool","capability","has","name","validateTool","set","registerCapability","defaultCapability","version","description","category","extractCategory","extractTags","supportedProtocolVersions","major","minor","patch","totalInvocations","successfulInvocations","failedInvocations","averageExecutionTime","totalExecutionTime","debug","unregister","delete","getTool","get","listTools","Array","from","values","filterTools","map","getToolCount","length","size","getTotalToolCount","getFilterStats","executeTool","input","context","startTime","Date","now","validateInput","checkToolCapabilities","result","handler","executionTime","lastInvoked","success","error","inputSchema","includes","schema","type","properties","inputObj","required","isArray","prop","propSchema","Object","entries","value","expectedType","checkType","toolName","add","forEach","tag","parts","split","toLowerCase","push","deprecated","warn","message","deprecationMessage","requiredPermissions","permissions","hasAllPermissions","every","permission","join","protocolVersion","isCompatible","some","isProtocolVersionCompatible","client","supported","discoverTools","query","results","cap","includeDeprecated","getToolCapability","getToolMetrics","getCategories","getTags","resetMetrics","assign","undefined","getRegistryStats","stats","totalTools","toolsByCategory","toolsByTag","successRate","totalSuccessful"],"mappings":"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"}