{
  "version": 3,
  "sources": ["../../src/mcp/session-manager.ts"],
  "sourcesContent": ["/**\n * Session manager for MCP connections\n */\n\nimport {\n  MCPSession,\n  MCPInitializeParams,\n  MCPProtocolVersion,\n  MCPCapabilities,\n  MCPAuthConfig,\n  MCPConfig,\n} from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError } from '../utils/errors.js';\nimport { createHash, timingSafeEqual } from 'node:crypto';\n\nexport interface ISessionManager {\n  createSession(transport: 'stdio' | 'http' | 'websocket'): MCPSession;\n  getSession(id: string): MCPSession | undefined;\n  initializeSession(sessionId: string, params: MCPInitializeParams): void;\n  authenticateSession(sessionId: string, credentials: unknown): boolean;\n  updateActivity(sessionId: string): void;\n  removeSession(sessionId: string): void;\n  getActiveSessions(): MCPSession[];\n  cleanupExpiredSessions(): void;\n  getSessionMetrics(): {\n    total: number;\n    active: number;\n    authenticated: number;\n    expired: number;\n  };\n}\n\n/**\n * Session manager implementation\n */\nexport class SessionManager implements ISessionManager {\n  private sessions = new Map<string, MCPSession>();\n  private authConfig: MCPAuthConfig;\n  private sessionTimeout: number;\n  private maxSessions: number;\n  private cleanupInterval?: number;\n\n  constructor(\n    private config: MCPConfig,\n    private logger: ILogger,\n  ) {\n    this.authConfig = config.auth || { enabled: false, method: 'token' };\n    this.sessionTimeout = config.sessionTimeout || 3600000; // 1 hour default\n    this.maxSessions = config.maxSessions || 100;\n\n    // Start cleanup timer\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpiredSessions();\n    }, 60000); // Clean up every minute\n  }\n\n  createSession(transport: 'stdio' | 'http' | 'websocket'): MCPSession {\n    // Check session limit\n    if (this.sessions.size >= this.maxSessions) {\n      // Try to clean up expired sessions first\n      this.cleanupExpiredSessions();\n\n      if (this.sessions.size >= this.maxSessions) {\n        throw new MCPError('Maximum number of sessions reached');\n      }\n    }\n\n    const sessionId = this.generateSessionId();\n    const now = new Date();\n\n    const session: MCPSession = {\n      id: sessionId,\n      clientInfo: { name: 'unknown', version: 'unknown' },\n      protocolVersion: { major: 0, minor: 0, patch: 0 },\n      capabilities: {},\n      isInitialized: false,\n      createdAt: now,\n      lastActivity: now,\n      transport,\n      authenticated: !this.authConfig.enabled, // If auth disabled, session is authenticated\n    };\n\n    this.sessions.set(sessionId, session);\n\n    this.logger.info('Session created', {\n      sessionId,\n      transport,\n      totalSessions: this.sessions.size,\n    });\n\n    return session;\n  }\n\n  getSession(id: string): MCPSession | undefined {\n    const session = this.sessions.get(id);\n    if (session && this.isSessionExpired(session)) {\n      this.removeSession(id);\n      return undefined;\n    }\n    return session;\n  }\n\n  initializeSession(sessionId: string, params: MCPInitializeParams): void {\n    const session = this.getSession(sessionId);\n    if (!session) {\n      throw new MCPError(`Session not found: ${sessionId}`);\n    }\n\n    // Validate protocol version\n    this.validateProtocolVersion(params.protocolVersion);\n\n    // Update session with initialization params\n    session.clientInfo = params.clientInfo;\n    session.protocolVersion = params.protocolVersion;\n    session.capabilities = params.capabilities;\n    session.isInitialized = true;\n    session.lastActivity = new Date();\n\n    this.logger.info('Session initialized', {\n      sessionId,\n      clientInfo: params.clientInfo,\n      protocolVersion: params.protocolVersion,\n    });\n  }\n\n  authenticateSession(sessionId: string, credentials: unknown): boolean {\n    const session = this.getSession(sessionId);\n    if (!session) {\n      return false;\n    }\n\n    if (!this.authConfig.enabled) {\n      session.authenticated = true;\n      return true;\n    }\n\n    let authenticated = false;\n\n    switch (this.authConfig.method) {\n      case 'token':\n        authenticated = this.authenticateToken(credentials);\n        break;\n      case 'basic':\n        authenticated = this.authenticateBasic(credentials);\n        break;\n      case 'oauth':\n        authenticated = this.authenticateOAuth(credentials);\n        break;\n      default:\n        this.logger.warn('Unknown authentication method', {\n          method: this.authConfig.method,\n        });\n        return false;\n    }\n\n    if (authenticated) {\n      session.authenticated = true;\n      session.authData = this.extractAuthData(credentials);\n      session.lastActivity = new Date();\n\n      this.logger.info('Session authenticated', {\n        sessionId,\n        method: this.authConfig.method,\n      });\n    } else {\n      this.logger.warn('Session authentication failed', {\n        sessionId,\n        method: this.authConfig.method,\n      });\n    }\n\n    return authenticated;\n  }\n\n  updateActivity(sessionId: string): void {\n    const session = this.getSession(sessionId);\n    if (session) {\n      session.lastActivity = new Date();\n    }\n  }\n\n  removeSession(sessionId: string): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      this.sessions.delete(sessionId);\n      this.logger.info('Session removed', {\n        sessionId,\n        duration: Date.now() - session.createdAt.getTime(),\n        transport: session.transport,\n      });\n    }\n  }\n\n  getActiveSessions(): MCPSession[] {\n    const activeSessions: MCPSession[] = [];\n    for (const session of this.sessions.values()) {\n      if (!this.isSessionExpired(session)) {\n        activeSessions.push(session);\n      }\n    }\n    return activeSessions;\n  }\n\n  cleanupExpiredSessions(): void {\n    const expiredSessions: string[] = [];\n\n    for (const [sessionId, session] of this.sessions) {\n      if (this.isSessionExpired(session)) {\n        expiredSessions.push(sessionId);\n      }\n    }\n\n    for (const sessionId of expiredSessions) {\n      this.removeSession(sessionId);\n    }\n\n    if (expiredSessions.length > 0) {\n      this.logger.info('Cleaned up expired sessions', {\n        count: expiredSessions.length,\n        remainingSessions: this.sessions.size,\n      });\n    }\n  }\n\n  getSessionMetrics(): {\n    total: number;\n    active: number;\n    authenticated: number;\n    expired: number;\n  } {\n    let active = 0;\n    let authenticated = 0;\n    let expired = 0;\n\n    for (const session of this.sessions.values()) {\n      if (this.isSessionExpired(session)) {\n        expired++;\n      } else {\n        active++;\n        if (session.authenticated) {\n          authenticated++;\n        }\n      }\n    }\n\n    return {\n      total: this.sessions.size,\n      active,\n      authenticated,\n      expired,\n    };\n  }\n\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n    this.sessions.clear();\n  }\n\n  private generateSessionId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substr(2, 9);\n    return `session_${timestamp}_${random}`;\n  }\n\n  private isSessionExpired(session: MCPSession): boolean {\n    const now = Date.now();\n    const sessionAge = now - session.lastActivity.getTime();\n    return sessionAge > this.sessionTimeout;\n  }\n\n  private validateProtocolVersion(version: MCPProtocolVersion): void {\n    // Currently supporting MCP version 2024-11-05\n    const supportedVersions = [{ major: 2024, minor: 11, patch: 5 }];\n\n    const isSupported = supportedVersions.some(\n      (supported) =>\n        supported.major === version.major &&\n        supported.minor === version.minor &&\n        supported.patch === version.patch,\n    );\n\n    if (!isSupported) {\n      throw new MCPError(\n        `Unsupported protocol version: ${version.major}.${version.minor}.${version.patch}`,\n        { supportedVersions },\n      );\n    }\n  }\n\n  private authenticateToken(credentials: unknown): boolean {\n    if (!this.authConfig.tokens || this.authConfig.tokens.length === 0) {\n      return false;\n    }\n\n    const token = this.extractToken(credentials);\n    if (!token) {\n      return false;\n    }\n\n    // Use timing-safe comparison to prevent timing attacks\n    return this.authConfig.tokens.some((validToken) => {\n      const encoder = new TextEncoder();\n      const validTokenBytes = encoder.encode(validToken);\n      const providedTokenBytes = encoder.encode(token);\n\n      if (validTokenBytes.length !== providedTokenBytes.length) {\n        return false;\n      }\n\n      return timingSafeEqual(validTokenBytes, providedTokenBytes);\n    });\n  }\n\n  private authenticateBasic(credentials: unknown): boolean {\n    if (!this.authConfig.users || this.authConfig.users.length === 0) {\n      return false;\n    }\n\n    const { username, password } = this.extractBasicAuth(credentials);\n    if (!username || !password) {\n      return false;\n    }\n\n    const user = this.authConfig.users.find((u) => u.username === username);\n    if (!user) {\n      return false;\n    }\n\n    // Hash the provided password and compare\n    const hashedPassword = this.hashPassword(password);\n    const expectedHashedPassword = this.hashPassword(user.password);\n\n    const encoder = new TextEncoder();\n    const hashedPasswordBytes = encoder.encode(hashedPassword);\n    const expectedHashedPasswordBytes = encoder.encode(expectedHashedPassword);\n\n    if (hashedPasswordBytes.length !== expectedHashedPasswordBytes.length) {\n      return false;\n    }\n\n    return timingSafeEqual(hashedPasswordBytes, expectedHashedPasswordBytes);\n  }\n\n  private authenticateOAuth(credentials: unknown): boolean {\n    // TODO: Implement OAuth authentication\n    // This would typically involve validating JWT tokens\n    this.logger.warn('OAuth authentication not yet implemented');\n    return false;\n  }\n\n  private extractToken(credentials: unknown): string | null {\n    if (typeof credentials === 'string') {\n      return credentials;\n    }\n\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n      if (typeof creds.token === 'string') {\n        return creds.token;\n      }\n      if (typeof creds.authorization === 'string') {\n        const match = creds.authorization.match(/^Bearer\\s+(.+)$/);\n        return match ? match[1] : null;\n      }\n    }\n\n    return null;\n  }\n\n  private extractBasicAuth(credentials: unknown): { username?: string; password?: string } {\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n\n      if (typeof creds.username === 'string' && typeof creds.password === 'string') {\n        return {\n          username: creds.username,\n          password: creds.password,\n        };\n      }\n\n      if (typeof creds.authorization === 'string') {\n        const match = creds.authorization.match(/^Basic\\s+(.+)$/);\n        if (match) {\n          try {\n            const decoded = atob(match[1]);\n            const [username, password] = decoded.split(':', 2);\n            return { username, password };\n          } catch {\n            return {};\n          }\n        }\n      }\n    }\n\n    return {};\n  }\n\n  private extractAuthData(credentials: unknown): any {\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n      return {\n        token: this.extractToken(credentials),\n        user: creds.username || creds.user,\n        permissions: creds.permissions || [],\n      };\n    }\n    return {};\n  }\n\n  private hashPassword(password: string): string {\n    return createHash('sha256').update(password).digest('hex');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
