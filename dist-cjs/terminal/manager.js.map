{
  "version": 3,
  "sources": ["../../src/terminal/manager.ts"],
  "sourcesContent": ["import * as process from 'node:process';\n/**\n * Terminal manager interface and implementation\n */\n\nimport type { AgentProfile, AgentSession, TerminalConfig } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TerminalError, TerminalSpawnError } from '../utils/errors.js';\nimport type { ITerminalAdapter } from './adapters/base.js';\nimport { VSCodeAdapter } from './adapters/vscode.js';\nimport { NativeAdapter } from './adapters/native.js';\nimport { TerminalPool } from './pool.js';\nimport { TerminalSession } from './session.js';\n\nexport interface ITerminalManager {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  spawnTerminal(profile: AgentProfile): Promise<string>;\n  terminateTerminal(terminalId: string): Promise<void>;\n  executeCommand(terminalId: string, command: string): Promise<string>;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  performMaintenance(): Promise<void>;\n}\n\n/**\n * Terminal manager implementation\n */\nexport class TerminalManager implements ITerminalManager {\n  private adapter: ITerminalAdapter;\n  private pool: TerminalPool;\n  private sessions = new Map<string, TerminalSession>();\n  private initialized = false;\n\n  constructor(\n    private config: TerminalConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    // Select adapter based on configuration\n    this.adapter = this.createAdapter();\n\n    // Create terminal pool\n    this.pool = new TerminalPool(\n      this.config.poolSize,\n      this.config.recycleAfter,\n      this.adapter,\n      this.logger,\n    );\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    this.logger.info('Initializing terminal manager...');\n\n    try {\n      // Initialize adapter\n      await this.adapter.initialize();\n\n      // Initialize pool\n      await this.pool.initialize();\n\n      this.initialized = true;\n      this.logger.info('Terminal manager initialized');\n    } catch (error) {\n      this.logger.error('Failed to initialize terminal manager', error);\n      throw new TerminalError('Terminal manager initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down terminal manager...');\n\n    try {\n      // Terminate all sessions\n      const sessionIds = Array.from(this.sessions.keys());\n      await Promise.all(sessionIds.map((id) => this.terminateTerminal(id)));\n\n      // Shutdown pool\n      await this.pool.shutdown();\n\n      // Shutdown adapter\n      await this.adapter.shutdown();\n\n      this.initialized = false;\n      this.logger.info('Terminal manager shutdown complete');\n    } catch (error) {\n      this.logger.error('Error during terminal manager shutdown', error);\n      throw error;\n    }\n  }\n\n  async spawnTerminal(profile: AgentProfile): Promise<string> {\n    if (!this.initialized) {\n      throw new TerminalError('Terminal manager not initialized');\n    }\n\n    this.logger.debug('Spawning terminal', { agentId: profile.id });\n\n    try {\n      // Get terminal from pool\n      const terminal = await this.pool.acquire();\n\n      // Create session\n      const session = new TerminalSession(\n        terminal,\n        profile,\n        this.config.commandTimeout,\n        this.logger,\n      );\n\n      // Initialize session\n      await session.initialize();\n\n      // Store session\n      this.sessions.set(session.id, session);\n\n      this.logger.info('Terminal spawned', {\n        terminalId: session.id,\n        agentId: profile.id,\n      });\n\n      return session.id;\n    } catch (error) {\n      this.logger.error('Failed to spawn terminal', error);\n      throw new TerminalSpawnError('Failed to spawn terminal', { error });\n    }\n  }\n\n  async terminateTerminal(terminalId: string): Promise<void> {\n    const session = this.sessions.get(terminalId);\n    if (!session) {\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\n    }\n\n    this.logger.debug('Terminating terminal', { terminalId });\n\n    try {\n      // Cleanup session\n      await session.cleanup();\n\n      // Return terminal to pool\n      await this.pool.release(session.terminal);\n\n      // Remove session\n      this.sessions.delete(terminalId);\n\n      this.logger.info('Terminal terminated', { terminalId });\n    } catch (error) {\n      this.logger.error('Failed to terminate terminal', error);\n      throw error;\n    }\n  }\n\n  async executeCommand(terminalId: string, command: string): Promise<string> {\n    const session = this.sessions.get(terminalId);\n    if (!session) {\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\n    }\n\n    return await session.executeCommand(command);\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const poolHealth = await this.pool.getHealthStatus();\n      const activeSessions = this.sessions.size;\n      const healthySessions = Array.from(this.sessions.values()).filter((session) =>\n        session.isHealthy(),\n      ).length;\n\n      const metrics = {\n        activeSessions,\n        healthySessions,\n        poolSize: poolHealth.size,\n        availableTerminals: poolHealth.available,\n        recycledTerminals: poolHealth.recycled,\n      };\n\n      const healthy = poolHealth.healthy && healthySessions === activeSessions;\n\n      if (healthy) {\n        return {\n          healthy,\n          metrics,\n        };\n      } else {\n        return {\n          healthy,\n          metrics,\n          error: 'Some terminals are unhealthy',\n        };\n      }\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  async performMaintenance(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.debug('Performing terminal manager maintenance');\n\n    try {\n      // Clean up dead sessions\n      const deadSessions = Array.from(this.sessions.entries()).filter(\n        ([_, session]) => !session.isHealthy(),\n      );\n\n      for (const [terminalId, _] of deadSessions) {\n        this.logger.warn('Cleaning up dead terminal session', { terminalId });\n        await this.terminateTerminal(terminalId).catch((error) =>\n          this.logger.error('Failed to clean up terminal', { terminalId, error }),\n        );\n      }\n\n      // Perform pool maintenance\n      await this.pool.performMaintenance();\n\n      // Emit maintenance event\n      this.eventBus.emit('terminal:maintenance', {\n        deadSessions: deadSessions.length,\n        activeSessions: this.sessions.size,\n        poolStatus: await this.pool.getHealthStatus(),\n      });\n\n      this.logger.debug('Terminal manager maintenance completed');\n    } catch (error) {\n      this.logger.error('Error during terminal manager maintenance', error);\n    }\n  }\n\n  /**\n   * Get all active sessions\n   */\n  getActiveSessions(): AgentSession[] {\n    return Array.from(this.sessions.values()).map((session) => ({\n      id: session.id,\n      agentId: session.profile.id,\n      terminalId: session.terminal.id,\n      startTime: session.startTime,\n      status: session.isHealthy() ? 'active' : 'error',\n      lastActivity: session.lastActivity,\n      memoryBankId: '', // TODO: Link to memory bank\n    }));\n  }\n\n  /**\n   * Get session by ID\n   */\n  getSession(sessionId: string): TerminalSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  /**\n   * Stream terminal output\n   */\n  async streamOutput(terminalId: string, callback: (output: string) => void): Promise<() => void> {\n    const session = this.sessions.get(terminalId);\n    if (!session) {\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\n    }\n\n    return session.streamOutput(callback);\n  }\n\n  private createAdapter(): ITerminalAdapter {\n    switch (this.config.type) {\n      case 'vscode':\n        return new VSCodeAdapter(this.logger);\n      case 'native':\n        return new NativeAdapter(this.logger);\n      case 'auto':\n        // Detect environment and choose appropriate adapter\n        if (this.isVSCodeEnvironment()) {\n          this.logger.info('Detected VSCode environment, using VSCode adapter');\n          return new VSCodeAdapter(this.logger);\n        } else {\n          this.logger.info('Using native terminal adapter');\n          return new NativeAdapter(this.logger);\n        }\n      default:\n        throw new TerminalError(`Unknown terminal type: ${this.config.type}`);\n    }\n  }\n\n  private isVSCodeEnvironment(): boolean {\n    // Check for VSCode-specific environment variables\n    return (\n      process.env.TERM_PROGRAM === 'vscode' ||\n      process.env.VSCODE_PID !== undefined ||\n      process.env.VSCODE_IPC_HOOK !== undefined\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
