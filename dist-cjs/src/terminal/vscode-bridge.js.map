{"version":3,"sources":["../../../src/terminal/vscode-bridge.ts"],"sourcesContent":["import { getErrorMessage } from '../utils/error-handler.js';\r\n/**\r\n * VSCode Extension Bridge for Terminal Integration\r\n *\r\n * This file provides the bridge between Claude-Flow and VSCode extension API\r\n * for terminal management and output capture.\r\n *\r\n * NOTE: This file is only used when Claude-Flow is packaged as a VS Code extension.\r\n * It is excluded from the main CLI build. If you need to use this in a VS Code\r\n * extension context, install @types/vscode as a devDependency.\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\n\r\n/**\r\n * Terminal output processors registry\r\n */\r\nconst terminalOutputProcessors = new Map<string, (data: string) => void>();\r\n\r\n/**\r\n * Active terminals registry\r\n */\r\nconst activeTerminals = new Map<string, vscode.Terminal>();\r\n\r\n/**\r\n * Terminal write emulators for output capture\r\n */\r\nconst terminalWriteEmulators = new Map<vscode.Terminal, vscode.EventEmitter<string>>();\r\n\r\n/**\r\n * Initialize the VSCode terminal bridge\r\n */\r\nexport function initializeTerminalBridge(context: vscode.ExtensionContext): void {\r\n  // Inject VSCode API into global scope for Claude-Flow\r\n  (globalThis as any).vscode = vscode;\r\n\r\n  // Register terminal output processor function\r\n  (globalThis as any).registerTerminalOutputProcessor = (\r\n    terminalId: string,\r\n    processor: (data: string) => void,\r\n  ) => {\r\n    terminalOutputProcessors.set(terminalId, processor);\r\n  };\r\n\r\n  // Override terminal creation to capture output\r\n  const originalCreateTerminal = vscode.window.createTerminal;\r\n  (vscode.window as any).createTerminal = function (options: vscode.TerminalOptions) {\r\n    const terminal = originalCreateTerminal.call(vscode.window, options) as vscode.Terminal;\r\n\r\n    // Create write emulator for this terminal\r\n    const writeEmulator = new vscode.EventEmitter<string>();\r\n    terminalWriteEmulators.set(terminal, writeEmulator);\r\n\r\n    // Find terminal ID from name\r\n    const match = options.name?.match(/Claude-Flow Terminal ([\\w-]+)/);\r\n    if (match) {\r\n      const terminalId = match[1];\r\n      activeTerminals.set(terminalId, terminal);\r\n\r\n      // Set up output capture\r\n      captureTerminalOutput(terminal, terminalId);\r\n    }\r\n\r\n    return terminal;\r\n  };\r\n\r\n  // Clean up on terminal close\r\n  context.subscriptions.push(\r\n    vscode.window.onDidCloseTerminal((terminal: vscode.Terminal) => {\r\n      // Find and remove from registries\r\n      for (const [id, term] of activeTerminals.entries()) {\r\n        if (term === terminal) {\r\n          activeTerminals.delete(id);\r\n          terminalOutputProcessors.delete(id);\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Clean up write emulator\r\n      const emulator = terminalWriteEmulators.get(terminal);\r\n      if (emulator) {\r\n        emulator.dispose();\r\n        terminalWriteEmulators.delete(terminal);\r\n      }\r\n    }),\r\n  );\r\n}\r\n\r\n/**\r\n * Capture terminal output using various methods\r\n */\r\nfunction captureTerminalOutput(terminal: vscode.Terminal, terminalId: string): void {\r\n  // Method 1: Use terminal.sendText override to capture commands\r\n  const originalSendText = terminal.sendText;\r\n  (terminal as any).sendText = function (text: string, addNewLine?: boolean) {\r\n    // Call original method\r\n    originalSendText.call(terminal, text, addNewLine);\r\n\r\n    // Process command\r\n    const processor = terminalOutputProcessors.get(terminalId);\r\n    if (processor && text) {\r\n      // Simulate command echo\r\n      processor(text + (addNewLine !== false ? '\\n' : ''));\r\n    }\r\n  };\r\n\r\n  // Method 2: Use proposed API if available\r\n  if ('onDidWriteData' in terminal) {\r\n    const writeDataEvent = (terminal as any).onDidWriteData;\r\n    if (writeDataEvent) {\r\n      writeDataEvent((data: string) => {\r\n        const processor = terminalOutputProcessors.get(terminalId);\r\n        if (processor) {\r\n          processor(data);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Method 3: Use terminal renderer if available\r\n  setupTerminalRenderer(terminal, terminalId);\r\n}\r\n\r\n/**\r\n * Set up terminal renderer for output capture\r\n */\r\nfunction setupTerminalRenderer(terminal: vscode.Terminal, terminalId: string): void {\r\n  // Check if terminal renderer API is available\r\n  if (vscode.window.registerTerminalProfileProvider) {\r\n    // This is a more advanced method that requires additional setup\r\n    // It would involve creating a custom terminal profile that captures output\r\n\r\n    // For now, we'll use a simpler approach with periodic output checking\r\n    let lastOutput = '';\r\n    const checkOutput = setInterval(() => {\r\n      // This is a placeholder - actual implementation would depend on\r\n      // available VSCode APIs for reading terminal content\r\n\r\n      // Check if terminal is still active\r\n      if (!activeTerminals.has(terminalId)) {\r\n        clearInterval(checkOutput);\r\n      }\r\n    }, 100);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a terminal with output capture\r\n */\r\nexport async function createCapturedTerminal(\r\n  name: string,\r\n  shellPath?: string,\r\n  shellArgs?: string[],\r\n): Promise<{\r\n  terminal: vscode.Terminal;\r\n  onData: vscode.Event<string>;\r\n}> {\r\n  const writeEmulator = new vscode.EventEmitter<string>();\r\n\r\n  const terminal = vscode.window.createTerminal({\r\n    name,\r\n    shellPath,\r\n    shellArgs,\r\n  });\r\n\r\n  terminalWriteEmulators.set(terminal, writeEmulator);\r\n\r\n  return {\r\n    terminal,\r\n    onData: writeEmulator.event,\r\n  };\r\n}\r\n\r\n/**\r\n * Send command to terminal and capture output\r\n */\r\nexport async function executeTerminalCommand(\r\n  terminal: vscode.Terminal,\r\n  command: string,\r\n  timeout: number = 30000,\r\n): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const writeEmulator = terminalWriteEmulators.get(terminal);\r\n    if (!writeEmulator) {\r\n      reject(new Error('No write emulator for terminal'));\r\n      return;\r\n    }\r\n\r\n    let output = '';\r\n    const marker = `__COMMAND_COMPLETE_${Date.now()}__`;\r\n\r\n    // Set up output listener\r\n    const disposable = writeEmulator.event((data: string) => {\r\n      output += data;\r\n\r\n      if (output.includes(marker)) {\r\n        // Command completed\r\n        disposable.dispose();\r\n        const result = output.substring(0, output.indexOf(marker));\r\n        resolve(result);\r\n      }\r\n    });\r\n\r\n    // Set timeout\r\n    const timer = setTimeout(() => {\r\n      disposable.dispose();\r\n      reject(new Error('Command timeout'));\r\n    }, timeout);\r\n\r\n    // Execute command with marker\r\n    terminal.sendText(`${command} && echo \"${marker}\"`);\r\n\r\n    // Clear timeout on success\r\n    writeEmulator.event(() => {\r\n      if (output.includes(marker)) {\r\n        clearTimeout(timer);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Get terminal by ID\r\n */\r\nexport function getTerminalById(terminalId: string): vscode.Terminal | undefined {\r\n  return activeTerminals.get(terminalId);\r\n}\r\n\r\n/**\r\n * Dispose all terminal resources\r\n */\r\nexport function disposeTerminalBridge(): void {\r\n  // Clean up all terminals\r\n  for (const terminal of activeTerminals.values()) {\r\n    terminal.dispose();\r\n  }\r\n  activeTerminals.clear();\r\n\r\n  // Clean up processors\r\n  terminalOutputProcessors.clear();\r\n\r\n  // Clean up write emulators\r\n  for (const emulator of terminalWriteEmulators.values()) {\r\n    emulator.dispose();\r\n  }\r\n  terminalWriteEmulators.clear();\r\n}\r\n"],"names":["vscode","terminalOutputProcessors","Map","activeTerminals","terminalWriteEmulators","initializeTerminalBridge","context","globalThis","registerTerminalOutputProcessor","terminalId","processor","set","originalCreateTerminal","window","createTerminal","options","terminal","call","writeEmulator","EventEmitter","match","name","captureTerminalOutput","subscriptions","push","onDidCloseTerminal","id","term","entries","delete","emulator","get","dispose","originalSendText","sendText","text","addNewLine","writeDataEvent","onDidWriteData","data","setupTerminalRenderer","registerTerminalProfileProvider","lastOutput","checkOutput","setInterval","has","clearInterval","createCapturedTerminal","shellPath","shellArgs","onData","event","executeTerminalCommand","command","timeout","Promise","resolve","reject","Error","output","marker","Date","now","disposable","includes","result","substring","indexOf","timer","setTimeout","clearTimeout","getTerminalById","disposeTerminalBridge","values","clear"],"mappings":"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"}