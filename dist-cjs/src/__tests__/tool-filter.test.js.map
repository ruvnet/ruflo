{"version":3,"sources":["../../../src/__tests__/tool-filter.test.ts"],"sourcesContent":["/**\n * Tool Filter Tests\n *\n * Comprehensive test suite for MCP tool filtering system.\n * Supports allowlist, denylist, category filtering, and priority-based limiting.\n */\n\nimport { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';\nimport type { MCPTool, MCPContext } from '../utils/types.js';\nimport { join } from 'node:path';\n\n// ===== Type Definitions for Tool Filter =====\n\n/**\n * Tool category definitions for semantic grouping\n */\nexport type ToolCategory =\n  | 'system'\n  | 'swarm'\n  | 'memory'\n  | 'neural'\n  | 'github'\n  | 'workflow'\n  | 'analysis'\n  | 'coordination'\n  | 'other';\n\n/**\n * Configuration for MCP tool filtering\n */\nexport interface MCPToolFilterConfig {\n  /** Whether filtering is enabled */\n  enabled: boolean;\n\n  /** Filter mode: allowlist includes only listed, denylist excludes listed */\n  mode: 'allowlist' | 'denylist';\n\n  /** Tool name patterns to match (supports glob-like patterns) */\n  patterns: string[];\n\n  /** Categories to include/exclude based on mode */\n  categories?: ToolCategory[];\n\n  /** Maximum number of tools to expose */\n  maxTools?: number;\n\n  /** Priority ordering for tools when limiting (higher = more important) */\n  toolPriorities?: Record<string, number>;\n\n  /** Enable statistics tracking */\n  trackStats?: boolean;\n}\n\n/**\n * Statistics about filter operations\n */\nexport interface FilterStats {\n  totalTools: number;\n  filteredTools: number;\n  matchedPatterns: string[];\n  filterTime: number;\n  lastFiltered: Date;\n}\n\n/**\n * Result of a filter operation\n */\nexport interface FilterResult {\n  tools: MCPTool[];\n  stats: FilterStats;\n}\n\n// ===== Tool Filter Implementation (Mock for Testing) =====\n\n/**\n * Tool Filter class for filtering MCP tools based on configuration\n */\nexport class ToolFilter {\n  private config: MCPToolFilterConfig;\n  private lastStats?: FilterStats;\n  private categoryMap: Map<string, ToolCategory> = new Map();\n\n  constructor(config: MCPToolFilterConfig) {\n    this.config = config;\n    this.initializeCategoryMap();\n  }\n\n  /**\n   * Initialize category mapping based on tool name prefixes\n   */\n  private initializeCategoryMap(): void {\n    // Category detection patterns\n    const categoryPatterns: Record<string, ToolCategory> = {\n      'swarm_': 'swarm',\n      'agent_': 'swarm',\n      'memory_': 'memory',\n      'neural_': 'neural',\n      'github_': 'github',\n      'workflow_': 'workflow',\n      'task_': 'coordination',\n      'daa_': 'coordination',\n      'benchmark_': 'analysis',\n      'features_': 'system',\n      'system_': 'system',\n    };\n\n    this.categoryMap = new Map(Object.entries(categoryPatterns));\n  }\n\n  /**\n   * Get the category for a tool based on its name\n   */\n  getToolCategory(toolName: string): ToolCategory {\n    for (const [prefix, category] of this.categoryMap.entries()) {\n      if (toolName.startsWith(prefix)) {\n        return category;\n      }\n    }\n    return 'other';\n  }\n\n  /**\n   * Check if a tool name matches a pattern\n   * Supports glob-like patterns: * (any), ? (single char)\n   */\n  matchPattern(toolName: string, pattern: string): boolean {\n    // Exact match\n    if (pattern === toolName) {\n      return true;\n    }\n\n    // Wildcard match\n    if (pattern === '*') {\n      return true;\n    }\n\n    // Convert glob pattern to regex\n    const regexPattern = pattern\n      .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape special regex chars\n      .replace(/\\*/g, '.*')  // * matches any characters\n      .replace(/\\?/g, '.');  // ? matches single character\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(toolName);\n  }\n\n  /**\n   * Filter tools based on configuration\n   */\n  filter(tools: MCPTool[]): FilterResult {\n    const startTime = performance.now();\n\n    // If filtering is disabled, return all tools\n    if (!this.config.enabled) {\n      const stats: FilterStats = {\n        totalTools: tools.length,\n        filteredTools: tools.length,\n        matchedPatterns: [],\n        filterTime: performance.now() - startTime,\n        lastFiltered: new Date(),\n      };\n      this.lastStats = stats;\n      return { tools, stats };\n    }\n\n    const matchedPatterns: string[] = [];\n    let filteredTools: MCPTool[];\n\n    if (this.config.mode === 'allowlist') {\n      // Allowlist mode: only include tools matching patterns\n      filteredTools = tools.filter(tool => {\n        const matches = this.config.patterns.some(pattern => {\n          const isMatch = this.matchPattern(tool.name, pattern);\n          if (isMatch && !matchedPatterns.includes(pattern)) {\n            matchedPatterns.push(pattern);\n          }\n          return isMatch;\n        });\n\n        // Also check category filter if specified\n        if (matches && this.config.categories && this.config.categories.length > 0) {\n          const category = this.getToolCategory(tool.name);\n          return this.config.categories.includes(category);\n        }\n\n        return matches;\n      });\n    } else {\n      // Denylist mode: exclude tools matching patterns\n      filteredTools = tools.filter(tool => {\n        const shouldExclude = this.config.patterns.some(pattern => {\n          const isMatch = this.matchPattern(tool.name, pattern);\n          if (isMatch && !matchedPatterns.includes(pattern)) {\n            matchedPatterns.push(pattern);\n          }\n          return isMatch;\n        });\n\n        // Also check category filter if specified (exclude matching categories)\n        if (!shouldExclude && this.config.categories && this.config.categories.length > 0) {\n          const category = this.getToolCategory(tool.name);\n          return !this.config.categories.includes(category);\n        }\n\n        return !shouldExclude;\n      });\n    }\n\n    // Apply maxTools limit with priority ordering\n    if (this.config.maxTools && filteredTools.length > this.config.maxTools) {\n      const priorities = this.config.toolPriorities || {};\n\n      // Sort by priority (higher first), then by name for stable ordering\n      filteredTools.sort((a, b) => {\n        const priorityA = priorities[a.name] ?? 0;\n        const priorityB = priorities[b.name] ?? 0;\n        if (priorityA !== priorityB) {\n          return priorityB - priorityA; // Higher priority first\n        }\n        return a.name.localeCompare(b.name);\n      });\n\n      filteredTools = filteredTools.slice(0, this.config.maxTools);\n    }\n\n    const stats: FilterStats = {\n      totalTools: tools.length,\n      filteredTools: filteredTools.length,\n      matchedPatterns,\n      filterTime: performance.now() - startTime,\n      lastFiltered: new Date(),\n    };\n\n    this.lastStats = stats;\n    return { tools: filteredTools, stats };\n  }\n\n  /**\n   * Get the last filter statistics\n   */\n  getStats(): FilterStats | undefined {\n    return this.lastStats;\n  }\n\n  /**\n   * Update filter configuration\n   */\n  updateConfig(config: Partial<MCPToolFilterConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Get current configuration (deep copy to prevent mutation)\n   */\n  getConfig(): MCPToolFilterConfig {\n    return {\n      ...this.config,\n      patterns: [...this.config.patterns],\n      categories: this.config.categories ? [...this.config.categories] : undefined,\n      toolPriorities: this.config.toolPriorities\n        ? { ...this.config.toolPriorities }\n        : undefined,\n    };\n  }\n}\n\n/**\n * Factory function to create a ToolFilter instance\n */\nexport function createToolFilter(config: MCPToolFilterConfig): ToolFilter {\n  return new ToolFilter(config);\n}\n\n// ===== Test Helpers =====\n\n/**\n * Create a mock MCP tool with the given name\n */\nfunction createMockTool(name: string, description?: string): MCPTool {\n  return {\n    name,\n    description: description ?? `Description for ${name}`,\n    inputSchema: { type: 'object', properties: {} },\n    handler: async () => ({}),\n  };\n}\n\n/**\n * Create a set of mock tools for testing\n */\nfunction createMockToolSet(): MCPTool[] {\n  return [\n    createMockTool('swarm_init'),\n    createMockTool('swarm_status'),\n    createMockTool('swarm_monitor'),\n    createMockTool('agent_spawn'),\n    createMockTool('agent_list'),\n    createMockTool('agent_metrics'),\n    createMockTool('memory_usage'),\n    createMockTool('memory_search'),\n    createMockTool('memory_persist'),\n    createMockTool('neural_status'),\n    createMockTool('neural_train'),\n    createMockTool('neural_patterns'),\n    createMockTool('github_repo_analyze'),\n    createMockTool('github_pr_manage'),\n    createMockTool('workflow_create'),\n    createMockTool('workflow_execute'),\n    createMockTool('task_orchestrate'),\n    createMockTool('task_status'),\n    createMockTool('daa_agent_create'),\n    createMockTool('benchmark_run'),\n    createMockTool('features_detect'),\n    createMockTool('system_health'),\n  ];\n}\n\n// ===== Tests =====\n\ndescribe('ToolFilter', () => {\n  let mockTools: MCPTool[];\n\n  beforeEach(() => {\n    mockTools = createMockToolSet();\n  });\n\n  afterEach(() => {\n    // Clear any mock state if needed\n  });\n\n  describe('No Filtering (Disabled)', () => {\n    it('should return all tools when filtering is disabled', () => {\n      const filter = createToolFilter({\n        enabled: false,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(mockTools.length);\n      expect(result.tools).toEqual(mockTools);\n      expect(result.stats.totalTools).toBe(mockTools.length);\n      expect(result.stats.filteredTools).toBe(mockTools.length);\n    });\n\n    it('should track timing even when disabled', () => {\n      const filter = createToolFilter({\n        enabled: false,\n        mode: 'allowlist',\n        patterns: [],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.filterTime).toBeGreaterThanOrEqual(0);\n      expect(result.stats.lastFiltered).toBeInstanceOf(Date);\n    });\n  });\n\n  describe('Allowlist Mode - Exact Matching', () => {\n    it('should include only exactly matched tools', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_init', 'swarm_status'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(2);\n      expect(result.tools.map(t => t.name)).toEqual(['swarm_init', 'swarm_status']);\n    });\n\n    it('should return empty array when no tools match', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['nonexistent_tool'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(0);\n      expect(result.stats.filteredTools).toBe(0);\n    });\n  });\n\n  describe('Allowlist Mode - Glob Pattern Matching', () => {\n    it('should match tools using wildcard pattern', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t => t.name.startsWith('swarm_'))).toBe(true);\n      expect(result.tools.map(t => t.name)).toEqual([\n        'swarm_init',\n        'swarm_status',\n        'swarm_monitor',\n      ]);\n    });\n\n    it('should match tools using multiple wildcard patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*', 'agent_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(6);\n      expect(result.tools.every(t =>\n        t.name.startsWith('swarm_') || t.name.startsWith('agent_')\n      )).toBe(true);\n    });\n\n    it('should match all tools with global wildcard', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(mockTools.length);\n    });\n\n    it('should handle complex patterns with prefix and suffix', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*_status'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t => t.name.endsWith('_status'))).toBe(true);\n      expect(result.tools.map(t => t.name)).toEqual([\n        'swarm_status',\n        'neural_status',\n        'task_status',\n      ]);\n    });\n\n    it('should match middle wildcard patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*_*_*'],  // Tools with at least 2 underscores\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t =>\n        t.name.split('_').length >= 3\n      )).toBe(true);\n    });\n  });\n\n  describe('Denylist Mode', () => {\n    it('should exclude exactly matched tools', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['swarm_init', 'swarm_status'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.some(t => t.name === 'swarm_init')).toBe(false);\n      expect(result.tools.some(t => t.name === 'swarm_status')).toBe(false);\n      expect(result.tools).toHaveLength(mockTools.length - 2);\n    });\n\n    it('should exclude tools matching wildcard patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['swarm_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t => !t.name.startsWith('swarm_'))).toBe(true);\n      expect(result.tools).toHaveLength(mockTools.length - 3);\n    });\n\n    it('should exclude all tools with global wildcard', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(0);\n    });\n\n    it('should exclude multiple pattern groups', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['swarm_*', 'agent_*', 'neural_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t =>\n        !t.name.startsWith('swarm_') &&\n        !t.name.startsWith('agent_') &&\n        !t.name.startsWith('neural_')\n      )).toBe(true);\n      // Original has 3 swarm, 3 agent, 3 neural = 9 tools to exclude\n      expect(result.tools).toHaveLength(mockTools.length - 9);\n    });\n  });\n\n  describe('Category Filtering', () => {\n    it('should filter by category in allowlist mode', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        categories: ['swarm'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // swarm_* and agent_* both map to 'swarm' category\n      expect(result.tools.every(t =>\n        t.name.startsWith('swarm_') || t.name.startsWith('agent_')\n      )).toBe(true);\n    });\n\n    it('should filter by multiple categories', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        categories: ['swarm', 'memory'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Should include swarm, agent (swarm category) and memory tools\n      const toolNames = result.tools.map(t => t.name);\n      expect(toolNames.some(n => n.startsWith('swarm_'))).toBe(true);\n      expect(toolNames.some(n => n.startsWith('agent_'))).toBe(true);\n      expect(toolNames.some(n => n.startsWith('memory_'))).toBe(true);\n    });\n\n    it('should exclude categories in denylist mode', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: [],  // No pattern exclusions\n        categories: ['neural', 'github'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t =>\n        !t.name.startsWith('neural_') && !t.name.startsWith('github_')\n      )).toBe(true);\n    });\n\n    it('should correctly detect tool categories', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n      });\n\n      expect(filter.getToolCategory('swarm_init')).toBe('swarm');\n      expect(filter.getToolCategory('agent_spawn')).toBe('swarm');\n      expect(filter.getToolCategory('memory_usage')).toBe('memory');\n      expect(filter.getToolCategory('neural_train')).toBe('neural');\n      expect(filter.getToolCategory('github_pr_manage')).toBe('github');\n      expect(filter.getToolCategory('workflow_create')).toBe('workflow');\n      expect(filter.getToolCategory('task_orchestrate')).toBe('coordination');\n      expect(filter.getToolCategory('daa_agent_create')).toBe('coordination');\n      expect(filter.getToolCategory('benchmark_run')).toBe('analysis');\n      expect(filter.getToolCategory('features_detect')).toBe('system');\n      expect(filter.getToolCategory('unknown_tool')).toBe('other');\n    });\n  });\n\n  describe('maxTools Limit', () => {\n    it('should limit the number of tools returned', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 5,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(5);\n    });\n\n    it('should not affect result when under limit', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n        maxTools: 10,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(3); // Only 3 swarm tools\n    });\n\n    it('should maintain stable ordering when limiting', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 5,\n      });\n\n      const result1 = filter.filter(mockTools);\n      const result2 = filter.filter(mockTools);\n\n      expect(result1.tools.map(t => t.name)).toEqual(result2.tools.map(t => t.name));\n    });\n  });\n\n  describe('Priority Ordering', () => {\n    it('should order tools by priority when limiting', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 3,\n        toolPriorities: {\n          'neural_train': 100,\n          'swarm_init': 50,\n          'memory_usage': 75,\n        },\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Should include highest priority tools\n      const names = result.tools.map(t => t.name);\n      expect(names).toContain('neural_train');\n      expect(names).toContain('memory_usage');\n      expect(names).toContain('swarm_init');\n    });\n\n    it('should use name ordering for tools without explicit priority', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 5,\n        toolPriorities: {\n          'neural_train': 100, // Only this has priority\n        },\n      });\n\n      const result = filter.filter(mockTools);\n\n      // neural_train should be first due to high priority\n      expect(result.tools[0].name).toBe('neural_train');\n    });\n\n    it('should handle equal priorities by name', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*', 'agent_*'],\n        maxTools: 4,\n        toolPriorities: {\n          'swarm_init': 50,\n          'swarm_status': 50,\n          'agent_spawn': 50,\n          'agent_list': 50,\n        },\n      });\n\n      const result = filter.filter(mockTools);\n\n      // With equal priorities, should be alphabetically sorted\n      const names = result.tools.map(t => t.name);\n      const sortedNames = [...names].sort();\n      expect(names).toEqual(sortedNames);\n    });\n  });\n\n  describe('Filter Statistics Tracking', () => {\n    it('should track total and filtered tool counts', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n        trackStats: true,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.totalTools).toBe(mockTools.length);\n      expect(result.stats.filteredTools).toBe(3);\n    });\n\n    it('should track matched patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*', 'agent_*', 'nonexistent_*'],\n        trackStats: true,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.matchedPatterns).toContain('swarm_*');\n      expect(result.stats.matchedPatterns).toContain('agent_*');\n      expect(result.stats.matchedPatterns).not.toContain('nonexistent_*');\n    });\n\n    it('should record filter execution time', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        trackStats: true,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.filterTime).toBeGreaterThanOrEqual(0);\n      expect(result.stats.filterTime).toBeLessThan(100); // Should be fast\n    });\n\n    it('should record timestamp of filter operation', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        trackStats: true,\n      });\n\n      const before = new Date();\n      const result = filter.filter(mockTools);\n      const after = new Date();\n\n      expect(result.stats.lastFiltered.getTime()).toBeGreaterThanOrEqual(before.getTime());\n      expect(result.stats.lastFiltered.getTime()).toBeLessThanOrEqual(after.getTime());\n    });\n\n    it('should provide stats via getStats()', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n        trackStats: true,\n      });\n\n      // Before filtering, no stats\n      expect(filter.getStats()).toBeUndefined();\n\n      filter.filter(mockTools);\n\n      const stats = filter.getStats();\n      expect(stats).toBeDefined();\n      expect(stats?.filteredTools).toBe(3);\n    });\n  });\n\n  describe('Empty Tool List Handling', () => {\n    it('should handle empty input gracefully', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n      });\n\n      const result = filter.filter([]);\n\n      expect(result.tools).toHaveLength(0);\n      expect(result.stats.totalTools).toBe(0);\n      expect(result.stats.filteredTools).toBe(0);\n    });\n\n    it('should handle empty patterns array', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: [],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Empty patterns in allowlist mode = nothing matches\n      expect(result.tools).toHaveLength(0);\n    });\n\n    it('should handle empty patterns in denylist mode', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: [],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Empty patterns in denylist mode = nothing excluded\n      expect(result.tools).toHaveLength(mockTools.length);\n    });\n  });\n\n  describe('Configuration Management', () => {\n    it('should update configuration dynamically', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result1 = filter.filter(mockTools);\n      expect(result1.tools).toHaveLength(3);\n\n      filter.updateConfig({\n        patterns: ['agent_*'],\n      });\n\n      const result2 = filter.filter(mockTools);\n      expect(result2.tools).toHaveLength(3);\n      expect(result2.tools.every(t => t.name.startsWith('agent_'))).toBe(true);\n    });\n\n    it('should toggle enabled state', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result1 = filter.filter(mockTools);\n      expect(result1.tools).toHaveLength(3);\n\n      filter.updateConfig({ enabled: false });\n\n      const result2 = filter.filter(mockTools);\n      expect(result2.tools).toHaveLength(mockTools.length);\n    });\n\n    it('should switch modes', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result1 = filter.filter(mockTools);\n      expect(result1.tools).toHaveLength(3);\n\n      filter.updateConfig({ mode: 'denylist' });\n\n      const result2 = filter.filter(mockTools);\n      expect(result2.tools).toHaveLength(mockTools.length - 3);\n    });\n\n    it('should return current config via getConfig()', () => {\n      const originalConfig: MCPToolFilterConfig = {\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['test_*'],\n        categories: ['swarm'],\n        maxTools: 10,\n      };\n\n      const filter = createToolFilter(originalConfig);\n      const config = filter.getConfig();\n\n      expect(config.enabled).toBe(true);\n      expect(config.mode).toBe('allowlist');\n      expect(config.patterns).toEqual(['test_*']);\n      expect(config.categories).toEqual(['swarm']);\n      expect(config.maxTools).toBe(10);\n    });\n\n    it('should not mutate internal config when returning', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const config = filter.getConfig();\n      config.patterns.push('hacked_*');\n\n      // Internal config should be unchanged\n      const config2 = filter.getConfig();\n      expect(config2.patterns).toEqual(['swarm_*']);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle special characters in tool names', () => {\n      const specialTools = [\n        createMockTool('tool-with-dashes'),\n        createMockTool('tool.with.dots'),\n        createMockTool('tool_with_underscores'),\n        createMockTool('Tool123WithNumbers'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool*'],\n      });\n\n      const result = filter.filter(specialTools);\n\n      expect(result.tools).toHaveLength(3); // Matches tool- tool. tool_\n    });\n\n    it('should handle very long tool names', () => {\n      const longName = 'a'.repeat(1000);\n      const longTools = [createMockTool(longName)];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['a*'],\n      });\n\n      const result = filter.filter(longTools);\n\n      expect(result.tools).toHaveLength(1);\n    });\n\n    it('should handle many patterns efficiently', () => {\n      const patterns = Array.from({ length: 100 }, (_, i) => `pattern_${i}_*`);\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns,\n      });\n\n      const start = performance.now();\n      const result = filter.filter(mockTools);\n      const elapsed = performance.now() - start;\n\n      expect(elapsed).toBeLessThan(50); // Should complete quickly\n      expect(result.tools).toHaveLength(0); // None match\n    });\n\n    it('should handle many tools efficiently', () => {\n      const manyTools = Array.from({ length: 1000 }, (_, i) =>\n        createMockTool(`tool_${i}`)\n      );\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool_*'],\n      });\n\n      const start = performance.now();\n      const result = filter.filter(manyTools);\n      const elapsed = performance.now() - start;\n\n      expect(elapsed).toBeLessThan(100); // Should complete quickly\n      expect(result.tools).toHaveLength(1000);\n    });\n  });\n\n  describe('Pattern Edge Cases', () => {\n    it('should handle single character wildcard', () => {\n      const tools = [\n        createMockTool('tool_a'),\n        createMockTool('tool_b'),\n        createMockTool('tool_ab'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool_?'],\n      });\n\n      const result = filter.filter(tools);\n\n      expect(result.tools.map(t => t.name)).toEqual(['tool_a', 'tool_b']);\n    });\n\n    it('should handle mixed wildcards', () => {\n      const tools = [\n        createMockTool('a1x'),\n        createMockTool('a2y'),\n        createMockTool('a12x'),\n        createMockTool('b1x'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['a?*'],\n      });\n\n      const result = filter.filter(tools);\n\n      expect(result.tools.map(t => t.name)).toEqual(['a1x', 'a2y', 'a12x']);\n    });\n\n    it('should handle escaped regex special characters', () => {\n      const tools = [\n        createMockTool('tool.name'),\n        createMockTool('tool_name'),\n        createMockTool('toolXname'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool.name'],  // Should match literal dot\n      });\n\n      const result = filter.filter(tools);\n\n      expect(result.tools).toHaveLength(1);\n      expect(result.tools[0].name).toBe('tool.name');\n    });\n  });\n});\n\ndescribe('createToolFilter Factory', () => {\n  it('should create a ToolFilter instance', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n    });\n\n    expect(filter).toBeInstanceOf(ToolFilter);\n  });\n\n  it('should create independent instances', () => {\n    const filter1 = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['swarm_*'],\n    });\n\n    const filter2 = createToolFilter({\n      enabled: true,\n      mode: 'denylist',\n      patterns: ['agent_*'],\n    });\n\n    expect(filter1.getConfig().mode).toBe('allowlist');\n    expect(filter2.getConfig().mode).toBe('denylist');\n  });\n});\n\n// ===== Config File Precedence Tests =====\n\ndescribe('Config File Precedence', () => {\n  const originalEnv = process.env;\n\n  beforeEach(() => {\n    jest.resetModules();\n    process.env = { ...originalEnv };\n  });\n\n  afterEach(() => {\n    process.env = originalEnv;\n  });\n\n  /**\n   * Mock configuration loader that simulates file system behavior\n   * This is a simplified version for testing precedence logic\n   */\n  interface MockFileSystem {\n    files: Record<string, string>;\n  }\n\n  function createMockConfigLoader(mockFs: MockFileSystem) {\n    const configPaths = [\n      '.claude-flow/mcp-tools.json',\n      '.claude-flow/mcp-tools.yaml',\n      'mcp-tools.json',\n    ];\n\n    return async function loadConfig(cwd: string): Promise<{ config: MCPToolFilterConfig; source: string } | null> {\n      for (const configPath of configPaths) {\n        const fullPath = join(cwd, configPath);\n        if (mockFs.files[fullPath]) {\n          const content = mockFs.files[fullPath];\n          const parsed = JSON.parse(content);\n          return {\n            config: {\n              enabled: parsed.enabled ?? false,\n              mode: parsed.mode ?? 'allowlist',\n              patterns: parsed.patterns ?? [],\n              categories: parsed.categories,\n              maxTools: parsed.maxTools,\n              toolPriorities: parsed.toolPriorities,\n            },\n            source: configPath,\n          };\n        }\n      }\n      return null;\n    };\n  }\n\n  it('should return first file found when multiple config files exist', async () => {\n    const mockFs: MockFileSystem = {\n      files: {\n        '/project/.claude-flow/mcp-tools.json': JSON.stringify({\n          enabled: true,\n          mode: 'allowlist',\n          patterns: ['first_*'],\n        }),\n        '/project/mcp-tools.json': JSON.stringify({\n          enabled: true,\n          mode: 'denylist',\n          patterns: ['second_*'],\n        }),\n      },\n    };\n\n    const loadConfig = createMockConfigLoader(mockFs);\n    const result = await loadConfig('/project');\n\n    expect(result).not.toBeNull();\n    expect(result?.source).toBe('.claude-flow/mcp-tools.json');\n    expect(result?.config.patterns).toEqual(['first_*']);\n    expect(result?.config.mode).toBe('allowlist');\n  });\n\n  it('should prefer JSON over YAML at same directory level (.claude-flow)', async () => {\n    // JSON is checked before YAML in the config paths array\n    const mockFs: MockFileSystem = {\n      files: {\n        '/project/.claude-flow/mcp-tools.json': JSON.stringify({\n          enabled: true,\n          mode: 'allowlist',\n          patterns: ['json_*'],\n        }),\n        // YAML would be at: '/project/.claude-flow/mcp-tools.yaml'\n        // but JSON comes first in precedence\n      },\n    };\n\n    const loadConfig = createMockConfigLoader(mockFs);\n    const result = await loadConfig('/project');\n\n    expect(result).not.toBeNull();\n    expect(result?.source).toBe('.claude-flow/mcp-tools.json');\n    expect(result?.config.patterns).toEqual(['json_*']);\n  });\n\n  it('should check .claude-flow/mcp-tools.json before mcp-tools.json at root', async () => {\n    const mockFs: MockFileSystem = {\n      files: {\n        '/project/.claude-flow/mcp-tools.json': JSON.stringify({\n          enabled: true,\n          mode: 'allowlist',\n          patterns: ['subdir_config_*'],\n        }),\n        '/project/mcp-tools.json': JSON.stringify({\n          enabled: true,\n          mode: 'denylist',\n          patterns: ['root_config_*'],\n        }),\n      },\n    };\n\n    const loadConfig = createMockConfigLoader(mockFs);\n    const result = await loadConfig('/project');\n\n    expect(result).not.toBeNull();\n    expect(result?.source).toBe('.claude-flow/mcp-tools.json');\n    expect(result?.config.patterns).toEqual(['subdir_config_*']);\n  });\n\n  it('should fall back to root mcp-tools.json when .claude-flow config is missing', async () => {\n    const mockFs: MockFileSystem = {\n      files: {\n        '/project/mcp-tools.json': JSON.stringify({\n          enabled: true,\n          mode: 'denylist',\n          patterns: ['fallback_*'],\n        }),\n      },\n    };\n\n    const loadConfig = createMockConfigLoader(mockFs);\n    const result = await loadConfig('/project');\n\n    expect(result).not.toBeNull();\n    expect(result?.source).toBe('mcp-tools.json');\n    expect(result?.config.patterns).toEqual(['fallback_*']);\n  });\n\n  it('should allow environment variables to override file config values', () => {\n    // Simulate file config\n    const fileConfig: MCPToolFilterConfig = {\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['file_pattern_*'],\n      maxTools: 10,\n    };\n\n    // Set environment overrides\n    process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_ENABLED = 'false';\n    process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_MODE = 'denylist';\n    process.env.CLAUDE_FLOW_MCP_TOOLS_ALLOWED = 'env_tool_1,env_tool_2';\n    process.env.CLAUDE_FLOW_MCP_MAX_TOOLS = '25';\n\n    // Simulate environment override logic\n    const enabledEnv = process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_ENABLED;\n    const hasExplicitEnabled = enabledEnv === 'true' || enabledEnv === 'false';\n    const enabled = enabledEnv === 'true';\n\n    const modeEnv = process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_MODE;\n    const hasExplicitMode = modeEnv === 'allowlist' || modeEnv === 'denylist';\n    const mode = hasExplicitMode ? (modeEnv as 'allowlist' | 'denylist') : fileConfig.mode;\n\n    const toolsEnv = process.env.CLAUDE_FLOW_MCP_TOOLS_ALLOWED || '';\n    const envTools = toolsEnv\n      ? toolsEnv.split(',').map(t => t.trim()).filter(t => t.length > 0)\n      : [];\n\n    const maxToolsEnv = process.env.CLAUDE_FLOW_MCP_MAX_TOOLS;\n    const envMaxTools = maxToolsEnv ? parseInt(maxToolsEnv, 10) : undefined;\n\n    // Apply overrides\n    const mergedConfig: MCPToolFilterConfig = {\n      ...fileConfig,\n      enabled: hasExplicitEnabled ? enabled : fileConfig.enabled,\n      mode: hasExplicitMode ? mode : fileConfig.mode,\n      patterns: envTools.length > 0 ? envTools : fileConfig.patterns,\n      maxTools: envMaxTools !== undefined && !isNaN(envMaxTools) ? envMaxTools : fileConfig.maxTools,\n    };\n\n    expect(mergedConfig.enabled).toBe(false); // env override\n    expect(mergedConfig.mode).toBe('denylist'); // env override\n    expect(mergedConfig.patterns).toEqual(['env_tool_1', 'env_tool_2']); // env override\n    expect(mergedConfig.maxTools).toBe(25); // env override\n  });\n\n  it('should return null when no config files exist', async () => {\n    const mockFs: MockFileSystem = {\n      files: {},\n    };\n\n    const loadConfig = createMockConfigLoader(mockFs);\n    const result = await loadConfig('/project');\n\n    expect(result).toBeNull();\n  });\n});\n\n// ===== Priority Ordering Edge Cases =====\n\ndescribe('Priority Ordering Edge Cases', () => {\n  let mockTools: MCPTool[];\n\n  beforeEach(() => {\n    mockTools = [\n      createMockTool('tool_a'),\n      createMockTool('tool_b'),\n      createMockTool('tool_c'),\n      createMockTool('tool_d'),\n      createMockTool('tool_e'),\n    ];\n  });\n\n  it('should use alphabetical ordering as tiebreaker when tools have same priority', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 5,\n      toolPriorities: {\n        'tool_a': 50,\n        'tool_b': 50,\n        'tool_c': 50,\n        'tool_d': 50,\n        'tool_e': 50,\n      },\n    });\n\n    const result = filter.filter(mockTools);\n    const names = result.tools.map(t => t.name);\n\n    // All have same priority, should be alphabetically sorted\n    expect(names).toEqual(['tool_a', 'tool_b', 'tool_c', 'tool_d', 'tool_e']);\n  });\n\n  it('should ensure stable sorting with same priority (multiple runs produce same order)', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 3,\n      toolPriorities: {\n        'tool_a': 100,\n        'tool_b': 100,\n        'tool_c': 100,\n        'tool_d': 50,\n        'tool_e': 50,\n      },\n    });\n\n    // Run multiple times to verify stability\n    const results: string[][] = [];\n    for (let i = 0; i < 5; i++) {\n      const result = filter.filter(mockTools);\n      results.push(result.tools.map(t => t.name));\n    }\n\n    // All results should be identical\n    const firstResult = results[0];\n    for (const result of results) {\n      expect(result).toEqual(firstResult);\n    }\n\n    // Should have the 3 highest priority tools, alphabetically ordered among equals\n    expect(firstResult).toEqual(['tool_a', 'tool_b', 'tool_c']);\n  });\n\n  it('should always rank tools with explicit priority above those with default priority', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 3,\n      toolPriorities: {\n        'tool_c': 1,  // Even low explicit priority\n        'tool_e': 1,  // should matter\n        // tool_a, tool_b, tool_d have no explicit priority (default to 0)\n      },\n    });\n\n    const result = filter.filter(mockTools);\n    const names = result.tools.map(t => t.name);\n\n    // Tools with explicit priority (even priority 1) should come before those with default (0)\n    expect(names).toContain('tool_c');\n    expect(names).toContain('tool_e');\n  });\n\n  it('should handle negative priority values correctly', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 3,\n      toolPriorities: {\n        'tool_a': 100,\n        'tool_b': 50,\n        'tool_c': 0,\n        'tool_d': -50,\n        'tool_e': -100,\n      },\n    });\n\n    const result = filter.filter(mockTools);\n    const names = result.tools.map(t => t.name);\n\n    // Higher priority should come first (100 > 50 > 0)\n    expect(names[0]).toBe('tool_a');\n    expect(names[1]).toBe('tool_b');\n    expect(names[2]).toBe('tool_c');\n\n    // Negative priorities should be excluded when maxTools limits\n    expect(names).not.toContain('tool_d');\n    expect(names).not.toContain('tool_e');\n  });\n\n  it('should handle zero priority correctly', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 3,\n      toolPriorities: {\n        'tool_a': 0,\n        'tool_b': 0,\n        'tool_c': 0,\n        'tool_d': 1,  // Slightly higher\n        'tool_e': -1, // Slightly lower\n      },\n    });\n\n    const result = filter.filter(mockTools);\n    const names = result.tools.map(t => t.name);\n\n    // tool_d (priority 1) should be first\n    expect(names[0]).toBe('tool_d');\n\n    // Then zero-priority tools alphabetically (a, b, c)\n    // maxTools is 3, so we get: tool_d, tool_a, tool_b\n    expect(names).toHaveLength(3);\n    expect(names.includes('tool_d')).toBe(true);\n    // Zero priority tools should follow\n    expect(names.filter(n => ['tool_a', 'tool_b', 'tool_c'].includes(n))).toHaveLength(2);\n  });\n\n  it('should handle very large priority values correctly', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 3,\n      toolPriorities: {\n        'tool_a': Number.MAX_SAFE_INTEGER,\n        'tool_b': 1e15,\n        'tool_c': 1e10,\n        'tool_d': 1e5,\n        'tool_e': 1,\n      },\n    });\n\n    const result = filter.filter(mockTools);\n    const names = result.tools.map(t => t.name);\n\n    // Should respect the ordering of very large numbers\n    expect(names[0]).toBe('tool_a'); // MAX_SAFE_INTEGER\n    expect(names[1]).toBe('tool_b'); // 1e15\n    expect(names[2]).toBe('tool_c'); // 1e10\n  });\n\n  it('should handle mixed positive, zero, and negative priorities', () => {\n    // Use maxTools: 4 to force sorting (since we have 5 tools, this triggers truncation)\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['tool_*'],\n      maxTools: 4,  // Less than 5 tools to trigger priority sorting\n      toolPriorities: {\n        'tool_a': 100,\n        'tool_b': -100,\n        'tool_c': 0,\n        'tool_d': 50,\n        'tool_e': -50,\n      },\n    });\n\n    const result = filter.filter(mockTools);\n    const names = result.tools.map(t => t.name);\n\n    // Should have 4 tools (maxTools limit)\n    expect(names).toHaveLength(4);\n\n    // tool_a should be first (highest priority: 100)\n    expect(names[0]).toBe('tool_a');\n\n    // Verify the 4 highest priority tools are kept in order:\n    // a(100), d(50), c(0), e(-50) - b(-100) should be excluded\n    expect(names).toContain('tool_a');\n    expect(names).toContain('tool_d');\n    expect(names).toContain('tool_c');\n    expect(names).toContain('tool_e');\n    expect(names).not.toContain('tool_b');  // Lowest priority, excluded\n\n    // Verify ordering: a > d > c > e\n    expect(names.indexOf('tool_a')).toBeLessThan(names.indexOf('tool_d'));  // 100 > 50\n    expect(names.indexOf('tool_d')).toBeLessThan(names.indexOf('tool_c'));  // 50 > 0\n    expect(names.indexOf('tool_c')).toBeLessThan(names.indexOf('tool_e'));  // 0 > -50\n  });\n});\n\n// ===== Empty Allowlist Behavior =====\n\ndescribe('Empty Allowlist Behavior', () => {\n  let mockTools: MCPTool[];\n\n  beforeEach(() => {\n    mockTools = createMockToolSet();\n  });\n\n  /**\n   * EXPECTED BEHAVIOR: When allowlist mode is enabled with an empty patterns array,\n   * no tools will match and the result will be an empty array.\n   *\n   * This is intentional and documented behavior - an empty allowlist means\n   * \"allow nothing\" since no patterns can match. This is the correct semantic\n   * for allowlist mode vs denylist mode (where empty patterns means \"deny nothing\").\n   */\n  it('should return empty array when allowlist has no patterns (expected behavior)', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: [],  // Empty patterns array\n    });\n\n    const result = filter.filter(mockTools);\n\n    // Empty allowlist = nothing is allowed through\n    // This is expected and documented behavior\n    expect(result.tools).toHaveLength(0);\n    expect(result.stats.filteredTools).toBe(0);\n    expect(result.stats.totalTools).toBe(mockTools.length);\n  });\n\n  it('should return all tools when denylist has no patterns (contrast with allowlist)', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'denylist',\n      patterns: [],  // Empty patterns array\n    });\n\n    const result = filter.filter(mockTools);\n\n    // Empty denylist = nothing is denied, all tools pass through\n    expect(result.tools).toHaveLength(mockTools.length);\n    expect(result.stats.filteredTools).toBe(mockTools.length);\n  });\n\n  it('should still respect maxTools even with empty allowlist result', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: [],\n      maxTools: 5,\n    });\n\n    const result = filter.filter(mockTools);\n\n    // Even with maxTools set, empty allowlist produces empty result\n    expect(result.tools).toHaveLength(0);\n  });\n});\n\n// ===== Config Validation =====\n\ndescribe('Config Validation', () => {\n  let mockTools: MCPTool[];\n\n  beforeEach(() => {\n    mockTools = createMockToolSet();\n  });\n\n  it('should default to allowlist mode when mode value is invalid', () => {\n    // TypeScript would normally prevent this, but we test runtime behavior\n    const invalidConfig = {\n      enabled: true,\n      mode: 'invalid_mode' as 'allowlist' | 'denylist',\n      patterns: ['swarm_*'],\n    };\n\n    // The filter should still work - it may use the invalid mode as-is\n    // or default to a sensible value depending on implementation\n    const filter = createToolFilter(invalidConfig);\n    const config = filter.getConfig();\n\n    // Test that filtering still works\n    const result = filter.filter(mockTools);\n\n    // The filter should not throw and should process tools\n    expect(result.tools).toBeDefined();\n    expect(Array.isArray(result.tools)).toBe(true);\n  });\n\n  it('should handle negative maxTools value', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n      maxTools: -5,  // Invalid negative value\n    });\n\n    const result = filter.filter(mockTools);\n\n    // With negative maxTools, the behavior depends on implementation:\n    // - If slice(-5) is used, it returns the last 5 elements\n    // - The filter may not validate this edge case\n    // We simply verify the filter doesn't throw and produces a result\n    expect(result.tools).toBeDefined();\n    expect(Array.isArray(result.tools)).toBe(true);\n    // Note: This documents current behavior - negative maxTools may produce unexpected results\n    // A robust implementation would validate maxTools > 0\n  });\n\n  it('should ignore zero maxTools value', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n      maxTools: 0,  // Edge case\n    });\n\n    const result = filter.filter(mockTools);\n\n    // maxTools: 0 could mean \"unlimited\" or \"return nothing\"\n    // Based on implementation (if > 0), zero should be treated as unlimited\n    expect(result.tools.length).toBeGreaterThanOrEqual(0);\n  });\n\n  it('should handle NaN maxTools gracefully', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n      maxTools: parseInt('not_a_number', 10),  // Results in NaN\n    });\n\n    const result = filter.filter(mockTools);\n\n    // NaN should be treated as \"no limit\"\n    expect(result.tools).toBeDefined();\n    expect(Array.isArray(result.tools)).toBe(true);\n  });\n\n  it('should skip malformed patterns gracefully without throwing', () => {\n    // Test patterns that might cause regex issues\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: [\n        'valid_pattern_*',\n        '',                    // Empty pattern\n        'another_valid_*',\n      ],\n    });\n\n    // Should not throw\n    expect(() => filter.filter(mockTools)).not.toThrow();\n\n    const result = filter.filter(mockTools);\n    expect(result.tools).toBeDefined();\n  });\n\n  it('should handle undefined categories array', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['swarm_*'],\n      categories: undefined,\n    });\n\n    const result = filter.filter(mockTools);\n\n    // Should work normally with undefined categories\n    expect(result.tools.length).toBe(3); // 3 swarm tools\n  });\n\n  it('should handle empty categories array', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n      categories: [],\n    });\n\n    const result = filter.filter(mockTools);\n\n    // Empty categories should not restrict further (pattern matching takes precedence)\n    expect(result.tools.length).toBeGreaterThan(0);\n  });\n\n  it('should handle toolPriorities with undefined values', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['swarm_*'],\n      maxTools: 2,\n      toolPriorities: {\n        'swarm_init': 100,\n        'swarm_status': undefined as unknown as number,  // Simulate bad data\n        'swarm_monitor': 50,\n      },\n    });\n\n    const result = filter.filter(mockTools);\n\n    // Should handle undefined priority gracefully\n    expect(result.tools).toHaveLength(2);\n  });\n\n  it('should validate and use defaults for missing config properties', () => {\n    // Minimal config\n    const minimalConfig: MCPToolFilterConfig = {\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n    };\n\n    const filter = createToolFilter(minimalConfig);\n    const config = filter.getConfig();\n\n    expect(config.enabled).toBe(true);\n    expect(config.mode).toBe('allowlist');\n    expect(config.patterns).toEqual(['*']);\n    // Optional properties should be undefined or have sensible defaults\n    expect(config.maxTools).toBeUndefined();\n  });\n});\n\n// ===== Pattern Validation Tests (ReDoS Protection) =====\n\ndescribe('Pattern Validation (ReDoS Protection)', () => {\n  // We'll import the validation functions dynamically in each test\n  let validateGlobPattern: (pattern: unknown) => { valid: boolean; reason?: string };\n  let MAX_PATTERN_LENGTH: number;\n  let ToolFilterClass: any;\n\n  beforeAll(async () => {\n    const toolFilterModule = await import('../mcp/tool-filter.js');\n    validateGlobPattern = toolFilterModule.validateGlobPattern;\n    MAX_PATTERN_LENGTH = toolFilterModule.MAX_PATTERN_LENGTH;\n    ToolFilterClass = toolFilterModule.ToolFilter;\n  });\n\n  describe('validateGlobPattern', () => {\n    it('should accept valid simple patterns', () => {\n      expect(validateGlobPattern('system/*').valid).toBe(true);\n      expect(validateGlobPattern('agent_spawn').valid).toBe(true);\n      expect(validateGlobPattern('**/test').valid).toBe(true);\n      expect(validateGlobPattern('*.js').valid).toBe(true);\n    });\n\n    it('should reject non-string patterns', () => {\n      const result = validateGlobPattern(123);\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('must be a string');\n    });\n\n    it('should reject empty strings', () => {\n      const result = validateGlobPattern('');\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('cannot be empty');\n    });\n\n    it('should reject whitespace-only strings', () => {\n      const result = validateGlobPattern('   ');\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('whitespace only');\n    });\n\n    it('should reject patterns exceeding max length', () => {\n      const longPattern = 'a'.repeat(MAX_PATTERN_LENGTH + 1);\n      const result = validateGlobPattern(longPattern);\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('maximum length');\n    });\n\n    it('should accept patterns at max length', () => {\n      const maxPattern = 'a'.repeat(MAX_PATTERN_LENGTH);\n      const result = validateGlobPattern(maxPattern);\n      expect(result.valid).toBe(true);\n    });\n\n    it('should reject nested double stars (ReDoS risk)', () => {\n      const result = validateGlobPattern('**/**/file.js');\n      expect(result.valid).toBe(false);\n      // Either message is valid depending on which pattern is matched first\n      expect(\n        result.reason?.includes('catastrophic backtracking') ||\n        result.reason?.includes('performance issues')\n      ).toBe(true);\n    });\n\n    it('should reject triple wildcards', () => {\n      const result = validateGlobPattern('***');\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('not valid glob patterns');\n    });\n\n    it('should reject excessive repeated wildcard segments', () => {\n      const result = validateGlobPattern('/*/*/*/*/*/*');\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('Excessive repeated');\n    });\n\n    it('should accept valid double star patterns', () => {\n      expect(validateGlobPattern('**/file.js').valid).toBe(true);\n      expect(validateGlobPattern('src/**/*.ts').valid).toBe(true);\n    });\n\n    it('should accept normal glob patterns with multiple wildcards', () => {\n      expect(validateGlobPattern('*.{js,ts}').valid).toBe(true);\n      expect(validateGlobPattern('src/*.test.js').valid).toBe(true);\n    });\n  });\n\n  describe('Pattern Validation in ToolFilter', () => {\n    it('should filter out invalid patterns during construction', () => {\n      // Create a mock logger\n      const mockLogger = {\n        debug: jest.fn(),\n        info: jest.fn(),\n        warn: jest.fn(),\n        error: jest.fn(),\n      };\n\n      // Create filter with mix of valid and invalid patterns\n      const filter = new ToolFilterClass(\n        {\n          enabled: true,\n          mode: 'allowlist',\n          tools: ['system/*', '**/**/**', 'valid_tool', '***'],\n        },\n        mockLogger\n      );\n\n      // Invalid patterns should have been logged as warnings\n      expect(mockLogger.warn).toHaveBeenCalled();\n    });\n  });\n});\n"],"names":["describe","it","expect","beforeEach","afterEach","jest","join","ToolFilter","config","lastStats","categoryMap","Map","initializeCategoryMap","categoryPatterns","Object","entries","getToolCategory","toolName","prefix","category","startsWith","matchPattern","pattern","regexPattern","replace","regex","RegExp","test","filter","tools","startTime","performance","now","enabled","stats","totalTools","length","filteredTools","matchedPatterns","filterTime","lastFiltered","Date","mode","tool","matches","patterns","some","isMatch","name","includes","push","categories","shouldExclude","maxTools","priorities","toolPriorities","sort","a","b","priorityA","priorityB","localeCompare","slice","getStats","updateConfig","getConfig","undefined","createToolFilter","createMockTool","description","inputSchema","type","properties","handler","createMockToolSet","mockTools","result","toHaveLength","toEqual","toBe","toBeGreaterThanOrEqual","toBeInstanceOf","map","t","every","endsWith","split","toolNames","n","result1","result2","names","toContain","sortedNames","trackStats","not","toBeLessThan","before","after","getTime","toBeLessThanOrEqual","toBeUndefined","toBeDefined","originalConfig","config2","specialTools","longName","repeat","longTools","Array","from","_","i","start","elapsed","manyTools","filter1","filter2","originalEnv","process","env","resetModules","createMockConfigLoader","mockFs","configPaths","loadConfig","cwd","configPath","fullPath","files","content","parsed","JSON","parse","source","stringify","toBeNull","fileConfig","CLAUDE_FLOW_MCP_TOOL_FILTER_ENABLED","CLAUDE_FLOW_MCP_TOOL_FILTER_MODE","CLAUDE_FLOW_MCP_TOOLS_ALLOWED","CLAUDE_FLOW_MCP_MAX_TOOLS","enabledEnv","hasExplicitEnabled","modeEnv","hasExplicitMode","toolsEnv","envTools","trim","maxToolsEnv","envMaxTools","parseInt","mergedConfig","isNaN","results","firstResult","Number","MAX_SAFE_INTEGER","indexOf","invalidConfig","isArray","toThrow","toBeGreaterThan","minimalConfig","validateGlobPattern","MAX_PATTERN_LENGTH","ToolFilterClass","beforeAll","toolFilterModule","valid","reason","longPattern","maxPattern","mockLogger","debug","fn","info","warn","error","toHaveBeenCalled"],"mappings":"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"}