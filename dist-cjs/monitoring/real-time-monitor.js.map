{
  "version": 3,
  "sources": ["../../src/monitoring/real-time-monitor.ts"],
  "sourcesContent": ["/**\n * Real-time monitoring system for swarm operations\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  SystemMetrics,\n  Alert,\n  AlertLevel,\n  AlertType,\n  MonitoringConfig,\n  AgentMetrics,\n  SwarmMetrics,\n  AgentId,\n} from '../swarm/types.js';\nimport type { DistributedMemorySystem } from '../memory/distributed-memory.js';\n\nexport interface MonitorConfig {\n  updateInterval: number;\n  retentionPeriod: number;\n  alertingEnabled: boolean;\n  alertThresholds: AlertThresholds;\n  metricsEnabled: boolean;\n  tracingEnabled: boolean;\n  dashboardEnabled: boolean;\n  exportEnabled: boolean;\n  exportFormat: 'json' | 'csv' | 'prometheus';\n  debugMode: boolean;\n}\n\nexport interface AlertThresholds {\n  cpu: { warning: number; critical: number };\n  memory: { warning: number; critical: number };\n  disk: { warning: number; critical: number };\n  errorRate: { warning: number; critical: number };\n  responseTime: { warning: number; critical: number };\n  queueDepth: { warning: number; critical: number };\n  agentHealth: { warning: number; critical: number };\n  swarmUtilization: { warning: number; critical: number };\n}\n\nexport interface MetricPoint {\n  timestamp: Date;\n  value: number;\n  tags: Record<string, string>;\n  metadata?: Record<string, any>;\n}\n\nexport interface TimeSeries {\n  name: string;\n  points: MetricPoint[];\n  aggregations: {\n    min: number;\n    max: number;\n    avg: number;\n    sum: number;\n    count: number;\n  };\n  lastUpdated: Date;\n}\n\nexport interface MonitoringDashboard {\n  title: string;\n  panels: DashboardPanel[];\n  refreshInterval: number;\n  timeRange: { start: Date; end: Date };\n  filters: Record<string, any>;\n}\n\nexport interface DashboardPanel {\n  id: string;\n  title: string;\n  type: 'line' | 'bar' | 'gauge' | 'table' | 'heatmap' | 'stat';\n  metrics: string[];\n  config: {\n    width: number;\n    height: number;\n    position: { x: number; y: number };\n    visualization: Record<string, any>;\n  };\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  enabled: boolean;\n  metric: string;\n  condition: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n  threshold: number;\n  duration: number; // How long condition must persist\n  severity: AlertLevel;\n  tags: Record<string, string>;\n  actions: AlertAction[];\n  suppressions: AlertSuppression[];\n}\n\nexport interface AlertAction {\n  type: 'email' | 'webhook' | 'slack' | 'log' | 'auto-scale' | 'restart';\n  config: Record<string, any>;\n  enabled: boolean;\n}\n\nexport interface AlertSuppression {\n  condition: string;\n  duration: number;\n  reason: string;\n}\n\nexport interface HealthCheck {\n  name: string;\n  type: 'http' | 'tcp' | 'custom';\n  target: string;\n  interval: number;\n  timeout: number;\n  retries: number;\n  expectedResponse?: any;\n  customCheck?: () => Promise<boolean>;\n}\n\n/**\n * Comprehensive real-time monitoring and alerting system\n */\nexport class RealTimeMonitor extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private memory: DistributedMemorySystem;\n  private config: MonitorConfig;\n\n  // Metrics storage\n  private timeSeries = new Map<string, TimeSeries>();\n  private activeAlerts = new Map<string, Alert>();\n  private alertHistory: Alert[] = [];\n\n  // Monitoring state\n  private monitoringInterval?: NodeJS.Timeout;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private alertRules = new Map<string, AlertRule>();\n  private healthChecks = new Map<string, HealthCheck>();\n\n  // System state tracking\n  private systemMetrics: SystemMetrics;\n  private agentMetrics = new Map<string, AgentMetrics>();\n  private swarmMetrics: SwarmMetrics;\n\n  // Dashboards\n  private dashboards = new Map<string, MonitoringDashboard>();\n\n  // Performance tracking\n  private lastMetricsUpdate = new Date();\n  private metricsBuffer: MetricPoint[] = [];\n  private alertProcessor?: NodeJS.Timeout;\n\n  constructor(\n    config: Partial<MonitorConfig>,\n    logger: ILogger,\n    eventBus: IEventBus,\n    memory: DistributedMemorySystem,\n  ) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n    this.memory = memory;\n\n    this.config = {\n      updateInterval: 5000,\n      retentionPeriod: 86400000, // 24 hours\n      alertingEnabled: true,\n      alertThresholds: {\n        cpu: { warning: 70, critical: 90 },\n        memory: { warning: 80, critical: 95 },\n        disk: { warning: 85, critical: 95 },\n        errorRate: { warning: 5, critical: 10 },\n        responseTime: { warning: 5000, critical: 10000 },\n        queueDepth: { warning: 10, critical: 20 },\n        agentHealth: { warning: 0.7, critical: 0.5 },\n        swarmUtilization: { warning: 0.8, critical: 0.95 },\n      },\n      metricsEnabled: true,\n      tracingEnabled: true,\n      dashboardEnabled: true,\n      exportEnabled: false,\n      exportFormat: 'json',\n      debugMode: false,\n      ...config,\n    };\n\n    this.systemMetrics = this.initializeSystemMetrics();\n    this.swarmMetrics = this.initializeSwarmMetrics();\n\n    this.setupEventHandlers();\n    this.initializeDefaultAlertRules();\n    this.initializeDefaultDashboards();\n  }\n\n  private setupEventHandlers(): void {\n    // Agent events\n    this.eventBus.on('agent:metrics-update', (data) => {\n      this.updateAgentMetrics(data.agentId, data.metrics);\n    });\n\n    this.eventBus.on('agent:status-changed', (data) => {\n      this.recordMetric('agent.status.change', 1, {\n        agentId: data.agentId,\n        from: data.from,\n        to: data.to,\n      });\n    });\n\n    // Task events\n    this.eventBus.on('task:started', (data) => {\n      this.recordMetric('task.started', 1, { taskId: data.taskId, agentId: data.agentId });\n    });\n\n    this.eventBus.on('task:completed', (data) => {\n      this.recordMetric('task.completed', 1, { taskId: data.taskId });\n      this.recordMetric('task.duration', data.duration, { taskId: data.taskId });\n    });\n\n    this.eventBus.on('task:failed', (data) => {\n      this.recordMetric('task.failed', 1, { taskId: data.taskId, error: data.error });\n    });\n\n    // System events\n    this.eventBus.on('system:resource-update', (data) => {\n      this.updateSystemMetrics(data);\n    });\n\n    this.eventBus.on('swarm:metrics-update', (data) => {\n      this.updateSwarmMetrics(data.metrics);\n    });\n\n    // Error events\n    this.eventBus.on('error', (data) => {\n      this.handleError(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing real-time monitor', {\n      updateInterval: this.config.updateInterval,\n      alerting: this.config.alertingEnabled,\n      dashboard: this.config.dashboardEnabled,\n    });\n\n    // Start monitoring loops\n    this.startMetricsCollection();\n    this.startHealthChecks();\n\n    if (this.config.alertingEnabled) {\n      this.startAlertProcessing();\n    }\n\n    // Initialize default health checks\n    this.initializeHealthChecks();\n\n    this.emit('monitor:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down real-time monitor');\n\n    // Stop all intervals\n    if (this.monitoringInterval) clearInterval(this.monitoringInterval);\n    if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);\n    if (this.alertProcessor) clearInterval(this.alertProcessor);\n\n    // Flush any remaining metrics\n    await this.flushMetrics();\n\n    this.emit('monitor:shutdown');\n  }\n\n  // === METRICS COLLECTION ===\n\n  private startMetricsCollection(): void {\n    this.monitoringInterval = setInterval(() => {\n      this.collectSystemMetrics();\n      this.processMetricsBuffer();\n      this.cleanupOldMetrics();\n    }, this.config.updateInterval);\n\n    this.logger.info('Started metrics collection', {\n      interval: this.config.updateInterval,\n    });\n  }\n\n  private async collectSystemMetrics(): Promise<void> {\n    try {\n      // Update system metrics\n      this.systemMetrics = {\n        ...this.systemMetrics,\n        timestamp: new Date(),\n        cpuUsage: await this.getCpuUsage(),\n        memoryUsage: await this.getMemoryUsage(),\n        diskUsage: await this.getDiskUsage(),\n        networkUsage: await this.getNetworkUsage(),\n      };\n\n      // Record as time series\n      this.recordMetric('system.cpu', this.systemMetrics.cpuUsage);\n      this.recordMetric('system.memory', this.systemMetrics.memoryUsage);\n      this.recordMetric('system.disk', this.systemMetrics.diskUsage);\n      this.recordMetric('system.network', this.systemMetrics.networkUsage);\n\n      // Update swarm-level metrics\n      await this.updateSwarmLevelMetrics();\n    } catch (error) {\n      this.logger.error('Failed to collect system metrics', error);\n    }\n  }\n\n  private async updateSwarmLevelMetrics(): Promise<void> {\n    const agents = Array.from(this.agentMetrics.values());\n\n    this.swarmMetrics = {\n      ...this.swarmMetrics,\n      agentUtilization: this.calculateAgentUtilization(agents),\n      throughput: this.calculateSwarmThroughput(agents),\n      latency: this.calculateAverageLatency(agents),\n      efficiency: this.calculateSwarmEfficiency(agents),\n      reliability: this.calculateSwarmReliability(agents),\n      averageQuality: this.calculateAverageQuality(agents),\n    };\n\n    // Record swarm metrics\n    this.recordMetric('swarm.utilization', this.swarmMetrics.agentUtilization);\n    this.recordMetric('swarm.throughput', this.swarmMetrics.throughput);\n    this.recordMetric('swarm.latency', this.swarmMetrics.latency);\n    this.recordMetric('swarm.efficiency', this.swarmMetrics.efficiency);\n    this.recordMetric('swarm.reliability', this.swarmMetrics.reliability);\n  }\n\n  recordMetric(name: string, value: number, tags: Record<string, string> = {}): void {\n    const point: MetricPoint = {\n      timestamp: new Date(),\n      value,\n      tags,\n    };\n\n    // Add to buffer for batch processing\n    this.metricsBuffer.push({ ...point, tags: { ...tags, metric: name } });\n\n    // Immediate processing for critical metrics\n    if (this.isCriticalMetric(name)) {\n      this.processMetricPoint(name, point);\n    }\n  }\n\n  private processMetricsBuffer(): void {\n    if (this.metricsBuffer.length === 0) return;\n\n    // Group by metric name\n    const metricGroups = new Map<string, MetricPoint[]>();\n    for (const point of this.metricsBuffer) {\n      const metricName = point.tags.metric || 'unknown';\n      const group = metricGroups.get(metricName) || [];\n      group.push(point);\n      metricGroups.set(metricName, group);\n    }\n\n    // Process each metric group\n    for (const [metricName, points] of metricGroups) {\n      for (const point of points) {\n        this.processMetricPoint(metricName, point);\n      }\n    }\n\n    // Clear buffer\n    this.metricsBuffer = [];\n  }\n\n  private processMetricPoint(metricName: string, point: MetricPoint): void {\n    let series = this.timeSeries.get(metricName);\n\n    if (!series) {\n      series = {\n        name: metricName,\n        points: [],\n        aggregations: {\n          min: point.value,\n          max: point.value,\n          avg: point.value,\n          sum: point.value,\n          count: 1,\n        },\n        lastUpdated: point.timestamp,\n      };\n      this.timeSeries.set(metricName, series);\n    }\n\n    // Add point\n    series.points.push(point);\n    series.lastUpdated = point.timestamp;\n\n    // Update aggregations\n    series.aggregations.count++;\n    series.aggregations.sum += point.value;\n    series.aggregations.avg = series.aggregations.sum / series.aggregations.count;\n    series.aggregations.min = Math.min(series.aggregations.min, point.value);\n    series.aggregations.max = Math.max(series.aggregations.max, point.value);\n\n    // Trigger alert checking for this metric\n    if (this.config.alertingEnabled) {\n      this.checkAlertsForMetric(metricName, point);\n    }\n  }\n\n  // === ALERTING ===\n\n  private startAlertProcessing(): void {\n    this.alertProcessor = setInterval(() => {\n      this.processAlerts();\n    }, 1000); // Process alerts every second\n\n    this.logger.info('Started alert processing');\n  }\n\n  private processAlerts(): void {\n    const now = new Date();\n\n    // Check for alert resolution\n    for (const [alertId, alert] of this.activeAlerts) {\n      if (!alert.resolved) {\n        const rule = this.alertRules.get(alert.context.ruleId);\n        if (rule && this.isAlertResolved(rule, alert)) {\n          this.resolveAlert(alertId, 'condition_resolved');\n        }\n      }\n    }\n\n    // Clean up old resolved alerts\n    this.cleanupResolvedAlerts();\n  }\n\n  private checkAlertsForMetric(metricName: string, point: MetricPoint): void {\n    for (const [ruleId, rule] of this.alertRules) {\n      if (rule.enabled && rule.metric === metricName) {\n        this.evaluateAlertRule(rule, point);\n      }\n    }\n  }\n\n  private evaluateAlertRule(rule: AlertRule, point: MetricPoint): void {\n    const conditionMet = this.evaluateCondition(rule.condition, point.value, rule.threshold);\n\n    if (conditionMet) {\n      // Check if we already have an active alert for this rule\n      const existingAlert = Array.from(this.activeAlerts.values()).find(\n        (alert) => alert.context.ruleId === rule.id && !alert.resolved,\n      );\n\n      if (!existingAlert) {\n        this.createAlert(rule, point);\n      }\n    }\n  }\n\n  private createAlert(rule: AlertRule, triggeringPoint: MetricPoint): void {\n    const alertId = `alert-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n\n    const alert: Alert = {\n      id: alertId,\n      timestamp: new Date(),\n      level: rule.severity,\n      type: this.getAlertTypeFromMetric(rule.metric),\n      message: `${rule.name}: ${rule.metric} ${rule.condition} ${rule.threshold} (current: ${triggeringPoint.value})`,\n      source: 'real-time-monitor',\n      context: {\n        ruleId: rule.id,\n        metric: rule.metric,\n        value: triggeringPoint.value,\n        threshold: rule.threshold,\n        tags: { ...rule.tags, ...triggeringPoint.tags },\n      },\n      acknowledged: false,\n      resolved: false,\n      escalationLevel: 0,\n    };\n\n    this.activeAlerts.set(alertId, alert);\n    this.alertHistory.push(alert);\n\n    this.logger.warn('Alert created', {\n      alertId,\n      rule: rule.name,\n      metric: rule.metric,\n      value: triggeringPoint.value,\n      threshold: rule.threshold,\n    });\n\n    this.emit('alert:created', { alert });\n\n    // Execute alert actions\n    this.executeAlertActions(rule, alert);\n  }\n\n  private executeAlertActions(rule: AlertRule, alert: Alert): void {\n    for (const action of rule.actions) {\n      if (!action.enabled) continue;\n\n      try {\n        switch (action.type) {\n          case 'log':\n            this.logger.warn(`ALERT: ${alert.message}`, alert.context);\n            break;\n\n          case 'email':\n            this.sendEmailAlert(alert, action.config);\n            break;\n\n          case 'webhook':\n            this.sendWebhookAlert(alert, action.config);\n            break;\n\n          case 'auto-scale':\n            this.triggerAutoScale(alert, action.config);\n            break;\n\n          case 'restart':\n            this.triggerRestart(alert, action.config);\n            break;\n\n          default:\n            this.logger.warn('Unknown alert action type', { type: action.type });\n        }\n      } catch (error) {\n        this.logger.error('Failed to execute alert action', {\n          alertId: alert.id,\n          actionType: action.type,\n          error,\n        });\n      }\n    }\n  }\n\n  private resolveAlert(alertId: string, reason: string): void {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert) return;\n\n    alert.resolved = true;\n    alert.context.resolutionReason = reason;\n    alert.context.resolvedAt = new Date();\n\n    this.logger.info('Alert resolved', { alertId, reason });\n    this.emit('alert:resolved', { alert, reason });\n  }\n\n  // === HEALTH CHECKS ===\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthChecks();\n    }, 30000); // Every 30 seconds\n\n    this.logger.info('Started health checks');\n  }\n\n  private async performHealthChecks(): Promise<void> {\n    const checks = Array.from(this.healthChecks.values());\n    const promises = checks.map((check) => this.executeHealthCheck(check));\n\n    await Promise.allSettled(promises);\n  }\n\n  private async executeHealthCheck(check: HealthCheck): Promise<void> {\n    try {\n      let isHealthy = false;\n\n      switch (check.type) {\n        case 'http':\n          isHealthy = await this.performHttpHealthCheck(check);\n          break;\n        case 'tcp':\n          isHealthy = await this.performTcpHealthCheck(check);\n          break;\n        case 'custom':\n          if (check.customCheck) {\n            isHealthy = await check.customCheck();\n          }\n          break;\n      }\n\n      this.recordMetric(`healthcheck.${check.name}`, isHealthy ? 1 : 0, {\n        type: check.type,\n        target: check.target,\n      });\n    } catch (error) {\n      this.logger.error('Health check failed', { check: check.name, error });\n      this.recordMetric(`healthcheck.${check.name}`, 0, {\n        type: check.type,\n        target: check.target,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  // === DASHBOARD MANAGEMENT ===\n\n  createDashboard(title: string, panels: DashboardPanel[]): string {\n    const dashboardId = `dashboard-${Date.now()}`;\n\n    const dashboard: MonitoringDashboard = {\n      title,\n      panels,\n      refreshInterval: 30000,\n      timeRange: {\n        start: new Date(Date.now() - 3600000), // Last hour\n        end: new Date(),\n      },\n      filters: {},\n    };\n\n    this.dashboards.set(dashboardId, dashboard);\n    this.emit('dashboard:created', { dashboardId, dashboard });\n\n    return dashboardId;\n  }\n\n  getDashboardData(dashboardId: string): any {\n    const dashboard = this.dashboards.get(dashboardId);\n    if (!dashboard) return null;\n\n    const data: any = {\n      dashboard,\n      panels: [],\n    };\n\n    for (const panel of dashboard.panels) {\n      const panelData = {\n        id: panel.id,\n        title: panel.title,\n        type: panel.type,\n        data: this.getPanelData(panel, dashboard.timeRange),\n      };\n      data.panels.push(panelData);\n    }\n\n    return data;\n  }\n\n  private getPanelData(panel: DashboardPanel, timeRange: { start: Date; end: Date }): any {\n    const data: any = {};\n\n    for (const metricName of panel.metrics) {\n      const series = this.timeSeries.get(metricName);\n      if (series) {\n        // Filter points by time range\n        const filteredPoints = series.points.filter(\n          (point) => point.timestamp >= timeRange.start && point.timestamp <= timeRange.end,\n        );\n\n        data[metricName] = {\n          points: filteredPoints,\n          aggregations: this.calculateAggregations(filteredPoints),\n        };\n      }\n    }\n\n    return data;\n  }\n\n  // === UTILITY METHODS ===\n\n  private async getCpuUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 100;\n  }\n\n  private async getMemoryUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 100;\n  }\n\n  private async getDiskUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 100;\n  }\n\n  private async getNetworkUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 1024 * 1024; // bytes\n  }\n\n  private updateAgentMetrics(agentId: string, metrics: AgentMetrics): void {\n    this.agentMetrics.set(agentId, metrics);\n\n    // Record individual agent metrics\n    this.recordMetric('agent.cpu', metrics.cpuUsage, { agentId });\n    this.recordMetric('agent.memory', metrics.memoryUsage, { agentId });\n    this.recordMetric('agent.tasks.completed', metrics.tasksCompleted, { agentId });\n    this.recordMetric('agent.tasks.failed', metrics.tasksFailed, { agentId });\n    this.recordMetric('agent.response.time', metrics.responseTime, { agentId });\n  }\n\n  private updateSystemMetrics(data: Partial<SystemMetrics>): void {\n    this.systemMetrics = { ...this.systemMetrics, ...data };\n  }\n\n  private updateSwarmMetrics(metrics: SwarmMetrics): void {\n    this.swarmMetrics = { ...this.swarmMetrics, ...metrics };\n  }\n\n  private handleError(data: any): void {\n    this.recordMetric('error.count', 1, {\n      type: data.type || 'unknown',\n      source: data.source || 'unknown',\n    });\n\n    // Create critical alert for errors\n    if (data.severity === 'critical') {\n      const alertId = `error-alert-${Date.now()}`;\n      const alert: Alert = {\n        id: alertId,\n        timestamp: new Date(),\n        level: 'critical',\n        type: 'system',\n        message: `Critical error: ${data.message}`,\n        source: data.source || 'unknown',\n        context: data,\n        acknowledged: false,\n        resolved: false,\n        escalationLevel: 0,\n      };\n\n      this.activeAlerts.set(alertId, alert);\n      this.emit('alert:created', { alert });\n    }\n  }\n\n  private isCriticalMetric(name: string): boolean {\n    const criticalMetrics = [\n      'system.cpu',\n      'system.memory',\n      'system.disk',\n      'agent.health',\n      'task.failed',\n      'error.count',\n    ];\n    return criticalMetrics.includes(name);\n  }\n\n  private evaluateCondition(condition: string, value: number, threshold: number): boolean {\n    switch (condition) {\n      case 'gt':\n        return value > threshold;\n      case 'gte':\n        return value >= threshold;\n      case 'lt':\n        return value < threshold;\n      case 'lte':\n        return value <= threshold;\n      case 'eq':\n        return value === threshold;\n      default:\n        return false;\n    }\n  }\n\n  private isAlertResolved(rule: AlertRule, alert: Alert): boolean {\n    // Get recent metric values\n    const series = this.timeSeries.get(rule.metric);\n    if (!series || series.points.length === 0) return false;\n\n    // Check if condition is no longer met\n    const recentPoints = series.points.slice(-5); // Last 5 points\n    const allResolved = recentPoints.every(\n      (point) => !this.evaluateCondition(rule.condition, point.value, rule.threshold),\n    );\n\n    return allResolved;\n  }\n\n  private getAlertTypeFromMetric(metric: string): AlertType {\n    if (metric.includes('system')) return 'system';\n    if (metric.includes('agent')) return 'agent';\n    if (metric.includes('task')) return 'task';\n    if (metric.includes('swarm')) return 'swarm';\n    if (metric.includes('performance')) return 'performance';\n    if (metric.includes('resource')) return 'resource';\n    return 'custom';\n  }\n\n  private calculateAgentUtilization(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0;\n    const totalUtilization = agents.reduce((sum, agent) => sum + agent.cpuUsage, 0);\n    return totalUtilization / agents.length;\n  }\n\n  private calculateSwarmThroughput(agents: AgentMetrics[]): number {\n    return agents.reduce((sum, agent) => sum + (agent.tasksCompleted || 0), 0);\n  }\n\n  private calculateAverageLatency(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0;\n    const totalLatency = agents.reduce((sum, agent) => sum + agent.responseTime, 0);\n    return totalLatency / agents.length;\n  }\n\n  private calculateSwarmEfficiency(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0;\n    const totalTasks = agents.reduce(\n      (sum, agent) => sum + (agent.tasksCompleted || 0) + (agent.tasksFailed || 0),\n      0,\n    );\n    const completedTasks = agents.reduce((sum, agent) => sum + (agent.tasksCompleted || 0), 0);\n    return totalTasks > 0 ? completedTasks / totalTasks : 1;\n  }\n\n  private calculateSwarmReliability(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 1;\n    const totalReliability = agents.reduce((sum, agent) => sum + (agent.successRate || 1), 0);\n    return totalReliability / agents.length;\n  }\n\n  private calculateAverageQuality(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0.8;\n    const totalQuality = agents.reduce((sum, agent) => sum + (agent.codeQuality || 0.8), 0);\n    return totalQuality / agents.length;\n  }\n\n  private calculateAggregations(points: MetricPoint[]): any {\n    if (points.length === 0) {\n      return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };\n    }\n\n    const values = points.map((p) => p.value);\n    return {\n      min: Math.min(...values),\n      max: Math.max(...values),\n      avg: values.reduce((sum, val) => sum + val, 0) / values.length,\n      sum: values.reduce((sum, val) => sum + val, 0),\n      count: values.length,\n    };\n  }\n\n  private cleanupOldMetrics(): void {\n    const cutoff = new Date(Date.now() - this.config.retentionPeriod);\n\n    for (const [name, series] of this.timeSeries) {\n      series.points = series.points.filter((point) => point.timestamp > cutoff);\n\n      if (series.points.length === 0) {\n        this.timeSeries.delete(name);\n      }\n    }\n  }\n\n  private cleanupResolvedAlerts(): void {\n    const cutoff = new Date(Date.now() - 86400000); // 24 hours\n\n    // Remove old resolved alerts from active alerts\n    for (const [alertId, alert] of this.activeAlerts) {\n      if (alert.resolved && alert.timestamp < cutoff) {\n        this.activeAlerts.delete(alertId);\n      }\n    }\n\n    // Trim alert history\n    this.alertHistory = this.alertHistory.filter((alert) => alert.timestamp > cutoff).slice(-1000); // Keep last 1000 alerts max\n  }\n\n  private async flushMetrics(): Promise<void> {\n    if (this.metricsBuffer.length > 0) {\n      this.processMetricsBuffer();\n    }\n\n    // Persist metrics to memory if enabled\n    if (this.config.exportEnabled) {\n      await this.exportMetrics();\n    }\n  }\n\n  private async exportMetrics(): Promise<void> {\n    try {\n      const exportData = {\n        timestamp: new Date(),\n        timeSeries: Array.from(this.timeSeries.entries()),\n        systemMetrics: this.systemMetrics,\n        swarmMetrics: this.swarmMetrics,\n        activeAlerts: Array.from(this.activeAlerts.values()),\n      };\n\n      await this.memory.store('monitoring:export', exportData, {\n        type: 'monitoring-export',\n        partition: 'metrics',\n      });\n    } catch (error) {\n      this.logger.error('Failed to export metrics', error);\n    }\n  }\n\n  private initializeDefaultAlertRules(): void {\n    const rules: AlertRule[] = [\n      {\n        id: 'cpu-warning',\n        name: 'High CPU Usage',\n        enabled: true,\n        metric: 'system.cpu',\n        condition: 'gt',\n        threshold: this.config.alertThresholds.cpu.warning,\n        duration: 60000,\n        severity: 'warning',\n        tags: { category: 'system' },\n        actions: [{ type: 'log', config: {}, enabled: true }],\n        suppressions: [],\n      },\n      {\n        id: 'memory-critical',\n        name: 'Critical Memory Usage',\n        enabled: true,\n        metric: 'system.memory',\n        condition: 'gt',\n        threshold: this.config.alertThresholds.memory.critical,\n        duration: 30000,\n        severity: 'critical',\n        tags: { category: 'system' },\n        actions: [\n          { type: 'log', config: {}, enabled: true },\n          { type: 'auto-scale', config: { action: 'scale-down' }, enabled: true },\n        ],\n        suppressions: [],\n      },\n    ];\n\n    rules.forEach((rule) => this.alertRules.set(rule.id, rule));\n  }\n\n  private initializeDefaultDashboards(): void {\n    const systemDashboard = this.createDashboard('System Overview', [\n      {\n        id: 'cpu-panel',\n        title: 'CPU Usage',\n        type: 'line',\n        metrics: ['system.cpu'],\n        config: {\n          width: 6,\n          height: 4,\n          position: { x: 0, y: 0 },\n          visualization: { yAxis: { max: 100 } },\n        },\n      },\n      {\n        id: 'memory-panel',\n        title: 'Memory Usage',\n        type: 'gauge',\n        metrics: ['system.memory'],\n        config: {\n          width: 6,\n          height: 4,\n          position: { x: 6, y: 0 },\n          visualization: { max: 100, threshold: [70, 90] },\n        },\n      },\n    ]);\n\n    this.logger.info('Created default dashboard', { dashboardId: systemDashboard });\n  }\n\n  private initializeHealthChecks(): void {\n    // Add default health checks\n    this.healthChecks.set('system', {\n      name: 'system',\n      type: 'custom',\n      target: 'local',\n      interval: 30000,\n      timeout: 5000,\n      retries: 3,\n      customCheck: async () => {\n        // Basic system health check\n        return this.systemMetrics.cpuUsage < 95 && this.systemMetrics.memoryUsage < 95;\n      },\n    });\n  }\n\n  private async performHttpHealthCheck(check: HealthCheck): Promise<boolean> {\n    // Placeholder for HTTP health check\n    return true;\n  }\n\n  private async performTcpHealthCheck(check: HealthCheck): Promise<boolean> {\n    // Placeholder for TCP health check\n    return true;\n  }\n\n  private async sendEmailAlert(alert: Alert, config: any): Promise<void> {\n    // Placeholder for email alert\n    this.logger.info('Email alert sent', { alertId: alert.id });\n  }\n\n  private async sendWebhookAlert(alert: Alert, config: any): Promise<void> {\n    // Placeholder for webhook alert\n    this.logger.info('Webhook alert sent', { alertId: alert.id });\n  }\n\n  private async triggerAutoScale(alert: Alert, config: any): Promise<void> {\n    // Placeholder for auto-scaling\n    this.logger.info('Auto-scale triggered', { alertId: alert.id, action: config.action });\n    this.eventBus.emit('autoscale:triggered', { alert, config });\n  }\n\n  private async triggerRestart(alert: Alert, config: any): Promise<void> {\n    // Placeholder for restart action\n    this.logger.info('Restart triggered', { alertId: alert.id });\n    this.eventBus.emit('restart:triggered', { alert, config });\n  }\n\n  private initializeSystemMetrics(): SystemMetrics {\n    return {\n      timestamp: new Date(),\n      cpuUsage: 0,\n      memoryUsage: 0,\n      diskUsage: 0,\n      networkUsage: 0,\n      activeSwarms: 0,\n      totalAgents: 0,\n      activeAgents: 0,\n      totalTasks: 0,\n      runningTasks: 0,\n      throughput: 0,\n      latency: 0,\n      errorRate: 0,\n      successRate: 100,\n      resourceUtilization: {},\n      queueLengths: {},\n    };\n  }\n\n  private initializeSwarmMetrics(): SwarmMetrics {\n    return {\n      throughput: 0,\n      latency: 0,\n      efficiency: 1.0,\n      reliability: 1.0,\n      averageQuality: 0.8,\n      defectRate: 0,\n      reworkRate: 0,\n      resourceUtilization: {},\n      costEfficiency: 1.0,\n      agentUtilization: 0,\n      agentSatisfaction: 0.8,\n      collaborationEffectiveness: 0.8,\n      scheduleVariance: 0,\n      deadlineAdherence: 1.0,\n    };\n  }\n\n  // === PUBLIC API ===\n\n  getSystemMetrics(): SystemMetrics {\n    return { ...this.systemMetrics };\n  }\n\n  getSwarmMetrics(): SwarmMetrics {\n    return { ...this.swarmMetrics };\n  }\n\n  getActiveAlerts(): Alert[] {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  getAlertHistory(limit: number = 100): Alert[] {\n    return this.alertHistory.slice(-limit);\n  }\n\n  getTimeSeries(metricName: string): TimeSeries | undefined {\n    return this.timeSeries.get(metricName);\n  }\n\n  getAllTimeSeries(): TimeSeries[] {\n    return Array.from(this.timeSeries.values());\n  }\n\n  acknowledgeAlert(alertId: string, acknowledgedBy: string): void {\n    const alert = this.activeAlerts.get(alertId);\n    if (alert) {\n      alert.acknowledged = true;\n      alert.assignedTo = acknowledgedBy;\n      this.emit('alert:acknowledged', { alert, acknowledgedBy });\n    }\n  }\n\n  createAlertRule(rule: Omit<AlertRule, 'id'>): string {\n    const ruleId = `rule-${Date.now()}`;\n    this.alertRules.set(ruleId, { ...rule, id: ruleId });\n    return ruleId;\n  }\n\n  updateAlertRule(ruleId: string, updates: Partial<AlertRule>): void {\n    const rule = this.alertRules.get(ruleId);\n    if (rule) {\n      this.alertRules.set(ruleId, { ...rule, ...updates });\n    }\n  }\n\n  deleteAlertRule(ruleId: string): void {\n    this.alertRules.delete(ruleId);\n  }\n\n  getAlertRules(): AlertRule[] {\n    return Array.from(this.alertRules.values());\n  }\n\n  getMonitoringStatistics(): {\n    metricsCount: number;\n    activeAlerts: number;\n    alertRules: number;\n    healthChecks: number;\n    dashboards: number;\n    uptime: number;\n  } {\n    return {\n      metricsCount: this.timeSeries.size,\n      activeAlerts: this.activeAlerts.size,\n      alertRules: this.alertRules.size,\n      healthChecks: this.healthChecks.size,\n      dashboards: this.dashboards.size,\n      uptime: Date.now() - this.lastMetricsUpdate.getTime(),\n    };\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,yBAA6B;AAwHtB,MAAM,wBAAwB,gCAAa;AAAA,EA5HlD,OA4HkD;AAAA;AAAA;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA,aAAa,oBAAI,IAAwB;AAAA,EACzC,eAAe,oBAAI,IAAmB;AAAA,EACtC,eAAwB,CAAC;AAAA;AAAA,EAGzB;AAAA,EACA;AAAA,EACA,aAAa,oBAAI,IAAuB;AAAA,EACxC,eAAe,oBAAI,IAAyB;AAAA;AAAA,EAG5C;AAAA,EACA,eAAe,oBAAI,IAA0B;AAAA,EAC7C;AAAA;AAAA,EAGA,aAAa,oBAAI,IAAiC;AAAA;AAAA,EAGlD,oBAAoB,oBAAI,KAAK;AAAA,EAC7B,gBAA+B,CAAC;AAAA,EAChC;AAAA,EAER,YACE,QACA,QACA,UACA,QACA;AACA,UAAM;AACN,SAAK,SAAS;AACd,SAAK,WAAW;AAChB,SAAK,SAAS;AAEd,SAAK,SAAS;AAAA,MACZ,gBAAgB;AAAA,MAChB,iBAAiB;AAAA;AAAA,MACjB,iBAAiB;AAAA,MACjB,iBAAiB;AAAA,QACf,KAAK,EAAE,SAAS,IAAI,UAAU,GAAG;AAAA,QACjC,QAAQ,EAAE,SAAS,IAAI,UAAU,GAAG;AAAA,QACpC,MAAM,EAAE,SAAS,IAAI,UAAU,GAAG;AAAA,QAClC,WAAW,EAAE,SAAS,GAAG,UAAU,GAAG;AAAA,QACtC,cAAc,EAAE,SAAS,KAAM,UAAU,IAAM;AAAA,QAC/C,YAAY,EAAE,SAAS,IAAI,UAAU,GAAG;AAAA,QACxC,aAAa,EAAE,SAAS,KAAK,UAAU,IAAI;AAAA,QAC3C,kBAAkB,EAAE,SAAS,KAAK,UAAU,KAAK;AAAA,MACnD;AAAA,MACA,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,MAChB,kBAAkB;AAAA,MAClB,eAAe;AAAA,MACf,cAAc;AAAA,MACd,WAAW;AAAA,MACX,GAAG;AAAA,IACL;AAEA,SAAK,gBAAgB,KAAK,wBAAwB;AAClD,SAAK,eAAe,KAAK,uBAAuB;AAEhD,SAAK,mBAAmB;AACxB,SAAK,4BAA4B;AACjC,SAAK,4BAA4B;AAAA,EACnC;AAAA,EAEQ,qBAA2B;AAEjC,SAAK,SAAS,GAAG,wBAAwB,CAAC,SAAS;AACjD,WAAK,mBAAmB,KAAK,SAAS,KAAK,OAAO;AAAA,IACpD,CAAC;AAED,SAAK,SAAS,GAAG,wBAAwB,CAAC,SAAS;AACjD,WAAK,aAAa,uBAAuB,GAAG;AAAA,QAC1C,SAAS,KAAK;AAAA,QACd,MAAM,KAAK;AAAA,QACX,IAAI,KAAK;AAAA,MACX,CAAC;AAAA,IACH,CAAC;AAGD,SAAK,SAAS,GAAG,gBAAgB,CAAC,SAAS;AACzC,WAAK,aAAa,gBAAgB,GAAG,EAAE,QAAQ,KAAK,QAAQ,SAAS,KAAK,QAAQ,CAAC;AAAA,IACrF,CAAC;AAED,SAAK,SAAS,GAAG,kBAAkB,CAAC,SAAS;AAC3C,WAAK,aAAa,kBAAkB,GAAG,EAAE,QAAQ,KAAK,OAAO,CAAC;AAC9D,WAAK,aAAa,iBAAiB,KAAK,UAAU,EAAE,QAAQ,KAAK,OAAO,CAAC;AAAA,IAC3E,CAAC;AAED,SAAK,SAAS,GAAG,eAAe,CAAC,SAAS;AACxC,WAAK,aAAa,eAAe,GAAG,EAAE,QAAQ,KAAK,QAAQ,OAAO,KAAK,MAAM,CAAC;AAAA,IAChF,CAAC;AAGD,SAAK,SAAS,GAAG,0BAA0B,CAAC,SAAS;AACnD,WAAK,oBAAoB,IAAI;AAAA,IAC/B,CAAC;AAED,SAAK,SAAS,GAAG,wBAAwB,CAAC,SAAS;AACjD,WAAK,mBAAmB,KAAK,OAAO;AAAA,IACtC,CAAC;AAGD,SAAK,SAAS,GAAG,SAAS,CAAC,SAAS;AAClC,WAAK,YAAY,IAAI;AAAA,IACvB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,aAA4B;AAChC,SAAK,OAAO,KAAK,kCAAkC;AAAA,MACjD,gBAAgB,KAAK,OAAO;AAAA,MAC5B,UAAU,KAAK,OAAO;AAAA,MACtB,WAAW,KAAK,OAAO;AAAA,IACzB,CAAC;AAGD,SAAK,uBAAuB;AAC5B,SAAK,kBAAkB;AAEvB,QAAI,KAAK,OAAO,iBAAiB;AAC/B,WAAK,qBAAqB;AAAA,IAC5B;AAGA,SAAK,uBAAuB;AAE5B,SAAK,KAAK,qBAAqB;AAAA,EACjC;AAAA,EAEA,MAAM,WAA0B;AAC9B,SAAK,OAAO,KAAK,iCAAiC;AAGlD,QAAI,KAAK;AAAoB,oBAAc,KAAK,kBAAkB;AAClE,QAAI,KAAK;AAAqB,oBAAc,KAAK,mBAAmB;AACpE,QAAI,KAAK;AAAgB,oBAAc,KAAK,cAAc;AAG1D,UAAM,KAAK,aAAa;AAExB,SAAK,KAAK,kBAAkB;AAAA,EAC9B;AAAA;AAAA,EAIQ,yBAA+B;AACrC,SAAK,qBAAqB,YAAY,MAAM;AAC1C,WAAK,qBAAqB;AAC1B,WAAK,qBAAqB;AAC1B,WAAK,kBAAkB;AAAA,IACzB,GAAG,KAAK,OAAO,cAAc;AAE7B,SAAK,OAAO,KAAK,8BAA8B;AAAA,MAC7C,UAAU,KAAK,OAAO;AAAA,IACxB,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,uBAAsC;AAClD,QAAI;AAEF,WAAK,gBAAgB;AAAA,QACnB,GAAG,KAAK;AAAA,QACR,WAAW,oBAAI,KAAK;AAAA,QACpB,UAAU,MAAM,KAAK,YAAY;AAAA,QACjC,aAAa,MAAM,KAAK,eAAe;AAAA,QACvC,WAAW,MAAM,KAAK,aAAa;AAAA,QACnC,cAAc,MAAM,KAAK,gBAAgB;AAAA,MAC3C;AAGA,WAAK,aAAa,cAAc,KAAK,cAAc,QAAQ;AAC3D,WAAK,aAAa,iBAAiB,KAAK,cAAc,WAAW;AACjE,WAAK,aAAa,eAAe,KAAK,cAAc,SAAS;AAC7D,WAAK,aAAa,kBAAkB,KAAK,cAAc,YAAY;AAGnE,YAAM,KAAK,wBAAwB;AAAA,IACrC,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,oCAAoC,KAAK;AAAA,IAC7D;AAAA,EACF;AAAA,EAEA,MAAc,0BAAyC;AACrD,UAAM,SAAS,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAEpD,SAAK,eAAe;AAAA,MAClB,GAAG,KAAK;AAAA,MACR,kBAAkB,KAAK,0BAA0B,MAAM;AAAA,MACvD,YAAY,KAAK,yBAAyB,MAAM;AAAA,MAChD,SAAS,KAAK,wBAAwB,MAAM;AAAA,MAC5C,YAAY,KAAK,yBAAyB,MAAM;AAAA,MAChD,aAAa,KAAK,0BAA0B,MAAM;AAAA,MAClD,gBAAgB,KAAK,wBAAwB,MAAM;AAAA,IACrD;AAGA,SAAK,aAAa,qBAAqB,KAAK,aAAa,gBAAgB;AACzE,SAAK,aAAa,oBAAoB,KAAK,aAAa,UAAU;AAClE,SAAK,aAAa,iBAAiB,KAAK,aAAa,OAAO;AAC5D,SAAK,aAAa,oBAAoB,KAAK,aAAa,UAAU;AAClE,SAAK,aAAa,qBAAqB,KAAK,aAAa,WAAW;AAAA,EACtE;AAAA,EAEA,aAAa,MAAc,OAAe,OAA+B,CAAC,GAAS;AACjF,UAAM,QAAqB;AAAA,MACzB,WAAW,oBAAI,KAAK;AAAA,MACpB;AAAA,MACA;AAAA,IACF;AAGA,SAAK,cAAc,KAAK,EAAE,GAAG,OAAO,MAAM,EAAE,GAAG,MAAM,QAAQ,KAAK,EAAE,CAAC;AAGrE,QAAI,KAAK,iBAAiB,IAAI,GAAG;AAC/B,WAAK,mBAAmB,MAAM,KAAK;AAAA,IACrC;AAAA,EACF;AAAA,EAEQ,uBAA6B;AACnC,QAAI,KAAK,cAAc,WAAW;AAAG;AAGrC,UAAM,eAAe,oBAAI,IAA2B;AACpD,eAAW,SAAS,KAAK,eAAe;AACtC,YAAM,aAAa,MAAM,KAAK,UAAU;AACxC,YAAM,QAAQ,aAAa,IAAI,UAAU,KAAK,CAAC;AAC/C,YAAM,KAAK,KAAK;AAChB,mBAAa,IAAI,YAAY,KAAK;AAAA,IACpC;AAGA,eAAW,CAAC,YAAY,MAAM,KAAK,cAAc;AAC/C,iBAAW,SAAS,QAAQ;AAC1B,aAAK,mBAAmB,YAAY,KAAK;AAAA,MAC3C;AAAA,IACF;AAGA,SAAK,gBAAgB,CAAC;AAAA,EACxB;AAAA,EAEQ,mBAAmB,YAAoB,OAA0B;AACvE,QAAI,SAAS,KAAK,WAAW,IAAI,UAAU;AAE3C,QAAI,CAAC,QAAQ;AACX,eAAS;AAAA,QACP,MAAM;AAAA,QACN,QAAQ,CAAC;AAAA,QACT,cAAc;AAAA,UACZ,KAAK,MAAM;AAAA,UACX,KAAK,MAAM;AAAA,UACX,KAAK,MAAM;AAAA,UACX,KAAK,MAAM;AAAA,UACX,OAAO;AAAA,QACT;AAAA,QACA,aAAa,MAAM;AAAA,MACrB;AACA,WAAK,WAAW,IAAI,YAAY,MAAM;AAAA,IACxC;AAGA,WAAO,OAAO,KAAK,KAAK;AACxB,WAAO,cAAc,MAAM;AAG3B,WAAO,aAAa;AACpB,WAAO,aAAa,OAAO,MAAM;AACjC,WAAO,aAAa,MAAM,OAAO,aAAa,MAAM,OAAO,aAAa;AACxE,WAAO,aAAa,MAAM,KAAK,IAAI,OAAO,aAAa,KAAK,MAAM,KAAK;AACvE,WAAO,aAAa,MAAM,KAAK,IAAI,OAAO,aAAa,KAAK,MAAM,KAAK;AAGvE,QAAI,KAAK,OAAO,iBAAiB;AAC/B,WAAK,qBAAqB,YAAY,KAAK;AAAA,IAC7C;AAAA,EACF;AAAA;AAAA,EAIQ,uBAA6B;AACnC,SAAK,iBAAiB,YAAY,MAAM;AACtC,WAAK,cAAc;AAAA,IACrB,GAAG,GAAI;AAEP,SAAK,OAAO,KAAK,0BAA0B;AAAA,EAC7C;AAAA,EAEQ,gBAAsB;AAC5B,UAAM,MAAM,oBAAI,KAAK;AAGrB,eAAW,CAAC,SAAS,KAAK,KAAK,KAAK,cAAc;AAChD,UAAI,CAAC,MAAM,UAAU;AACnB,cAAM,OAAO,KAAK,WAAW,IAAI,MAAM,QAAQ,MAAM;AACrD,YAAI,QAAQ,KAAK,gBAAgB,MAAM,KAAK,GAAG;AAC7C,eAAK,aAAa,SAAS,oBAAoB;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAGA,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEQ,qBAAqB,YAAoB,OAA0B;AACzE,eAAW,CAAC,QAAQ,IAAI,KAAK,KAAK,YAAY;AAC5C,UAAI,KAAK,WAAW,KAAK,WAAW,YAAY;AAC9C,aAAK,kBAAkB,MAAM,KAAK;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,kBAAkB,MAAiB,OAA0B;AACnE,UAAM,eAAe,KAAK,kBAAkB,KAAK,WAAW,MAAM,OAAO,KAAK,SAAS;AAEvF,QAAI,cAAc;AAEhB,YAAM,gBAAgB,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC,EAAE;AAAA,QAC3D,CAAC,UAAU,MAAM,QAAQ,WAAW,KAAK,MAAM,CAAC,MAAM;AAAA,MACxD;AAEA,UAAI,CAAC,eAAe;AAClB,aAAK,YAAY,MAAM,KAAK;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,YAAY,MAAiB,iBAAoC;AACvE,UAAM,UAAU,SAAS,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAE1E,UAAM,QAAe;AAAA,MACnB,IAAI;AAAA,MACJ,WAAW,oBAAI,KAAK;AAAA,MACpB,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK,uBAAuB,KAAK,MAAM;AAAA,MAC7C,SAAS,GAAG,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,KAAK,SAAS,IAAI,KAAK,SAAS,cAAc,gBAAgB,KAAK;AAAA,MAC5G,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,QAAQ,KAAK;AAAA,QACb,QAAQ,KAAK;AAAA,QACb,OAAO,gBAAgB;AAAA,QACvB,WAAW,KAAK;AAAA,QAChB,MAAM,EAAE,GAAG,KAAK,MAAM,GAAG,gBAAgB,KAAK;AAAA,MAChD;AAAA,MACA,cAAc;AAAA,MACd,UAAU;AAAA,MACV,iBAAiB;AAAA,IACnB;AAEA,SAAK,aAAa,IAAI,SAAS,KAAK;AACpC,SAAK,aAAa,KAAK,KAAK;AAE5B,SAAK,OAAO,KAAK,iBAAiB;AAAA,MAChC;AAAA,MACA,MAAM,KAAK;AAAA,MACX,QAAQ,KAAK;AAAA,MACb,OAAO,gBAAgB;AAAA,MACvB,WAAW,KAAK;AAAA,IAClB,CAAC;AAED,SAAK,KAAK,iBAAiB,EAAE,MAAM,CAAC;AAGpC,SAAK,oBAAoB,MAAM,KAAK;AAAA,EACtC;AAAA,EAEQ,oBAAoB,MAAiB,OAAoB;AAC/D,eAAW,UAAU,KAAK,SAAS;AACjC,UAAI,CAAC,OAAO;AAAS;AAErB,UAAI;AACF,gBAAQ,OAAO,MAAM;AAAA,UACnB,KAAK;AACH,iBAAK,OAAO,KAAK,UAAU,MAAM,OAAO,IAAI,MAAM,OAAO;AACzD;AAAA,UAEF,KAAK;AACH,iBAAK,eAAe,OAAO,OAAO,MAAM;AACxC;AAAA,UAEF,KAAK;AACH,iBAAK,iBAAiB,OAAO,OAAO,MAAM;AAC1C;AAAA,UAEF,KAAK;AACH,iBAAK,iBAAiB,OAAO,OAAO,MAAM;AAC1C;AAAA,UAEF,KAAK;AACH,iBAAK,eAAe,OAAO,OAAO,MAAM;AACxC;AAAA,UAEF;AACE,iBAAK,OAAO,KAAK,6BAA6B,EAAE,MAAM,OAAO,KAAK,CAAC;AAAA,QACvE;AAAA,MACF,SAAS,OAAO;AACd,aAAK,OAAO,MAAM,kCAAkC;AAAA,UAClD,SAAS,MAAM;AAAA,UACf,YAAY,OAAO;AAAA,UACnB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,aAAa,SAAiB,QAAsB;AAC1D,UAAM,QAAQ,KAAK,aAAa,IAAI,OAAO;AAC3C,QAAI,CAAC;AAAO;AAEZ,UAAM,WAAW;AACjB,UAAM,QAAQ,mBAAmB;AACjC,UAAM,QAAQ,aAAa,oBAAI,KAAK;AAEpC,SAAK,OAAO,KAAK,kBAAkB,EAAE,SAAS,OAAO,CAAC;AACtD,SAAK,KAAK,kBAAkB,EAAE,OAAO,OAAO,CAAC;AAAA,EAC/C;AAAA;AAAA,EAIQ,oBAA0B;AAChC,SAAK,sBAAsB,YAAY,MAAM;AAC3C,WAAK,oBAAoB;AAAA,IAC3B,GAAG,GAAK;AAER,SAAK,OAAO,KAAK,uBAAuB;AAAA,EAC1C;AAAA,EAEA,MAAc,sBAAqC;AACjD,UAAM,SAAS,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AACpD,UAAM,WAAW,OAAO,IAAI,CAAC,UAAU,KAAK,mBAAmB,KAAK,CAAC;AAErE,UAAM,QAAQ,WAAW,QAAQ;AAAA,EACnC;AAAA,EAEA,MAAc,mBAAmB,OAAmC;AAClE,QAAI;AACF,UAAI,YAAY;AAEhB,cAAQ,MAAM,MAAM;AAAA,QAClB,KAAK;AACH,sBAAY,MAAM,KAAK,uBAAuB,KAAK;AACnD;AAAA,QACF,KAAK;AACH,sBAAY,MAAM,KAAK,sBAAsB,KAAK;AAClD;AAAA,QACF,KAAK;AACH,cAAI,MAAM,aAAa;AACrB,wBAAY,MAAM,MAAM,YAAY;AAAA,UACtC;AACA;AAAA,MACJ;AAEA,WAAK,aAAa,eAAe,MAAM,IAAI,IAAI,YAAY,IAAI,GAAG;AAAA,QAChE,MAAM,MAAM;AAAA,QACZ,QAAQ,MAAM;AAAA,MAChB,CAAC;AAAA,IACH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,uBAAuB,EAAE,OAAO,MAAM,MAAM,MAAM,CAAC;AACrE,WAAK,aAAa,eAAe,MAAM,IAAI,IAAI,GAAG;AAAA,QAChD,MAAM,MAAM;AAAA,QACZ,QAAQ,MAAM;AAAA,QACd,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA,EAIA,gBAAgB,OAAe,QAAkC;AAC/D,UAAM,cAAc,aAAa,KAAK,IAAI,CAAC;AAE3C,UAAM,YAAiC;AAAA,MACrC;AAAA,MACA;AAAA,MACA,iBAAiB;AAAA,MACjB,WAAW;AAAA,QACT,OAAO,IAAI,KAAK,KAAK,IAAI,IAAI,IAAO;AAAA;AAAA,QACpC,KAAK,oBAAI,KAAK;AAAA,MAChB;AAAA,MACA,SAAS,CAAC;AAAA,IACZ;AAEA,SAAK,WAAW,IAAI,aAAa,SAAS;AAC1C,SAAK,KAAK,qBAAqB,EAAE,aAAa,UAAU,CAAC;AAEzD,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,aAA0B;AACzC,UAAM,YAAY,KAAK,WAAW,IAAI,WAAW;AACjD,QAAI,CAAC;AAAW,aAAO;AAEvB,UAAM,OAAY;AAAA,MAChB;AAAA,MACA,QAAQ,CAAC;AAAA,IACX;AAEA,eAAW,SAAS,UAAU,QAAQ;AACpC,YAAM,YAAY;AAAA,QAChB,IAAI,MAAM;AAAA,QACV,OAAO,MAAM;AAAA,QACb,MAAM,MAAM;AAAA,QACZ,MAAM,KAAK,aAAa,OAAO,UAAU,SAAS;AAAA,MACpD;AACA,WAAK,OAAO,KAAK,SAAS;AAAA,IAC5B;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa,OAAuB,WAA4C;AACtF,UAAM,OAAY,CAAC;AAEnB,eAAW,cAAc,MAAM,SAAS;AACtC,YAAM,SAAS,KAAK,WAAW,IAAI,UAAU;AAC7C,UAAI,QAAQ;AAEV,cAAM,iBAAiB,OAAO,OAAO;AAAA,UACnC,CAAC,UAAU,MAAM,aAAa,UAAU,SAAS,MAAM,aAAa,UAAU;AAAA,QAChF;AAEA,aAAK,UAAU,IAAI;AAAA,UACjB,QAAQ;AAAA,UACR,cAAc,KAAK,sBAAsB,cAAc;AAAA,QACzD;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAIA,MAAc,cAA+B;AAE3C,WAAO,KAAK,OAAO,IAAI;AAAA,EACzB;AAAA,EAEA,MAAc,iBAAkC;AAE9C,WAAO,KAAK,OAAO,IAAI;AAAA,EACzB;AAAA,EAEA,MAAc,eAAgC;AAE5C,WAAO,KAAK,OAAO,IAAI;AAAA,EACzB;AAAA,EAEA,MAAc,kBAAmC;AAE/C,WAAO,KAAK,OAAO,IAAI,OAAO;AAAA,EAChC;AAAA,EAEQ,mBAAmB,SAAiB,SAA6B;AACvE,SAAK,aAAa,IAAI,SAAS,OAAO;AAGtC,SAAK,aAAa,aAAa,QAAQ,UAAU,EAAE,QAAQ,CAAC;AAC5D,SAAK,aAAa,gBAAgB,QAAQ,aAAa,EAAE,QAAQ,CAAC;AAClE,SAAK,aAAa,yBAAyB,QAAQ,gBAAgB,EAAE,QAAQ,CAAC;AAC9E,SAAK,aAAa,sBAAsB,QAAQ,aAAa,EAAE,QAAQ,CAAC;AACxE,SAAK,aAAa,uBAAuB,QAAQ,cAAc,EAAE,QAAQ,CAAC;AAAA,EAC5E;AAAA,EAEQ,oBAAoB,MAAoC;AAC9D,SAAK,gBAAgB,EAAE,GAAG,KAAK,eAAe,GAAG,KAAK;AAAA,EACxD;AAAA,EAEQ,mBAAmB,SAA6B;AACtD,SAAK,eAAe,EAAE,GAAG,KAAK,cAAc,GAAG,QAAQ;AAAA,EACzD;AAAA,EAEQ,YAAY,MAAiB;AACnC,SAAK,aAAa,eAAe,GAAG;AAAA,MAClC,MAAM,KAAK,QAAQ;AAAA,MACnB,QAAQ,KAAK,UAAU;AAAA,IACzB,CAAC;AAGD,QAAI,KAAK,aAAa,YAAY;AAChC,YAAM,UAAU,eAAe,KAAK,IAAI,CAAC;AACzC,YAAM,QAAe;AAAA,QACnB,IAAI;AAAA,QACJ,WAAW,oBAAI,KAAK;AAAA,QACpB,OAAO;AAAA,QACP,MAAM;AAAA,QACN,SAAS,mBAAmB,KAAK,OAAO;AAAA,QACxC,QAAQ,KAAK,UAAU;AAAA,QACvB,SAAS;AAAA,QACT,cAAc;AAAA,QACd,UAAU;AAAA,QACV,iBAAiB;AAAA,MACnB;AAEA,WAAK,aAAa,IAAI,SAAS,KAAK;AACpC,WAAK,KAAK,iBAAiB,EAAE,MAAM,CAAC;AAAA,IACtC;AAAA,EACF;AAAA,EAEQ,iBAAiB,MAAuB;AAC9C,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,gBAAgB,SAAS,IAAI;AAAA,EACtC;AAAA,EAEQ,kBAAkB,WAAmB,OAAe,WAA4B;AACtF,YAAQ,WAAW;AAAA,MACjB,KAAK;AACH,eAAO,QAAQ;AAAA,MACjB,KAAK;AACH,eAAO,SAAS;AAAA,MAClB,KAAK;AACH,eAAO,QAAQ;AAAA,MACjB,KAAK;AACH,eAAO,SAAS;AAAA,MAClB,KAAK;AACH,eAAO,UAAU;AAAA,MACnB;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEQ,gBAAgB,MAAiB,OAAuB;AAE9D,UAAM,SAAS,KAAK,WAAW,IAAI,KAAK,MAAM;AAC9C,QAAI,CAAC,UAAU,OAAO,OAAO,WAAW;AAAG,aAAO;AAGlD,UAAM,eAAe,OAAO,OAAO,MAAM,EAAE;AAC3C,UAAM,cAAc,aAAa;AAAA,MAC/B,CAAC,UAAU,CAAC,KAAK,kBAAkB,KAAK,WAAW,MAAM,OAAO,KAAK,SAAS;AAAA,IAChF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,uBAAuB,QAA2B;AACxD,QAAI,OAAO,SAAS,QAAQ;AAAG,aAAO;AACtC,QAAI,OAAO,SAAS,OAAO;AAAG,aAAO;AACrC,QAAI,OAAO,SAAS,MAAM;AAAG,aAAO;AACpC,QAAI,OAAO,SAAS,OAAO;AAAG,aAAO;AACrC,QAAI,OAAO,SAAS,aAAa;AAAG,aAAO;AAC3C,QAAI,OAAO,SAAS,UAAU;AAAG,aAAO;AACxC,WAAO;AAAA,EACT;AAAA,EAEQ,0BAA0B,QAAgC;AAChE,QAAI,OAAO,WAAW;AAAG,aAAO;AAChC,UAAM,mBAAmB,OAAO,OAAO,CAAC,KAAK,UAAU,MAAM,MAAM,UAAU,CAAC;AAC9E,WAAO,mBAAmB,OAAO;AAAA,EACnC;AAAA,EAEQ,yBAAyB,QAAgC;AAC/D,WAAO,OAAO,OAAO,CAAC,KAAK,UAAU,OAAO,MAAM,kBAAkB,IAAI,CAAC;AAAA,EAC3E;AAAA,EAEQ,wBAAwB,QAAgC;AAC9D,QAAI,OAAO,WAAW;AAAG,aAAO;AAChC,UAAM,eAAe,OAAO,OAAO,CAAC,KAAK,UAAU,MAAM,MAAM,cAAc,CAAC;AAC9E,WAAO,eAAe,OAAO;AAAA,EAC/B;AAAA,EAEQ,yBAAyB,QAAgC;AAC/D,QAAI,OAAO,WAAW;AAAG,aAAO;AAChC,UAAM,aAAa,OAAO;AAAA,MACxB,CAAC,KAAK,UAAU,OAAO,MAAM,kBAAkB,MAAM,MAAM,eAAe;AAAA,MAC1E;AAAA,IACF;AACA,UAAM,iBAAiB,OAAO,OAAO,CAAC,KAAK,UAAU,OAAO,MAAM,kBAAkB,IAAI,CAAC;AACzF,WAAO,aAAa,IAAI,iBAAiB,aAAa;AAAA,EACxD;AAAA,EAEQ,0BAA0B,QAAgC;AAChE,QAAI,OAAO,WAAW;AAAG,aAAO;AAChC,UAAM,mBAAmB,OAAO,OAAO,CAAC,KAAK,UAAU,OAAO,MAAM,eAAe,IAAI,CAAC;AACxF,WAAO,mBAAmB,OAAO;AAAA,EACnC;AAAA,EAEQ,wBAAwB,QAAgC;AAC9D,QAAI,OAAO,WAAW;AAAG,aAAO;AAChC,UAAM,eAAe,OAAO,OAAO,CAAC,KAAK,UAAU,OAAO,MAAM,eAAe,MAAM,CAAC;AACtF,WAAO,eAAe,OAAO;AAAA,EAC/B;AAAA,EAEQ,sBAAsB,QAA4B;AACxD,QAAI,OAAO,WAAW,GAAG;AACvB,aAAO,EAAE,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE;AAAA,IACpD;AAEA,UAAM,SAAS,OAAO,IAAI,CAAC,MAAM,EAAE,KAAK;AACxC,WAAO;AAAA,MACL,KAAK,KAAK,IAAI,GAAG,MAAM;AAAA,MACvB,KAAK,KAAK,IAAI,GAAG,MAAM;AAAA,MACvB,KAAK,OAAO,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC,IAAI,OAAO;AAAA,MACxD,KAAK,OAAO,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC;AAAA,MAC7C,OAAO,OAAO;AAAA,IAChB;AAAA,EACF;AAAA,EAEQ,oBAA0B;AAChC,UAAM,SAAS,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,OAAO,eAAe;AAEhE,eAAW,CAAC,MAAM,MAAM,KAAK,KAAK,YAAY;AAC5C,aAAO,SAAS,OAAO,OAAO,OAAO,CAAC,UAAU,MAAM,YAAY,MAAM;AAExE,UAAI,OAAO,OAAO,WAAW,GAAG;AAC9B,aAAK,WAAW,OAAO,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,wBAA8B;AACpC,UAAM,SAAS,IAAI,KAAK,KAAK,IAAI,IAAI,KAAQ;AAG7C,eAAW,CAAC,SAAS,KAAK,KAAK,KAAK,cAAc;AAChD,UAAI,MAAM,YAAY,MAAM,YAAY,QAAQ;AAC9C,aAAK,aAAa,OAAO,OAAO;AAAA,MAClC;AAAA,IACF;AAGA,SAAK,eAAe,KAAK,aAAa,OAAO,CAAC,UAAU,MAAM,YAAY,MAAM,EAAE,MAAM,IAAK;AAAA,EAC/F;AAAA,EAEA,MAAc,eAA8B;AAC1C,QAAI,KAAK,cAAc,SAAS,GAAG;AACjC,WAAK,qBAAqB;AAAA,IAC5B;AAGA,QAAI,KAAK,OAAO,eAAe;AAC7B,YAAM,KAAK,cAAc;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,MAAc,gBAA+B;AAC3C,QAAI;AACF,YAAM,aAAa;AAAA,QACjB,WAAW,oBAAI,KAAK;AAAA,QACpB,YAAY,MAAM,KAAK,KAAK,WAAW,QAAQ,CAAC;AAAA,QAChD,eAAe,KAAK;AAAA,QACpB,cAAc,KAAK;AAAA,QACnB,cAAc,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAAA,MACrD;AAEA,YAAM,KAAK,OAAO,MAAM,qBAAqB,YAAY;AAAA,QACvD,MAAM;AAAA,QACN,WAAW;AAAA,MACb,CAAC;AAAA,IACH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,4BAA4B,KAAK;AAAA,IACrD;AAAA,EACF;AAAA,EAEQ,8BAAoC;AAC1C,UAAM,QAAqB;AAAA,MACzB;AAAA,QACE,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,WAAW,KAAK,OAAO,gBAAgB,IAAI;AAAA,QAC3C,UAAU;AAAA,QACV,UAAU;AAAA,QACV,MAAM,EAAE,UAAU,SAAS;AAAA,QAC3B,SAAS,CAAC,EAAE,MAAM,OAAO,QAAQ,CAAC,GAAG,SAAS,KAAK,CAAC;AAAA,QACpD,cAAc,CAAC;AAAA,MACjB;AAAA,MACA;AAAA,QACE,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,WAAW,KAAK,OAAO,gBAAgB,OAAO;AAAA,QAC9C,UAAU;AAAA,QACV,UAAU;AAAA,QACV,MAAM,EAAE,UAAU,SAAS;AAAA,QAC3B,SAAS;AAAA,UACP,EAAE,MAAM,OAAO,QAAQ,CAAC,GAAG,SAAS,KAAK;AAAA,UACzC,EAAE,MAAM,cAAc,QAAQ,EAAE,QAAQ,aAAa,GAAG,SAAS,KAAK;AAAA,QACxE;AAAA,QACA,cAAc,CAAC;AAAA,MACjB;AAAA,IACF;AAEA,UAAM,QAAQ,CAAC,SAAS,KAAK,WAAW,IAAI,KAAK,IAAI,IAAI,CAAC;AAAA,EAC5D;AAAA,EAEQ,8BAAoC;AAC1C,UAAM,kBAAkB,KAAK,gBAAgB,mBAAmB;AAAA,MAC9D;AAAA,QACE,IAAI;AAAA,QACJ,OAAO;AAAA,QACP,MAAM;AAAA,QACN,SAAS,CAAC,YAAY;AAAA,QACtB,QAAQ;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,UAAU,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,UACvB,eAAe,EAAE,OAAO,EAAE,KAAK,IAAI,EAAE;AAAA,QACvC;AAAA,MACF;AAAA,MACA;AAAA,QACE,IAAI;AAAA,QACJ,OAAO;AAAA,QACP,MAAM;AAAA,QACN,SAAS,CAAC,eAAe;AAAA,QACzB,QAAQ;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,UAAU,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,UACvB,eAAe,EAAE,KAAK,KAAK,WAAW,CAAC,IAAI,EAAE,EAAE;AAAA,QACjD;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,OAAO,KAAK,6BAA6B,EAAE,aAAa,gBAAgB,CAAC;AAAA,EAChF;AAAA,EAEQ,yBAA+B;AAErC,SAAK,aAAa,IAAI,UAAU;AAAA,MAC9B,MAAM;AAAA,MACN,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,SAAS;AAAA,MACT,SAAS;AAAA,MACT,aAAa,YAAY;AAEvB,eAAO,KAAK,cAAc,WAAW,MAAM,KAAK,cAAc,cAAc;AAAA,MAC9E;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,uBAAuB,OAAsC;AAEzE,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,sBAAsB,OAAsC;AAExE,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,eAAe,OAAc,QAA4B;AAErE,SAAK,OAAO,KAAK,oBAAoB,EAAE,SAAS,MAAM,GAAG,CAAC;AAAA,EAC5D;AAAA,EAEA,MAAc,iBAAiB,OAAc,QAA4B;AAEvE,SAAK,OAAO,KAAK,sBAAsB,EAAE,SAAS,MAAM,GAAG,CAAC;AAAA,EAC9D;AAAA,EAEA,MAAc,iBAAiB,OAAc,QAA4B;AAEvE,SAAK,OAAO,KAAK,wBAAwB,EAAE,SAAS,MAAM,IAAI,QAAQ,OAAO,OAAO,CAAC;AACrF,SAAK,SAAS,KAAK,uBAAuB,EAAE,OAAO,OAAO,CAAC;AAAA,EAC7D;AAAA,EAEA,MAAc,eAAe,OAAc,QAA4B;AAErE,SAAK,OAAO,KAAK,qBAAqB,EAAE,SAAS,MAAM,GAAG,CAAC;AAC3D,SAAK,SAAS,KAAK,qBAAqB,EAAE,OAAO,OAAO,CAAC;AAAA,EAC3D;AAAA,EAEQ,0BAAyC;AAC/C,WAAO;AAAA,MACL,WAAW,oBAAI,KAAK;AAAA,MACpB,UAAU;AAAA,MACV,aAAa;AAAA,MACb,WAAW;AAAA,MACX,cAAc;AAAA,MACd,cAAc;AAAA,MACd,aAAa;AAAA,MACb,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,WAAW;AAAA,MACX,aAAa;AAAA,MACb,qBAAqB,CAAC;AAAA,MACtB,cAAc,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EAEQ,yBAAuC;AAC7C,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,qBAAqB,CAAC;AAAA,MACtB,gBAAgB;AAAA,MAChB,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,MACnB,4BAA4B;AAAA,MAC5B,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,IACrB;AAAA,EACF;AAAA;AAAA,EAIA,mBAAkC;AAChC,WAAO,EAAE,GAAG,KAAK,cAAc;AAAA,EACjC;AAAA,EAEA,kBAAgC;AAC9B,WAAO,EAAE,GAAG,KAAK,aAAa;AAAA,EAChC;AAAA,EAEA,kBAA2B;AACzB,WAAO,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AAAA,EAC9C;AAAA,EAEA,gBAAgB,QAAgB,KAAc;AAC5C,WAAO,KAAK,aAAa,MAAM,CAAC,KAAK;AAAA,EACvC;AAAA,EAEA,cAAc,YAA4C;AACxD,WAAO,KAAK,WAAW,IAAI,UAAU;AAAA,EACvC;AAAA,EAEA,mBAAiC;AAC/B,WAAO,MAAM,KAAK,KAAK,WAAW,OAAO,CAAC;AAAA,EAC5C;AAAA,EAEA,iBAAiB,SAAiB,gBAA8B;AAC9D,UAAM,QAAQ,KAAK,aAAa,IAAI,OAAO;AAC3C,QAAI,OAAO;AACT,YAAM,eAAe;AACrB,YAAM,aAAa;AACnB,WAAK,KAAK,sBAAsB,EAAE,OAAO,eAAe,CAAC;AAAA,IAC3D;AAAA,EACF;AAAA,EAEA,gBAAgB,MAAqC;AACnD,UAAM,SAAS,QAAQ,KAAK,IAAI,CAAC;AACjC,SAAK,WAAW,IAAI,QAAQ,EAAE,GAAG,MAAM,IAAI,OAAO,CAAC;AACnD,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,QAAgB,SAAmC;AACjE,UAAM,OAAO,KAAK,WAAW,IAAI,MAAM;AACvC,QAAI,MAAM;AACR,WAAK,WAAW,IAAI,QAAQ,EAAE,GAAG,MAAM,GAAG,QAAQ,CAAC;AAAA,IACrD;AAAA,EACF;AAAA,EAEA,gBAAgB,QAAsB;AACpC,SAAK,WAAW,OAAO,MAAM;AAAA,EAC/B;AAAA,EAEA,gBAA6B;AAC3B,WAAO,MAAM,KAAK,KAAK,WAAW,OAAO,CAAC;AAAA,EAC5C;AAAA,EAEA,0BAOE;AACA,WAAO;AAAA,MACL,cAAc,KAAK,WAAW;AAAA,MAC9B,cAAc,KAAK,aAAa;AAAA,MAChC,YAAY,KAAK,WAAW;AAAA,MAC5B,cAAc,KAAK,aAAa;AAAA,MAChC,YAAY,KAAK,WAAW;AAAA,MAC5B,QAAQ,KAAK,IAAI,IAAI,KAAK,kBAAkB,QAAQ;AAAA,IACtD;AAAA,EACF;AACF;",
  "names": []
}
