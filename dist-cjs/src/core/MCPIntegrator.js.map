{"version":3,"sources":["../../../src/core/MCPIntegrator.ts"],"sourcesContent":["/**\r\n * MCPIntegrator - Manages MCP tool coordination\r\n * Provides integration with external MCP tools and orchestration services\r\n */\r\n\r\nexport interface MCPTool {\r\n  name: string;\r\n  server: string;\r\n  functions: MCPFunction[];\r\n  status: 'connected' | 'disconnected' | 'error';\r\n  lastPing?: Date;\r\n}\r\n\r\nexport interface MCPFunction {\r\n  name: string;\r\n  description: string;\r\n  parameters: any;\r\n  required: string[];\r\n}\r\n\r\nexport interface MCPCommand {\r\n  tool: string;\r\n  function: string;\r\n  parameters: any;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface MCPResult {\r\n  success: boolean;\r\n  data?: any;\r\n  error?: string;\r\n  metadata?: {\r\n    executionTime: number;\r\n    tool: string;\r\n    function: string;\r\n  };\r\n}\r\n\r\nexport class MCPIntegrator {\r\n  private tools: Map<string, MCPTool> = new Map();\r\n  private initialized: boolean = false;\r\n\r\n  constructor() {\r\n    this.registerDefaultTools();\r\n  }\r\n\r\n  /**\r\n   * Initialize MCP integrator and discover available tools\r\n   */\r\n  async initialize(): Promise<void> {\r\n    await this.discoverTools();\r\n    await this.testConnections();\r\n    this.initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Register default MCP tools\r\n   */\r\n  private registerDefaultTools(): void {\r\n    // Claude Flow MCP tools\r\n    this.tools.set('claude-flow', {\r\n      name: 'claude-flow',\r\n      server: 'npx claude-flow@alpha mcp start',\r\n      functions: [\r\n        {\r\n          name: 'swarm_init',\r\n          description: 'Initialize swarm with topology',\r\n          parameters: { topology: 'string', maxAgents: 'number', strategy: 'string' },\r\n          required: ['topology']\r\n        },\r\n        {\r\n          name: 'agent_spawn',\r\n          description: 'Spawn specialized agents',\r\n          parameters: { type: 'string', capabilities: 'array', name: 'string' },\r\n          required: ['type']\r\n        },\r\n        {\r\n          name: 'task_orchestrate',\r\n          description: 'Orchestrate complex tasks',\r\n          parameters: { task: 'string', strategy: 'string', priority: 'string' },\r\n          required: ['task']\r\n        },\r\n        {\r\n          name: 'memory_usage',\r\n          description: 'Manage coordination memory',\r\n          parameters: { action: 'string', key: 'string', value: 'string', namespace: 'string' },\r\n          required: ['action']\r\n        },\r\n        {\r\n          name: 'swarm_status',\r\n          description: 'Get swarm status and metrics',\r\n          parameters: { detailed: 'boolean' },\r\n          required: []\r\n        }\r\n      ],\r\n      status: 'disconnected'\r\n    });\r\n\r\n    // ruv-swarm MCP tools (optional)\r\n    this.tools.set('ruv-swarm', {\r\n      name: 'ruv-swarm',\r\n      server: 'npx ruv-swarm mcp start',\r\n      functions: [\r\n        {\r\n          name: 'swarm_init',\r\n          description: 'Initialize RUV swarm',\r\n          parameters: { topology: 'string', maxAgents: 'number', strategy: 'string' },\r\n          required: ['topology']\r\n        },\r\n        {\r\n          name: 'neural_status',\r\n          description: 'Get neural network status',\r\n          parameters: { agentId: 'string' },\r\n          required: []\r\n        },\r\n        {\r\n          name: 'benchmark_run',\r\n          description: 'Run performance benchmarks',\r\n          parameters: { type: 'string', iterations: 'number' },\r\n          required: []\r\n        }\r\n      ],\r\n      status: 'disconnected'\r\n    });\r\n\r\n    // Flow Nexus MCP tools (optional)\r\n    this.tools.set('flow-nexus', {\r\n      name: 'flow-nexus',\r\n      server: 'npx flow-nexus@latest mcp start',\r\n      functions: [\r\n        {\r\n          name: 'swarm_init',\r\n          description: 'Initialize Flow Nexus swarm',\r\n          parameters: { topology: 'string', maxAgents: 'number', strategy: 'string' },\r\n          required: ['topology']\r\n        },\r\n        {\r\n          name: 'sandbox_create',\r\n          description: 'Create execution sandbox',\r\n          parameters: { template: 'string', env_vars: 'object' },\r\n          required: ['template']\r\n        },\r\n        {\r\n          name: 'neural_train',\r\n          description: 'Train neural networks',\r\n          parameters: { config: 'object', tier: 'string' },\r\n          required: ['config']\r\n        }\r\n      ],\r\n      status: 'disconnected'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Discover available MCP tools\r\n   */\r\n  private async discoverTools(): Promise<void> {\r\n    // In a real implementation, this would probe for available MCP servers\r\n    // For now, we'll simulate the discovery process\r\n\r\n    for (const [name, tool] of this.tools) {\r\n      try {\r\n        // Simulate tool discovery\r\n        const isAvailable = await this.checkToolAvailability(name);\r\n        tool.status = isAvailable ? 'connected' : 'disconnected';\r\n        tool.lastPing = new Date();\r\n      } catch (error) {\r\n        tool.status = 'error';\r\n        console.warn(`Failed to discover MCP tool ${name}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a specific tool is available\r\n   */\r\n  private async checkToolAvailability(toolName: string): Promise<boolean> {\r\n    // Simulate availability check\r\n    // In real implementation, this would try to connect to the MCP server\r\n    return Math.random() > 0.3; // 70% availability simulation\r\n  }\r\n\r\n  /**\r\n   * Test connections to all tools\r\n   */\r\n  private async testConnections(): Promise<void> {\r\n    for (const [name, tool] of this.tools) {\r\n      if (tool.status === 'connected') {\r\n        try {\r\n          // Simulate connection test\r\n          await new Promise(resolve => setTimeout(resolve, 100));\r\n          console.log(`✓ MCP tool ${name} connected successfully`);\r\n        } catch (error) {\r\n          tool.status = 'error';\r\n          console.warn(`✗ MCP tool ${name} connection failed:`, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute MCP command\r\n   */\r\n  async executeCommand(command: MCPCommand): Promise<MCPResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const tool = this.tools.get(command.tool);\r\n      if (!tool) {\r\n        return {\r\n          success: false,\r\n          error: `Unknown MCP tool: ${command.tool}`,\r\n          metadata: {\r\n            executionTime: Date.now() - startTime,\r\n            tool: command.tool,\r\n            function: command.function\r\n          }\r\n        };\r\n      }\r\n\r\n      if (tool.status !== 'connected') {\r\n        return {\r\n          success: false,\r\n          error: `MCP tool ${command.tool} is not connected (status: ${tool.status})`,\r\n          metadata: {\r\n            executionTime: Date.now() - startTime,\r\n            tool: command.tool,\r\n            function: command.function\r\n          }\r\n        };\r\n      }\r\n\r\n      // Validate function exists\r\n      const func = tool.functions.find(f => f.name === command.function);\r\n      if (!func) {\r\n        return {\r\n          success: false,\r\n          error: `Function ${command.function} not found in tool ${command.tool}`,\r\n          metadata: {\r\n            executionTime: Date.now() - startTime,\r\n            tool: command.tool,\r\n            function: command.function\r\n          }\r\n        };\r\n      }\r\n\r\n      // Validate required parameters\r\n      const missingParams = func.required.filter(param => !(param in command.parameters));\r\n      if (missingParams.length > 0) {\r\n        return {\r\n          success: false,\r\n          error: `Missing required parameters: ${missingParams.join(', ')}`,\r\n          metadata: {\r\n            executionTime: Date.now() - startTime,\r\n            tool: command.tool,\r\n            function: command.function\r\n          }\r\n        };\r\n      }\r\n\r\n      // Execute the command (simulation)\r\n      const result = await this.simulateCommandExecution(command);\r\n\r\n      return {\r\n        success: true,\r\n        data: result,\r\n        metadata: {\r\n          executionTime: Date.now() - startTime,\r\n          tool: command.tool,\r\n          function: command.function\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error),\r\n        metadata: {\r\n          executionTime: Date.now() - startTime,\r\n          tool: command.tool,\r\n          function: command.function\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simulate command execution (replace with real MCP calls in production)\r\n   */\r\n  private async simulateCommandExecution(command: MCPCommand): Promise<any> {\r\n    // Simulate processing time\r\n    await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 800));\r\n\r\n    // Return different results based on function\r\n    switch (command.function) {\r\n      case 'swarm_init':\r\n        return {\r\n          swarmId: `swarm-${Date.now()}`,\r\n          topology: command.parameters.topology,\r\n          maxAgents: command.parameters.maxAgents || 8,\r\n          status: 'initialized'\r\n        };\r\n\r\n      case 'agent_spawn':\r\n        return {\r\n          agentId: `agent-${Date.now()}`,\r\n          type: command.parameters.type,\r\n          capabilities: command.parameters.capabilities || [],\r\n          status: 'spawned'\r\n        };\r\n\r\n      case 'task_orchestrate':\r\n        return {\r\n          taskId: `task-${Date.now()}`,\r\n          task: command.parameters.task,\r\n          strategy: command.parameters.strategy || 'adaptive',\r\n          status: 'orchestrating'\r\n        };\r\n\r\n      case 'memory_usage':\r\n        if (command.parameters.action === 'store') {\r\n          return { stored: true, key: command.parameters.key };\r\n        } else if (command.parameters.action === 'retrieve') {\r\n          return { found: Math.random() > 0.3, value: 'simulated-value' };\r\n        }\r\n        return { action: command.parameters.action, success: true };\r\n\r\n      case 'swarm_status':\r\n        return {\r\n          activeAgents: Math.floor(Math.random() * 8) + 1,\r\n          topology: 'mesh',\r\n          health: 'good',\r\n          metrics: {\r\n            throughput: Math.random() * 100,\r\n            latency: Math.random() * 50 + 10\r\n          }\r\n        };\r\n\r\n      case 'neural_status':\r\n        return {\r\n          modelLoaded: true,\r\n          accuracy: 0.85 + Math.random() * 0.1,\r\n          trainingProgress: Math.random() * 100\r\n        };\r\n\r\n      case 'benchmark_run':\r\n        return {\r\n          benchmarks: [\r\n            { name: 'cpu', value: Math.random() * 100, unit: 'ms' },\r\n            { name: 'memory', value: Math.random() * 512, unit: 'MB' },\r\n            { name: 'network', value: Math.random() * 50, unit: 'ms' }\r\n          ]\r\n        };\r\n\r\n      default:\r\n        return { function: command.function, executed: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get available tools\r\n   */\r\n  getAvailableTools(): MCPTool[] {\r\n    return Array.from(this.tools.values());\r\n  }\r\n\r\n  /**\r\n   * Get connected tools\r\n   */\r\n  getConnectedTools(): MCPTool[] {\r\n    return Array.from(this.tools.values()).filter(tool => tool.status === 'connected');\r\n  }\r\n\r\n  /**\r\n   * Get tool by name\r\n   */\r\n  getTool(name: string): MCPTool | undefined {\r\n    return this.tools.get(name);\r\n  }\r\n\r\n  /**\r\n   * Check if a tool is available\r\n   */\r\n  isToolAvailable(name: string): boolean {\r\n    const tool = this.tools.get(name);\r\n    return tool?.status === 'connected' || false;\r\n  }\r\n\r\n  /**\r\n   * Get tool functions\r\n   */\r\n  getToolFunctions(toolName: string): MCPFunction[] {\r\n    const tool = this.tools.get(toolName);\r\n    return tool?.functions || [];\r\n  }\r\n\r\n  /**\r\n   * Initialize swarm coordination using MCP tools\r\n   */\r\n  async initializeSwarmCoordination(config: {\r\n    topology: string;\r\n    maxAgents: number;\r\n    strategy: string;\r\n  }): Promise<MCPResult> {\r\n    // Try claude-flow first, then fallback to other tools\r\n    const toolPriority = ['claude-flow', 'ruv-swarm', 'flow-nexus'];\r\n\r\n    for (const toolName of toolPriority) {\r\n      if (this.isToolAvailable(toolName)) {\r\n        return await this.executeCommand({\r\n          tool: toolName,\r\n          function: 'swarm_init',\r\n          parameters: config\r\n        });\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'No MCP tools available for swarm initialization',\r\n      metadata: {\r\n        executionTime: 0,\r\n        tool: 'none',\r\n        function: 'swarm_init'\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Coordinate memory across swarm using MCP tools\r\n   */\r\n  async coordinateMemory(action: string, key: string, value?: string, namespace?: string): Promise<MCPResult> {\r\n    const command: MCPCommand = {\r\n      tool: 'claude-flow',\r\n      function: 'memory_usage',\r\n      parameters: { action, key, value, namespace: namespace || 'coordination' }\r\n    };\r\n\r\n    return await this.executeCommand(command);\r\n  }\r\n\r\n  /**\r\n   * Spawn agents using MCP tools\r\n   */\r\n  async spawnAgent(type: string, capabilities?: string[], name?: string): Promise<MCPResult> {\r\n    const command: MCPCommand = {\r\n      tool: 'claude-flow',\r\n      function: 'agent_spawn',\r\n      parameters: { type, capabilities, name }\r\n    };\r\n\r\n    return await this.executeCommand(command);\r\n  }\r\n\r\n  /**\r\n   * Orchestrate tasks using MCP tools\r\n   */\r\n  async orchestrateTask(task: string, strategy?: string, priority?: string): Promise<MCPResult> {\r\n    const command: MCPCommand = {\r\n      tool: 'claude-flow',\r\n      function: 'task_orchestrate',\r\n      parameters: { task, strategy, priority }\r\n    };\r\n\r\n    return await this.executeCommand(command);\r\n  }\r\n\r\n  /**\r\n   * Get swarm status using MCP tools\r\n   */\r\n  async getSwarmStatus(detailed: boolean = false): Promise<MCPResult> {\r\n    const command: MCPCommand = {\r\n      tool: 'claude-flow',\r\n      function: 'swarm_status',\r\n      parameters: { detailed }\r\n    };\r\n\r\n    return await this.executeCommand(command);\r\n  }\r\n\r\n  /**\r\n   * Refresh tool connections\r\n   */\r\n  async refreshConnections(): Promise<void> {\r\n    await this.discoverTools();\r\n    await this.testConnections();\r\n  }\r\n\r\n  /**\r\n   * Register a custom tool\r\n   */\r\n  registerTool(tool: MCPTool): void {\r\n    this.tools.set(tool.name, tool);\r\n  }\r\n\r\n  /**\r\n   * Unregister a tool\r\n   */\r\n  unregisterTool(name: string): boolean {\r\n    return this.tools.delete(name);\r\n  }\r\n\r\n  /**\r\n   * Get integration status\r\n   */\r\n  getIntegrationStatus(): {\r\n    initialized: boolean;\r\n    totalTools: number;\r\n    connectedTools: number;\r\n    availableFunctions: number;\r\n  } {\r\n    const tools = Array.from(this.tools.values());\r\n    const connectedTools = tools.filter(tool => tool.status === 'connected');\r\n    const availableFunctions = connectedTools.reduce((sum, tool) => sum + tool.functions.length, 0);\r\n\r\n    return {\r\n      initialized: this.initialized,\r\n      totalTools: tools.length,\r\n      connectedTools: connectedTools.length,\r\n      availableFunctions\r\n    };\r\n  }\r\n}"],"names":["MCPIntegrator","tools","Map","initialized","registerDefaultTools","initialize","discoverTools","testConnections","set","name","server","functions","description","parameters","topology","maxAgents","strategy","required","type","capabilities","task","priority","action","key","value","namespace","detailed","status","agentId","iterations","template","env_vars","config","tier","tool","isAvailable","checkToolAvailability","lastPing","Date","error","console","warn","toolName","Math","random","Promise","resolve","setTimeout","log","executeCommand","command","startTime","now","get","success","metadata","executionTime","function","func","find","f","missingParams","filter","param","length","join","result","simulateCommandExecution","data","Error","message","String","swarmId","taskId","stored","found","activeAgents","floor","health","metrics","throughput","latency","modelLoaded","accuracy","trainingProgress","benchmarks","unit","executed","getAvailableTools","Array","from","values","getConnectedTools","getTool","isToolAvailable","getToolFunctions","initializeSwarmCoordination","toolPriority","coordinateMemory","spawnAgent","orchestrateTask","getSwarmStatus","refreshConnections","registerTool","unregisterTool","delete","getIntegrationStatus","connectedTools","availableFunctions","reduce","sum","totalTools"],"mappings":"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"}