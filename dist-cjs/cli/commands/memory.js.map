{
  "version": 3,
  "sources": ["../../../src/cli/commands/memory.ts"],
  "sourcesContent": ["import chalk from 'chalk';\n/**\n * Memory management commands\n */\n\nimport { Command } from 'commander';\nimport { promises as fs } from 'node:fs';\nimport * as Table from 'cli-table3';\n\ninterface MemoryEntry {\n  key: string;\n  value: string;\n  namespace: string;\n  timestamp: number;\n}\n\nexport class SimpleMemoryManager {\n  private filePath = './memory/memory-store.json';\n  private data: Record<string, MemoryEntry[]> = {};\n\n  async load() {\n    try {\n      const content = await fs.readFile(this.filePath, 'utf-8');\n      this.data = JSON.parse(content);\n    } catch {\n      // File doesn't exist yet\n      this.data = {};\n    }\n  }\n\n  async save() {\n    await fs.mkdir('./memory', { recursive: true });\n    await fs.writeFile(this.filePath, JSON.stringify(this.data, null, 2));\n  }\n\n  async store(key: string, value: string, namespace: string = 'default') {\n    await this.load();\n\n    if (!this.data[namespace]) {\n      this.data[namespace] = [];\n    }\n\n    // Remove existing entry with same key\n    this.data[namespace] = this.data[namespace].filter((e) => e.key !== key);\n\n    // Add new entry\n    this.data[namespace].push({\n      key,\n      value,\n      namespace,\n      timestamp: Date.now(),\n    });\n\n    await this.save();\n  }\n\n  async query(search: string, namespace?: string) {\n    await this.load();\n\n    const results: MemoryEntry[] = [];\n    const namespaces = namespace ? [namespace] : Object.keys(this.data);\n\n    for (const ns of namespaces) {\n      if (this.data[ns]) {\n        for (const entry of this.data[ns]) {\n          if (entry.key.includes(search) || entry.value.includes(search)) {\n            results.push(entry);\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  async getStats() {\n    await this.load();\n\n    let totalEntries = 0;\n    const namespaceStats: Record<string, number> = {};\n\n    for (const [namespace, entries] of Object.entries(this.data)) {\n      namespaceStats[namespace] = entries.length;\n      totalEntries += entries.length;\n    }\n\n    return {\n      totalEntries,\n      namespaces: Object.keys(this.data).length,\n      namespaceStats,\n      sizeBytes: new TextEncoder().encode(JSON.stringify(this.data)).length,\n    };\n  }\n\n  async exportData(filePath: string) {\n    await this.load();\n    await fs.writeFile(filePath, JSON.stringify(this.data, null, 2));\n  }\n\n  async importData(filePath: string) {\n    const content = await fs.readFile(filePath, 'utf8');\n    this.data = JSON.parse(content);\n    await this.save();\n  }\n\n  async cleanup(daysOld: number = 30) {\n    await this.load();\n\n    const cutoffTime = Date.now() - daysOld * 24 * 60 * 60 * 1000;\n    let removedCount = 0;\n\n    for (const namespace of Object.keys(this.data)) {\n      const before = this.data[namespace].length;\n      this.data[namespace] = this.data[namespace].filter((e) => e.timestamp > cutoffTime);\n      removedCount += before - this.data[namespace].length;\n    }\n\n    await this.save();\n    return removedCount;\n  }\n}\n\nexport const memoryCommand = new Command()\n  .name('memory')\n  .description('Manage memory bank')\n  .action(() => {\n    memoryCommand.help();\n  });\n\n// Store command\nmemoryCommand\n  .command('store')\n  .description('Store information in memory')\n  .arguments('<key> <value>')\n  .option('-n, --namespace <namespace>', 'Target namespace', 'default')\n  .action(async (key: string, value: string, options: any) => {\n    try {\n      const memory = new SimpleMemoryManager();\n      await memory.store(key, value, options.namespace);\n      console.log(chalk.green('\u2705 Stored successfully'));\n      console.log(`\uD83D\uDCDD Key: ${key}`);\n      console.log(`\uD83D\uDCE6 Namespace: ${options.namespace}`);\n      console.log(`\uD83D\uDCBE Size: ${new TextEncoder().encode(value).length} bytes`);\n    } catch (error) {\n      console.error(chalk.red('Failed to store:'), (error as Error).message);\n    }\n  });\n\n// Query command\nmemoryCommand\n  .command('query')\n  .description('Search memory entries')\n  .arguments('<search>')\n  .option('-n, --namespace <namespace>', 'Filter by namespace')\n  .option('-l, --limit <limit>', 'Limit results', '10')\n  .action(async (search: string, options: any) => {\n    try {\n      const memory = new SimpleMemoryManager();\n      const results = await memory.query(search, options.namespace);\n\n      if (results.length === 0) {\n        console.log(chalk.yellow('No results found'));\n        return;\n      }\n\n      console.log(chalk.green(`\u2705 Found ${results.length} results:`));\n\n      const limited = results.slice(0, parseInt(options.limit));\n      for (const entry of limited) {\n        console.log(chalk.blue(`\\n\uD83D\uDCCC ${entry.key}`));\n        console.log(`   Namespace: ${entry.namespace}`);\n        console.log(\n          `   Value: ${entry.value.substring(0, 100)}${entry.value.length > 100 ? '...' : ''}`,\n        );\n        console.log(`   Stored: ${new Date(entry.timestamp).toLocaleString()}`);\n      }\n\n      if (results.length > parseInt(options.limit)) {\n        console.log(\n          chalk.gray(`\\n... and ${results.length - parseInt(options.limit)} more results`),\n        );\n      }\n    } catch (error) {\n      console.error(chalk.red('Failed to query:'), (error as Error).message);\n    }\n  });\n\n// Export command\nmemoryCommand\n  .command('export')\n  .description('Export memory to file')\n  .arguments('<file>')\n  .action(async (file: string, options: any) => {\n    try {\n      const memory = new SimpleMemoryManager();\n      await memory.exportData(file);\n      const stats = await memory.getStats();\n      console.log(chalk.green('\u2705 Memory exported successfully'));\n      console.log(`\uD83D\uDCC1 File: ${file}`);\n      console.log(`\uD83D\uDCCA Entries: ${stats.totalEntries}`);\n      console.log(`\uD83D\uDCBE Size: ${(stats.sizeBytes / 1024).toFixed(2)} KB`);\n    } catch (error) {\n      console.error(chalk.red('Failed to export:'), (error as Error).message);\n    }\n  });\n\n// Import command\nmemoryCommand\n  .command('import')\n  .description('Import memory from file')\n  .arguments('<file>')\n  .action(async (file: string, options: any) => {\n    try {\n      const memory = new SimpleMemoryManager();\n      await memory.importData(file);\n      const stats = await memory.getStats();\n      console.log(chalk.green('\u2705 Memory imported successfully'));\n      console.log(`\uD83D\uDCC1 File: ${file}`);\n      console.log(`\uD83D\uDCCA Entries: ${stats.totalEntries}`);\n      console.log(`\uD83D\uDDC2\uFE0F  Namespaces: ${stats.namespaces}`);\n    } catch (error) {\n      console.error(chalk.red('Failed to import:'), (error as Error).message);\n    }\n  });\n\n// Stats command\nmemoryCommand\n  .command('stats')\n  .description('Show memory statistics')\n  .action(async () => {\n    try {\n      const memory = new SimpleMemoryManager();\n      const stats = await memory.getStats();\n\n      console.log(chalk.green('\uD83D\uDCCA Memory Bank Statistics:'));\n      console.log(`   Total Entries: ${stats.totalEntries}`);\n      console.log(`   Namespaces: ${stats.namespaces}`);\n      console.log(`   Size: ${(stats.sizeBytes / 1024).toFixed(2)} KB`);\n\n      if (stats.namespaces > 0) {\n        console.log(chalk.blue('\\n\uD83D\uDCC1 Namespace Breakdown:'));\n        for (const [namespace, count] of Object.entries(stats.namespaceStats)) {\n          console.log(`   ${namespace}: ${count} entries`);\n        }\n      }\n    } catch (error) {\n      console.error(chalk.red('Failed to get stats:'), (error as Error).message);\n    }\n  });\n\n// Cleanup command\nmemoryCommand\n  .command('cleanup')\n  .description('Clean up old entries')\n  .option('-d, --days <days>', 'Entries older than n days', '30')\n  .action(async (options: any) => {\n    try {\n      const memory = new SimpleMemoryManager();\n      const removed = await memory.cleanup(parseInt(options.days));\n      console.log(chalk.green('\u2705 Cleanup completed'));\n      console.log(`\uD83D\uDDD1\uFE0F  Removed: ${removed} entries older than ${options.days} days`);\n    } catch (error) {\n      console.error(chalk.red('Failed to cleanup:'), (error as Error).message);\n    }\n  });\n"],
  "mappings": "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",
  "names": ["fs", "chalk"]
}
