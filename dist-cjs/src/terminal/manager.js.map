{"version":3,"sources":["../../../src/terminal/manager.ts"],"sourcesContent":["import * as process from 'node:process';\r\n/**\r\n * Terminal manager interface and implementation\r\n */\r\n\r\nimport type { AgentProfile, AgentSession, TerminalConfig } from '../utils/types.js';\r\nimport type { IEventBus } from '../core/event-bus.js';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { TerminalError, TerminalSpawnError } from '../utils/errors.js';\r\nimport type { ITerminalAdapter } from './adapters/base.js';\r\nimport { VSCodeAdapter } from './adapters/vscode.js';\r\nimport { NativeAdapter } from './adapters/native.js';\r\nimport { TerminalPool } from './pool.js';\r\nimport { TerminalSession } from './session.js';\r\n\r\nexport interface ITerminalManager {\r\n  initialize(): Promise<void>;\r\n  shutdown(): Promise<void>;\r\n  spawnTerminal(profile: AgentProfile): Promise<string>;\r\n  terminateTerminal(terminalId: string): Promise<void>;\r\n  executeCommand(terminalId: string, command: string): Promise<string>;\r\n  getHealthStatus(): Promise<{\r\n    healthy: boolean;\r\n    error?: string;\r\n    metrics?: Record<string, number>;\r\n  }>;\r\n  performMaintenance(): Promise<void>;\r\n}\r\n\r\n/**\r\n * Terminal manager implementation\r\n */\r\nexport class TerminalManager implements ITerminalManager {\r\n  private adapter: ITerminalAdapter;\r\n  private pool: TerminalPool;\r\n  private sessions = new Map<string, TerminalSession>();\r\n  private initialized = false;\r\n\r\n  constructor(\r\n    private config: TerminalConfig,\r\n    private eventBus: IEventBus,\r\n    private logger: ILogger,\r\n  ) {\r\n    // Select adapter based on configuration\r\n    this.adapter = this.createAdapter();\r\n\r\n    // Create terminal pool\r\n    this.pool = new TerminalPool(\r\n      this.config.poolSize,\r\n      this.config.recycleAfter,\r\n      this.adapter,\r\n      this.logger,\r\n    );\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.initialized) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Initializing terminal manager...');\r\n\r\n    try {\r\n      // Initialize adapter\r\n      await this.adapter.initialize();\r\n\r\n      // Initialize pool\r\n      await this.pool.initialize();\r\n\r\n      this.initialized = true;\r\n      this.logger.info('Terminal manager initialized');\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize terminal manager', error);\r\n      throw new TerminalError('Terminal manager initialization failed', { error });\r\n    }\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    if (!this.initialized) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Shutting down terminal manager...');\r\n\r\n    try {\r\n      // Terminate all sessions\r\n      const sessionIds = Array.from(this.sessions.keys());\r\n      await Promise.all(sessionIds.map((id) => this.terminateTerminal(id)));\r\n\r\n      // Shutdown pool\r\n      await this.pool.shutdown();\r\n\r\n      // Shutdown adapter\r\n      await this.adapter.shutdown();\r\n\r\n      this.initialized = false;\r\n      this.logger.info('Terminal manager shutdown complete');\r\n    } catch (error) {\r\n      this.logger.error('Error during terminal manager shutdown', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async spawnTerminal(profile: AgentProfile): Promise<string> {\r\n    if (!this.initialized) {\r\n      throw new TerminalError('Terminal manager not initialized');\r\n    }\r\n\r\n    this.logger.debug('Spawning terminal', { agentId: profile.id });\r\n\r\n    try {\r\n      // Get terminal from pool\r\n      const terminal = await this.pool.acquire();\r\n\r\n      // Create session\r\n      const session = new TerminalSession(\r\n        terminal,\r\n        profile,\r\n        this.config.commandTimeout,\r\n        this.logger,\r\n      );\r\n\r\n      // Initialize session\r\n      await session.initialize();\r\n\r\n      // Store session\r\n      this.sessions.set(session.id, session);\r\n\r\n      this.logger.info('Terminal spawned', {\r\n        terminalId: session.id,\r\n        agentId: profile.id,\r\n      });\r\n\r\n      return session.id;\r\n    } catch (error) {\r\n      this.logger.error('Failed to spawn terminal', error);\r\n      throw new TerminalSpawnError('Failed to spawn terminal', { error });\r\n    }\r\n  }\r\n\r\n  async terminateTerminal(terminalId: string): Promise<void> {\r\n    const session = this.sessions.get(terminalId);\r\n    if (!session) {\r\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\r\n    }\r\n\r\n    this.logger.debug('Terminating terminal', { terminalId });\r\n\r\n    try {\r\n      // Cleanup session\r\n      await session.cleanup();\r\n\r\n      // Return terminal to pool\r\n      await this.pool.release(session.terminal);\r\n\r\n      // Remove session\r\n      this.sessions.delete(terminalId);\r\n\r\n      this.logger.info('Terminal terminated', { terminalId });\r\n    } catch (error) {\r\n      this.logger.error('Failed to terminate terminal', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async executeCommand(terminalId: string, command: string): Promise<string> {\r\n    const session = this.sessions.get(terminalId);\r\n    if (!session) {\r\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\r\n    }\r\n\r\n    return await session.executeCommand(command);\r\n  }\r\n\r\n  async getHealthStatus(): Promise<{\r\n    healthy: boolean;\r\n    error?: string;\r\n    metrics?: Record<string, number>;\r\n  }> {\r\n    try {\r\n      const poolHealth = await this.pool.getHealthStatus();\r\n      const activeSessions = this.sessions.size;\r\n      const healthySessions = Array.from(this.sessions.values()).filter((session) =>\r\n        session.isHealthy(),\r\n      ).length;\r\n\r\n      const metrics = {\r\n        activeSessions,\r\n        healthySessions,\r\n        poolSize: poolHealth.size,\r\n        availableTerminals: poolHealth.available,\r\n        recycledTerminals: poolHealth.recycled,\r\n      };\r\n\r\n      const healthy = poolHealth.healthy && healthySessions === activeSessions;\r\n\r\n      if (healthy) {\r\n        return {\r\n          healthy,\r\n          metrics,\r\n        };\r\n      } else {\r\n        return {\r\n          healthy,\r\n          metrics,\r\n          error: 'Some terminals are unhealthy',\r\n        };\r\n      }\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      };\r\n    }\r\n  }\r\n\r\n  async performMaintenance(): Promise<void> {\r\n    if (!this.initialized) {\r\n      return;\r\n    }\r\n\r\n    this.logger.debug('Performing terminal manager maintenance');\r\n\r\n    try {\r\n      // Clean up dead sessions\r\n      const deadSessions = Array.from(this.sessions.entries()).filter(\r\n        ([_, session]) => !session.isHealthy(),\r\n      );\r\n\r\n      for (const [terminalId, _] of deadSessions) {\r\n        this.logger.warn('Cleaning up dead terminal session', { terminalId });\r\n        await this.terminateTerminal(terminalId).catch((error) =>\r\n          this.logger.error('Failed to clean up terminal', { terminalId, error }),\r\n        );\r\n      }\r\n\r\n      // Perform pool maintenance\r\n      await this.pool.performMaintenance();\r\n\r\n      // Emit maintenance event\r\n      this.eventBus.emit('terminal:maintenance', {\r\n        deadSessions: deadSessions.length,\r\n        activeSessions: this.sessions.size,\r\n        poolStatus: await this.pool.getHealthStatus(),\r\n      });\r\n\r\n      this.logger.debug('Terminal manager maintenance completed');\r\n    } catch (error) {\r\n      this.logger.error('Error during terminal manager maintenance', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions\r\n   */\r\n  getActiveSessions(): AgentSession[] {\r\n    return Array.from(this.sessions.values()).map((session) => ({\r\n      id: session.id,\r\n      agentId: session.profile.id,\r\n      terminalId: session.terminal.id,\r\n      startTime: session.startTime,\r\n      status: session.isHealthy() ? 'active' : 'error',\r\n      lastActivity: session.lastActivity,\r\n      memoryBankId: '', // TODO: Link to memory bank\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get session by ID\r\n   */\r\n  getSession(sessionId: string): TerminalSession | undefined {\r\n    return this.sessions.get(sessionId);\r\n  }\r\n\r\n  /**\r\n   * Stream terminal output\r\n   */\r\n  async streamOutput(terminalId: string, callback: (output: string) => void): Promise<() => void> {\r\n    const session = this.sessions.get(terminalId);\r\n    if (!session) {\r\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\r\n    }\r\n\r\n    return session.streamOutput(callback);\r\n  }\r\n\r\n  private createAdapter(): ITerminalAdapter {\r\n    switch (this.config.type) {\r\n      case 'vscode':\r\n        return new VSCodeAdapter(this.logger);\r\n      case 'native':\r\n        return new NativeAdapter(this.logger);\r\n      case 'auto':\r\n        // Detect environment and choose appropriate adapter\r\n        if (this.isVSCodeEnvironment()) {\r\n          this.logger.info('Detected VSCode environment, using VSCode adapter');\r\n          return new VSCodeAdapter(this.logger);\r\n        } else {\r\n          this.logger.info('Using native terminal adapter');\r\n          return new NativeAdapter(this.logger);\r\n        }\r\n      default:\r\n        throw new TerminalError(`Unknown terminal type: ${this.config.type}`);\r\n    }\r\n  }\r\n\r\n  private isVSCodeEnvironment(): boolean {\r\n    // Check for VSCode-specific environment variables\r\n    return (\r\n      process.env.TERM_PROGRAM === 'vscode' ||\r\n      process.env.VSCODE_PID !== undefined ||\r\n      process.env.VSCODE_IPC_HOOK !== undefined\r\n    );\r\n  }\r\n}\r\n"],"names":["process","TerminalError","TerminalSpawnError","VSCodeAdapter","NativeAdapter","TerminalPool","TerminalSession","TerminalManager","adapter","pool","sessions","Map","initialized","config","eventBus","logger","createAdapter","poolSize","recycleAfter","initialize","info","error","shutdown","sessionIds","Array","from","keys","Promise","all","map","id","terminateTerminal","spawnTerminal","profile","debug","agentId","terminal","acquire","session","commandTimeout","set","terminalId","get","cleanup","release","delete","executeCommand","command","getHealthStatus","poolHealth","activeSessions","size","healthySessions","values","filter","isHealthy","length","metrics","availableTerminals","available","recycledTerminals","recycled","healthy","Error","message","performMaintenance","deadSessions","entries","_","warn","catch","emit","poolStatus","getActiveSessions","startTime","status","lastActivity","memoryBankId","getSession","sessionId","streamOutput","callback","type","isVSCodeEnvironment","env","TERM_PROGRAM","VSCODE_PID","undefined","VSCODE_IPC_HOOK"],"mappings":"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"}