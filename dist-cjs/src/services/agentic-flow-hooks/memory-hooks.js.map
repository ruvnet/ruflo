{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/memory-hooks.ts"],"sourcesContent":["/**\r\n * Memory persistence hooks for agentic-flow\r\n * \r\n * Provides cross-provider memory state management with\r\n * synchronization and persistence capabilities.\r\n */\r\n\r\nimport { agenticHookManager } from './hook-manager.js';\r\nimport type {\r\n  AgenticHookContext,\r\n  HookHandlerResult,\r\n  MemoryHookPayload,\r\n  SideEffect,\r\n} from './types.js';\r\n\r\n// ===== Pre-Memory Store Hook =====\r\n\r\nexport const preMemoryStoreHook = {\r\n  id: 'agentic-pre-memory-store',\r\n  type: 'pre-memory-store' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: MemoryHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { namespace, key, value, ttl, provider } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Validate memory constraints\r\n    const validation = await validateMemoryStore(namespace, key, value, context);\r\n    if (!validation.valid) {\r\n      return {\r\n        continue: false,\r\n        sideEffects: [\r\n          {\r\n            type: 'log',\r\n            action: 'write',\r\n            data: {\r\n              level: 'error',\r\n              message: 'Memory store validation failed',\r\n              data: validation,\r\n            },\r\n          },\r\n        ],\r\n      };\r\n    }\r\n    \r\n    // Compress large values\r\n    let processedValue = value;\r\n    if (shouldCompress(value)) {\r\n      processedValue = await compressValue(value);\r\n      sideEffects.push({\r\n        type: 'metric',\r\n        action: 'increment',\r\n        data: { name: 'memory.compressions' },\r\n      });\r\n    }\r\n    \r\n    // Add metadata\r\n    const enrichedValue = {\r\n      data: processedValue,\r\n      metadata: {\r\n        stored: Date.now(),\r\n        provider,\r\n        sessionId: context.sessionId,\r\n        compressed: processedValue !== value,\r\n        size: getValueSize(processedValue),\r\n      },\r\n    };\r\n    \r\n    // Track memory usage\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'update',\r\n      data: {\r\n        name: `memory.usage.${namespace}`,\r\n        value: getValueSize(enrichedValue),\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      modified: true,\r\n      payload: {\r\n        ...payload,\r\n        value: enrichedValue,\r\n      },\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Post-Memory Store Hook =====\r\n\r\nexport const postMemoryStoreHook = {\r\n  id: 'agentic-post-memory-store',\r\n  type: 'post-memory-store' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: MemoryHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { namespace, key, value, crossProvider, syncTargets } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Cross-provider sync if enabled\r\n    if (crossProvider && syncTargets && syncTargets.length > 0) {\r\n      for (const target of syncTargets) {\r\n        sideEffects.push({\r\n          type: 'memory',\r\n          action: 'sync',\r\n          data: {\r\n            source: payload.provider,\r\n            target,\r\n            namespace,\r\n            key,\r\n            value,\r\n          },\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Update memory index for search\r\n    await updateMemoryIndex(namespace, key, value, context);\r\n    \r\n    // Neural pattern detection\r\n    const patterns = await detectMemoryPatterns(namespace, key, value, context);\r\n    if (patterns.length > 0) {\r\n      sideEffects.push({\r\n        type: 'neural',\r\n        action: 'analyze',\r\n        data: {\r\n          patterns,\r\n          context: { namespace, key },\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Emit memory change event\r\n    sideEffects.push({\r\n      type: 'notification',\r\n      action: 'emit',\r\n      data: {\r\n        event: 'memory:stored',\r\n        data: { namespace, key, size: getValueSize(value) },\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Pre-Memory Retrieve Hook =====\r\n\r\nexport const preMemoryRetrieveHook = {\r\n  id: 'agentic-pre-memory-retrieve',\r\n  type: 'pre-memory-retrieve' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: MemoryHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { namespace, key } = payload;\r\n    \r\n    // Check local cache first\r\n    const cached = await checkLocalCache(namespace, key!, context);\r\n    if (cached) {\r\n      return {\r\n        continue: false,\r\n        modified: true,\r\n        payload: {\r\n          ...payload,\r\n          value: cached,\r\n        },\r\n        sideEffects: [\r\n          {\r\n            type: 'metric',\r\n            action: 'increment',\r\n            data: { name: 'memory.cache.hits' },\r\n          },\r\n        ],\r\n      };\r\n    }\r\n    \r\n    // Pre-fetch related keys\r\n    const relatedKeys = await findRelatedKeys(namespace, key!, context);\r\n    if (relatedKeys.length > 0) {\r\n      // Trigger background fetch\r\n      prefetchKeys(namespace, relatedKeys, context);\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects: [\r\n        {\r\n          type: 'metric',\r\n          action: 'increment',\r\n          data: { name: `memory.retrievals.${namespace}` },\r\n        },\r\n      ],\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Post-Memory Retrieve Hook =====\r\n\r\nexport const postMemoryRetrieveHook = {\r\n  id: 'agentic-post-memory-retrieve',\r\n  type: 'post-memory-retrieve' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: MemoryHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { namespace, key, value } = payload;\r\n    \r\n    if (!value) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Decompress if needed\r\n    let processedValue = value;\r\n    if (value.metadata?.compressed) {\r\n      processedValue = await decompressValue(value.data);\r\n      sideEffects.push({\r\n        type: 'metric',\r\n        action: 'increment',\r\n        data: { name: 'memory.decompressions' },\r\n      });\r\n    }\r\n    \r\n    // Update access patterns\r\n    await updateAccessPattern(namespace, key!, context);\r\n    \r\n    // Cache locally for fast access\r\n    await cacheLocally(namespace, key!, processedValue, context);\r\n    \r\n    // Track retrieval latency\r\n    const latency = Date.now() - context.timestamp;\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'update',\r\n      data: {\r\n        name: `memory.latency.${namespace}`,\r\n        value: latency,\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      modified: true,\r\n      payload: {\r\n        ...payload,\r\n        value: processedValue.data || processedValue,\r\n      },\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Memory Sync Hook =====\r\n\r\nexport const memorySyncHook = {\r\n  id: 'agentic-memory-sync',\r\n  type: 'memory-sync' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: MemoryHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { operation, namespace, provider, syncTargets } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    switch (operation) {\r\n      case 'sync':\r\n        // Bidirectional sync\r\n        const changes = await detectMemoryChanges(namespace, provider, context);\r\n        \r\n        if (changes.length > 0) {\r\n          sideEffects.push({\r\n            type: 'log',\r\n            action: 'write',\r\n            data: {\r\n              level: 'info',\r\n              message: `Syncing ${changes.length} memory changes`,\r\n              data: { namespace, provider, targets: syncTargets },\r\n            },\r\n          });\r\n          \r\n          // Apply changes\r\n          for (const change of changes) {\r\n            await applyMemoryChange(change, syncTargets || [], context);\r\n          }\r\n          \r\n          sideEffects.push({\r\n            type: 'metric',\r\n            action: 'update',\r\n            data: {\r\n              name: 'memory.sync.changes',\r\n              value: changes.length,\r\n            },\r\n          });\r\n        }\r\n        break;\r\n        \r\n      case 'persist':\r\n        // Persist to long-term storage\r\n        const snapshot = await createMemorySnapshot(namespace, context);\r\n        \r\n        sideEffects.push({\r\n          type: 'memory',\r\n          action: 'store',\r\n          data: {\r\n            key: `snapshot:${namespace}:${Date.now()}`,\r\n            value: snapshot,\r\n            ttl: 0, // No expiration\r\n          },\r\n        });\r\n        \r\n        sideEffects.push({\r\n          type: 'notification',\r\n          action: 'emit',\r\n          data: {\r\n            event: 'memory:persisted',\r\n            data: { namespace, size: snapshot.size },\r\n          },\r\n        });\r\n        break;\r\n        \r\n      case 'expire':\r\n        // Clean up expired entries\r\n        const expired = await findExpiredEntries(namespace, context);\r\n        \r\n        if (expired.length > 0) {\r\n          for (const key of expired) {\r\n            await removeMemoryEntry(namespace, key, context);\r\n          }\r\n          \r\n          sideEffects.push({\r\n            type: 'metric',\r\n            action: 'update',\r\n            data: {\r\n              name: 'memory.expired',\r\n              value: expired.length,\r\n            },\r\n          });\r\n        }\r\n        break;\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Memory Persist Hook =====\r\n\r\nexport const memoryPersistHook = {\r\n  id: 'agentic-memory-persist',\r\n  type: 'memory-persist' as const,\r\n  priority: 90,\r\n  handler: async (\r\n    payload: MemoryHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { namespace } = payload;\r\n    \r\n    // Create full memory backup\r\n    const backup = await createFullBackup(namespace, context);\r\n    \r\n    // Store backup with metadata\r\n    const backupData = {\r\n      timestamp: Date.now(),\r\n      sessionId: context.sessionId,\r\n      namespace,\r\n      entries: backup.entries,\r\n      size: backup.size,\r\n      checksum: calculateChecksum(backup),\r\n    };\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects: [\r\n        {\r\n          type: 'memory',\r\n          action: 'store',\r\n          data: {\r\n            key: `backup:${namespace}:${context.sessionId}`,\r\n            value: backupData,\r\n            ttl: 604800, // 7 days\r\n          },\r\n        },\r\n        {\r\n          type: 'notification',\r\n          action: 'emit',\r\n          data: {\r\n            event: 'memory:backup:created',\r\n            data: {\r\n              namespace,\r\n              size: backup.size,\r\n              entries: backup.entries.length,\r\n            },\r\n          },\r\n        },\r\n      ],\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Helper Functions =====\r\n\r\nasync function validateMemoryStore(\r\n  namespace: string,\r\n  key: string | undefined,\r\n  value: any,\r\n  context: AgenticHookContext\r\n): Promise<{ valid: boolean; reason?: string }> {\r\n  // Check size limits\r\n  const size = getValueSize(value);\r\n  const maxSize = 10 * 1024 * 1024; // 10MB\r\n  \r\n  if (size > maxSize) {\r\n    return {\r\n      valid: false,\r\n      reason: `Value size ${size} exceeds limit ${maxSize}`,\r\n    };\r\n  }\r\n  \r\n  // Check namespace quota\r\n  const quota = await getNamespaceQuota(namespace, context);\r\n  const usage = await getNamespaceUsage(namespace, context);\r\n  \r\n  if (usage + size > quota) {\r\n    return {\r\n      valid: false,\r\n      reason: `Namespace quota exceeded: ${usage + size} > ${quota}`,\r\n    };\r\n  }\r\n  \r\n  // Validate key format\r\n  if (key && !isValidKey(key)) {\r\n    return {\r\n      valid: false,\r\n      reason: `Invalid key format: ${key}`,\r\n    };\r\n  }\r\n  \r\n  return { valid: true };\r\n}\r\n\r\nfunction shouldCompress(value: any): boolean {\r\n  const size = getValueSize(value);\r\n  return size > 1024; // Compress if larger than 1KB\r\n}\r\n\r\nasync function compressValue(value: any): Promise<any> {\r\n  // Implement compression (placeholder)\r\n  // In real implementation, use zlib or similar\r\n  return {\r\n    compressed: true,\r\n    data: JSON.stringify(value),\r\n  };\r\n}\r\n\r\nasync function decompressValue(value: any): Promise<any> {\r\n  // Implement decompression (placeholder)\r\n  if (value.compressed) {\r\n    return JSON.parse(value.data);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction getValueSize(value: any): number {\r\n  return Buffer.byteLength(JSON.stringify(value), 'utf8');\r\n}\r\n\r\nasync function updateMemoryIndex(\r\n  namespace: string,\r\n  key: string,\r\n  value: any,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Update search index (placeholder)\r\n  // In real implementation, update inverted index for search\r\n}\r\n\r\nasync function detectMemoryPatterns(\r\n  namespace: string,\r\n  key: string,\r\n  value: any,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  // Detect patterns in memory usage\r\n  const patterns = [];\r\n  \r\n  // Check for sequential access pattern\r\n  const accessHistory = await getAccessHistory(namespace, context);\r\n  if (isSequentialPattern(accessHistory)) {\r\n    patterns.push({\r\n      type: 'sequential',\r\n      confidence: 0.8,\r\n      suggestion: 'prefetch-next',\r\n    });\r\n  }\r\n  \r\n  // Check for temporal patterns\r\n  if (isTemporalPattern(accessHistory)) {\r\n    patterns.push({\r\n      type: 'temporal',\r\n      confidence: 0.7,\r\n      suggestion: 'cache-duration',\r\n    });\r\n  }\r\n  \r\n  return patterns;\r\n}\r\n\r\nasync function checkLocalCache(\r\n  namespace: string,\r\n  key: string,\r\n  context: AgenticHookContext\r\n): Promise<any | null> {\r\n  const cacheKey = `${namespace}:${key}`;\r\n  return context.memory.cache.get(cacheKey);\r\n}\r\n\r\nasync function findRelatedKeys(\r\n  namespace: string,\r\n  key: string,\r\n  context: AgenticHookContext\r\n): Promise<string[]> {\r\n  // Find related keys based on patterns\r\n  // Placeholder implementation\r\n  return [];\r\n}\r\n\r\nasync function prefetchKeys(\r\n  namespace: string,\r\n  keys: string[],\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Trigger background prefetch\r\n  // Placeholder implementation\r\n}\r\n\r\nasync function updateAccessPattern(\r\n  namespace: string,\r\n  key: string,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Track access patterns for optimization\r\n  const patternKey = `pattern:${namespace}:${key}`;\r\n  const pattern = await context.memory.cache.get(patternKey) || {\r\n    accesses: [],\r\n    lastAccess: 0,\r\n  };\r\n  \r\n  pattern.accesses.push(Date.now());\r\n  pattern.lastAccess = Date.now();\r\n  \r\n  // Keep last 100 accesses\r\n  if (pattern.accesses.length > 100) {\r\n    pattern.accesses = pattern.accesses.slice(-100);\r\n  }\r\n  \r\n  await context.memory.cache.set(patternKey, pattern);\r\n}\r\n\r\nasync function cacheLocally(\r\n  namespace: string,\r\n  key: string,\r\n  value: any,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  const cacheKey = `${namespace}:${key}`;\r\n  context.memory.cache.set(cacheKey, value);\r\n}\r\n\r\nasync function detectMemoryChanges(\r\n  namespace: string,\r\n  provider: string,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  // Detect changes for sync\r\n  // Placeholder implementation\r\n  return [];\r\n}\r\n\r\nasync function applyMemoryChange(\r\n  change: any,\r\n  targets: string[],\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Apply memory change to targets\r\n  // Placeholder implementation\r\n}\r\n\r\nasync function createMemorySnapshot(\r\n  namespace: string,\r\n  context: AgenticHookContext\r\n): Promise<any> {\r\n  // Create snapshot of namespace\r\n  // Placeholder implementation\r\n  return {\r\n    namespace,\r\n    timestamp: Date.now(),\r\n    entries: [],\r\n    size: 0,\r\n  };\r\n}\r\n\r\nasync function findExpiredEntries(\r\n  namespace: string,\r\n  context: AgenticHookContext\r\n): Promise<string[]> {\r\n  // Find expired entries\r\n  // Placeholder implementation\r\n  return [];\r\n}\r\n\r\nasync function removeMemoryEntry(\r\n  namespace: string,\r\n  key: string,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Remove memory entry\r\n  // Placeholder implementation\r\n}\r\n\r\nasync function createFullBackup(\r\n  namespace: string,\r\n  context: AgenticHookContext\r\n): Promise<any> {\r\n  // Create full backup\r\n  // Placeholder implementation\r\n  return {\r\n    entries: [],\r\n    size: 0,\r\n  };\r\n}\r\n\r\nfunction calculateChecksum(data: any): string {\r\n  // Calculate checksum\r\n  // Placeholder implementation\r\n  return 'checksum';\r\n}\r\n\r\nasync function getNamespaceQuota(\r\n  namespace: string,\r\n  context: AgenticHookContext\r\n): Promise<number> {\r\n  // Get namespace quota\r\n  return 100 * 1024 * 1024; // 100MB default\r\n}\r\n\r\nasync function getNamespaceUsage(\r\n  namespace: string,\r\n  context: AgenticHookContext\r\n): Promise<number> {\r\n  // Get current usage\r\n  // Placeholder implementation\r\n  return 0;\r\n}\r\n\r\nfunction isValidKey(key: string): boolean {\r\n  // Validate key format\r\n  return /^[a-zA-Z0-9:_\\-./]+$/.test(key);\r\n}\r\n\r\nasync function getAccessHistory(\r\n  namespace: string,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  // Get access history\r\n  // Placeholder implementation\r\n  return [];\r\n}\r\n\r\nfunction isSequentialPattern(history: any[]): boolean {\r\n  // Check for sequential access\r\n  // Placeholder implementation\r\n  return false;\r\n}\r\n\r\nfunction isTemporalPattern(history: any[]): boolean {\r\n  // Check for temporal patterns\r\n  // Placeholder implementation\r\n  return false;\r\n}\r\n\r\n// ===== Register Hooks =====\r\n\r\nexport function registerMemoryHooks(): void {\r\n  agenticHookManager.register(preMemoryStoreHook);\r\n  agenticHookManager.register(postMemoryStoreHook);\r\n  agenticHookManager.register(preMemoryRetrieveHook);\r\n  agenticHookManager.register(postMemoryRetrieveHook);\r\n  agenticHookManager.register(memorySyncHook);\r\n  agenticHookManager.register(memoryPersistHook);\r\n}"],"names":["agenticHookManager","preMemoryStoreHook","id","type","priority","handler","payload","context","namespace","key","value","ttl","provider","sideEffects","validation","validateMemoryStore","valid","continue","action","data","level","message","processedValue","shouldCompress","compressValue","push","name","enrichedValue","metadata","stored","Date","now","sessionId","compressed","size","getValueSize","modified","postMemoryStoreHook","crossProvider","syncTargets","length","target","source","updateMemoryIndex","patterns","detectMemoryPatterns","event","preMemoryRetrieveHook","cached","checkLocalCache","relatedKeys","findRelatedKeys","prefetchKeys","postMemoryRetrieveHook","decompressValue","updateAccessPattern","cacheLocally","latency","timestamp","memorySyncHook","operation","changes","detectMemoryChanges","targets","change","applyMemoryChange","snapshot","createMemorySnapshot","expired","findExpiredEntries","removeMemoryEntry","memoryPersistHook","backup","createFullBackup","backupData","entries","checksum","calculateChecksum","maxSize","reason","quota","getNamespaceQuota","usage","getNamespaceUsage","isValidKey","JSON","stringify","parse","Buffer","byteLength","accessHistory","getAccessHistory","isSequentialPattern","confidence","suggestion","isTemporalPattern","cacheKey","memory","cache","get","keys","patternKey","pattern","accesses","lastAccess","slice","set","test","history","registerMemoryHooks","register"],"mappings":"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"}