{
  "version": 3,
  "sources": ["../../../src/swarm/optimizations/async-file-manager.ts"],
  "sourcesContent": ["/**\n * Async File Manager\n * Handles non-blocking file operations with queuing\n */\n\nimport { promises as fs } from 'node:fs';\nimport { pipeline } from 'node:stream/promises';\nimport { createWriteStream, createReadStream } from 'node:fs';\nimport { Readable } from 'node:stream';\nimport { join, dirname } from 'node:path';\nimport PQueue from 'p-queue';\nimport { Logger } from '../../core/logger.js';\n\nexport interface FileOperationResult {\n  path: string;\n  operation: 'read' | 'write' | 'delete' | 'mkdir';\n  success: boolean;\n  duration: number;\n  size?: number;\n  error?: Error;\n}\n\nexport class AsyncFileManager {\n  private writeQueue: PQueue;\n  private readQueue: PQueue;\n  private logger: Logger;\n  private metrics = {\n    operations: new Map<string, number>(),\n    totalBytes: 0,\n    errors: 0,\n  };\n\n  constructor(\n    private concurrency = {\n      write: 10,\n      read: 20,\n    },\n  ) {\n    this.writeQueue = new PQueue({ concurrency: this.concurrency.write });\n    this.readQueue = new PQueue({ concurrency: this.concurrency.read });\n\n    // Use test-safe logger configuration\n    const loggerConfig =\n      process.env.CLAUDE_FLOW_ENV === 'test'\n        ? { level: 'error' as const, format: 'json' as const, destination: 'console' as const }\n        : { level: 'info' as const, format: 'json' as const, destination: 'console' as const };\n\n    this.logger = new Logger(loggerConfig, { component: 'AsyncFileManager' });\n  }\n\n  async writeFile(path: string, data: string | Buffer): Promise<FileOperationResult> {\n    const start = Date.now();\n\n    return await this.writeQueue.add(async () => {\n      try {\n        // Ensure directory exists\n        await this.ensureDirectory(dirname(path));\n\n        // Use streaming for large files\n        if (data.length > 1024 * 1024) {\n          // > 1MB\n          await this.streamWrite(path, data);\n        } else {\n          await fs.writeFile(path, data, 'utf8');\n        }\n\n        const duration = Date.now() - start;\n        const size = Buffer.byteLength(data);\n\n        this.trackOperation('write', size);\n\n        return {\n          path,\n          operation: 'write' as const,\n          success: true,\n          duration,\n          size,\n        };\n      } catch (error) {\n        this.metrics.errors++;\n        this.logger.error('Failed to write file', { path, error });\n\n        return {\n          path,\n          operation: 'write' as const,\n          success: false,\n          duration: Date.now() - start,\n          error: error as Error,\n        };\n      }\n    });\n  }\n\n  async readFile(path: string): Promise<FileOperationResult & { data?: string }> {\n    const start = Date.now();\n\n    return await this.readQueue.add(async () => {\n      try {\n        const data = await fs.readFile(path, 'utf8');\n        const duration = Date.now() - start;\n        const size = Buffer.byteLength(data);\n\n        this.trackOperation('read', size);\n\n        return {\n          path,\n          operation: 'read' as const,\n          success: true,\n          duration,\n          size,\n          data,\n        };\n      } catch (error) {\n        this.metrics.errors++;\n        this.logger.error('Failed to read file', { path, error });\n\n        return {\n          path,\n          operation: 'read' as const,\n          success: false,\n          duration: Date.now() - start,\n          error: error as Error,\n        };\n      }\n    });\n  }\n\n  async writeJSON(path: string, data: any, pretty = true): Promise<FileOperationResult> {\n    const jsonString = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);\n\n    return this.writeFile(path, jsonString);\n  }\n\n  async readJSON(path: string): Promise<FileOperationResult & { data?: any }> {\n    const result = await this.readFile(path);\n\n    if (result.success && result.data) {\n      try {\n        const parsed = JSON.parse(result.data);\n        return { ...result, data: parsed };\n      } catch (error) {\n        return {\n          ...result,\n          success: false,\n          error: new Error('Invalid JSON format'),\n        };\n      }\n    }\n\n    return result;\n  }\n\n  async deleteFile(path: string): Promise<FileOperationResult> {\n    const start = Date.now();\n\n    return this.writeQueue.add(async () => {\n      try {\n        await fs.unlink(path);\n\n        this.trackOperation('delete', 0);\n\n        return {\n          path,\n          operation: 'delete',\n          success: true,\n          duration: Date.now() - start,\n        };\n      } catch (error) {\n        this.metrics.errors++;\n        this.logger.error('Failed to delete file', { path, error });\n\n        return {\n          path,\n          operation: 'delete',\n          success: false,\n          duration: Date.now() - start,\n          error: error as Error,\n        };\n      }\n    });\n  }\n\n  async ensureDirectory(path: string): Promise<FileOperationResult> {\n    const start = Date.now();\n\n    try {\n      await fs.mkdir(path, { recursive: true });\n\n      this.trackOperation('mkdir', 0);\n\n      return {\n        path,\n        operation: 'mkdir',\n        success: true,\n        duration: Date.now() - start,\n      };\n    } catch (error) {\n      this.metrics.errors++;\n      this.logger.error('Failed to create directory', { path, error });\n\n      return {\n        path,\n        operation: 'mkdir',\n        success: false,\n        duration: Date.now() - start,\n        error: error as Error,\n      };\n    }\n  }\n\n  async ensureDirectories(paths: string[]): Promise<FileOperationResult[]> {\n    return Promise.all(paths.map((path) => this.ensureDirectory(path)));\n  }\n\n  private async streamWrite(path: string, data: string | Buffer): Promise<void> {\n    const stream = createWriteStream(path);\n    await pipeline(Readable.from(data), stream);\n  }\n\n  async streamRead(path: string): Promise<NodeJS.ReadableStream> {\n    return createReadStream(path);\n  }\n\n  async copyFile(source: string, destination: string): Promise<FileOperationResult> {\n    const start = Date.now();\n\n    return this.writeQueue.add(async () => {\n      try {\n        await this.ensureDirectory(dirname(destination));\n        await fs.copyFile(source, destination);\n\n        const stats = await fs.stat(destination);\n        this.trackOperation('write', stats.size);\n\n        return {\n          path: destination,\n          operation: 'write',\n          success: true,\n          duration: Date.now() - start,\n          size: stats.size,\n        };\n      } catch (error) {\n        this.metrics.errors++;\n        this.logger.error('Failed to copy file', { source, destination, error });\n\n        return {\n          path: destination,\n          operation: 'write',\n          success: false,\n          duration: Date.now() - start,\n          error: error as Error,\n        };\n      }\n    });\n  }\n\n  async moveFile(source: string, destination: string): Promise<FileOperationResult> {\n    const copyResult = await this.copyFile(source, destination);\n    if (copyResult.success) {\n      await this.deleteFile(source);\n    }\n    return copyResult;\n  }\n\n  private trackOperation(type: string, bytes: number): void {\n    const count = this.metrics.operations.get(type) || 0;\n    this.metrics.operations.set(type, count + 1);\n    this.metrics.totalBytes += bytes;\n  }\n\n  getMetrics() {\n    return {\n      operations: Object.fromEntries(this.metrics.operations),\n      totalBytes: this.metrics.totalBytes,\n      errors: this.metrics.errors,\n      writeQueueSize: this.writeQueue.size,\n      readQueueSize: this.readQueue.size,\n      writeQueuePending: this.writeQueue.pending,\n      readQueuePending: this.readQueue.pending,\n    };\n  }\n\n  async waitForPendingOperations(): Promise<void> {\n    await Promise.all([this.writeQueue.onIdle(), this.readQueue.onIdle()]);\n  }\n\n  clearQueues(): void {\n    this.writeQueue.clear();\n    this.readQueue.clear();\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_node_fs", "PQueue", "fs"]
}
