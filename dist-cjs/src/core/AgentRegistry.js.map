{"version":3,"sources":["../../../src/core/AgentRegistry.ts"],"sourcesContent":["/**\r\n * AgentRegistry - Tracks and manages agent lifecycle\r\n * Provides centralized management for agent spawning, coordination, and monitoring\r\n */\r\n\r\nimport { IDatabaseProvider, IAgentCoordinator, Agent, AgentType, AgentConfig, Task, Result, Metrics, AgentMetrics, AgentPerformance } from '../types/interfaces.js';\r\nimport { nanoid } from 'nanoid';\r\n\r\nexport class AgentRegistry implements IAgentCoordinator {\r\n  private agents: Map<string, Agent> = new Map();\r\n  private tasks: Map<string, Task> = new Map();\r\n  private activeAssignments: Map<string, string[]> = new Map(); // agentId -> taskIds\r\n\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  /**\r\n   * Initialize the agent registry\r\n   */\r\n  async initialize(): Promise<void> {\r\n    // Load existing agents from database\r\n    try {\r\n      const agentIds = await this.database.list('agents');\r\n      for (const agentId of agentIds) {\r\n        const agentData = await this.database.retrieve(agentId, 'agents');\r\n        if (agentData) {\r\n          const agent = typeof agentData === 'string' ? JSON.parse(agentData) : agentData;\r\n          this.agents.set(agent.id, agent);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to load existing agents:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawn a new agent\r\n   */\r\n  async spawn(type: AgentType, config: AgentConfig = {}): Promise<Agent> {\r\n    const agent: Agent = {\r\n      id: nanoid(),\r\n      type,\r\n      capabilities: config.capabilities || this.getDefaultCapabilities(type),\r\n      status: 'idle',\r\n      metadata: {\r\n        ...config.metadata,\r\n        spawnedAt: new Date().toISOString(),\r\n        maxConcurrency: config.maxConcurrency || 1,\r\n        timeout: config.timeout || 30000,\r\n        resources: config.resources || {\r\n          memory: 512,\r\n          cpu: 1,\r\n          storage: 100,\r\n          network: 10\r\n        }\r\n      },\r\n      connections: [],\r\n      performance: {\r\n        tasksCompleted: 0,\r\n        averageResponseTime: 0,\r\n        successRate: 1.0,\r\n        resourceUtilization: {\r\n          memory: 0,\r\n          cpu: 0,\r\n          storage: 0,\r\n          network: 0\r\n        },\r\n        lastActivity: new Date()\r\n      }\r\n    };\r\n\r\n    // Store agent\r\n    this.agents.set(agent.id, agent);\r\n    await this.database.store(agent.id, agent, 'agents');\r\n\r\n    // Initialize task tracking\r\n    this.activeAssignments.set(agent.id, []);\r\n\r\n    return agent;\r\n  }\r\n\r\n  /**\r\n   * Get default capabilities for agent type\r\n   */\r\n  private getDefaultCapabilities(type: AgentType): string[] {\r\n    const capabilityMap: Record<AgentType, string[]> = {\r\n      researcher: ['research', 'analysis', 'documentation', 'web-search'],\r\n      coder: ['programming', 'debugging', 'refactoring', 'testing'],\r\n      analyst: ['data-analysis', 'visualization', 'reporting', 'metrics'],\r\n      optimizer: ['performance-tuning', 'resource-optimization', 'bottleneck-analysis'],\r\n      coordinator: ['task-delegation', 'workflow-management', 'communication'],\r\n      tester: ['unit-testing', 'integration-testing', 'quality-assurance'],\r\n      reviewer: ['code-review', 'security-audit', 'compliance-check']\r\n    };\r\n\r\n    return capabilityMap[type] || ['general'];\r\n  }\r\n\r\n  /**\r\n   * Coordinate task execution\r\n   */\r\n  async coordinate(task: Task): Promise<Result> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Find suitable agents\r\n      const suitableAgents = this.findSuitableAgents(task);\r\n\r\n      if (suitableAgents.length === 0) {\r\n        return {\r\n          success: false,\r\n          error: `No suitable agents found for task ${task.id}. Required capabilities: ${task.requiredCapabilities.join(', ')}`\r\n        };\r\n      }\r\n\r\n      // Select best agent based on availability and performance\r\n      const selectedAgent = this.selectBestAgent(suitableAgents, task);\r\n\r\n      // Assign task to agent\r\n      await this.assignTask(selectedAgent.id, task);\r\n\r\n      // Simulate task execution (in real implementation, this would communicate with actual agent)\r\n      const executionResult = await this.executeTask(selectedAgent, task);\r\n\r\n      // Update agent performance\r\n      await this.updateAgentPerformance(selectedAgent.id, task, executionResult, Date.now() - startTime);\r\n\r\n      return executionResult;\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find agents with required capabilities\r\n   */\r\n  private findSuitableAgents(task: Task): Agent[] {\r\n    return Array.from(this.agents.values()).filter(agent => {\r\n      // Check if agent has required capabilities\r\n      const hasCapabilities = task.requiredCapabilities.every(cap =>\r\n        agent.capabilities.some(agentCap =>\r\n          agentCap.toLowerCase().includes(cap.toLowerCase()) ||\r\n          cap.toLowerCase().includes(agentCap.toLowerCase())\r\n        )\r\n      );\r\n\r\n      // Check availability\r\n      const isAvailable = agent.status === 'idle' || agent.status === 'active';\r\n\r\n      // Check concurrency limits\r\n      const currentTasks = this.activeAssignments.get(agent.id)?.length || 0;\r\n      const maxConcurrency = agent.metadata.maxConcurrency || 1;\r\n      const canTakeTask = currentTasks < maxConcurrency;\r\n\r\n      return hasCapabilities && isAvailable && canTakeTask;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Select the best agent for a task\r\n   */\r\n  private selectBestAgent(candidates: Agent[], task: Task): Agent {\r\n    // Score agents based on performance, availability, and specialization\r\n    const scored = candidates.map(agent => {\r\n      let score = 0;\r\n\r\n      // Performance score (higher success rate and lower response time is better)\r\n      score += agent.performance!.successRate * 40;\r\n      score += Math.max(0, 20 - (agent.performance!.averageResponseTime / 1000)) * 2;\r\n\r\n      // Availability score (fewer active tasks is better)\r\n      const activeTasks = this.activeAssignments.get(agent.id)?.length || 0;\r\n      score += Math.max(0, 10 - activeTasks) * 3;\r\n\r\n      // Specialization score (exact capability matches are better)\r\n      const exactMatches = task.requiredCapabilities.filter(cap =>\r\n        agent.capabilities.includes(cap)\r\n      ).length;\r\n      score += exactMatches * 5;\r\n\r\n      // Priority matching\r\n      if (task.priority === 'critical' && agent.type === 'coordinator') score += 10;\r\n      if (task.priority === 'high' && ['coordinator', 'optimizer'].includes(agent.type)) score += 5;\r\n\r\n      return { agent, score };\r\n    });\r\n\r\n    // Return agent with highest score\r\n    scored.sort((a, b) => b.score - a.score);\r\n    return scored[0].agent;\r\n  }\r\n\r\n  /**\r\n   * Assign task to agent\r\n   */\r\n  private async assignTask(agentId: string, task: Task): Promise<void> {\r\n    // Update agent status\r\n    const agent = this.agents.get(agentId);\r\n    if (agent) {\r\n      agent.status = 'busy';\r\n      await this.database.store(agentId, agent, 'agents');\r\n    }\r\n\r\n    // Add to active assignments\r\n    const currentTasks = this.activeAssignments.get(agentId) || [];\r\n    currentTasks.push(task.id);\r\n    this.activeAssignments.set(agentId, currentTasks);\r\n\r\n    // Store task\r\n    this.tasks.set(task.id, task);\r\n    await this.database.store(task.id, task, 'tasks');\r\n  }\r\n\r\n  /**\r\n   * Execute task (simulation)\r\n   */\r\n  private async executeTask(agent: Agent, task: Task): Promise<Result> {\r\n    // Simulate processing time based on task complexity and agent performance\r\n    const baseTime = 1000 + Math.random() * 2000; // 1-3 seconds\r\n    const complexityFactor = task.requiredCapabilities.length * 0.5;\r\n    const performanceFactor = 2 - agent.performance!.successRate;\r\n\r\n    const processingTime = baseTime * complexityFactor * performanceFactor;\r\n\r\n    await new Promise(resolve => setTimeout(resolve, Math.min(processingTime, 5000)));\r\n\r\n    // Simulate success/failure based on agent performance\r\n    const successProbability = agent.performance!.successRate * 0.9 + 0.1;\r\n    const success = Math.random() < successProbability;\r\n\r\n    if (success) {\r\n      return {\r\n        success: true,\r\n        data: {\r\n          taskId: task.id,\r\n          agentId: agent.id,\r\n          result: `Task ${task.description} completed successfully by ${agent.type} agent`,\r\n          processingTime: Math.round(processingTime)\r\n        },\r\n        metadata: {\r\n          capabilities: agent.capabilities,\r\n          performance: agent.performance\r\n        }\r\n      };\r\n    } else {\r\n      return {\r\n        success: false,\r\n        error: `Task ${task.id} failed during execution by agent ${agent.id}`,\r\n        metadata: {\r\n          processingTime: Math.round(processingTime)\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update agent performance metrics\r\n   */\r\n  private async updateAgentPerformance(agentId: string, task: Task, result: Result, duration: number): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent || !agent.performance) return;\r\n\r\n    const perf = agent.performance;\r\n\r\n    // Update task count\r\n    perf.tasksCompleted++;\r\n\r\n    // Update success rate (exponential moving average)\r\n    const alpha = 0.1; // Learning rate\r\n    perf.successRate = perf.successRate * (1 - alpha) + (result.success ? 1 : 0) * alpha;\r\n\r\n    // Update average response time\r\n    perf.averageResponseTime = perf.averageResponseTime * (1 - alpha) + duration * alpha;\r\n\r\n    // Update last activity\r\n    perf.lastActivity = new Date();\r\n\r\n    // Update resource utilization (simulated)\r\n    perf.resourceUtilization = {\r\n      memory: Math.min(100, perf.resourceUtilization.memory + Math.random() * 10),\r\n      cpu: Math.min(100, perf.resourceUtilization.cpu + Math.random() * 15),\r\n      storage: Math.min(100, perf.resourceUtilization.storage + Math.random() * 5),\r\n      network: Math.min(100, perf.resourceUtilization.network + Math.random() * 8)\r\n    };\r\n\r\n    // Update agent status\r\n    const currentTasks = this.activeAssignments.get(agentId) || [];\r\n    const updatedTasks = currentTasks.filter(id => id !== task.id);\r\n    this.activeAssignments.set(agentId, updatedTasks);\r\n\r\n    agent.status = updatedTasks.length > 0 ? 'busy' : 'idle';\r\n\r\n    // Persist changes\r\n    await this.database.store(agentId, agent, 'agents');\r\n  }\r\n\r\n  /**\r\n   * Monitor all agents\r\n   */\r\n  async monitor(): Promise<Metrics> {\r\n    const agentMetrics: AgentMetrics[] = Array.from(this.agents.values()).map(agent => ({\r\n      agentId: agent.id,\r\n      type: agent.type,\r\n      performance: agent.performance!,\r\n      status: agent.status\r\n    }));\r\n\r\n    // Calculate system metrics\r\n    const totalMemory = agentMetrics.reduce((sum, m) => sum + m.performance.resourceUtilization.memory, 0);\r\n    const totalCpu = agentMetrics.reduce((sum, m) => sum + m.performance.resourceUtilization.cpu, 0);\r\n    const activeConnections = Array.from(this.agents.values()).reduce((sum, agent) => sum + (agent.connections?.length || 0), 0);\r\n\r\n    const systemMetrics = {\r\n      uptime: Date.now() - (this.getOldestAgent()?.metadata.spawnedAt ? new Date(this.getOldestAgent()!.metadata.spawnedAt).getTime() : Date.now()),\r\n      memoryUsage: totalMemory / agentMetrics.length || 0,\r\n      cpuUsage: totalCpu / agentMetrics.length || 0,\r\n      networkLatency: Math.random() * 10 + 5, // Simulated\r\n      activeConnections\r\n    };\r\n\r\n    // Calculate performance metrics\r\n    const totalTasks = agentMetrics.reduce((sum, m) => sum + m.performance.tasksCompleted, 0);\r\n    const avgSuccessRate = agentMetrics.reduce((sum, m) => sum + m.performance.successRate, 0) / agentMetrics.length || 0;\r\n    const avgResponseTime = agentMetrics.reduce((sum, m) => sum + m.performance.averageResponseTime, 0) / agentMetrics.length || 0;\r\n\r\n    const performanceMetrics = {\r\n      throughput: totalTasks / (systemMetrics.uptime / 1000 / 60) || 0, // tasks per minute\r\n      latency: avgResponseTime,\r\n      errorRate: 1 - avgSuccessRate,\r\n      bottlenecks: this.identifyBottlenecks(agentMetrics)\r\n    };\r\n\r\n    return {\r\n      agents: agentMetrics,\r\n      system: systemMetrics,\r\n      performance: performanceMetrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Identify performance bottlenecks\r\n   */\r\n  private identifyBottlenecks(agentMetrics: AgentMetrics[]): string[] {\r\n    const bottlenecks: string[] = [];\r\n\r\n    // High CPU usage\r\n    const highCpuAgents = agentMetrics.filter(m => m.performance.resourceUtilization.cpu > 80);\r\n    if (highCpuAgents.length > 0) {\r\n      bottlenecks.push(`High CPU usage: ${highCpuAgents.map(a => a.agentId).join(', ')}`);\r\n    }\r\n\r\n    // High memory usage\r\n    const highMemoryAgents = agentMetrics.filter(m => m.performance.resourceUtilization.memory > 80);\r\n    if (highMemoryAgents.length > 0) {\r\n      bottlenecks.push(`High memory usage: ${highMemoryAgents.map(a => a.agentId).join(', ')}`);\r\n    }\r\n\r\n    // Low success rate\r\n    const lowSuccessAgents = agentMetrics.filter(m => m.performance.successRate < 0.8);\r\n    if (lowSuccessAgents.length > 0) {\r\n      bottlenecks.push(`Low success rate: ${lowSuccessAgents.map(a => a.agentId).join(', ')}`);\r\n    }\r\n\r\n    // High response time\r\n    const slowAgents = agentMetrics.filter(m => m.performance.averageResponseTime > 5000);\r\n    if (slowAgents.length > 0) {\r\n      bottlenecks.push(`Slow response time: ${slowAgents.map(a => a.agentId).join(', ')}`);\r\n    }\r\n\r\n    return bottlenecks;\r\n  }\r\n\r\n  /**\r\n   * Shutdown agent\r\n   */\r\n  async shutdown(agentId: string): Promise<void> {\r\n    const agent = this.agents.get(agentId);\r\n    if (!agent) return;\r\n\r\n    // Cancel active tasks\r\n    const activeTasks = this.activeAssignments.get(agentId) || [];\r\n    for (const taskId of activeTasks) {\r\n      await this.database.delete(taskId, 'tasks');\r\n    }\r\n\r\n    // Remove agent\r\n    this.agents.delete(agentId);\r\n    this.activeAssignments.delete(agentId);\r\n    await this.database.delete(agentId, 'agents');\r\n  }\r\n\r\n  /**\r\n   * Get active agents\r\n   */\r\n  async getActiveAgents(): Promise<Agent[]> {\r\n    return Array.from(this.agents.values()).filter(agent => agent.status !== 'offline');\r\n  }\r\n\r\n  /**\r\n   * Get agent by ID\r\n   */\r\n  getAgent(agentId: string): Agent | undefined {\r\n    return this.agents.get(agentId);\r\n  }\r\n\r\n  /**\r\n   * Get agents by type\r\n   */\r\n  getAgentsByType(type: AgentType): Agent[] {\r\n    return Array.from(this.agents.values()).filter(agent => agent.type === type);\r\n  }\r\n\r\n  /**\r\n   * Get agent count\r\n   */\r\n  getAgentCount(): number {\r\n    return this.agents.size;\r\n  }\r\n\r\n  /**\r\n   * Get oldest agent (for uptime calculation)\r\n   */\r\n  private getOldestAgent(): Agent | undefined {\r\n    let oldest: Agent | undefined;\r\n    let oldestTime = Date.now();\r\n\r\n    for (const agent of this.agents.values()) {\r\n      const spawnTime = new Date(agent.metadata.spawnedAt).getTime();\r\n      if (spawnTime < oldestTime) {\r\n        oldestTime = spawnTime;\r\n        oldest = agent;\r\n      }\r\n    }\r\n\r\n    return oldest;\r\n  }\r\n}"],"names":["nanoid","AgentRegistry","agents","Map","tasks","activeAssignments","database","initialize","agentIds","list","agentId","agentData","retrieve","agent","JSON","parse","set","id","error","console","warn","spawn","type","config","capabilities","getDefaultCapabilities","status","metadata","spawnedAt","Date","toISOString","maxConcurrency","timeout","resources","memory","cpu","storage","network","connections","performance","tasksCompleted","averageResponseTime","successRate","resourceUtilization","lastActivity","store","capabilityMap","researcher","coder","analyst","optimizer","coordinator","tester","reviewer","coordinate","task","startTime","now","suitableAgents","findSuitableAgents","length","success","requiredCapabilities","join","selectedAgent","selectBestAgent","assignTask","executionResult","executeTask","updateAgentPerformance","Error","message","String","Array","from","values","filter","hasCapabilities","every","cap","some","agentCap","toLowerCase","includes","isAvailable","currentTasks","get","canTakeTask","candidates","scored","map","score","Math","max","activeTasks","exactMatches","priority","sort","a","b","push","baseTime","random","complexityFactor","performanceFactor","processingTime","Promise","resolve","setTimeout","min","successProbability","data","taskId","result","description","round","duration","perf","alpha","updatedTasks","monitor","agentMetrics","totalMemory","reduce","sum","m","totalCpu","activeConnections","systemMetrics","uptime","getOldestAgent","getTime","memoryUsage","cpuUsage","networkLatency","totalTasks","avgSuccessRate","avgResponseTime","performanceMetrics","throughput","latency","errorRate","bottlenecks","identifyBottlenecks","system","highCpuAgents","highMemoryAgents","lowSuccessAgents","slowAgents","shutdown","delete","getActiveAgents","getAgent","getAgentsByType","getAgentCount","size","oldest","oldestTime","spawnTime"],"mappings":"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"}