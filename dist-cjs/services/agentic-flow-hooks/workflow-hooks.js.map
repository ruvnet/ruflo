{
  "version": 3,
  "sources": ["../../../src/services/agentic-flow-hooks/workflow-hooks.ts"],
  "sourcesContent": ["/**\n * Self-improving workflow hooks for agentic-flow\n * \n * Enables adaptive workflows with provider selection\n * and continuous improvement based on outcomes.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  WorkflowHookPayload,\n  WorkflowDecision,\n  Learning,\n  SideEffect,\n  Pattern,\n} from './types.js';\n\n// ===== Workflow Start Hook =====\n\nexport const workflowStartHook = {\n  id: 'agentic-workflow-start',\n  type: 'workflow-start' as const,\n  priority: 100,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, state } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Load workflow history and learnings\n    const history = await loadWorkflowHistory(workflowId, context);\n    const learnings = await loadWorkflowLearnings(workflowId, context);\n    \n    // Select optimal provider based on history\n    const provider = await selectOptimalProvider(\n      workflowId,\n      state,\n      history,\n      context\n    );\n    \n    // Initialize workflow state\n    const enhancedState = {\n      ...state,\n      startTime: Date.now(),\n      provider,\n      learnings: learnings.slice(-10), // Last 10 learnings\n      predictions: await generateWorkflowPredictions(workflowId, state, context),\n    };\n    \n    // Store workflow session\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `workflow:session:${workflowId}:${context.sessionId}`,\n        value: enhancedState,\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    // Track workflow start\n    sideEffects.push({\n      type: 'metric',\n      action: 'increment',\n      data: { name: `workflow.starts.${workflowId}` },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        state: enhancedState,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Step Hook =====\n\nexport const workflowStepHook = {\n  id: 'agentic-workflow-step',\n  type: 'workflow-step' as const,\n  priority: 100,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, step, state } = payload;\n    \n    if (!step) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Measure step performance\n    const stepStart = Date.now();\n    \n    // Check for step optimizations\n    const optimizations = await getStepOptimizations(\n      workflowId,\n      step,\n      context\n    );\n    \n    if (optimizations.length > 0) {\n      // Apply step optimizations\n      const optimizedState = applyStepOptimizations(\n        state,\n        optimizations\n      );\n      \n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: `Applied ${optimizations.length} optimizations to step ${step}`,\n          data: { optimizations },\n        },\n      });\n      \n      return {\n        continue: true,\n        modified: true,\n        payload: {\n          ...payload,\n          state: optimizedState,\n        },\n        sideEffects,\n      };\n    }\n    \n    // Track step execution\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `workflow:step:${workflowId}:${step}:${Date.now()}`,\n        value: {\n          step,\n          state: summarizeState(state),\n          timestamp: Date.now(),\n        },\n        ttl: 86400,\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Decision Hook =====\n\nexport const workflowDecisionHook = {\n  id: 'agentic-workflow-decision',\n  type: 'workflow-decision' as const,\n  priority: 90,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, decision, state } = payload;\n    \n    if (!decision) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Enhance decision with historical data\n    const historicalOutcomes = await getDecisionOutcomes(\n      workflowId,\n      decision.point,\n      context\n    );\n    \n    // Calculate confidence adjustments\n    const adjustedDecision = adjustDecisionConfidence(\n      decision,\n      historicalOutcomes\n    );\n    \n    // Generate alternative paths\n    const alternatives = await generateAlternativeDecisions(\n      workflowId,\n      decision,\n      state,\n      context\n    );\n    \n    if (alternatives.length > 0) {\n      // Check if better alternative exists\n      const bestAlternative = alternatives.find(alt => \n        alt.confidence > adjustedDecision.confidence * 1.2\n      );\n      \n      if (bestAlternative) {\n        sideEffects.push({\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'workflow:decision:alternative',\n            data: {\n              original: adjustedDecision,\n              suggested: bestAlternative,\n            },\n          },\n        });\n        \n        // Override with better decision\n        adjustedDecision.selected = bestAlternative.selected;\n        adjustedDecision.confidence = bestAlternative.confidence;\n        adjustedDecision.reasoning = `${adjustedDecision.reasoning} (AI-optimized)`;\n      }\n    }\n    \n    // Store decision for learning\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `decision:${workflowId}:${decision.point}:${Date.now()}`,\n        value: {\n          ...adjustedDecision,\n          alternatives,\n          state: summarizeState(state),\n        },\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Track decision metrics\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `workflow.decisions.confidence.${workflowId}`,\n        value: adjustedDecision.confidence,\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        decision: adjustedDecision,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Complete Hook =====\n\nexport const workflowCompleteHook = {\n  id: 'agentic-workflow-complete',\n  type: 'workflow-complete' as const,\n  priority: 100,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, state, metrics } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Calculate workflow performance\n    const performance = calculateWorkflowPerformance(state, metrics);\n    \n    // Extract learnings from this execution\n    const learnings = await extractWorkflowLearnings(\n      workflowId,\n      state,\n      performance,\n      context\n    );\n    \n    // Store learnings\n    for (const learning of learnings) {\n      sideEffects.push({\n        type: 'memory',\n        action: 'store',\n        data: {\n          key: `learning:${workflowId}:${learning.type}:${Date.now()}`,\n          value: learning,\n          ttl: 0, // Permanent\n        },\n      });\n    }\n    \n    // Update workflow success patterns\n    if (performance.success) {\n      const pattern: Pattern = {\n        id: `workflow_success_${Date.now()}`,\n        type: 'success',\n        confidence: performance.score,\n        occurrences: 1,\n        context: {\n          workflowId,\n          provider: state.provider,\n          duration: metrics?.duration || 0,\n          decisions: countDecisions(state),\n        },\n      };\n      \n      context.neural.patterns.add(pattern);\n      \n      sideEffects.push({\n        type: 'neural',\n        action: 'train',\n        data: {\n          patterns: [pattern],\n          modelId: `workflow-optimizer-${workflowId}`,\n        },\n      });\n    }\n    \n    // Generate improvement suggestions\n    const improvements = await generateImprovementSuggestions(\n      workflowId,\n      state,\n      performance,\n      learnings,\n      context\n    );\n    \n    if (improvements.length > 0) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'workflow:improvements:suggested',\n          data: {\n            workflowId,\n            improvements,\n            performance,\n          },\n        },\n      });\n    }\n    \n    // Update workflow metrics\n    sideEffects.push(\n      {\n        type: 'metric',\n        action: 'update',\n        data: {\n          name: `workflow.completion.rate.${workflowId}`,\n          value: performance.success ? 1 : 0,\n        },\n      },\n      {\n        type: 'metric',\n        action: 'update',\n        data: {\n          name: `workflow.performance.score.${workflowId}`,\n          value: performance.score,\n        },\n      }\n    );\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Error Hook =====\n\nexport const workflowErrorHook = {\n  id: 'agentic-workflow-error',\n  type: 'workflow-error' as const,\n  priority: 95,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, error, state } = payload;\n    \n    if (!error) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Analyze error pattern\n    const errorPattern = await analyzeErrorPattern(\n      workflowId,\n      error,\n      state,\n      context\n    );\n    \n    // Store error for learning\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `error:${workflowId}:${Date.now()}`,\n        value: {\n          error: {\n            message: error.message,\n            stack: error.stack,\n            type: error.name,\n          },\n          pattern: errorPattern,\n          state: summarizeState(state),\n          timestamp: Date.now(),\n        },\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Check for recovery strategies\n    const recovery = await findRecoveryStrategy(\n      workflowId,\n      error,\n      errorPattern,\n      context\n    );\n    \n    if (recovery) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Recovery strategy found',\n          data: recovery,\n        },\n      });\n      \n      // Apply recovery\n      const recoveredState = applyRecoveryStrategy(state, recovery);\n      \n      return {\n        continue: true,\n        modified: true,\n        payload: {\n          ...payload,\n          state: recoveredState,\n          error: undefined, // Clear error after recovery\n        },\n        sideEffects,\n      };\n    }\n    \n    // Learn from failure\n    const failureLearning: Learning = {\n      type: 'failure',\n      context: `Error in workflow ${workflowId}: ${error.message}`,\n      value: {\n        errorType: error.name,\n        state: summarizeState(state),\n        pattern: errorPattern,\n      },\n      applicability: errorPattern.confidence,\n    };\n    \n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `learning:failure:${workflowId}:${Date.now()}`,\n        value: failureLearning,\n        ttl: 0, // Permanent\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nasync function loadWorkflowHistory(\n  workflowId: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  const historyKey = `workflow:history:${workflowId}`;\n  return await context.memory.cache.get(historyKey) || [];\n}\n\nasync function loadWorkflowLearnings(\n  workflowId: string,\n  context: AgenticHookContext\n): Promise<Learning[]> {\n  const learningsKey = `workflow:learnings:${workflowId}`;\n  return await context.memory.cache.get(learningsKey) || [];\n}\n\nasync function selectOptimalProvider(\n  workflowId: string,\n  state: any,\n  history: any[],\n  context: AgenticHookContext\n): Promise<string> {\n  // Analyze historical performance by provider\n  const providerStats = new Map<string, { success: number; total: number }>();\n  \n  for (const execution of history) {\n    const provider = execution.provider;\n    if (!provider) continue;\n    \n    const stats = providerStats.get(provider) || { success: 0, total: 0 };\n    stats.total++;\n    if (execution.success) stats.success++;\n    providerStats.set(provider, stats);\n  }\n  \n  // Calculate success rates\n  let bestProvider = 'openai'; // Default\n  let bestRate = 0;\n  \n  for (const [provider, stats] of providerStats) {\n    const rate = stats.success / stats.total;\n    if (rate > bestRate && stats.total >= 5) {\n      bestRate = rate;\n      bestProvider = provider;\n    }\n  }\n  \n  // Check current provider health\n  const healthKey = `provider:health:${bestProvider}`;\n  const health = await context.memory.cache.get(healthKey);\n  \n  if (health && health.score < 0.5) {\n    // Provider unhealthy, select alternative\n    return selectAlternativeProvider(bestProvider, providerStats);\n  }\n  \n  return bestProvider;\n}\n\nasync function generateWorkflowPredictions(\n  workflowId: string,\n  state: any,\n  context: AgenticHookContext\n): Promise<any> {\n  // Generate predictions for workflow execution\n  const predictions = {\n    estimatedDuration: 0,\n    successProbability: 0.7,\n    likelyBottlenecks: [],\n    recommendedOptimizations: [],\n  };\n  \n  // Load historical durations\n  const history = await loadWorkflowHistory(workflowId, context);\n  if (history.length > 0) {\n    const durations = history\n      .filter(h => h.duration)\n      .map(h => h.duration);\n    \n    if (durations.length > 0) {\n      predictions.estimatedDuration = \n        durations.reduce((a, b) => a + b, 0) / durations.length;\n    }\n    \n    const successes = history.filter(h => h.success).length;\n    predictions.successProbability = successes / history.length;\n  }\n  \n  return predictions;\n}\n\nasync function getStepOptimizations(\n  workflowId: string,\n  step: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Get optimizations for specific step\n  const optKey = `optimizations:${workflowId}:${step}`;\n  return await context.memory.cache.get(optKey) || [];\n}\n\nfunction applyStepOptimizations(\n  state: any,\n  optimizations: any[]\n): any {\n  let optimizedState = { ...state };\n  \n  for (const opt of optimizations) {\n    switch (opt.type) {\n      case 'skip':\n        if (opt.condition && opt.condition(state)) {\n          optimizedState.skipSteps = [\n            ...(optimizedState.skipSteps || []),\n            opt.target,\n          ];\n        }\n        break;\n        \n      case 'parallel':\n        optimizedState.parallelSteps = [\n          ...(optimizedState.parallelSteps || []),\n          ...opt.steps,\n        ];\n        break;\n        \n      case 'cache':\n        optimizedState.useCache = true;\n        optimizedState.cacheKeys = [\n          ...(optimizedState.cacheKeys || []),\n          opt.key,\n        ];\n        break;\n    }\n  }\n  \n  return optimizedState;\n}\n\nfunction summarizeState(state: any): any {\n  // Create summary of state for storage\n  return {\n    keys: Object.keys(state),\n    size: JSON.stringify(state).length,\n    hasError: !!state.error,\n    provider: state.provider,\n    timestamp: Date.now(),\n  };\n}\n\nasync function getDecisionOutcomes(\n  workflowId: string,\n  decisionPoint: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Get historical outcomes for decision point\n  const outcomeKey = `outcomes:${workflowId}:${decisionPoint}`;\n  return await context.memory.cache.get(outcomeKey) || [];\n}\n\nfunction adjustDecisionConfidence(\n  decision: WorkflowDecision,\n  historicalOutcomes: any[]\n): WorkflowDecision {\n  if (historicalOutcomes.length === 0) {\n    return decision;\n  }\n  \n  // Calculate success rate for selected option\n  const relevantOutcomes = historicalOutcomes.filter(o => \n    o.selected === decision.selected\n  );\n  \n  if (relevantOutcomes.length === 0) {\n    return decision;\n  }\n  \n  const successRate = relevantOutcomes.filter(o => o.success).length / \n    relevantOutcomes.length;\n  \n  // Adjust confidence based on historical success\n  const adjustedConfidence = decision.confidence * 0.7 + successRate * 0.3;\n  \n  return {\n    ...decision,\n    confidence: adjustedConfidence,\n    learnings: [\n      ...decision.learnings,\n      {\n        type: 'success',\n        context: `Historical success rate: ${(successRate * 100).toFixed(1)}%`,\n        value: successRate,\n        applicability: Math.min(relevantOutcomes.length / 10, 1),\n      },\n    ],\n  };\n}\n\nasync function generateAlternativeDecisions(\n  workflowId: string,\n  decision: WorkflowDecision,\n  state: any,\n  context: AgenticHookContext\n): Promise<WorkflowDecision[]> {\n  // Generate alternative decision paths\n  const alternatives: WorkflowDecision[] = [];\n  \n  // Check each option not selected\n  for (const option of decision.options) {\n    if (option === decision.selected) continue;\n    \n    // Calculate alternative confidence\n    const altConfidence = await calculateAlternativeConfidence(\n      workflowId,\n      decision.point,\n      option,\n      state,\n      context\n    );\n    \n    if (altConfidence > 0.5) {\n      alternatives.push({\n        ...decision,\n        selected: option,\n        confidence: altConfidence,\n        reasoning: `Alternative path based on historical analysis`,\n      });\n    }\n  }\n  \n  return alternatives;\n}\n\nfunction calculateWorkflowPerformance(\n  state: any,\n  metrics: any\n): any {\n  const performance = {\n    success: !state.error,\n    score: 0,\n    duration: metrics?.duration || 0,\n    efficiency: 0,\n    reliability: 0,\n  };\n  \n  // Calculate performance score\n  if (performance.success) {\n    performance.score = 0.7; // Base success score\n    \n    // Adjust for duration\n    if (metrics?.duration && state.predictions?.estimatedDuration) {\n      const durationRatio = state.predictions.estimatedDuration / metrics.duration;\n      performance.efficiency = Math.min(durationRatio, 1);\n      performance.score += performance.efficiency * 0.2;\n    }\n    \n    // Adjust for error rate\n    if (metrics?.errorRate !== undefined) {\n      performance.reliability = 1 - metrics.errorRate;\n      performance.score += performance.reliability * 0.1;\n    }\n  }\n  \n  return performance;\n}\n\nasync function extractWorkflowLearnings(\n  workflowId: string,\n  state: any,\n  performance: any,\n  context: AgenticHookContext\n): Promise<Learning[]> {\n  const learnings: Learning[] = [];\n  \n  // Learn from successful execution\n  if (performance.success) {\n    learnings.push({\n      type: 'success',\n      context: `Successful workflow execution with score ${performance.score}`,\n      value: {\n        provider: state.provider,\n        duration: performance.duration,\n        decisions: extractDecisions(state),\n      },\n      applicability: performance.score,\n    });\n  }\n  \n  // Learn from optimizations\n  if (state.appliedOptimizations) {\n    for (const opt of state.appliedOptimizations) {\n      learnings.push({\n        type: 'optimization',\n        context: `Applied ${opt.type} optimization at ${opt.step}`,\n        value: opt,\n        applicability: 0.8,\n      });\n    }\n  }\n  \n  return learnings;\n}\n\nfunction countDecisions(state: any): number {\n  // Count decisions made during workflow\n  return state.decisions?.length || 0;\n}\n\nasync function generateImprovementSuggestions(\n  workflowId: string,\n  state: any,\n  performance: any,\n  learnings: Learning[],\n  context: AgenticHookContext\n): Promise<any[]> {\n  const suggestions: any[] = [];\n  \n  // Suggest caching if repeated operations\n  if (performance.duration > 5000) {\n    suggestions.push({\n      type: 'cache',\n      target: 'frequent_operations',\n      reason: 'Long execution time detected',\n      expectedImprovement: '30-50% reduction in duration',\n    });\n  }\n  \n  // Suggest parallelization\n  if (state.sequentialSteps?.length > 3) {\n    suggestions.push({\n      type: 'parallel',\n      target: 'independent_steps',\n      reason: 'Multiple sequential steps detected',\n      expectedImprovement: '40-60% reduction in duration',\n    });\n  }\n  \n  // Suggest provider switch based on learnings\n  const providerLearnings = learnings.filter(l => \n    l.type === 'success' && l.value.provider\n  );\n  \n  if (providerLearnings.length > 0) {\n    const providerScores = new Map<string, number>();\n    for (const learning of providerLearnings) {\n      const provider = learning.value.provider;\n      const score = providerScores.get(provider) || 0;\n      providerScores.set(provider, score + learning.applicability);\n    }\n    \n    const currentScore = providerScores.get(state.provider) || 0;\n    for (const [provider, score] of providerScores) {\n      if (score > currentScore * 1.2) {\n        suggestions.push({\n          type: 'provider',\n          target: provider,\n          reason: `${provider} shows better historical performance`,\n          expectedImprovement: `${((score / currentScore - 1) * 100).toFixed(0)}% better reliability`,\n        });\n      }\n    }\n  }\n  \n  return suggestions;\n}\n\nasync function analyzeErrorPattern(\n  workflowId: string,\n  error: Error,\n  state: any,\n  context: AgenticHookContext\n): Promise<any> {\n  // Analyze error to find patterns\n  const pattern = {\n    type: classifyError(error),\n    confidence: 0.7,\n    context: {\n      step: state.currentStep,\n      provider: state.provider,\n      errorMessage: error.message,\n    },\n  };\n  \n  // Check for similar errors\n  const errorHistory = await context.memory.cache.get(\n    `errors:${workflowId}:${pattern.type}`\n  ) || [];\n  \n  if (errorHistory.length > 5) {\n    pattern.confidence = 0.9;\n    pattern.context.recurring = true;\n    pattern.context.occurrences = errorHistory.length;\n  }\n  \n  return pattern;\n}\n\nasync function findRecoveryStrategy(\n  workflowId: string,\n  error: Error,\n  errorPattern: any,\n  context: AgenticHookContext\n): Promise<any | null> {\n  // Find recovery strategy for error\n  if (errorPattern.type === 'timeout') {\n    return {\n      type: 'retry',\n      params: {\n        maxRetries: 3,\n        backoff: 'exponential',\n        timeout: 30000,\n      },\n    };\n  }\n  \n  if (errorPattern.type === 'rate_limit') {\n    return {\n      type: 'throttle',\n      params: {\n        delay: 1000,\n        maxConcurrent: 1,\n      },\n    };\n  }\n  \n  if (errorPattern.type === 'validation') {\n    return {\n      type: 'transform',\n      params: {\n        sanitize: true,\n        validate: true,\n      },\n    };\n  }\n  \n  return null;\n}\n\nfunction applyRecoveryStrategy(state: any, recovery: any): any {\n  const recoveredState = { ...state };\n  \n  switch (recovery.type) {\n    case 'retry':\n      recoveredState.retryConfig = recovery.params;\n      recoveredState.shouldRetry = true;\n      break;\n      \n    case 'throttle':\n      recoveredState.throttleConfig = recovery.params;\n      recoveredState.throttled = true;\n      break;\n      \n    case 'transform':\n      recoveredState.transformConfig = recovery.params;\n      recoveredState.needsTransform = true;\n      break;\n  }\n  \n  recoveredState.recoveryApplied = recovery;\n  delete recoveredState.error; // Clear error state\n  \n  return recoveredState;\n}\n\nfunction selectAlternativeProvider(\n  currentProvider: string,\n  providerStats: Map<string, { success: number; total: number }>\n): string {\n  // Select alternative provider based on stats\n  let bestAlternative = 'anthropic'; // Default fallback\n  let bestRate = 0;\n  \n  for (const [provider, stats] of providerStats) {\n    if (provider === currentProvider) continue;\n    \n    const rate = stats.success / stats.total;\n    if (rate > bestRate && stats.total >= 3) {\n      bestRate = rate;\n      bestAlternative = provider;\n    }\n  }\n  \n  return bestAlternative;\n}\n\nasync function calculateAlternativeConfidence(\n  workflowId: string,\n  decisionPoint: string,\n  option: string,\n  state: any,\n  context: AgenticHookContext\n): Promise<number> {\n  // Calculate confidence for alternative option\n  const outcomeKey = `outcomes:${workflowId}:${decisionPoint}:${option}`;\n  const outcomes = await context.memory.cache.get(outcomeKey) || [];\n  \n  if (outcomes.length === 0) {\n    return 0.5; // Default confidence\n  }\n  \n  const successRate = outcomes.filter((o: any) => o.success).length / \n    outcomes.length;\n  \n  // Adjust for recency\n  const recentOutcomes = outcomes.slice(-10);\n  const recentSuccessRate = recentOutcomes.filter((o: any) => o.success).length / \n    recentOutcomes.length;\n  \n  return successRate * 0.7 + recentSuccessRate * 0.3;\n}\n\nfunction extractDecisions(state: any): any[] {\n  // Extract decisions from state\n  return state.decisions || [];\n}\n\nfunction classifyError(error: Error): string {\n  const message = error.message.toLowerCase();\n  \n  if (message.includes('timeout')) return 'timeout';\n  if (message.includes('rate limit')) return 'rate_limit';\n  if (message.includes('validation')) return 'validation';\n  if (message.includes('network')) return 'network';\n  if (message.includes('auth')) return 'authentication';\n  \n  return 'unknown';\n}\n\n// ===== Register Hooks =====\n\nexport function registerWorkflowHooks(): void {\n  agenticHookManager.register(workflowStartHook);\n  agenticHookManager.register(workflowStepHook);\n  agenticHookManager.register(workflowDecisionHook);\n  agenticHookManager.register(workflowCompleteHook);\n  agenticHookManager.register(workflowErrorHook);\n}"],
  "mappings": "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",
  "names": []
}
