{"version":3,"sources":["../../../src/swarm/mcp-integration-wrapper.ts"],"sourcesContent":["/**\r\n * MCP Integration Wrapper for Swarm System\r\n * \r\n * This module provides a comprehensive wrapper around MCP tools to enable\r\n * seamless integration with the swarm orchestration system. It handles\r\n * tool discovery, execution, error handling, and result aggregation.\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport { Logger } from '../core/logger.js';\r\nimport { generateId } from '../utils/helpers.js';\r\nimport { createClaudeFlowTools } from '../mcp/claude-flow-tools.js';\r\nimport { createRuvSwarmTools } from '../mcp/ruv-swarm-tools.js';\r\nimport type { MCPTool, MCPContext } from '../utils/types.js';\r\nimport type { AdvancedSwarmOrchestrator } from './advanced-orchestrator.js';\r\nimport {\r\n  SwarmAgent,\r\n  SwarmTask,\r\n  TaskResult,\r\n  SwarmExecutionContext,\r\n  AgentState,\r\n  TaskDefinition,\r\n} from './types.js';\r\n\r\nexport interface MCPToolExecutionResult {\r\n  success: boolean;\r\n  result?: any;\r\n  error?: string;\r\n  duration: number;\r\n  toolName: string;\r\n  agentId: string;\r\n  taskId?: string;\r\n  metadata: {\r\n    timestamp: Date;\r\n    executionId: string;\r\n    attempts: number;\r\n    resourcesUsed?: any;\r\n  };\r\n}\r\n\r\nexport interface MCPToolRegistry {\r\n  tools: Map<string, MCPTool>;\r\n  categories: Map<string, string[]>;\r\n  capabilities: Map<string, string[]>;\r\n  permissions: Map<string, string[]>;\r\n}\r\n\r\nexport interface MCPExecutionContext extends MCPContext {\r\n  orchestrator: AdvancedSwarmOrchestrator;\r\n  agent: SwarmAgent;\r\n  task?: SwarmTask;\r\n  swarmId: string;\r\n  executionId: string;\r\n  timeout: number;\r\n  maxRetries: number;\r\n}\r\n\r\nexport interface MCPIntegrationConfig {\r\n  enableClaudeFlowTools: boolean;\r\n  enableRuvSwarmTools: boolean;\r\n  enableCustomTools: boolean;\r\n  toolTimeout: number;\r\n  maxRetries: number;\r\n  enableCaching: boolean;\r\n  cacheTimeout: number;\r\n  enableMetrics: boolean;\r\n  enableLogging: boolean;\r\n  enableErrorRecovery: boolean;\r\n  parallelExecution: boolean;\r\n  maxConcurrentTools: number;\r\n}\r\n\r\nexport class MCPIntegrationWrapper extends EventEmitter {\r\n  private logger: Logger;\r\n  private config: MCPIntegrationConfig;\r\n  private toolRegistry: MCPToolRegistry;\r\n  private executionCache: Map<string, MCPToolExecutionResult> = new Map();\r\n  private activeExecutions: Map<string, AbortController> = new Map();\r\n  private metrics: MCPIntegrationMetrics;\r\n\r\n  constructor(config: Partial<MCPIntegrationConfig> = {}) {\r\n    super();\r\n    \r\n    this.logger = new Logger('MCPIntegrationWrapper');\r\n    this.config = this.createDefaultConfig(config);\r\n    this.toolRegistry = this.initializeToolRegistry();\r\n    this.metrics = this.initializeMetrics();\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  /**\r\n   * Initialize the MCP integration wrapper\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing MCP integration wrapper...');\r\n\r\n    try {\r\n      // Register Claude Flow tools\r\n      if (this.config.enableClaudeFlowTools) {\r\n        await this.registerClaudeFlowTools();\r\n      }\r\n\r\n      // Register ruv-swarm tools\r\n      if (this.config.enableRuvSwarmTools) {\r\n        await this.registerRuvSwarmTools();\r\n      }\r\n\r\n      // Start cache cleanup if enabled\r\n      if (this.config.enableCaching) {\r\n        this.startCacheCleanup();\r\n      }\r\n\r\n      this.logger.info('MCP integration wrapper initialized successfully', {\r\n        totalTools: this.toolRegistry.tools.size,\r\n        categories: this.toolRegistry.categories.size,\r\n        capabilities: this.toolRegistry.capabilities.size,\r\n      });\r\n\r\n      this.emit('initialized', {\r\n        toolCount: this.toolRegistry.tools.size,\r\n        config: this.config,\r\n      });\r\n\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize MCP integration wrapper', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shutdown the wrapper gracefully\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down MCP integration wrapper...');\r\n\r\n    try {\r\n      // Cancel all active executions\r\n      for (const [executionId, controller] of this.activeExecutions) {\r\n        controller.abort();\r\n        this.logger.debug('Cancelled execution', { executionId });\r\n      }\r\n      this.activeExecutions.clear();\r\n\r\n      // Clear cache if needed\r\n      this.executionCache.clear();\r\n\r\n      this.logger.info('MCP integration wrapper shut down successfully');\r\n      this.emit('shutdown');\r\n\r\n    } catch (error) {\r\n      this.logger.error('Error during MCP wrapper shutdown', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute an MCP tool within a swarm context\r\n   */\r\n  async executeTool(\r\n    toolName: string,\r\n    input: any,\r\n    context: MCPExecutionContext\r\n  ): Promise<MCPToolExecutionResult> {\r\n    const executionId = generateId('mcp-execution');\r\n    const startTime = performance.now();\r\n\r\n    this.logger.info('Executing MCP tool', {\r\n      toolName,\r\n      executionId,\r\n      agentId: context.agent.id,\r\n      taskId: context.task?.id,\r\n      swarmId: context.swarmId,\r\n    });\r\n\r\n    try {\r\n      // Check if tool exists\r\n      const tool = this.toolRegistry.tools.get(toolName);\r\n      if (!tool) {\r\n        throw new Error(`Tool not found: ${toolName}`);\r\n      }\r\n\r\n      // Check cache if enabled\r\n      if (this.config.enableCaching) {\r\n        const cached = await this.getCachedResult(toolName, input, context);\r\n        if (cached) {\r\n          this.logger.debug('Using cached result', { toolName, executionId });\r\n          return cached;\r\n        }\r\n      }\r\n\r\n      // Create abort controller for timeout\r\n      const abortController = new AbortController();\r\n      this.activeExecutions.set(executionId, abortController);\r\n\r\n      // Set up timeout\r\n      const timeoutHandle = setTimeout(() => {\r\n        abortController.abort();\r\n      }, context.timeout || this.config.toolTimeout);\r\n\r\n      try {\r\n        // Execute tool with retry logic\r\n        const result = await this.executeWithRetry(\r\n          tool,\r\n          input,\r\n          context,\r\n          executionId,\r\n          abortController.signal\r\n        );\r\n\r\n        clearTimeout(timeoutHandle);\r\n\r\n        const duration = performance.now() - startTime;\r\n        const executionResult: MCPToolExecutionResult = {\r\n          success: true,\r\n          result,\r\n          duration,\r\n          toolName,\r\n          agentId: context.agent.id,\r\n          taskId: context.task?.id,\r\n          metadata: {\r\n            timestamp: new Date(),\r\n            executionId,\r\n            attempts: 1,\r\n          },\r\n        };\r\n\r\n        // Cache result if enabled\r\n        if (this.config.enableCaching) {\r\n          await this.cacheResult(toolName, input, context, executionResult);\r\n        }\r\n\r\n        // Update metrics\r\n        this.updateMetrics(executionResult);\r\n\r\n        this.logger.info('MCP tool executed successfully', {\r\n          toolName,\r\n          executionId,\r\n          duration,\r\n        });\r\n\r\n        this.emit('tool:executed', executionResult);\r\n        return executionResult;\r\n\r\n      } finally {\r\n        clearTimeout(timeoutHandle);\r\n        this.activeExecutions.delete(executionId);\r\n      }\r\n\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      const executionResult: MCPToolExecutionResult = {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error),\r\n        duration,\r\n        toolName,\r\n        agentId: context.agent.id,\r\n        taskId: context.task?.id,\r\n        metadata: {\r\n          timestamp: new Date(),\r\n          executionId,\r\n          attempts: 1,\r\n        },\r\n      };\r\n\r\n      this.updateMetrics(executionResult);\r\n\r\n      this.logger.error('MCP tool execution failed', {\r\n        toolName,\r\n        executionId,\r\n        error: executionResult.error,\r\n        duration,\r\n      });\r\n\r\n      this.emit('tool:failed', executionResult);\r\n      return executionResult;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute multiple tools in parallel\r\n   */\r\n  async executeToolsParallel(\r\n    toolExecutions: Array<{\r\n      toolName: string;\r\n      input: any;\r\n      context: MCPExecutionContext;\r\n    }>\r\n  ): Promise<MCPToolExecutionResult[]> {\r\n    if (!this.config.parallelExecution) {\r\n      // Execute sequentially if parallel execution is disabled\r\n      const results: MCPToolExecutionResult[] = [];\r\n      for (const execution of toolExecutions) {\r\n        const result = await this.executeTool(\r\n          execution.toolName,\r\n          execution.input,\r\n          execution.context\r\n        );\r\n        results.push(result);\r\n      }\r\n      return results;\r\n    }\r\n\r\n    this.logger.info('Executing tools in parallel', {\r\n      toolCount: toolExecutions.length,\r\n      maxConcurrent: this.config.maxConcurrentTools,\r\n    });\r\n\r\n    // Limit concurrent executions\r\n    const semaphore = new Semaphore(this.config.maxConcurrentTools);\r\n    \r\n    const promises = toolExecutions.map(async (execution) => {\r\n      await semaphore.acquire();\r\n      try {\r\n        return await this.executeTool(\r\n          execution.toolName,\r\n          execution.input,\r\n          execution.context\r\n        );\r\n      } finally {\r\n        semaphore.release();\r\n      }\r\n    });\r\n\r\n    const results = await Promise.allSettled(promises);\r\n    \r\n    return results.map((result, index) => {\r\n      if (result.status === 'fulfilled') {\r\n        return result.value;\r\n      } else {\r\n        // Create error result\r\n        return {\r\n          success: false,\r\n          error: result.reason instanceof Error ? result.reason.message : String(result.reason),\r\n          duration: 0,\r\n          toolName: toolExecutions[index].toolName,\r\n          agentId: toolExecutions[index].context.agent.id,\r\n          taskId: toolExecutions[index].context.task?.id,\r\n          metadata: {\r\n            timestamp: new Date(),\r\n            executionId: generateId('failed-execution'),\r\n            attempts: 1,\r\n          },\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get available tools with filtering options\r\n   */\r\n  getAvailableTools(options: {\r\n    category?: string;\r\n    capability?: string;\r\n    agent?: SwarmAgent;\r\n  } = {}): MCPTool[] {\r\n    let tools = Array.from(this.toolRegistry.tools.values());\r\n\r\n    // Filter by category\r\n    if (options.category) {\r\n      const categoryTools = this.toolRegistry.categories.get(options.category) || [];\r\n      tools = tools.filter(tool => categoryTools.includes(tool.name));\r\n    }\r\n\r\n    // Filter by capability\r\n    if (options.capability) {\r\n      const capabilityTools = this.toolRegistry.capabilities.get(options.capability) || [];\r\n      tools = tools.filter(tool => capabilityTools.includes(tool.name));\r\n    }\r\n\r\n    // Filter by agent permissions\r\n    if (options.agent) {\r\n      tools = tools.filter(tool => this.hasPermission(tool, options.agent!));\r\n    }\r\n\r\n    return tools;\r\n  }\r\n\r\n  /**\r\n   * Get tool information\r\n   */\r\n  getToolInfo(toolName: string): MCPTool | null {\r\n    return this.toolRegistry.tools.get(toolName) || null;\r\n  }\r\n\r\n  /**\r\n   * Get integration metrics\r\n   */\r\n  getMetrics(): MCPIntegrationMetrics {\r\n    return {\r\n      ...this.metrics,\r\n      cacheHitRate: this.calculateCacheHitRate(),\r\n      averageExecutionTime: this.calculateAverageExecutionTime(),\r\n      toolUsageDistribution: this.calculateToolUsageDistribution(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create MCP execution context for swarm operations\r\n   */\r\n  createExecutionContext(\r\n    orchestrator: AdvancedSwarmOrchestrator,\r\n    agent: SwarmAgent,\r\n    swarmId: string,\r\n    task?: SwarmTask\r\n  ): MCPExecutionContext {\r\n    return {\r\n      sessionId: generateId('mcp-session'),\r\n      orchestrator,\r\n      agent,\r\n      task,\r\n      swarmId,\r\n      executionId: generateId('mcp-execution'),\r\n      timeout: this.config.toolTimeout,\r\n      maxRetries: this.config.maxRetries,\r\n    };\r\n  }\r\n\r\n  // Private methods\r\n\r\n  private async registerClaudeFlowTools(): Promise<void> {\r\n    this.logger.info('Registering Claude Flow tools...');\r\n    \r\n    const claudeFlowTools = createClaudeFlowTools(this.logger);\r\n    \r\n    for (const tool of claudeFlowTools) {\r\n      this.toolRegistry.tools.set(tool.name, tool);\r\n      \r\n      // Categorize tool\r\n      const category = this.categorizeClaudeFlowTool(tool.name);\r\n      if (!this.toolRegistry.categories.has(category)) {\r\n        this.toolRegistry.categories.set(category, []);\r\n      }\r\n      this.toolRegistry.categories.get(category)!.push(tool.name);\r\n      \r\n      // Add capabilities\r\n      const capabilities = this.extractCapabilities(tool);\r\n      for (const capability of capabilities) {\r\n        if (!this.toolRegistry.capabilities.has(capability)) {\r\n          this.toolRegistry.capabilities.set(capability, []);\r\n        }\r\n        this.toolRegistry.capabilities.get(capability)!.push(tool.name);\r\n      }\r\n    }\r\n\r\n    this.logger.info(`Registered ${claudeFlowTools.length} Claude Flow tools`);\r\n  }\r\n\r\n  private async registerRuvSwarmTools(): Promise<void> {\r\n    this.logger.info('Registering ruv-swarm tools...');\r\n    \r\n    const ruvSwarmTools = createRuvSwarmTools(this.logger);\r\n    \r\n    for (const tool of ruvSwarmTools) {\r\n      this.toolRegistry.tools.set(tool.name, tool);\r\n      \r\n      // Categorize tool\r\n      const category = this.categorizeRuvSwarmTool(tool.name);\r\n      if (!this.toolRegistry.categories.has(category)) {\r\n        this.toolRegistry.categories.set(category, []);\r\n      }\r\n      this.toolRegistry.categories.get(category)!.push(tool.name);\r\n      \r\n      // Add capabilities\r\n      const capabilities = this.extractCapabilities(tool);\r\n      for (const capability of capabilities) {\r\n        if (!this.toolRegistry.capabilities.has(capability)) {\r\n          this.toolRegistry.capabilities.set(capability, []);\r\n        }\r\n        this.toolRegistry.capabilities.get(capability)!.push(tool.name);\r\n      }\r\n    }\r\n\r\n    this.logger.info(`Registered ${ruvSwarmTools.length} ruv-swarm tools`);\r\n  }\r\n\r\n  private async executeWithRetry(\r\n    tool: MCPTool,\r\n    input: any,\r\n    context: MCPExecutionContext,\r\n    executionId: string,\r\n    signal: AbortSignal\r\n  ): Promise<any> {\r\n    let lastError: Error | null = null;\r\n    const maxRetries = context.maxRetries || this.config.maxRetries;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Check if execution was aborted\r\n        if (signal.aborted) {\r\n          throw new Error('Execution aborted');\r\n        }\r\n\r\n        this.logger.debug('Executing tool attempt', {\r\n          toolName: tool.name,\r\n          executionId,\r\n          attempt,\r\n          maxRetries,\r\n        });\r\n\r\n        const result = await tool.handler(input, context);\r\n        \r\n        if (attempt > 1) {\r\n          this.logger.info('Tool execution succeeded after retry', {\r\n            toolName: tool.name,\r\n            executionId,\r\n            attempt,\r\n          });\r\n        }\r\n\r\n        return result;\r\n\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n        \r\n        this.logger.warn('Tool execution attempt failed', {\r\n          toolName: tool.name,\r\n          executionId,\r\n          attempt,\r\n          maxRetries,\r\n          error: lastError.message,\r\n        });\r\n\r\n        // Don't retry on certain errors\r\n        if (this.isNonRetryableError(lastError)) {\r\n          break;\r\n        }\r\n\r\n        // Wait before retry (exponential backoff)\r\n        if (attempt < maxRetries) {\r\n          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError || new Error('Tool execution failed after all retries');\r\n  }\r\n\r\n  private isNonRetryableError(error: Error): boolean {\r\n    const nonRetryablePatterns = [\r\n      /not found/i,\r\n      /invalid input/i,\r\n      /permission denied/i,\r\n      /unauthorized/i,\r\n      /forbidden/i,\r\n    ];\r\n\r\n    return nonRetryablePatterns.some(pattern => pattern.test(error.message));\r\n  }\r\n\r\n  private async getCachedResult(\r\n    toolName: string,\r\n    input: any,\r\n    context: MCPExecutionContext\r\n  ): Promise<MCPToolExecutionResult | null> {\r\n    const cacheKey = this.generateCacheKey(toolName, input, context);\r\n    const cached = this.executionCache.get(cacheKey);\r\n    \r\n    if (cached) {\r\n      const age = Date.now() - cached.metadata.timestamp.getTime();\r\n      if (age < this.config.cacheTimeout) {\r\n        this.metrics.cacheHits++;\r\n        return cached;\r\n      } else {\r\n        // Remove expired entry\r\n        this.executionCache.delete(cacheKey);\r\n      }\r\n    }\r\n\r\n    this.metrics.cacheMisses++;\r\n    return null;\r\n  }\r\n\r\n  private async cacheResult(\r\n    toolName: string,\r\n    input: any,\r\n    context: MCPExecutionContext,\r\n    result: MCPToolExecutionResult\r\n  ): Promise<void> {\r\n    const cacheKey = this.generateCacheKey(toolName, input, context);\r\n    this.executionCache.set(cacheKey, result);\r\n  }\r\n\r\n  private generateCacheKey(\r\n    toolName: string,\r\n    input: any,\r\n    context: MCPExecutionContext\r\n  ): string {\r\n    const inputHash = this.hashObject(input);\r\n    const contextHash = this.hashObject({\r\n      agentId: context.agent.id,\r\n      swarmId: context.swarmId,\r\n      taskId: context.task?.id,\r\n    });\r\n    \r\n    return `${toolName}:${inputHash}:${contextHash}`;\r\n  }\r\n\r\n  private hashObject(obj: any): string {\r\n    // Simple hash function for caching\r\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32bit integer\r\n    }\r\n    return hash.toString(36);\r\n  }\r\n\r\n  private hasPermission(tool: MCPTool, agent: SwarmAgent): boolean {\r\n    // Check if agent has permission to use this tool\r\n    const toolPermissions = this.toolRegistry.permissions.get(tool.name) || [];\r\n    \r\n    // If no specific permissions defined, allow all\r\n    if (toolPermissions.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // Check agent capabilities against tool permissions\r\n    return agent.capabilities.some(capability => \r\n      toolPermissions.includes(capability)\r\n    );\r\n  }\r\n\r\n  private categorizeClaudeFlowTool(toolName: string): string {\r\n    if (toolName.includes('agents/')) return 'agent-management';\r\n    if (toolName.includes('tasks/')) return 'task-management';\r\n    if (toolName.includes('memory/')) return 'memory-management';\r\n    if (toolName.includes('system/')) return 'system-monitoring';\r\n    if (toolName.includes('config/')) return 'configuration';\r\n    if (toolName.includes('workflow/')) return 'workflow-management';\r\n    if (toolName.includes('terminal/')) return 'terminal-management';\r\n    return 'general';\r\n  }\r\n\r\n  private categorizeRuvSwarmTool(toolName: string): string {\r\n    if (toolName.includes('swarm_')) return 'swarm-lifecycle';\r\n    if (toolName.includes('agent_')) return 'agent-management';\r\n    if (toolName.includes('task_')) return 'task-orchestration';\r\n    if (toolName.includes('memory_')) return 'memory-persistence';\r\n    if (toolName.includes('neural_')) return 'neural-capabilities';\r\n    if (toolName.includes('benchmark_')) return 'performance-benchmarking';\r\n    return 'general';\r\n  }\r\n\r\n  private extractCapabilities(tool: MCPTool): string[] {\r\n    const capabilities: string[] = [];\r\n    \r\n    // Extract capabilities from tool name and description\r\n    const text = `${tool.name} ${tool.description}`.toLowerCase();\r\n    \r\n    const capabilityPatterns = [\r\n      'agent', 'task', 'memory', 'system', 'config', 'workflow',\r\n      'terminal', 'swarm', 'neural', 'benchmark', 'monitoring',\r\n      'orchestration', 'coordination', 'analysis', 'research',\r\n      'development', 'testing', 'documentation', 'optimization',\r\n    ];\r\n\r\n    for (const pattern of capabilityPatterns) {\r\n      if (text.includes(pattern)) {\r\n        capabilities.push(pattern);\r\n      }\r\n    }\r\n\r\n    return capabilities.length > 0 ? capabilities : ['general'];\r\n  }\r\n\r\n  private updateMetrics(result: MCPToolExecutionResult): void {\r\n    this.metrics.totalExecutions++;\r\n    \r\n    if (result.success) {\r\n      this.metrics.successfulExecutions++;\r\n    } else {\r\n      this.metrics.failedExecutions++;\r\n    }\r\n\r\n    this.metrics.totalExecutionTime += result.duration;\r\n\r\n    // Update tool-specific metrics\r\n    if (!this.metrics.toolExecutions.has(result.toolName)) {\r\n      this.metrics.toolExecutions.set(result.toolName, {\r\n        count: 0,\r\n        totalTime: 0,\r\n        successCount: 0,\r\n        failureCount: 0,\r\n      });\r\n    }\r\n\r\n    const toolStats = this.metrics.toolExecutions.get(result.toolName)!;\r\n    toolStats.count++;\r\n    toolStats.totalTime += result.duration;\r\n    \r\n    if (result.success) {\r\n      toolStats.successCount++;\r\n    } else {\r\n      toolStats.failureCount++;\r\n    }\r\n  }\r\n\r\n  private calculateCacheHitRate(): number {\r\n    const total = this.metrics.cacheHits + this.metrics.cacheMisses;\r\n    return total > 0 ? this.metrics.cacheHits / total : 0;\r\n  }\r\n\r\n  private calculateAverageExecutionTime(): number {\r\n    return this.metrics.totalExecutions > 0 \r\n      ? this.metrics.totalExecutionTime / this.metrics.totalExecutions \r\n      : 0;\r\n  }\r\n\r\n  private calculateToolUsageDistribution(): Record<string, number> {\r\n    const distribution: Record<string, number> = {};\r\n    \r\n    for (const [toolName, stats] of this.metrics.toolExecutions) {\r\n      distribution[toolName] = stats.count;\r\n    }\r\n\r\n    return distribution;\r\n  }\r\n\r\n  private startCacheCleanup(): void {\r\n    // Clean up expired cache entries every 5 minutes\r\n    setInterval(() => {\r\n      const now = Date.now();\r\n      const expired: string[] = [];\r\n\r\n      for (const [key, result] of this.executionCache) {\r\n        const age = now - result.metadata.timestamp.getTime();\r\n        if (age > this.config.cacheTimeout) {\r\n          expired.push(key);\r\n        }\r\n      }\r\n\r\n      expired.forEach(key => this.executionCache.delete(key));\r\n      \r\n      if (expired.length > 0) {\r\n        this.logger.debug('Cleaned up expired cache entries', { \r\n          count: expired.length \r\n        });\r\n      }\r\n    }, 300000); // 5 minutes\r\n  }\r\n\r\n  private initializeToolRegistry(): MCPToolRegistry {\r\n    return {\r\n      tools: new Map(),\r\n      categories: new Map(),\r\n      capabilities: new Map(),\r\n      permissions: new Map(),\r\n    };\r\n  }\r\n\r\n  private initializeMetrics(): MCPIntegrationMetrics {\r\n    return {\r\n      totalExecutions: 0,\r\n      successfulExecutions: 0,\r\n      failedExecutions: 0,\r\n      totalExecutionTime: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      toolExecutions: new Map(),\r\n      cacheHitRate: 0,\r\n      averageExecutionTime: 0,\r\n      toolUsageDistribution: {},\r\n    };\r\n  }\r\n\r\n  private createDefaultConfig(config: Partial<MCPIntegrationConfig>): MCPIntegrationConfig {\r\n    return {\r\n      enableClaudeFlowTools: true,\r\n      enableRuvSwarmTools: true,\r\n      enableCustomTools: true,\r\n      toolTimeout: 30000, // 30 seconds\r\n      maxRetries: 3,\r\n      enableCaching: true,\r\n      cacheTimeout: 300000, // 5 minutes\r\n      enableMetrics: true,\r\n      enableLogging: true,\r\n      enableErrorRecovery: true,\r\n      parallelExecution: true,\r\n      maxConcurrentTools: 5,\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.on('tool:executed', (result) => {\r\n      if (this.config.enableLogging) {\r\n        this.logger.debug('Tool execution completed', {\r\n          toolName: result.toolName,\r\n          success: result.success,\r\n          duration: result.duration,\r\n        });\r\n      }\r\n    });\r\n\r\n    this.on('tool:failed', (result) => {\r\n      if (this.config.enableLogging) {\r\n        this.logger.warn('Tool execution failed', {\r\n          toolName: result.toolName,\r\n          error: result.error,\r\n          duration: result.duration,\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Supporting interfaces and classes\r\n\r\ninterface MCPIntegrationMetrics {\r\n  totalExecutions: number;\r\n  successfulExecutions: number;\r\n  failedExecutions: number;\r\n  totalExecutionTime: number;\r\n  cacheHits: number;\r\n  cacheMisses: number;\r\n  toolExecutions: Map<string, {\r\n    count: number;\r\n    totalTime: number;\r\n    successCount: number;\r\n    failureCount: number;\r\n  }>;\r\n  cacheHitRate: number;\r\n  averageExecutionTime: number;\r\n  toolUsageDistribution: Record<string, number>;\r\n}\r\n\r\nclass Semaphore {\r\n  private permits: number;\r\n  private waitQueue: Array<() => void> = [];\r\n\r\n  constructor(permits: number) {\r\n    this.permits = permits;\r\n  }\r\n\r\n  async acquire(): Promise<void> {\r\n    if (this.permits > 0) {\r\n      this.permits--;\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return new Promise<void>((resolve) => {\r\n      this.waitQueue.push(resolve);\r\n    });\r\n  }\r\n\r\n  release(): void {\r\n    if (this.waitQueue.length > 0) {\r\n      const resolve = this.waitQueue.shift()!;\r\n      resolve();\r\n    } else {\r\n      this.permits++;\r\n    }\r\n  }\r\n}\r\n\r\nexport default MCPIntegrationWrapper;"],"names":["EventEmitter","Logger","generateId","createClaudeFlowTools","createRuvSwarmTools","MCPIntegrationWrapper","logger","config","toolRegistry","executionCache","Map","activeExecutions","metrics","createDefaultConfig","initializeToolRegistry","initializeMetrics","setupEventHandlers","initialize","info","enableClaudeFlowTools","registerClaudeFlowTools","enableRuvSwarmTools","registerRuvSwarmTools","enableCaching","startCacheCleanup","totalTools","tools","size","categories","capabilities","emit","toolCount","error","shutdown","executionId","controller","abort","debug","clear","executeTool","toolName","input","context","startTime","performance","now","agentId","agent","id","taskId","task","swarmId","tool","get","Error","cached","getCachedResult","abortController","AbortController","set","timeoutHandle","setTimeout","timeout","toolTimeout","result","executeWithRetry","signal","clearTimeout","duration","executionResult","success","metadata","timestamp","Date","attempts","cacheResult","updateMetrics","delete","message","String","executeToolsParallel","toolExecutions","parallelExecution","results","execution","push","length","maxConcurrent","maxConcurrentTools","semaphore","Semaphore","promises","map","acquire","release","Promise","allSettled","index","status","value","reason","getAvailableTools","options","Array","from","values","category","categoryTools","filter","includes","name","capability","capabilityTools","hasPermission","getToolInfo","getMetrics","cacheHitRate","calculateCacheHitRate","averageExecutionTime","calculateAverageExecutionTime","toolUsageDistribution","calculateToolUsageDistribution","createExecutionContext","orchestrator","sessionId","maxRetries","claudeFlowTools","categorizeClaudeFlowTool","has","extractCapabilities","ruvSwarmTools","categorizeRuvSwarmTool","lastError","attempt","aborted","handler","warn","isNonRetryableError","delay","Math","min","pow","resolve","nonRetryablePatterns","some","pattern","test","cacheKey","generateCacheKey","age","getTime","cacheTimeout","cacheHits","cacheMisses","inputHash","hashObject","contextHash","obj","str","JSON","stringify","Object","keys","sort","hash","i","char","charCodeAt","toString","toolPermissions","permissions","text","description","toLowerCase","capabilityPatterns","totalExecutions","successfulExecutions","failedExecutions","totalExecutionTime","count","totalTime","successCount","failureCount","toolStats","total","distribution","stats","setInterval","expired","key","forEach","enableCustomTools","enableMetrics","enableLogging","enableErrorRecovery","on","permits","waitQueue","shift"],"mappings":"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"}