{"version":3,"sources":["../../../src/core/MetricsCollector.ts"],"sourcesContent":["/**\r\n * MetricsCollector - Performance and coordination tracking\r\n * Collects, aggregates, and analyzes system performance metrics\r\n */\r\n\r\nimport { IDatabaseProvider, InitializationMetrics, Metrics, PerformanceMetrics } from '../types/interfaces.js';\r\n\r\nexport interface SystemHealth {\r\n  status: 'healthy' | 'degraded' | 'critical';\r\n  score: number; // 0-100\r\n  issues: string[];\r\n  recommendations: string[];\r\n}\r\n\r\nexport interface PerformanceTrend {\r\n  metric: string;\r\n  trend: 'improving' | 'stable' | 'degrading';\r\n  change: number; // percentage change\r\n  period: string;\r\n}\r\n\r\nexport interface Benchmark {\r\n  name: string;\r\n  value: number;\r\n  unit: string;\r\n  timestamp: Date;\r\n  baseline?: number;\r\n  percentile?: number;\r\n}\r\n\r\nexport class MetricsCollector {\r\n  private metricsBuffer: Map<string, any[]> = new Map();\r\n  private initialized: boolean = false;\r\n\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  /**\r\n   * Initialize metrics collection\r\n   */\r\n  async initialize(): Promise<void> {\r\n    // Create metrics tables/collections if using database\r\n    await this.setupMetricsStorage();\r\n    this.initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Setup metrics storage structure\r\n   */\r\n  private async setupMetricsStorage(): Promise<void> {\r\n    // Initialize metrics namespaces\r\n    const namespaces = [\r\n      'initialization',\r\n      'system',\r\n      'performance',\r\n      'agents',\r\n      'consensus',\r\n      'topology',\r\n      'benchmarks'\r\n    ];\r\n\r\n    for (const namespace of namespaces) {\r\n      try {\r\n        await this.database.store(`metrics-${namespace}-init`, {\r\n          initialized: true,\r\n          timestamp: new Date().toISOString()\r\n        }, 'metrics');\r\n      } catch (error) {\r\n        console.warn(`Failed to initialize metrics namespace ${namespace}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record initialization metrics\r\n   */\r\n  async recordInitialization(metrics: InitializationMetrics): Promise<void> {\r\n    const key = `init-${Date.now()}`;\r\n    await this.database.store(key, metrics, 'metrics');\r\n\r\n    // Update aggregated initialization stats\r\n    await this.updateAggregatedMetrics('initialization', metrics);\r\n  }\r\n\r\n  /**\r\n   * Record system metrics\r\n   */\r\n  async recordSystemMetrics(metrics: {\r\n    cpuUsage: number;\r\n    memoryUsage: number;\r\n    diskUsage: number;\r\n    networkLatency: number;\r\n    activeConnections: number;\r\n    timestamp?: Date;\r\n  }): Promise<void> {\r\n    const timestampedMetrics = {\r\n      ...metrics,\r\n      timestamp: metrics.timestamp || new Date()\r\n    };\r\n\r\n    const key = `system-${Date.now()}`;\r\n    await this.database.store(key, timestampedMetrics, 'metrics');\r\n\r\n    // Buffer for real-time analysis\r\n    this.addToBuffer('system', timestampedMetrics);\r\n  }\r\n\r\n  /**\r\n   * Record agent performance metrics\r\n   */\r\n  async recordAgentMetrics(agentId: string, metrics: {\r\n    tasksCompleted: number;\r\n    successRate: number;\r\n    averageResponseTime: number;\r\n    resourceUtilization: any;\r\n    timestamp?: Date;\r\n  }): Promise<void> {\r\n    const timestampedMetrics = {\r\n      agentId,\r\n      ...metrics,\r\n      timestamp: metrics.timestamp || new Date()\r\n    };\r\n\r\n    const key = `agent-${agentId}-${Date.now()}`;\r\n    await this.database.store(key, timestampedMetrics, 'metrics');\r\n\r\n    this.addToBuffer('agents', timestampedMetrics);\r\n  }\r\n\r\n  /**\r\n   * Record consensus metrics\r\n   */\r\n  async recordConsensusMetrics(metrics: {\r\n    algorithm: string;\r\n    decisionId: string;\r\n    participantCount: number;\r\n    consensusTime: number;\r\n    outcome: boolean;\r\n    confidence: number;\r\n    timestamp?: Date;\r\n  }): Promise<void> {\r\n    const timestampedMetrics = {\r\n      ...metrics,\r\n      timestamp: metrics.timestamp || new Date()\r\n    };\r\n\r\n    const key = `consensus-${metrics.decisionId}`;\r\n    await this.database.store(key, timestampedMetrics, 'metrics');\r\n\r\n    this.addToBuffer('consensus', timestampedMetrics);\r\n  }\r\n\r\n  /**\r\n   * Record topology metrics\r\n   */\r\n  async recordTopologyMetrics(metrics: {\r\n    type: string;\r\n    agentCount: number;\r\n    connectionCount: number;\r\n    averageLatency: number;\r\n    throughput: number;\r\n    reliability: number;\r\n    timestamp?: Date;\r\n  }): Promise<void> {\r\n    const timestampedMetrics = {\r\n      ...metrics,\r\n      timestamp: metrics.timestamp || new Date()\r\n    };\r\n\r\n    const key = `topology-${Date.now()}`;\r\n    await this.database.store(key, timestampedMetrics, 'metrics');\r\n\r\n    this.addToBuffer('topology', timestampedMetrics);\r\n  }\r\n\r\n  /**\r\n   * Record performance benchmark\r\n   */\r\n  async recordBenchmark(benchmark: Benchmark): Promise<void> {\r\n    const key = `benchmark-${benchmark.name}-${Date.now()}`;\r\n    await this.database.store(key, benchmark, 'metrics');\r\n\r\n    this.addToBuffer('benchmarks', benchmark);\r\n  }\r\n\r\n  /**\r\n   * Get initialization metrics\r\n   */\r\n  async getInitializationMetrics(): Promise<{\r\n    total: number;\r\n    successful: number;\r\n    failed: number;\r\n    averageDuration: number;\r\n    modeDistribution: Record<string, number>;\r\n    recentMetrics: InitializationMetrics[];\r\n  }> {\r\n    const keys = await this.database.list('metrics');\r\n    const initKeys = keys.filter(key => key.startsWith('init-'));\r\n\r\n    const metrics: InitializationMetrics[] = [];\r\n    for (const key of initKeys) {\r\n      const metric = await this.database.retrieve(key, 'metrics');\r\n      if (metric) metrics.push(metric);\r\n    }\r\n\r\n    // Sort by timestamp (most recent first)\r\n    metrics.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n\r\n    const total = metrics.length;\r\n    const successful = metrics.filter(m => m.success).length;\r\n    const failed = total - successful;\r\n\r\n    const durations = metrics.map(m => m.duration).filter(d => d > 0);\r\n    const averageDuration = durations.length > 0\r\n      ? durations.reduce((sum, d) => sum + d, 0) / durations.length\r\n      : 0;\r\n\r\n    // Mode distribution\r\n    const modeDistribution: Record<string, number> = {};\r\n    metrics.forEach(m => {\r\n      modeDistribution[m.mode] = (modeDistribution[m.mode] || 0) + 1;\r\n    });\r\n\r\n    return {\r\n      total,\r\n      successful,\r\n      failed,\r\n      averageDuration,\r\n      modeDistribution,\r\n      recentMetrics: metrics.slice(0, 10) // Last 10 initializations\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get system health status\r\n   */\r\n  async getSystemHealth(): Promise<SystemHealth> {\r\n    const systemMetrics = this.getBufferedMetrics('system', 10); // Last 10 measurements\r\n\r\n    if (systemMetrics.length === 0) {\r\n      return {\r\n        status: 'critical',\r\n        score: 0,\r\n        issues: ['No system metrics available'],\r\n        recommendations: ['Ensure metrics collection is working']\r\n      };\r\n    }\r\n\r\n    const latest = systemMetrics[systemMetrics.length - 1];\r\n    const issues: string[] = [];\r\n    const recommendations: string[] = [];\r\n    let score = 100;\r\n\r\n    // Check CPU usage\r\n    if (latest.cpuUsage > 90) {\r\n      issues.push('High CPU usage');\r\n      recommendations.push('Consider scaling or optimizing CPU-intensive tasks');\r\n      score -= 30;\r\n    } else if (latest.cpuUsage > 70) {\r\n      issues.push('Elevated CPU usage');\r\n      score -= 15;\r\n    }\r\n\r\n    // Check memory usage\r\n    if (latest.memoryUsage > 90) {\r\n      issues.push('High memory usage');\r\n      recommendations.push('Check for memory leaks or increase available memory');\r\n      score -= 25;\r\n    } else if (latest.memoryUsage > 70) {\r\n      issues.push('Elevated memory usage');\r\n      score -= 10;\r\n    }\r\n\r\n    // Check network latency\r\n    if (latest.networkLatency > 100) {\r\n      issues.push('High network latency');\r\n      recommendations.push('Check network connectivity and optimize communication');\r\n      score -= 20;\r\n    }\r\n\r\n    // Check trend (if we have historical data)\r\n    if (systemMetrics.length >= 5) {\r\n      const recent = systemMetrics.slice(-3);\r\n      const older = systemMetrics.slice(-6, -3);\r\n\r\n      const recentAvgCpu = recent.reduce((sum, m) => sum + m.cpuUsage, 0) / recent.length;\r\n      const olderAvgCpu = older.reduce((sum, m) => sum + m.cpuUsage, 0) / older.length;\r\n\r\n      if (recentAvgCpu > olderAvgCpu * 1.2) {\r\n        issues.push('CPU usage trending upward');\r\n        score -= 10;\r\n      }\r\n    }\r\n\r\n    let status: 'healthy' | 'degraded' | 'critical';\r\n    if (score >= 80) status = 'healthy';\r\n    else if (score >= 50) status = 'degraded';\r\n    else status = 'critical';\r\n\r\n    return { status, score, issues, recommendations };\r\n  }\r\n\r\n  /**\r\n   * Get performance trends\r\n   */\r\n  async getPerformanceTrends(period: string = '1h'): Promise<PerformanceTrend[]> {\r\n    const trends: PerformanceTrend[] = [];\r\n\r\n    // Analyze different metric types\r\n    const metricTypes = ['system', 'agents', 'consensus', 'topology'];\r\n\r\n    for (const type of metricTypes) {\r\n      const metrics = this.getBufferedMetrics(type, 20);\r\n      if (metrics.length < 2) continue;\r\n\r\n      const recent = metrics.slice(-5);\r\n      const older = metrics.slice(-10, -5);\r\n\r\n      if (recent.length === 0 || older.length === 0) continue;\r\n\r\n      // Calculate trends for different metrics\r\n      switch (type) {\r\n        case 'system':\r\n          trends.push(...this.analyzeSystemTrends(recent, older, period));\r\n          break;\r\n        case 'agents':\r\n          trends.push(...this.analyzeAgentTrends(recent, older, period));\r\n          break;\r\n        case 'consensus':\r\n          trends.push(...this.analyzeConsensusTrends(recent, older, period));\r\n          break;\r\n        case 'topology':\r\n          trends.push(...this.analyzeTopologyTrends(recent, older, period));\r\n          break;\r\n      }\r\n    }\r\n\r\n    return trends;\r\n  }\r\n\r\n  /**\r\n   * Run performance benchmarks\r\n   */\r\n  async runBenchmarks(): Promise<Benchmark[]> {\r\n    const benchmarks: Benchmark[] = [];\r\n\r\n    // CPU benchmark\r\n    const cpuStart = Date.now();\r\n    for (let i = 0; i < 1000000; i++) {\r\n      Math.sqrt(i);\r\n    }\r\n    const cpuTime = Date.now() - cpuStart;\r\n\r\n    benchmarks.push({\r\n      name: 'cpu-computation',\r\n      value: cpuTime,\r\n      unit: 'ms',\r\n      timestamp: new Date(),\r\n      baseline: 50 // Expected baseline\r\n    });\r\n\r\n    // Memory allocation benchmark\r\n    const memStart = Date.now();\r\n    const arrays = [];\r\n    for (let i = 0; i < 1000; i++) {\r\n      arrays.push(new Array(1000).fill(i));\r\n    }\r\n    const memTime = Date.now() - memStart;\r\n\r\n    benchmarks.push({\r\n      name: 'memory-allocation',\r\n      value: memTime,\r\n      unit: 'ms',\r\n      timestamp: new Date(),\r\n      baseline: 20\r\n    });\r\n\r\n    // Database I/O benchmark\r\n    const dbStart = Date.now();\r\n    for (let i = 0; i < 10; i++) {\r\n      await this.database.store(`benchmark-test-${i}`, { value: i }, 'temp');\r\n      await this.database.retrieve(`benchmark-test-${i}`, 'temp');\r\n    }\r\n    const dbTime = Date.now() - dbStart;\r\n\r\n    benchmarks.push({\r\n      name: 'database-io',\r\n      value: dbTime,\r\n      unit: 'ms',\r\n      timestamp: new Date(),\r\n      baseline: 100\r\n    });\r\n\r\n    // Store benchmarks\r\n    for (const benchmark of benchmarks) {\r\n      await this.recordBenchmark(benchmark);\r\n    }\r\n\r\n    return benchmarks;\r\n  }\r\n\r\n  /**\r\n   * Get performance summary\r\n   */\r\n  async getPerformanceSummary(): Promise<{\r\n    health: SystemHealth;\r\n    trends: PerformanceTrend[];\r\n    benchmarks: Benchmark[];\r\n    recommendations: string[];\r\n  }> {\r\n    const [health, trends, benchmarks] = await Promise.all([\r\n      this.getSystemHealth(),\r\n      this.getPerformanceTrends(),\r\n      this.getRecentBenchmarks()\r\n    ]);\r\n\r\n    const recommendations = [\r\n      ...health.recommendations,\r\n      ...this.generateTrendRecommendations(trends),\r\n      ...this.generateBenchmarkRecommendations(benchmarks)\r\n    ];\r\n\r\n    return {\r\n      health,\r\n      trends,\r\n      benchmarks,\r\n      recommendations: [...new Set(recommendations)] // Remove duplicates\r\n    };\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  private addToBuffer(type: string, data: any): void {\r\n    if (!this.metricsBuffer.has(type)) {\r\n      this.metricsBuffer.set(type, []);\r\n    }\r\n\r\n    const buffer = this.metricsBuffer.get(type)!;\r\n    buffer.push(data);\r\n\r\n    // Keep buffer size manageable\r\n    if (buffer.length > 100) {\r\n      buffer.shift();\r\n    }\r\n  }\r\n\r\n  private getBufferedMetrics(type: string, limit?: number): any[] {\r\n    const buffer = this.metricsBuffer.get(type) || [];\r\n    return limit ? buffer.slice(-limit) : buffer;\r\n  }\r\n\r\n  private async updateAggregatedMetrics(type: string, metrics: any): Promise<void> {\r\n    const key = `aggregated-${type}`;\r\n    const existing = await this.database.retrieve(key, 'metrics') || {\r\n      count: 0,\r\n      sum: {},\r\n      avg: {}\r\n    };\r\n\r\n    // Update aggregated data (simplified example)\r\n    existing.count++;\r\n    existing.lastUpdated = new Date().toISOString();\r\n\r\n    await this.database.store(key, existing, 'metrics');\r\n  }\r\n\r\n  private analyzeSystemTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\r\n    const trends: PerformanceTrend[] = [];\r\n\r\n    const recentAvgCpu = recent.reduce((sum, m) => sum + m.cpuUsage, 0) / recent.length;\r\n    const olderAvgCpu = older.reduce((sum, m) => sum + m.cpuUsage, 0) / older.length;\r\n    const cpuChange = ((recentAvgCpu - olderAvgCpu) / olderAvgCpu) * 100;\r\n\r\n    trends.push({\r\n      metric: 'cpu-usage',\r\n      trend: cpuChange > 5 ? 'degrading' : cpuChange < -5 ? 'improving' : 'stable',\r\n      change: cpuChange,\r\n      period\r\n    });\r\n\r\n    return trends;\r\n  }\r\n\r\n  private analyzeAgentTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\r\n    // Analyze agent performance trends\r\n    return [];\r\n  }\r\n\r\n  private analyzeConsensusTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\r\n    // Analyze consensus performance trends\r\n    return [];\r\n  }\r\n\r\n  private analyzeTopologyTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\r\n    // Analyze topology performance trends\r\n    return [];\r\n  }\r\n\r\n  private async getRecentBenchmarks(): Promise<Benchmark[]> {\r\n    const keys = await this.database.list('metrics');\r\n    const benchmarkKeys = keys.filter(key => key.startsWith('benchmark-')).slice(-10);\r\n\r\n    const benchmarks: Benchmark[] = [];\r\n    for (const key of benchmarkKeys) {\r\n      const benchmark = await this.database.retrieve(key, 'metrics');\r\n      if (benchmark) benchmarks.push(benchmark);\r\n    }\r\n\r\n    return benchmarks;\r\n  }\r\n\r\n  private generateTrendRecommendations(trends: PerformanceTrend[]): string[] {\r\n    const recommendations: string[] = [];\r\n\r\n    trends.forEach(trend => {\r\n      if (trend.trend === 'degrading') {\r\n        recommendations.push(`${trend.metric} is degrading (${trend.change.toFixed(1)}% change) - investigate potential causes`);\r\n      }\r\n    });\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  private generateBenchmarkRecommendations(benchmarks: Benchmark[]): string[] {\r\n    const recommendations: string[] = [];\r\n\r\n    benchmarks.forEach(benchmark => {\r\n      if (benchmark.baseline && benchmark.value > benchmark.baseline * 2) {\r\n        recommendations.push(`${benchmark.name} performance is significantly below baseline - consider optimization`);\r\n      }\r\n    });\r\n\r\n    return recommendations;\r\n  }\r\n}"],"names":["MetricsCollector","metricsBuffer","Map","initialized","database","initialize","setupMetricsStorage","namespaces","namespace","store","timestamp","Date","toISOString","error","console","warn","recordInitialization","metrics","key","now","updateAggregatedMetrics","recordSystemMetrics","timestampedMetrics","addToBuffer","recordAgentMetrics","agentId","recordConsensusMetrics","decisionId","recordTopologyMetrics","recordBenchmark","benchmark","name","getInitializationMetrics","keys","list","initKeys","filter","startsWith","metric","retrieve","push","sort","a","b","getTime","total","length","successful","m","success","failed","durations","map","duration","d","averageDuration","reduce","sum","modeDistribution","forEach","mode","recentMetrics","slice","getSystemHealth","systemMetrics","getBufferedMetrics","status","score","issues","recommendations","latest","cpuUsage","memoryUsage","networkLatency","recent","older","recentAvgCpu","olderAvgCpu","getPerformanceTrends","period","trends","metricTypes","type","analyzeSystemTrends","analyzeAgentTrends","analyzeConsensusTrends","analyzeTopologyTrends","runBenchmarks","benchmarks","cpuStart","i","Math","sqrt","cpuTime","value","unit","baseline","memStart","arrays","Array","fill","memTime","dbStart","dbTime","getPerformanceSummary","health","Promise","all","getRecentBenchmarks","generateTrendRecommendations","generateBenchmarkRecommendations","Set","data","has","set","buffer","get","shift","limit","existing","count","avg","lastUpdated","cpuChange","trend","change","benchmarkKeys","toFixed"],"mappings":"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"}