{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/performance-optimizer.js"],"sourcesContent":["/**\r\n * Performance Optimizer for Hive Mind System\r\n * Implements advanced performance optimizations including:\r\n * - Async operation optimization\r\n * - Connection pooling management\r\n * - Batch operation coordination\r\n * - Performance monitoring and auto-tuning\r\n */\r\n\r\nimport EventEmitter from 'events';\r\nimport { performance } from 'perf_hooks';\r\n\r\n/**\r\n * AsyncOperationQueue for managing concurrent operations\r\n */\r\nclass AsyncOperationQueue {\r\n  constructor(maxConcurrency = 10, timeout = 30000) {\r\n    this.maxConcurrency = maxConcurrency;\r\n    this.timeout = timeout;\r\n    this.running = 0;\r\n    this.queue = [];\r\n    this.results = new Map();\r\n    this.metrics = {\r\n      processed: 0,\r\n      failures: 0,\r\n      avgProcessingTime: 0,\r\n      totalProcessingTime: 0,\r\n    };\r\n  }\r\n\r\n  async add(operation, priority = 5) {\r\n    return new Promise((resolve, reject) => {\r\n      const queueItem = {\r\n        operation,\r\n        priority,\r\n        resolve,\r\n        reject,\r\n        addedAt: Date.now(),\r\n        id: `op-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n      };\r\n\r\n      // Insert based on priority (higher priority first)\r\n      const insertIndex = this.queue.findIndex((item) => item.priority < priority);\r\n      if (insertIndex === -1) {\r\n        this.queue.push(queueItem);\r\n      } else {\r\n        this.queue.splice(insertIndex, 0, queueItem);\r\n      }\r\n\r\n      this._processQueue();\r\n    });\r\n  }\r\n\r\n  async _processQueue() {\r\n    if (this.running >= this.maxConcurrency || this.queue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const item = this.queue.shift();\r\n    this.running++;\r\n\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      // Add timeout wrapper\r\n      const timeoutPromise = new Promise((_, reject) => {\r\n        setTimeout(() => reject(new Error('Operation timeout')), this.timeout);\r\n      });\r\n\r\n      const result = await Promise.race([item.operation(), timeoutPromise]);\r\n\r\n      const processingTime = performance.now() - startTime;\r\n      this._updateMetrics(processingTime, true);\r\n\r\n      item.resolve(result);\r\n    } catch (error) {\r\n      const processingTime = performance.now() - startTime;\r\n      this._updateMetrics(processingTime, false);\r\n\r\n      item.reject(error);\r\n    } finally {\r\n      this.running--;\r\n      setImmediate(() => this._processQueue());\r\n    }\r\n  }\r\n\r\n  _updateMetrics(processingTime, success) {\r\n    this.metrics.processed++;\r\n    this.metrics.totalProcessingTime += processingTime;\r\n    this.metrics.avgProcessingTime = this.metrics.totalProcessingTime / this.metrics.processed;\r\n\r\n    if (!success) {\r\n      this.metrics.failures++;\r\n    }\r\n  }\r\n\r\n  getMetrics() {\r\n    return {\r\n      ...this.metrics,\r\n      successRate:\r\n        this.metrics.processed > 0\r\n          ? (\r\n              ((this.metrics.processed - this.metrics.failures) / this.metrics.processed) *\r\n              100\r\n            ).toFixed(2)\r\n          : 100,\r\n      queueSize: this.queue.length,\r\n      running: this.running,\r\n      utilization: ((this.running / this.maxConcurrency) * 100).toFixed(2),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * BatchProcessor for optimizing bulk operations\r\n */\r\nclass BatchProcessor extends EventEmitter {\r\n  constructor(config = {}) {\r\n    super();\r\n\r\n    this.config = {\r\n      maxBatchSize: config.maxBatchSize || 50,\r\n      flushInterval: config.flushInterval || 1000,\r\n      maxWaitTime: config.maxWaitTime || 5000,\r\n      ...config,\r\n    };\r\n\r\n    this.batches = new Map();\r\n    this.timers = new Map();\r\n    this.metrics = {\r\n      batchesProcessed: 0,\r\n      itemsProcessed: 0,\r\n      avgBatchSize: 0,\r\n      avgProcessingTime: 0,\r\n    };\r\n\r\n    this._startPeriodicFlush();\r\n  }\r\n\r\n  async addToBatch(batchKey, item, processor) {\r\n    if (!this.batches.has(batchKey)) {\r\n      this.batches.set(batchKey, {\r\n        items: [],\r\n        processor,\r\n        createdAt: Date.now(),\r\n      });\r\n\r\n      // Set timeout for this batch\r\n      const timer = setTimeout(() => {\r\n        this._processBatch(batchKey);\r\n      }, this.config.maxWaitTime);\r\n\r\n      this.timers.set(batchKey, timer);\r\n    }\r\n\r\n    const batch = this.batches.get(batchKey);\r\n    batch.items.push(item);\r\n\r\n    // Process if batch is full\r\n    if (batch.items.length >= this.config.maxBatchSize) {\r\n      return this._processBatch(batchKey);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      item._resolve = resolve;\r\n      item._reject = reject;\r\n    });\r\n  }\r\n\r\n  async _processBatch(batchKey) {\r\n    const batch = this.batches.get(batchKey);\r\n    if (!batch || batch.items.length === 0) return;\r\n\r\n    // Clear timer and remove from maps\r\n    const timer = this.timers.get(batchKey);\r\n    if (timer) clearTimeout(timer);\r\n\r\n    this.timers.delete(batchKey);\r\n    this.batches.delete(batchKey);\r\n\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const results = await batch.processor(batch.items);\r\n      const processingTime = performance.now() - startTime;\r\n\r\n      // Update metrics\r\n      this.metrics.batchesProcessed++;\r\n      this.metrics.itemsProcessed += batch.items.length;\r\n      this.metrics.avgBatchSize = this.metrics.itemsProcessed / this.metrics.batchesProcessed;\r\n      this.metrics.avgProcessingTime =\r\n        (this.metrics.avgProcessingTime * (this.metrics.batchesProcessed - 1) + processingTime) /\r\n        this.metrics.batchesProcessed;\r\n\r\n      // Resolve individual item promises\r\n      batch.items.forEach((item, index) => {\r\n        if (item._resolve) {\r\n          item._resolve(results[index] || results);\r\n        }\r\n      });\r\n\r\n      this.emit('batch:processed', {\r\n        batchKey,\r\n        itemCount: batch.items.length,\r\n        processingTime,\r\n        results,\r\n      });\r\n\r\n      return results;\r\n    } catch (error) {\r\n      // Reject individual item promises\r\n      batch.items.forEach((item) => {\r\n        if (item._reject) {\r\n          item._reject(error);\r\n        }\r\n      });\r\n\r\n      this.emit('batch:error', { batchKey, error, itemCount: batch.items.length });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  _startPeriodicFlush() {\r\n    setInterval(() => {\r\n      const now = Date.now();\r\n\r\n      for (const [batchKey, batch] of this.batches.entries()) {\r\n        // Flush batches that have been waiting too long\r\n        if (now - batch.createdAt > this.config.flushInterval) {\r\n          this._processBatch(batchKey);\r\n        }\r\n      }\r\n    }, this.config.flushInterval);\r\n  }\r\n\r\n  getMetrics() {\r\n    return {\r\n      ...this.metrics,\r\n      pendingBatches: this.batches.size,\r\n      pendingItems: Array.from(this.batches.values()).reduce(\r\n        (sum, batch) => sum + batch.items.length,\r\n        0,\r\n      ),\r\n    };\r\n  }\r\n\r\n  close() {\r\n    // Process all remaining batches\r\n    const batchKeys = Array.from(this.batches.keys());\r\n    return Promise.all(batchKeys.map((key) => this._processBatch(key)));\r\n  }\r\n}\r\n\r\n/**\r\n * PerformanceOptimizer main class\r\n */\r\nexport class PerformanceOptimizer extends EventEmitter {\r\n  constructor(config = {}) {\r\n    super();\r\n\r\n    this.config = {\r\n      enableAsyncQueue: config.enableAsyncQueue !== false,\r\n      enableBatchProcessing: config.enableBatchProcessing !== false,\r\n      enableAutoTuning: config.enableAutoTuning !== false,\r\n      asyncQueueConcurrency: config.asyncQueueConcurrency || 10,\r\n      batchMaxSize: config.batchMaxSize || 50,\r\n      metricsInterval: config.metricsInterval || 30000,\r\n      ...config,\r\n    };\r\n\r\n    this.asyncQueue = new AsyncOperationQueue(\r\n      this.config.asyncQueueConcurrency,\r\n      this.config.asyncTimeout || 30000,\r\n    );\r\n\r\n    this.batchProcessor = new BatchProcessor({\r\n      maxBatchSize: this.config.batchMaxSize,\r\n      flushInterval: this.config.batchFlushInterval || 1000,\r\n      maxWaitTime: this.config.batchMaxWaitTime || 5000,\r\n    });\r\n\r\n    this.metrics = {\r\n      optimizations: {\r\n        asyncOperations: 0,\r\n        batchOperations: 0,\r\n        cacheHits: 0,\r\n        performanceGains: [],\r\n      },\r\n      system: {\r\n        cpuUsage: 0,\r\n        memoryUsage: 0,\r\n        throughput: 0,\r\n      },\r\n    };\r\n\r\n    this.cache = new Map();\r\n    this.performanceBaseline = null;\r\n\r\n    this._initialize();\r\n  }\r\n\r\n  _initialize() {\r\n    // Start performance monitoring\r\n    if (this.config.metricsInterval > 0) {\r\n      setInterval(() => this._collectSystemMetrics(), this.config.metricsInterval);\r\n    }\r\n\r\n    // Auto-tuning\r\n    if (this.config.enableAutoTuning) {\r\n      setInterval(() => this._autoTune(), 60000); // Every minute\r\n    }\r\n\r\n    this.emit('optimizer:initialized');\r\n  }\r\n\r\n  /**\r\n   * Optimize async operation execution\r\n   */\r\n  async optimizeAsyncOperation(operation, options = {}) {\r\n    if (!this.config.enableAsyncQueue) {\r\n      return await operation();\r\n    }\r\n\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const result = await this.asyncQueue.add(operation, options.priority || 5);\r\n\r\n      const executionTime = performance.now() - startTime;\r\n      this.metrics.optimizations.asyncOperations++;\r\n\r\n      // Track performance gain vs baseline\r\n      if (this.performanceBaseline) {\r\n        const gain = Math.max(0, this.performanceBaseline.avgAsyncTime - executionTime);\r\n        this.metrics.optimizations.performanceGains.push(gain);\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.emit('error', { type: 'async_optimization_failed', error, operation: operation.name });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize batch operations\r\n   */\r\n  async optimizeBatchOperation(batchKey, item, processor, options = {}) {\r\n    if (!this.config.enableBatchProcessing) {\r\n      return await processor([item]);\r\n    }\r\n\r\n    this.metrics.optimizations.batchOperations++;\r\n\r\n    return await this.batchProcessor.addToBatch(batchKey, item, processor);\r\n  }\r\n\r\n  /**\r\n   * Optimized caching with automatic expiration\r\n   */\r\n  async optimizeWithCache(key, operation, ttl = 300000) {\r\n    // 5 minutes default\r\n    const cached = this.cache.get(key);\r\n\r\n    if (cached && Date.now() - cached.timestamp < ttl) {\r\n      this.metrics.optimizations.cacheHits++;\r\n      return cached.value;\r\n    }\r\n\r\n    const result = await operation();\r\n\r\n    this.cache.set(key, {\r\n      value: result,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    // Clean old cache entries periodically\r\n    if (this.cache.size > 1000) {\r\n      this._cleanCache();\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Optimize memory operations with connection pooling awareness\r\n   */\r\n  async optimizeMemoryOperation(operation, connectionPool) {\r\n    const startTime = performance.now();\r\n\r\n    let connection = null;\r\n    try {\r\n      connection = await connectionPool.acquire();\r\n      const result = await operation(connection);\r\n\r\n      const executionTime = performance.now() - startTime;\r\n\r\n      // Track connection efficiency\r\n      this.metrics.system.throughput =\r\n        this.metrics.system.throughput * 0.9 + (1000 / executionTime) * 0.1;\r\n\r\n      return result;\r\n    } finally {\r\n      if (connection) {\r\n        connectionPool.release(connection);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize agent spawning with intelligent batching\r\n   */\r\n  async optimizeAgentSpawning(agentTypes, spawnFunction) {\r\n    // Group agents by complexity for optimal batching\r\n    const groups = this._groupAgentsByComplexity(agentTypes);\r\n    const results = [];\r\n\r\n    for (const group of groups) {\r\n      const batchResult = await this.optimizeBatchOperation('agent_spawn', group, spawnFunction);\r\n      results.push(...(Array.isArray(batchResult) ? batchResult : [batchResult]));\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Group agents by complexity for optimal spawning\r\n   */\r\n  _groupAgentsByComplexity(agentTypes) {\r\n    const complexity = {\r\n      low: ['coordinator'],\r\n      medium: ['coder', 'tester', 'documenter'],\r\n      high: ['researcher', 'analyst', 'architect', 'optimizer', 'reviewer'],\r\n    };\r\n\r\n    const groups = [];\r\n\r\n    Object.entries(complexity).forEach(([level, types]) => {\r\n      const groupAgents = agentTypes.filter((type) => types.includes(type));\r\n      if (groupAgents.length > 0) {\r\n        groups.push(groupAgents);\r\n      }\r\n    });\r\n\r\n    return groups;\r\n  }\r\n\r\n  /**\r\n   * Auto-tune performance parameters based on metrics\r\n   */\r\n  _autoTune() {\r\n    const queueMetrics = this.asyncQueue.getMetrics();\r\n    const batchMetrics = this.batchProcessor.getMetrics();\r\n\r\n    // Adjust async queue concurrency based on utilization\r\n    if (queueMetrics.utilization > 90 && this.asyncQueue.maxConcurrency < 20) {\r\n      this.asyncQueue.maxConcurrency += 2;\r\n      this.emit('auto_tune', {\r\n        type: 'concurrency_increased',\r\n        newValue: this.asyncQueue.maxConcurrency,\r\n      });\r\n    } else if (queueMetrics.utilization < 30 && this.asyncQueue.maxConcurrency > 5) {\r\n      this.asyncQueue.maxConcurrency = Math.max(5, this.asyncQueue.maxConcurrency - 1);\r\n      this.emit('auto_tune', {\r\n        type: 'concurrency_decreased',\r\n        newValue: this.asyncQueue.maxConcurrency,\r\n      });\r\n    }\r\n\r\n    // Adjust batch sizes based on processing efficiency\r\n    if (batchMetrics.avgBatchSize > 30 && batchMetrics.avgProcessingTime > 5000) {\r\n      this.batchProcessor.config.maxBatchSize = Math.max(\r\n        20,\r\n        this.batchProcessor.config.maxBatchSize - 5,\r\n      );\r\n      this.emit('auto_tune', {\r\n        type: 'batch_size_decreased',\r\n        newValue: this.batchProcessor.config.maxBatchSize,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean old cache entries\r\n   */\r\n  _cleanCache() {\r\n    const now = Date.now();\r\n    const entries = Array.from(this.cache.entries());\r\n\r\n    // Remove oldest 20% of entries\r\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\r\n    const toRemove = Math.floor(entries.length * 0.2);\r\n\r\n    for (let i = 0; i < toRemove; i++) {\r\n      this.cache.delete(entries[i][0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collect system performance metrics\r\n   */\r\n  _collectSystemMetrics() {\r\n    // Simple CPU and memory usage estimation\r\n    const used = process.memoryUsage();\r\n    this.metrics.system.memoryUsage = (used.heapUsed / 1024 / 1024).toFixed(2); // MB\r\n\r\n    // Estimate throughput based on recent operations\r\n    const queueMetrics = this.asyncQueue.getMetrics();\r\n    this.metrics.system.throughput =\r\n      queueMetrics.processed > 0\r\n        ? (queueMetrics.processed / (queueMetrics.avgProcessingTime / 1000)).toFixed(2)\r\n        : 0;\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive performance statistics\r\n   */\r\n  getPerformanceStats() {\r\n    return {\r\n      optimizer: this.metrics,\r\n      asyncQueue: this.asyncQueue.getMetrics(),\r\n      batchProcessor: this.batchProcessor.getMetrics(),\r\n      cache: {\r\n        size: this.cache.size,\r\n        hitRate:\r\n          this.metrics.optimizations.cacheHits > 0\r\n            ? (\r\n                (this.metrics.optimizations.cacheHits /\r\n                  (this.metrics.optimizations.asyncOperations +\r\n                    this.metrics.optimizations.cacheHits)) *\r\n                100\r\n              ).toFixed(2)\r\n            : 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate performance report with recommendations\r\n   */\r\n  generatePerformanceReport() {\r\n    const stats = this.getPerformanceStats();\r\n    const recommendations = [];\r\n\r\n    // Analyze and provide recommendations\r\n    if (stats.asyncQueue.utilization > 80) {\r\n      recommendations.push({\r\n        type: 'scaling',\r\n        priority: 'high',\r\n        message: 'Consider increasing async queue concurrency',\r\n        currentValue: this.asyncQueue.maxConcurrency,\r\n        suggestedValue: this.asyncQueue.maxConcurrency + 3,\r\n      });\r\n    }\r\n\r\n    if (stats.cache.hitRate < 60) {\r\n      recommendations.push({\r\n        type: 'caching',\r\n        priority: 'medium',\r\n        message: 'Cache hit rate is low, consider increasing cache TTL or size',\r\n        currentHitRate: stats.cache.hitRate,\r\n      });\r\n    }\r\n\r\n    if (stats.batchProcessor.avgBatchSize < 10) {\r\n      recommendations.push({\r\n        type: 'batching',\r\n        priority: 'medium',\r\n        message: 'Batch sizes are small, consider increasing batch wait time',\r\n        avgBatchSize: stats.batchProcessor.avgBatchSize,\r\n      });\r\n    }\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      performance: stats,\r\n      recommendations,\r\n      summary: {\r\n        overallHealth: this._calculateOverallHealth(stats),\r\n        keyMetrics: {\r\n          throughput: stats.optimizer.system.throughput,\r\n          efficiency: stats.asyncQueue.successRate,\r\n          utilization: stats.asyncQueue.utilization,\r\n        },\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate overall system health score\r\n   */\r\n  _calculateOverallHealth(stats) {\r\n    const factors = [\r\n      Math.min(100, parseFloat(stats.asyncQueue.successRate)),\r\n      Math.min(100, 100 - parseFloat(stats.asyncQueue.utilization)), // Lower utilization is better\r\n      Math.min(100, parseFloat(stats.cache.hitRate)),\r\n      Math.min(100, (stats.batchProcessor.avgBatchSize / this.config.batchMaxSize) * 100),\r\n    ];\r\n\r\n    const avgScore = factors.reduce((sum, score) => sum + score, 0) / factors.length;\r\n\r\n    if (avgScore >= 80) return 'excellent';\r\n    if (avgScore >= 60) return 'good';\r\n    if (avgScore >= 40) return 'fair';\r\n    return 'poor';\r\n  }\r\n\r\n  /**\r\n   * Close optimizer and cleanup resources\r\n   */\r\n  async close() {\r\n    await this.batchProcessor.close();\r\n    this.cache.clear();\r\n    this.emit('optimizer:closed');\r\n  }\r\n}\r\n\r\nexport default PerformanceOptimizer;\r\n"],"names":["EventEmitter","performance","AsyncOperationQueue","maxConcurrency","timeout","running","queue","results","Map","metrics","processed","failures","avgProcessingTime","totalProcessingTime","add","operation","priority","Promise","resolve","reject","queueItem","addedAt","Date","now","id","Math","random","toString","substr","insertIndex","findIndex","item","push","splice","_processQueue","length","shift","startTime","timeoutPromise","_","setTimeout","Error","result","race","processingTime","_updateMetrics","error","setImmediate","success","getMetrics","successRate","toFixed","queueSize","utilization","BatchProcessor","config","maxBatchSize","flushInterval","maxWaitTime","batches","timers","batchesProcessed","itemsProcessed","avgBatchSize","_startPeriodicFlush","addToBatch","batchKey","processor","has","set","items","createdAt","timer","_processBatch","batch","get","_resolve","_reject","clearTimeout","delete","forEach","index","emit","itemCount","setInterval","entries","pendingBatches","size","pendingItems","Array","from","values","reduce","sum","close","batchKeys","keys","all","map","key","PerformanceOptimizer","enableAsyncQueue","enableBatchProcessing","enableAutoTuning","asyncQueueConcurrency","batchMaxSize","metricsInterval","asyncQueue","asyncTimeout","batchProcessor","batchFlushInterval","batchMaxWaitTime","optimizations","asyncOperations","batchOperations","cacheHits","performanceGains","system","cpuUsage","memoryUsage","throughput","cache","performanceBaseline","_initialize","_collectSystemMetrics","_autoTune","optimizeAsyncOperation","options","executionTime","gain","max","avgAsyncTime","type","name","optimizeBatchOperation","optimizeWithCache","ttl","cached","timestamp","value","_cleanCache","optimizeMemoryOperation","connectionPool","connection","acquire","release","optimizeAgentSpawning","agentTypes","spawnFunction","groups","_groupAgentsByComplexity","group","batchResult","isArray","complexity","low","medium","high","Object","level","types","groupAgents","filter","includes","queueMetrics","batchMetrics","newValue","sort","a","b","toRemove","floor","i","used","process","heapUsed","getPerformanceStats","optimizer","hitRate","generatePerformanceReport","stats","recommendations","message","currentValue","suggestedValue","currentHitRate","toISOString","summary","overallHealth","_calculateOverallHealth","keyMetrics","efficiency","factors","min","parseFloat","avgScore","score","clear"],"mappings":"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"}