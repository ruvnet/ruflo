{
  "version": 3,
  "sources": ["../../src/mcp/load-balancer.ts"],
  "sourcesContent": ["/**\n * Load balancer and rate limiting for MCP\n */\n\nimport type { MCPLoadBalancerConfig, MCPRequest, MCPResponse, MCPSession } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError } from '../utils/errors.js';\n\nexport interface RequestMetrics {\n  requestId: string;\n  sessionId: string;\n  method: string;\n  startTime: number;\n  endTime?: number;\n  success?: boolean;\n  error?: string;\n}\n\nexport interface LoadBalancerMetrics {\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  rateLimitedRequests: number;\n  averageResponseTime: number;\n  requestsPerSecond: number;\n  circuitBreakerTrips: number;\n  lastReset: Date;\n}\n\nexport interface ILoadBalancer {\n  shouldAllowRequest(session: MCPSession, request: MCPRequest): Promise<boolean>;\n  recordRequestStart(session: MCPSession, request: MCPRequest): RequestMetrics;\n  recordRequestEnd(metrics: RequestMetrics, response?: MCPResponse, error?: Error): void;\n  getMetrics(): LoadBalancerMetrics;\n  resetMetrics(): void;\n  isCircuitBreakerOpen(): boolean;\n}\n\n/**\n * Circuit breaker state\n */\nenum CircuitBreakerState {\n  CLOSED = 'closed',\n  OPEN = 'open',\n  HALF_OPEN = 'half_open',\n}\n\n/**\n * Rate limiter using token bucket algorithm\n */\nclass RateLimiter {\n  private tokens: number;\n  private lastRefill: number;\n\n  constructor(\n    private maxTokens: number,\n    private refillRate: number, // tokens per second\n  ) {\n    this.tokens = maxTokens;\n    this.lastRefill = Date.now();\n  }\n\n  tryConsume(tokens = 1): boolean {\n    this.refill();\n\n    if (this.tokens >= tokens) {\n      this.tokens -= tokens;\n      return true;\n    }\n\n    return false;\n  }\n\n  private refill(): void {\n    const now = Date.now();\n    const timePassed = (now - this.lastRefill) / 1000;\n    const tokensToAdd = Math.floor(timePassed * this.refillRate);\n\n    if (tokensToAdd > 0) {\n      this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n      this.lastRefill = now;\n    }\n  }\n\n  getTokens(): number {\n    this.refill();\n    return this.tokens;\n  }\n}\n\n/**\n * Circuit breaker implementation\n */\nclass CircuitBreaker {\n  private state = CircuitBreakerState.CLOSED;\n  private failureCount = 0;\n  private lastFailureTime = 0;\n  private successCount = 0;\n\n  constructor(\n    private failureThreshold: number,\n    private recoveryTimeout: number, // milliseconds\n    private halfOpenMaxRequests = 3,\n  ) {}\n\n  canExecute(): boolean {\n    const now = Date.now();\n\n    switch (this.state) {\n      case CircuitBreakerState.CLOSED:\n        return true;\n\n      case CircuitBreakerState.OPEN:\n        if (now - this.lastFailureTime >= this.recoveryTimeout) {\n          this.state = CircuitBreakerState.HALF_OPEN;\n          this.successCount = 0;\n          return true;\n        }\n        return false;\n\n      case CircuitBreakerState.HALF_OPEN:\n        return this.successCount < this.halfOpenMaxRequests;\n\n      default:\n        return false;\n    }\n  }\n\n  recordSuccess(): void {\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      this.successCount++;\n      if (this.successCount >= this.halfOpenMaxRequests) {\n        this.state = CircuitBreakerState.CLOSED;\n        this.failureCount = 0;\n      }\n    } else if (this.state === CircuitBreakerState.CLOSED) {\n      this.failureCount = 0;\n    }\n  }\n\n  recordFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      this.state = CircuitBreakerState.OPEN;\n    } else if (\n      this.state === CircuitBreakerState.CLOSED &&\n      this.failureCount >= this.failureThreshold\n    ) {\n      this.state = CircuitBreakerState.OPEN;\n    }\n  }\n\n  getState(): CircuitBreakerState {\n    return this.state;\n  }\n\n  getMetrics(): { state: string; failureCount: number; successCount: number } {\n    return {\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n    };\n  }\n}\n\n/**\n * Load balancer implementation\n */\nexport class LoadBalancer implements ILoadBalancer {\n  private rateLimiter: RateLimiter;\n  private circuitBreaker: CircuitBreaker;\n  private sessionRateLimiters = new Map<string, RateLimiter>();\n  private metrics: LoadBalancerMetrics;\n  private requestTimes: number[] = [];\n  private requestsInLastSecond = 0;\n  private lastSecondTimestamp = 0;\n\n  constructor(\n    private config: MCPLoadBalancerConfig,\n    private logger: ILogger,\n  ) {\n    this.rateLimiter = new RateLimiter(config.maxRequestsPerSecond, config.maxRequestsPerSecond);\n\n    this.circuitBreaker = new CircuitBreaker(\n      config.circuitBreakerThreshold,\n      30000, // 30 second recovery timeout\n    );\n\n    this.metrics = {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      rateLimitedRequests: 0,\n      averageResponseTime: 0,\n      requestsPerSecond: 0,\n      circuitBreakerTrips: 0,\n      lastReset: new Date(),\n    };\n\n    // Clean up old session rate limiters periodically\n    setInterval(() => {\n      this.cleanupSessionRateLimiters();\n    }, 300000); // Every 5 minutes\n  }\n\n  async shouldAllowRequest(session: MCPSession, request: MCPRequest): Promise<boolean> {\n    if (!this.config.enabled) {\n      return true;\n    }\n\n    // Check circuit breaker\n    if (!this.circuitBreaker.canExecute()) {\n      this.logger.warn('Request rejected by circuit breaker', {\n        sessionId: session.id,\n        method: request.method,\n        circuitState: this.circuitBreaker.getState(),\n      });\n      this.metrics.circuitBreakerTrips++;\n      return false;\n    }\n\n    // Check global rate limit\n    if (!this.rateLimiter.tryConsume()) {\n      this.logger.warn('Request rejected by global rate limiter', {\n        sessionId: session.id,\n        method: request.method,\n        remainingTokens: this.rateLimiter.getTokens(),\n      });\n      this.metrics.rateLimitedRequests++;\n      return false;\n    }\n\n    // Check per-session rate limit\n    const sessionRateLimiter = this.getSessionRateLimiter(session.id);\n    if (!sessionRateLimiter.tryConsume()) {\n      this.logger.warn('Request rejected by session rate limiter', {\n        sessionId: session.id,\n        method: request.method,\n        remainingTokens: sessionRateLimiter.getTokens(),\n      });\n      this.metrics.rateLimitedRequests++;\n      return false;\n    }\n\n    return true;\n  }\n\n  recordRequestStart(session: MCPSession, request: MCPRequest): RequestMetrics {\n    const requestMetrics: RequestMetrics = {\n      requestId: request.id.toString(),\n      sessionId: session.id,\n      method: request.method,\n      startTime: Date.now(),\n    };\n\n    this.metrics.totalRequests++;\n    this.updateRequestsPerSecond();\n\n    this.logger.debug('Request started', {\n      requestId: requestMetrics.requestId,\n      sessionId: session.id,\n      method: request.method,\n    });\n\n    return requestMetrics;\n  }\n\n  recordRequestEnd(metrics: RequestMetrics, response?: MCPResponse, error?: Error): void {\n    metrics.endTime = Date.now();\n    const duration = metrics.endTime - metrics.startTime;\n\n    // Update response time tracking\n    this.requestTimes.push(duration);\n    if (this.requestTimes.length > 1000) {\n      this.requestTimes.shift(); // Keep only last 1000 requests\n    }\n\n    const success = !error && (!response || !response.error);\n    metrics.success = success;\n    const errorMessage = error?.message || response?.error?.message;\n    if (errorMessage) {\n      metrics.error = errorMessage;\n    }\n\n    if (success) {\n      this.metrics.successfulRequests++;\n      this.circuitBreaker.recordSuccess();\n    } else {\n      this.metrics.failedRequests++;\n      this.circuitBreaker.recordFailure();\n    }\n\n    // Update average response time\n    this.metrics.averageResponseTime = this.calculateAverageResponseTime();\n\n    this.logger.debug('Request completed', {\n      requestId: metrics.requestId,\n      sessionId: metrics.sessionId,\n      method: metrics.method,\n      duration,\n      success,\n      error: metrics.error,\n    });\n  }\n\n  getMetrics(): LoadBalancerMetrics {\n    return { ...this.metrics };\n  }\n\n  resetMetrics(): void {\n    this.metrics = {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      rateLimitedRequests: 0,\n      averageResponseTime: 0,\n      requestsPerSecond: 0,\n      circuitBreakerTrips: 0,\n      lastReset: new Date(),\n    };\n    this.requestTimes = [];\n\n    this.logger.info('Load balancer metrics reset');\n  }\n\n  isCircuitBreakerOpen(): boolean {\n    return this.circuitBreaker.getState() === CircuitBreakerState.OPEN;\n  }\n\n  getDetailedMetrics(): {\n    loadBalancer: LoadBalancerMetrics;\n    circuitBreaker: { state: string; failureCount: number; successCount: number };\n    rateLimiter: { tokens: number; maxTokens: number };\n    sessions: number;\n  } {\n    return {\n      loadBalancer: this.getMetrics(),\n      circuitBreaker: this.circuitBreaker.getMetrics(),\n      rateLimiter: {\n        tokens: this.rateLimiter.getTokens(),\n        maxTokens: this.config.maxRequestsPerSecond,\n      },\n      sessions: this.sessionRateLimiters.size,\n    };\n  }\n\n  private getSessionRateLimiter(sessionId: string): RateLimiter {\n    let rateLimiter = this.sessionRateLimiters.get(sessionId);\n\n    if (!rateLimiter) {\n      // Create a per-session rate limiter (more restrictive than global)\n      const sessionLimit = Math.max(1, Math.floor(this.config.maxRequestsPerSecond / 10));\n      rateLimiter = new RateLimiter(sessionLimit, sessionLimit);\n      this.sessionRateLimiters.set(sessionId, rateLimiter);\n    }\n\n    return rateLimiter;\n  }\n\n  private calculateAverageResponseTime(): number {\n    if (this.requestTimes.length === 0) {\n      return 0;\n    }\n\n    const sum = this.requestTimes.reduce((acc, time) => acc + time, 0);\n    return sum / this.requestTimes.length;\n  }\n\n  private updateRequestsPerSecond(): void {\n    const now = Math.floor(Date.now() / 1000);\n\n    if (now !== this.lastSecondTimestamp) {\n      this.metrics.requestsPerSecond = this.requestsInLastSecond;\n      this.requestsInLastSecond = 1;\n      this.lastSecondTimestamp = now;\n    } else {\n      this.requestsInLastSecond++;\n    }\n  }\n\n  private cleanupSessionRateLimiters(): void {\n    // Remove rate limiters for sessions that haven't been used recently\n    const cutoffTime = Date.now() - 300000; // 5 minutes ago\n    let cleaned = 0;\n\n    for (const [sessionId, rateLimiter] of this.sessionRateLimiters.entries()) {\n      // If the rate limiter has full tokens, it hasn't been used recently\n      if (rateLimiter.getTokens() === this.config.maxRequestsPerSecond) {\n        this.sessionRateLimiters.delete(sessionId);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.debug('Cleaned up session rate limiters', { count: cleaned });\n    }\n  }\n}\n\n/**\n * Request queue for handling backpressure\n */\nexport class RequestQueue {\n  private queue: Array<{\n    session: MCPSession;\n    request: MCPRequest;\n    resolve: (result: any) => void;\n    reject: (error: Error) => void;\n    timestamp: number;\n  }> = [];\n\n  private processing = false;\n  private maxQueueSize: number;\n  private requestTimeout: number;\n\n  constructor(\n    maxQueueSize = 1000,\n    requestTimeout = 30000, // 30 seconds\n    private logger: ILogger,\n  ) {\n    this.maxQueueSize = maxQueueSize;\n    this.requestTimeout = requestTimeout;\n\n    // Clean up expired requests periodically\n    setInterval(() => {\n      this.cleanupExpiredRequests();\n    }, 10000); // Every 10 seconds\n  }\n\n  async enqueue<T>(\n    session: MCPSession,\n    request: MCPRequest,\n    processor: (session: MCPSession, request: MCPRequest) => Promise<T>,\n  ): Promise<T> {\n    if (this.queue.length >= this.maxQueueSize) {\n      throw new MCPError('Request queue is full');\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      this.queue.push({\n        session,\n        request,\n        resolve,\n        reject,\n        timestamp: Date.now(),\n      });\n\n      if (!this.processing) {\n        this.processQueue(processor);\n      }\n    });\n  }\n\n  private async processQueue<T>(\n    processor: (session: MCPSession, request: MCPRequest) => Promise<T>,\n  ): Promise<void> {\n    if (this.processing) {\n      return;\n    }\n\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const item = this.queue.shift()!;\n\n      // Check if request has expired\n      if (Date.now() - item.timestamp > this.requestTimeout) {\n        item.reject(new MCPError('Request timeout'));\n        continue;\n      }\n\n      try {\n        const result = await processor(item.session, item.request);\n        item.resolve(result);\n      } catch (error) {\n        item.reject(error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n\n    this.processing = false;\n  }\n\n  private cleanupExpiredRequests(): void {\n    const now = Date.now();\n    let cleaned = 0;\n\n    this.queue = this.queue.filter((item) => {\n      if (now - item.timestamp > this.requestTimeout) {\n        item.reject(new MCPError('Request timeout'));\n        cleaned++;\n        return false;\n      }\n      return true;\n    });\n\n    if (cleaned > 0) {\n      this.logger.warn('Cleaned up expired requests from queue', { count: cleaned });\n    }\n  }\n\n  getQueueSize(): number {\n    return this.queue.length;\n  }\n\n  isProcessing(): boolean {\n    return this.processing;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,oBAAyB;AAmCzB,IAAK,sBAAL,kBAAKA,yBAAL;AACE,EAAAA,qBAAA,YAAS;AACT,EAAAA,qBAAA,UAAO;AACP,EAAAA,qBAAA,eAAY;AAHT,SAAAA;AAAA,GAAA;AASL,MAAM,YAAY;AAAA,EAIhB,YACU,WACA,YACR;AAFQ;AACA;AAER,SAAK,SAAS;AACd,SAAK,aAAa,KAAK,IAAI;AAAA,EAC7B;AAAA,EA5DF,OAkDkB;AAAA;AAAA;AAAA,EACR;AAAA,EACA;AAAA,EAUR,WAAW,SAAS,GAAY;AAC9B,SAAK,OAAO;AAEZ,QAAI,KAAK,UAAU,QAAQ;AACzB,WAAK,UAAU;AACf,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,SAAe;AACrB,UAAM,MAAM,KAAK,IAAI;AACrB,UAAM,cAAc,MAAM,KAAK,cAAc;AAC7C,UAAM,cAAc,KAAK,MAAM,aAAa,KAAK,UAAU;AAE3D,QAAI,cAAc,GAAG;AACnB,WAAK,SAAS,KAAK,IAAI,KAAK,WAAW,KAAK,SAAS,WAAW;AAChE,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AAAA,EAEA,YAAoB;AAClB,SAAK,OAAO;AACZ,WAAO,KAAK;AAAA,EACd;AACF;AAKA,MAAM,eAAe;AAAA,EAMnB,YACU,kBACA,iBACA,sBAAsB,GAC9B;AAHQ;AACA;AACA;AAAA,EACP;AAAA,EAvGL,OA6FqB;AAAA;AAAA;AAAA,EACX,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,kBAAkB;AAAA,EAClB,eAAe;AAAA,EAQvB,aAAsB;AACpB,UAAM,MAAM,KAAK,IAAI;AAErB,YAAQ,KAAK,OAAO;AAAA,MAClB,KAAK;AACH,eAAO;AAAA,MAET,KAAK;AACH,YAAI,MAAM,KAAK,mBAAmB,KAAK,iBAAiB;AACtD,eAAK,QAAQ;AACb,eAAK,eAAe;AACpB,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MAET,KAAK;AACH,eAAO,KAAK,eAAe,KAAK;AAAA,MAElC;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEA,gBAAsB;AACpB,QAAI,KAAK,UAAU,6BAA+B;AAChD,WAAK;AACL,UAAI,KAAK,gBAAgB,KAAK,qBAAqB;AACjD,aAAK,QAAQ;AACb,aAAK,eAAe;AAAA,MACtB;AAAA,IACF,WAAW,KAAK,UAAU,uBAA4B;AACpD,WAAK,eAAe;AAAA,IACtB;AAAA,EACF;AAAA,EAEA,gBAAsB;AACpB,SAAK;AACL,SAAK,kBAAkB,KAAK,IAAI;AAEhC,QAAI,KAAK,UAAU,6BAA+B;AAChD,WAAK,QAAQ;AAAA,IACf,WACE,KAAK,UAAU,yBACf,KAAK,gBAAgB,KAAK,kBAC1B;AACA,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA,EAEA,WAAgC;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,aAA4E;AAC1E,WAAO;AAAA,MACL,OAAO,KAAK;AAAA,MACZ,cAAc,KAAK;AAAA,MACnB,cAAc,KAAK;AAAA,IACrB;AAAA,EACF;AACF;AAKO,MAAM,aAAsC;AAAA,EASjD,YACU,QACA,QACR;AAFQ;AACA;AAER,SAAK,cAAc,IAAI,YAAY,OAAO,sBAAsB,OAAO,oBAAoB;AAE3F,SAAK,iBAAiB,IAAI;AAAA,MACxB,OAAO;AAAA,MACP;AAAA;AAAA,IACF;AAEA,SAAK,UAAU;AAAA,MACb,eAAe;AAAA,MACf,oBAAoB;AAAA,MACpB,gBAAgB;AAAA,MAChB,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB,mBAAmB;AAAA,MACnB,qBAAqB;AAAA,MACrB,WAAW,oBAAI,KAAK;AAAA,IACtB;AAGA,gBAAY,MAAM;AAChB,WAAK,2BAA2B;AAAA,IAClC,GAAG,GAAM;AAAA,EACX;AAAA,EA7MF,OA0KmD;AAAA;AAAA;AAAA,EACzC;AAAA,EACA;AAAA,EACA,sBAAsB,oBAAI,IAAyB;AAAA,EACnD;AAAA,EACA,eAAyB,CAAC;AAAA,EAC1B,uBAAuB;AAAA,EACvB,sBAAsB;AAAA,EA8B9B,MAAM,mBAAmB,SAAqB,SAAuC;AACnF,QAAI,CAAC,KAAK,OAAO,SAAS;AACxB,aAAO;AAAA,IACT;AAGA,QAAI,CAAC,KAAK,eAAe,WAAW,GAAG;AACrC,WAAK,OAAO,KAAK,uCAAuC;AAAA,QACtD,WAAW,QAAQ;AAAA,QACnB,QAAQ,QAAQ;AAAA,QAChB,cAAc,KAAK,eAAe,SAAS;AAAA,MAC7C,CAAC;AACD,WAAK,QAAQ;AACb,aAAO;AAAA,IACT;AAGA,QAAI,CAAC,KAAK,YAAY,WAAW,GAAG;AAClC,WAAK,OAAO,KAAK,2CAA2C;AAAA,QAC1D,WAAW,QAAQ;AAAA,QACnB,QAAQ,QAAQ;AAAA,QAChB,iBAAiB,KAAK,YAAY,UAAU;AAAA,MAC9C,CAAC;AACD,WAAK,QAAQ;AACb,aAAO;AAAA,IACT;AAGA,UAAM,qBAAqB,KAAK,sBAAsB,QAAQ,EAAE;AAChE,QAAI,CAAC,mBAAmB,WAAW,GAAG;AACpC,WAAK,OAAO,KAAK,4CAA4C;AAAA,QAC3D,WAAW,QAAQ;AAAA,QACnB,QAAQ,QAAQ;AAAA,QAChB,iBAAiB,mBAAmB,UAAU;AAAA,MAChD,CAAC;AACD,WAAK,QAAQ;AACb,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB,SAAqB,SAAqC;AAC3E,UAAM,iBAAiC;AAAA,MACrC,WAAW,QAAQ,GAAG,SAAS;AAAA,MAC/B,WAAW,QAAQ;AAAA,MACnB,QAAQ,QAAQ;AAAA,MAChB,WAAW,KAAK,IAAI;AAAA,IACtB;AAEA,SAAK,QAAQ;AACb,SAAK,wBAAwB;AAE7B,SAAK,OAAO,MAAM,mBAAmB;AAAA,MACnC,WAAW,eAAe;AAAA,MAC1B,WAAW,QAAQ;AAAA,MACnB,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,SAAyB,UAAwB,OAAqB;AACrF,YAAQ,UAAU,KAAK,IAAI;AAC3B,UAAM,WAAW,QAAQ,UAAU,QAAQ;AAG3C,SAAK,aAAa,KAAK,QAAQ;AAC/B,QAAI,KAAK,aAAa,SAAS,KAAM;AACnC,WAAK,aAAa,MAAM;AAAA,IAC1B;AAEA,UAAM,UAAU,CAAC,UAAU,CAAC,YAAY,CAAC,SAAS;AAClD,YAAQ,UAAU;AAClB,UAAM,eAAe,OAAO,WAAW,UAAU,OAAO;AACxD,QAAI,cAAc;AAChB,cAAQ,QAAQ;AAAA,IAClB;AAEA,QAAI,SAAS;AACX,WAAK,QAAQ;AACb,WAAK,eAAe,cAAc;AAAA,IACpC,OAAO;AACL,WAAK,QAAQ;AACb,WAAK,eAAe,cAAc;AAAA,IACpC;AAGA,SAAK,QAAQ,sBAAsB,KAAK,6BAA6B;AAErE,SAAK,OAAO,MAAM,qBAAqB;AAAA,MACrC,WAAW,QAAQ;AAAA,MACnB,WAAW,QAAQ;AAAA,MACnB,QAAQ,QAAQ;AAAA,MAChB;AAAA,MACA;AAAA,MACA,OAAO,QAAQ;AAAA,IACjB,CAAC;AAAA,EACH;AAAA,EAEA,aAAkC;AAChC,WAAO,EAAE,GAAG,KAAK,QAAQ;AAAA,EAC3B;AAAA,EAEA,eAAqB;AACnB,SAAK,UAAU;AAAA,MACb,eAAe;AAAA,MACf,oBAAoB;AAAA,MACpB,gBAAgB;AAAA,MAChB,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB,mBAAmB;AAAA,MACnB,qBAAqB;AAAA,MACrB,WAAW,oBAAI,KAAK;AAAA,IACtB;AACA,SAAK,eAAe,CAAC;AAErB,SAAK,OAAO,KAAK,6BAA6B;AAAA,EAChD;AAAA,EAEA,uBAAgC;AAC9B,WAAO,KAAK,eAAe,SAAS,MAAM;AAAA,EAC5C;AAAA,EAEA,qBAKE;AACA,WAAO;AAAA,MACL,cAAc,KAAK,WAAW;AAAA,MAC9B,gBAAgB,KAAK,eAAe,WAAW;AAAA,MAC/C,aAAa;AAAA,QACX,QAAQ,KAAK,YAAY,UAAU;AAAA,QACnC,WAAW,KAAK,OAAO;AAAA,MACzB;AAAA,MACA,UAAU,KAAK,oBAAoB;AAAA,IACrC;AAAA,EACF;AAAA,EAEQ,sBAAsB,WAAgC;AAC5D,QAAI,cAAc,KAAK,oBAAoB,IAAI,SAAS;AAExD,QAAI,CAAC,aAAa;AAEhB,YAAM,eAAe,KAAK,IAAI,GAAG,KAAK,MAAM,KAAK,OAAO,uBAAuB,EAAE,CAAC;AAClF,oBAAc,IAAI,YAAY,cAAc,YAAY;AACxD,WAAK,oBAAoB,IAAI,WAAW,WAAW;AAAA,IACrD;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,+BAAuC;AAC7C,QAAI,KAAK,aAAa,WAAW,GAAG;AAClC,aAAO;AAAA,IACT;AAEA,UAAM,MAAM,KAAK,aAAa,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC;AACjE,WAAO,MAAM,KAAK,aAAa;AAAA,EACjC;AAAA,EAEQ,0BAAgC;AACtC,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAExC,QAAI,QAAQ,KAAK,qBAAqB;AACpC,WAAK,QAAQ,oBAAoB,KAAK;AACtC,WAAK,uBAAuB;AAC5B,WAAK,sBAAsB;AAAA,IAC7B,OAAO;AACL,WAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEQ,6BAAmC;AAEzC,UAAM,aAAa,KAAK,IAAI,IAAI;AAChC,QAAI,UAAU;AAEd,eAAW,CAAC,WAAW,WAAW,KAAK,KAAK,oBAAoB,QAAQ,GAAG;AAEzE,UAAI,YAAY,UAAU,MAAM,KAAK,OAAO,sBAAsB;AAChE,aAAK,oBAAoB,OAAO,SAAS;AACzC;AAAA,MACF;AAAA,IACF;AAEA,QAAI,UAAU,GAAG;AACf,WAAK,OAAO,MAAM,oCAAoC,EAAE,OAAO,QAAQ,CAAC;AAAA,IAC1E;AAAA,EACF;AACF;AAKO,MAAM,aAAa;AAAA,EAaxB,YACE,eAAe,KACf,iBAAiB,KACT,QACR;AADQ;AAER,SAAK,eAAe;AACpB,SAAK,iBAAiB;AAGtB,gBAAY,MAAM;AAChB,WAAK,uBAAuB;AAAA,IAC9B,GAAG,GAAK;AAAA,EACV;AAAA,EA7aF,OAoZ0B;AAAA;AAAA;AAAA,EAChB,QAMH,CAAC;AAAA,EAEE,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EAgBR,MAAM,QACJ,SACA,SACA,WACY;AACZ,QAAI,KAAK,MAAM,UAAU,KAAK,cAAc;AAC1C,YAAM,IAAI,uBAAS,uBAAuB;AAAA,IAC5C;AAEA,WAAO,IAAI,QAAW,CAAC,SAAS,WAAW;AACzC,WAAK,MAAM,KAAK;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW,KAAK,IAAI;AAAA,MACtB,CAAC;AAED,UAAI,CAAC,KAAK,YAAY;AACpB,aAAK,aAAa,SAAS;AAAA,MAC7B;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,aACZ,WACe;AACf,QAAI,KAAK,YAAY;AACnB;AAAA,IACF;AAEA,SAAK,aAAa;AAElB,WAAO,KAAK,MAAM,SAAS,GAAG;AAC5B,YAAM,OAAO,KAAK,MAAM,MAAM;AAG9B,UAAI,KAAK,IAAI,IAAI,KAAK,YAAY,KAAK,gBAAgB;AACrD,aAAK,OAAO,IAAI,uBAAS,iBAAiB,CAAC;AAC3C;AAAA,MACF;AAEA,UAAI;AACF,cAAM,SAAS,MAAM,UAAU,KAAK,SAAS,KAAK,OAAO;AACzD,aAAK,QAAQ,MAAM;AAAA,MACrB,SAAS,OAAO;AACd,aAAK,OAAO,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAAA,MACvE;AAAA,IACF;AAEA,SAAK,aAAa;AAAA,EACpB;AAAA,EAEQ,yBAA+B;AACrC,UAAM,MAAM,KAAK,IAAI;AACrB,QAAI,UAAU;AAEd,SAAK,QAAQ,KAAK,MAAM,OAAO,CAAC,SAAS;AACvC,UAAI,MAAM,KAAK,YAAY,KAAK,gBAAgB;AAC9C,aAAK,OAAO,IAAI,uBAAS,iBAAiB,CAAC;AAC3C;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,CAAC;AAED,QAAI,UAAU,GAAG;AACf,WAAK,OAAO,KAAK,0CAA0C,EAAE,OAAO,QAAQ,CAAC;AAAA,IAC/E;AAAA,EACF;AAAA,EAEA,eAAuB;AACrB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EAEA,eAAwB;AACtB,WAAO,KAAK;AAAA,EACd;AACF;",
  "names": ["CircuitBreakerState"]
}
