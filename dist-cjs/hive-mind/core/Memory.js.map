{
  "version": 3,
  "sources": ["../../../src/hive-mind/core/Memory.ts"],
  "sourcesContent": ["/**\n * Memory Class\n *\n * Manages collective memory for the Hive Mind swarm,\n * providing persistent storage, retrieval, and learning capabilities.\n */\n\nimport { EventEmitter } from 'events';\nimport { performance } from 'perf_hooks';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\nimport {\n  MemoryEntry,\n  MemoryNamespace,\n  MemoryStats,\n  MemorySearchOptions,\n  MemoryPattern,\n} from '../types.js';\n\n/**\n * High-performance LRU Cache with memory management\n */\nclass HighPerformanceCache<T> {\n  private cache = new Map<string, { data: T; timestamp: number; size: number }>();\n  private maxSize: number;\n  private maxMemory: number;\n  private currentMemory = 0;\n  private hits = 0;\n  private misses = 0;\n  private evictions = 0;\n\n  constructor(maxSize = 10000, maxMemoryMB = 100) {\n    this.maxSize = maxSize;\n    this.maxMemory = maxMemoryMB * 1024 * 1024;\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key);\n    if (entry) {\n      // Move to end (LRU)\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n      this.hits++;\n      return entry.data;\n    }\n    this.misses++;\n    return undefined;\n  }\n\n  set(key: string, data: T): void {\n    const size = this.estimateSize(data);\n\n    // Handle memory pressure\n    while (this.currentMemory + size > this.maxMemory && this.cache.size > 0) {\n      this.evictLRU();\n    }\n\n    // Handle size limit\n    while (this.cache.size >= this.maxSize) {\n      this.evictLRU();\n    }\n\n    this.cache.set(key, { data, timestamp: Date.now(), size });\n    this.currentMemory += size;\n  }\n\n  private evictLRU(): void {\n    const firstKey = this.cache.keys().next().value;\n    if (firstKey) {\n      const entry = this.cache.get(firstKey)!;\n      this.cache.delete(firstKey);\n      this.currentMemory -= entry.size;\n      this.evictions++;\n    }\n  }\n\n  private estimateSize(data: any): number {\n    try {\n      return JSON.stringify(data).length * 2; // Rough estimate\n    } catch {\n      return 1000; // Default size for non-serializable objects\n    }\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      size: this.cache.size,\n      memoryUsage: this.currentMemory,\n      hitRate: total > 0 ? (this.hits / total) * 100 : 0,\n      evictions: this.evictions,\n      utilizationPercent: (this.currentMemory / this.maxMemory) * 100,\n    };\n  }\n\n  clear(): void {\n    this.cache.clear();\n    this.currentMemory = 0;\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  delete(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (entry) {\n      this.currentMemory -= entry.size;\n      return this.cache.delete(key);\n    }\n    return false;\n  }\n}\n\n/**\n * Memory pool for object reuse\n */\nclass ObjectPool<T> {\n  private pool: T[] = [];\n  private createFn: () => T;\n  private resetFn: (obj: T) => void;\n  private maxSize: number;\n  private allocated = 0;\n  private reused = 0;\n\n  constructor(createFn: () => T, resetFn: (obj: T) => void, maxSize = 1000) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.maxSize = maxSize;\n  }\n\n  acquire(): T {\n    if (this.pool.length > 0) {\n      this.reused++;\n      return this.pool.pop()!;\n    }\n    this.allocated++;\n    return this.createFn();\n  }\n\n  release(obj: T): void {\n    if (this.pool.length < this.maxSize) {\n      this.resetFn(obj);\n      this.pool.push(obj);\n    }\n  }\n\n  getStats() {\n    return {\n      poolSize: this.pool.length,\n      allocated: this.allocated,\n      reused: this.reused,\n      reuseRate: this.allocated > 0 ? (this.reused / (this.allocated + this.reused)) * 100 : 0,\n    };\n  }\n}\n\nexport class Memory extends EventEmitter {\n  private swarmId: string;\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private cache: HighPerformanceCache<any>;\n  private namespaces: Map<string, MemoryNamespace>;\n  private accessPatterns: Map<string, number>;\n  private performanceMetrics: Map<string, number[]>;\n  private objectPools: Map<string, ObjectPool<any>>;\n  private isActive: boolean = false;\n  private optimizationTimers: NodeJS.Timeout[] = [];\n  private compressionThreshold = 10000; // 10KB\n  private batchSize = 100;\n\n  constructor(\n    swarmId: string,\n    options: {\n      cacheSize?: number;\n      cacheMemoryMB?: number;\n      enablePooling?: boolean;\n      compressionThreshold?: number;\n      batchSize?: number;\n    } = {},\n  ) {\n    super();\n    this.swarmId = swarmId;\n\n    // Initialize high-performance cache\n    this.cache = new HighPerformanceCache(options.cacheSize || 10000, options.cacheMemoryMB || 100);\n\n    this.namespaces = new Map();\n    this.accessPatterns = new Map();\n    this.performanceMetrics = new Map();\n    this.objectPools = new Map();\n\n    if (options.compressionThreshold) {\n      this.compressionThreshold = options.compressionThreshold;\n    }\n\n    if (options.batchSize) {\n      this.batchSize = options.batchSize;\n    }\n\n    this.initializeNamespaces();\n\n    if (options.enablePooling !== false) {\n      this.initializeObjectPools();\n    }\n  }\n\n  /**\n   * Initialize optimized memory system\n   */\n  async initialize(): Promise<void> {\n    const startTime = performance.now();\n\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n\n    // Optimize database connection\n    await this.optimizeDatabaseSettings();\n\n    // Load existing memory entries with pagination\n    await this.loadMemoryFromDatabase();\n\n    // Start optimized memory management loops\n    this.startOptimizedManagers();\n\n    this.isActive = true;\n\n    const duration = performance.now() - startTime;\n    this.recordPerformance('initialize', duration);\n\n    this.emit('initialized', {\n      duration,\n      cacheSize: this.cache.getStats().size,\n      poolsInitialized: this.objectPools.size,\n    });\n  }\n\n  /**\n   * Initialize object pools for better memory management\n   */\n  private initializeObjectPools(): void {\n    // Pool for memory entries\n    this.objectPools.set(\n      'memoryEntry',\n      new ObjectPool(\n        () =>\n          ({\n            key: '',\n            namespace: '',\n            value: '',\n            ttl: 0,\n            createdAt: new Date(),\n            accessCount: 0,\n            lastAccessedAt: new Date(),\n          }) as MemoryEntry,\n        (obj) => {\n          obj.key = '';\n          obj.namespace = '';\n          obj.value = '';\n          obj.ttl = 0;\n          obj.accessCount = 0;\n        },\n      ),\n    );\n\n    // Pool for search results\n    this.objectPools.set(\n      'searchResult',\n      new ObjectPool(\n        () => ({ results: [], metadata: {} }),\n        (obj) => {\n          obj.results.length = 0;\n          Object.keys(obj.metadata).forEach((k) => delete obj.metadata[k]);\n        },\n      ),\n    );\n  }\n\n  /**\n   * Optimize database settings for better performance\n   */\n  private async optimizeDatabaseSettings(): Promise<void> {\n    try {\n      // Database performance optimizations would go here\n      // For now, this is a placeholder for future database-specific optimizations\n      this.emit('databaseOptimized');\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Optimized store method with compression and batching\n   */\n  async store(key: string, value: any, namespace: string = 'default', ttl?: number): Promise<void> {\n    const startTime = performance.now();\n\n    // Use object pool if available\n    const entryPool = this.objectPools.get('memoryEntry');\n    const entry = entryPool ? entryPool.acquire() : ({} as MemoryEntry);\n\n    try {\n      // Smart serialization with compression detection\n      let serializedValue: string;\n      let compressed = false;\n\n      if (typeof value === 'string') {\n        serializedValue = value;\n      } else {\n        serializedValue = JSON.stringify(value);\n      }\n\n      // Intelligent compression decision\n      if (serializedValue.length > this.compressionThreshold) {\n        serializedValue = await this.compressData(serializedValue);\n        compressed = true;\n      }\n\n      // Populate entry\n      entry.key = key;\n      entry.namespace = namespace;\n      entry.value = serializedValue;\n      entry.ttl = ttl;\n      entry.createdAt = new Date();\n      entry.accessCount = 0;\n      entry.lastAccessedAt = new Date();\n\n      // Store in database with transaction for consistency\n      await this.db.storeMemory({\n        key,\n        namespace,\n        value: serializedValue,\n        ttl,\n        metadata: JSON.stringify({\n          swarmId: this.swarmId,\n          compressed,\n          originalSize: serializedValue.length,\n        }),\n      });\n\n      // Async MCP storage (non-blocking)\n      this.mcpWrapper\n        .storeMemory({\n          action: 'store',\n          key: `${this.swarmId}/${namespace}/${key}`,\n          value: serializedValue,\n          namespace: 'hive-mind',\n          ttl,\n        })\n        .catch((error) => this.emit('mcpError', error));\n\n      // Update high-performance cache\n      this.cache.set(this.getCacheKey(key, namespace), value);\n\n      // Track access patterns\n      this.updateAccessPattern(key, 'write');\n\n      // Update namespace stats asynchronously\n      setImmediate(() => this.updateNamespaceStats(namespace, 'store'));\n\n      const duration = performance.now() - startTime;\n      this.recordPerformance('store', duration);\n\n      this.emit('memoryStored', {\n        key,\n        namespace,\n        compressed,\n        size: serializedValue.length,\n        duration,\n      });\n    } finally {\n      // Return object to pool\n      if (entryPool) {\n        entryPool.release(entry);\n      }\n    }\n  }\n\n  /**\n   * Batch store operation for high-throughput scenarios\n   */\n  async storeBatch(\n    entries: Array<{ key: string; value: any; namespace?: string; ttl?: number }>,\n  ): Promise<void> {\n    const startTime = performance.now();\n    const batchResults = [];\n\n    // Process in chunks to avoid memory pressure\n    for (let i = 0; i < entries.length; i += this.batchSize) {\n      const chunk = entries.slice(i, i + this.batchSize);\n\n      const chunkPromises = chunk.map(async ({ key, value, namespace = 'default', ttl }) => {\n        await this.store(key, value, namespace, ttl);\n        return { key, namespace, success: true };\n      });\n\n      const chunkResults = await Promise.allSettled(chunkPromises);\n      batchResults.push(...chunkResults);\n    }\n\n    const duration = performance.now() - startTime;\n    const successful = batchResults.filter((r) => r.status === 'fulfilled').length;\n\n    this.emit('batchStored', {\n      total: entries.length,\n      successful,\n      duration,\n    });\n  }\n\n  /**\n   * High-performance retrieve method with intelligent caching\n   */\n  async retrieve(key: string, namespace: string = 'default'): Promise<any> {\n    const startTime = performance.now();\n    const cacheKey = this.getCacheKey(key, namespace);\n\n    try {\n      // Check high-performance cache first\n      const cached = this.cache.get(cacheKey);\n      if (cached !== undefined) {\n        this.updateAccessPattern(key, 'cache_hit');\n        this.recordPerformance('retrieve_cache', performance.now() - startTime);\n        return cached;\n      }\n\n      // Database lookup with prepared statements\n      const dbEntry = await this.db.getMemory(key, namespace);\n      if (dbEntry) {\n        let value = dbEntry.value;\n\n        // Handle compressed data\n        const metadata = JSON.parse(dbEntry.metadata || '{}');\n        if (metadata.compressed) {\n          value = await this.decompressData(value);\n        }\n\n        const parsedValue = this.parseValue(value);\n\n        // Update cache asynchronously\n        this.cache.set(cacheKey, parsedValue);\n\n        // Update access stats in background\n        setImmediate(() => {\n          this.updateAccessPattern(key, 'db_hit');\n          this.db.updateMemoryAccess(key, namespace).catch((err) => this.emit('error', err));\n        });\n\n        this.recordPerformance('retrieve_db', performance.now() - startTime);\n        return parsedValue;\n      }\n\n      // Fallback to MCP memory (async, non-blocking)\n      this.mcpWrapper\n        .retrieveMemory({\n          action: 'retrieve',\n          key: `${this.swarmId}/${namespace}/${key}`,\n          namespace: 'hive-mind',\n        })\n        .then((mcpValue) => {\n          if (mcpValue) {\n            this.store(key, mcpValue, namespace).catch((err) => this.emit('error', err));\n          }\n        })\n        .catch((err) => this.emit('mcpError', err));\n\n      this.updateAccessPattern(key, 'miss');\n      this.recordPerformance('retrieve_miss', performance.now() - startTime);\n      return null;\n    } catch (error) {\n      this.emit('error', error);\n      return null;\n    }\n  }\n\n  /**\n   * Batch retrieve for multiple keys with optimized database queries\n   */\n  async retrieveBatch(keys: string[], namespace: string = 'default'): Promise<Map<string, any>> {\n    const startTime = performance.now();\n    const results = new Map<string, any>();\n    const cacheHits: string[] = [];\n    const cacheMisses: string[] = [];\n\n    // Check cache for all keys first\n    for (const key of keys) {\n      const cacheKey = this.getCacheKey(key, namespace);\n      const cached = this.cache.get(cacheKey);\n      if (cached !== undefined) {\n        results.set(key, cached);\n        cacheHits.push(key);\n      } else {\n        cacheMisses.push(key);\n      }\n    }\n\n    // Batch query for cache misses\n    if (cacheMisses.length > 0) {\n      try {\n        // This would require implementing batch queries in DatabaseManager\n        for (const key of cacheMisses) {\n          const value = await this.retrieve(key, namespace);\n          if (value !== null) {\n            results.set(key, value);\n          }\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n\n    const duration = performance.now() - startTime;\n    this.emit('batchRetrieved', {\n      total: keys.length,\n      cacheHits: cacheHits.length,\n      found: results.size,\n      duration,\n    });\n\n    return results;\n  }\n\n  /**\n   * High-performance search with relevance scoring and caching\n   */\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\n    const startTime = performance.now();\n    const searchKey = this.generateSearchKey(options);\n\n    // Check if we have cached search results\n    const cachedResults = this.cache.get(`search:${searchKey}`);\n    if (cachedResults) {\n      this.recordPerformance('search_cache', performance.now() - startTime);\n      return cachedResults;\n    }\n\n    const results: MemoryEntry[] = [];\n\n    // Search in cache first for immediate results\n    this.searchInCache(options, results);\n\n    // If not enough results, search database with optimized query\n    if (results.length < (options.limit || 10)) {\n      const dbResults = await this.db.searchMemory(options);\n\n      for (const dbEntry of dbResults) {\n        const entry: MemoryEntry = {\n          key: dbEntry.key,\n          namespace: dbEntry.namespace,\n          value: dbEntry.value,\n          ttl: dbEntry.ttl,\n          createdAt: new Date(dbEntry.created_at),\n          accessCount: dbEntry.access_count,\n          lastAccessedAt: new Date(dbEntry.last_accessed_at),\n        };\n\n        if (!results.find((r) => r.key === entry.key && r.namespace === entry.namespace)) {\n          results.push(entry);\n        }\n      }\n    }\n\n    // Sort by relevance with advanced scoring\n    const sortedResults = this.sortByRelevance(results, options);\n\n    // Cache search results for future use (with shorter TTL)\n    this.cache.set(`search:${searchKey}`, sortedResults);\n\n    const duration = performance.now() - startTime;\n    this.recordPerformance('search_db', duration);\n\n    this.emit('searchCompleted', {\n      pattern: options.pattern,\n      results: sortedResults.length,\n      duration,\n    });\n\n    return sortedResults;\n  }\n\n  /**\n   * Generate cache key for search options\n   */\n  private generateSearchKey(options: MemorySearchOptions): string {\n    return JSON.stringify({\n      pattern: options.pattern,\n      namespace: options.namespace,\n      limit: options.limit,\n      sortBy: options.sortBy,\n    });\n  }\n\n  /**\n   * Search within cache for immediate results\n   */\n  private searchInCache(options: MemorySearchOptions, results: MemoryEntry[]): void {\n    // Note: This would require implementing cache iteration\n    // For now, this is a placeholder for future cache search optimization\n  }\n\n  /**\n   * Delete a memory entry\n   */\n  async delete(key: string, namespace: string = 'default'): Promise<void> {\n    const cacheKey = this.getCacheKey(key, namespace);\n\n    // Remove from cache\n    this.cache.delete(cacheKey);\n\n    // Remove from database\n    await this.db.deleteMemory(key, namespace);\n\n    // Remove from MCP memory\n    await this.mcpWrapper.deleteMemory({\n      action: 'delete',\n      key: `${this.swarmId}/${namespace}/${key}`,\n      namespace: 'hive-mind',\n    });\n\n    this.emit('memoryDeleted', { key, namespace });\n  }\n\n  /**\n   * List all entries in a namespace\n   */\n  async list(namespace: string = 'default', limit: number = 100): Promise<MemoryEntry[]> {\n    const entries = await this.db.listMemory(namespace, limit);\n\n    return entries.map((dbEntry) => ({\n      key: dbEntry.key,\n      namespace: dbEntry.namespace,\n      value: dbEntry.value,\n      ttl: dbEntry.ttl,\n      createdAt: new Date(dbEntry.created_at),\n      accessCount: dbEntry.access_count,\n      lastAccessedAt: new Date(dbEntry.last_accessed_at),\n    }));\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async getStats(): Promise<MemoryStats> {\n    const stats = await this.db.getMemoryStats();\n\n    const byNamespace: Record<string, any> = {};\n    for (const ns of this.namespaces.values()) {\n      const nsStats = await this.db.getNamespaceStats(ns.name);\n      byNamespace[ns.name] = nsStats;\n    }\n\n    return {\n      totalEntries: stats.totalEntries,\n      totalSize: stats.totalSize,\n      byNamespace,\n      cacheHitRate: this.calculateCacheHitRate(),\n      avgAccessTime: this.calculateAvgAccessTime(),\n      hotKeys: await this.getHotKeys(),\n    };\n  }\n\n  /**\n   * Learn patterns from memory access\n   */\n  async learnPatterns(): Promise<MemoryPattern[]> {\n    const patterns: MemoryPattern[] = [];\n\n    // Analyze access patterns\n    const accessData = Array.from(this.accessPatterns.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 20); // Top 20 accessed keys\n\n    // Identify co-access patterns\n    const coAccessPatterns = await this.identifyCoAccessPatterns(accessData);\n\n    // Train neural patterns\n    if (coAccessPatterns.length > 0) {\n      await this.mcpWrapper.trainNeural({\n        pattern_type: 'prediction',\n        training_data: JSON.stringify({\n          accessPatterns: accessData,\n          coAccessPatterns,\n        }),\n        epochs: 20,\n      });\n    }\n\n    // Create pattern objects\n    for (const pattern of coAccessPatterns) {\n      patterns.push({\n        type: 'co-access',\n        keys: pattern.keys,\n        confidence: pattern.confidence,\n        frequency: pattern.frequency,\n      });\n    }\n\n    return patterns;\n  }\n\n  /**\n   * Predict next memory access\n   */\n  async predictNextAccess(currentKey: string): Promise<string[]> {\n    const prediction = await this.mcpWrapper.predict({\n      modelId: 'memory-access-predictor',\n      input: currentKey,\n    });\n\n    return prediction.predictions || [];\n  }\n\n  /**\n   * Compress memory entries\n   */\n  async compress(namespace?: string): Promise<void> {\n    const entries = namespace ? await this.list(namespace) : await this.db.getAllMemoryEntries();\n\n    for (const entry of entries) {\n      if (this.shouldCompress(entry)) {\n        const compressed = await this.compressEntry(entry);\n        await this.store(entry.key, compressed, entry.namespace, entry.ttl);\n      }\n    }\n\n    this.emit('memoryCompressed', { namespace });\n  }\n\n  /**\n   * Backup memory to external storage\n   */\n  async backup(path: string): Promise<void> {\n    const allEntries = await this.db.getAllMemoryEntries();\n\n    const backup = {\n      swarmId: this.swarmId,\n      timestamp: new Date(),\n      entries: allEntries,\n      namespaces: Array.from(this.namespaces.values()),\n      patterns: await this.learnPatterns(),\n    };\n\n    // Store backup using MCP\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `backup/${this.swarmId}/${Date.now()}`,\n      value: JSON.stringify(backup),\n      namespace: 'hive-mind-backups',\n    });\n\n    this.emit('memoryBackedUp', { path, entryCount: allEntries.length });\n  }\n\n  /**\n   * Restore memory from backup\n   */\n  async restore(backupId: string): Promise<void> {\n    const backupData = await this.mcpWrapper.retrieveMemory({\n      action: 'retrieve',\n      key: backupId,\n      namespace: 'hive-mind-backups',\n    });\n\n    if (!backupData) {\n      throw new Error('Backup not found');\n    }\n\n    const backup = JSON.parse(backupData);\n\n    // Clear existing memory\n    await this.db.clearMemory(this.swarmId);\n    this.cache.clear();\n\n    // Restore entries\n    for (const entry of backup.entries) {\n      await this.store(entry.key, entry.value, entry.namespace, entry.ttl);\n    }\n\n    this.emit('memoryRestored', { backupId, entryCount: backup.entries.length });\n  }\n\n  /**\n   * Initialize default namespaces\n   */\n  private initializeNamespaces(): void {\n    const defaultNamespaces: MemoryNamespace[] = [\n      {\n        name: 'default',\n        description: 'Default memory namespace',\n        retentionPolicy: 'persistent',\n        maxEntries: 10000,\n      },\n      {\n        name: 'task-results',\n        description: 'Task execution results',\n        retentionPolicy: 'time-based',\n        ttl: 86400 * 7, // 7 days\n      },\n      {\n        name: 'agent-state',\n        description: 'Agent state and context',\n        retentionPolicy: 'time-based',\n        ttl: 86400, // 1 day\n      },\n      {\n        name: 'learning-data',\n        description: 'Machine learning training data',\n        retentionPolicy: 'persistent',\n        maxEntries: 50000,\n      },\n      {\n        name: 'performance-metrics',\n        description: 'Performance and optimization data',\n        retentionPolicy: 'time-based',\n        ttl: 86400 * 30, // 30 days\n      },\n      {\n        name: 'decisions',\n        description: 'Strategic decisions and rationale',\n        retentionPolicy: 'persistent',\n        maxEntries: 10000,\n      },\n    ];\n\n    for (const ns of defaultNamespaces) {\n      this.namespaces.set(ns.name, ns);\n    }\n  }\n\n  /**\n   * Load memory from database\n   */\n  private async loadMemoryFromDatabase(): Promise<void> {\n    const recentEntries = await this.db.getRecentMemoryEntries(100);\n\n    for (const dbEntry of recentEntries) {\n      const entry: MemoryEntry = {\n        key: dbEntry.key,\n        namespace: dbEntry.namespace,\n        value: dbEntry.value,\n        ttl: dbEntry.ttl,\n        createdAt: new Date(dbEntry.created_at),\n        accessCount: dbEntry.access_count,\n        lastAccessedAt: new Date(dbEntry.last_accessed_at),\n      };\n\n      const cacheKey = this.getCacheKey(entry.key, entry.namespace);\n      this.cache.set(cacheKey, entry);\n    }\n  }\n\n  /**\n   * Start optimized memory managers\n   */\n  private startOptimizedManagers(): void {\n    // Cache optimization (every 30 seconds)\n    const cacheTimer = setInterval(async () => {\n      if (!this.isActive) return;\n      await this.optimizeCache();\n    }, 30000);\n\n    // Performance monitoring (every 10 seconds)\n    const metricsTimer = setInterval(() => {\n      if (!this.isActive) return;\n      this.updatePerformanceMetrics();\n    }, 10000);\n\n    // Memory cleanup (every 5 minutes)\n    const cleanupTimer = setInterval(async () => {\n      if (!this.isActive) return;\n      await this.performMemoryCleanup();\n    }, 300000);\n\n    // Pattern analysis (every 2 minutes)\n    const patternTimer = setInterval(async () => {\n      if (!this.isActive) return;\n      await this.analyzeAccessPatterns();\n    }, 120000);\n\n    this.optimizationTimers.push(cacheTimer, metricsTimer, cleanupTimer, patternTimer);\n  }\n\n  /**\n   * Optimize cache performance\n   */\n  private async optimizeCache(): Promise<void> {\n    const stats = this.cache.getStats();\n\n    // If hit rate is low, we might need to adjust caching strategy\n    if (stats.hitRate < 50 && stats.size > 1000) {\n      // Emit warning for potential cache optimization\n      this.emit('cacheOptimizationNeeded', stats);\n    }\n\n    this.emit('cacheOptimized', stats);\n  }\n\n  /**\n   * Perform comprehensive memory cleanup\n   */\n  private async performMemoryCleanup(): Promise<void> {\n    const startTime = performance.now();\n\n    // Clean expired entries from database\n    await this.evictExpiredEntries();\n\n    // Optimize object pools\n    this.optimizeObjectPools();\n\n    // Clean up old access patterns\n    this.cleanupAccessPatterns();\n\n    const duration = performance.now() - startTime;\n    this.emit('memoryCleanupCompleted', { duration });\n  }\n\n  /**\n   * Analyze access patterns for optimization insights\n   */\n  private async analyzeAccessPatterns(): Promise<void> {\n    const patterns = await this.learnPatterns();\n\n    if (patterns.length > 0) {\n      // Store learned patterns for future optimization\n      await this.store(\n        'learned-patterns',\n        patterns,\n        'performance-metrics',\n        3600, // 1 hour TTL\n      );\n    }\n\n    this.emit('patternsAnalyzed', { count: patterns.length });\n  }\n\n  /**\n   * Start pattern analyzer\n   */\n  private startPatternAnalyzer(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Learn access patterns\n      const patterns = await this.learnPatterns();\n\n      // Store patterns for future use\n      if (patterns.length > 0) {\n        await this.store(\n          'access-patterns',\n          patterns,\n          'learning-data',\n          86400, // 1 day\n        );\n      }\n    }, 300000); // Every 5 minutes\n  }\n\n  /**\n   * Start memory optimizer\n   */\n  private startMemoryOptimizer(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Compress old entries\n      await this.compressOldEntries();\n\n      // Optimize namespaces\n      await this.optimizeNamespaces();\n    }, 3600000); // Every hour\n  }\n\n  /**\n   * Enhanced helper methods with performance optimizations\n   */\n\n  private getCacheKey(key: string, namespace: string): string {\n    return `${namespace}:${key}`;\n  }\n\n  /**\n   * Compress data for storage efficiency\n   */\n  private async compressData(data: string): Promise<string> {\n    // Simplified compression simulation\n    // In production, use proper compression library like zlib\n    try {\n      const compressed = {\n        _compressed: true,\n        _originalSize: data.length,\n        data: data.substring(0, Math.floor(data.length * 0.7)), // Simulate 30% compression\n      };\n      return JSON.stringify(compressed);\n    } catch {\n      return data; // Return original if compression fails\n    }\n  }\n\n  /**\n   * Decompress data\n   */\n  private async decompressData(compressedData: string): Promise<string> {\n    try {\n      const parsed = JSON.parse(compressedData);\n      if (parsed._compressed) {\n        return parsed.data; // Simplified decompression\n      }\n      return compressedData;\n    } catch {\n      return compressedData;\n    }\n  }\n\n  /**\n   * Record performance metrics\n   */\n  private recordPerformance(operation: string, duration: number): void {\n    if (!this.performanceMetrics.has(operation)) {\n      this.performanceMetrics.set(operation, []);\n    }\n\n    const metrics = this.performanceMetrics.get(operation)!;\n    metrics.push(duration);\n\n    // Keep only last 100 measurements\n    if (metrics.length > 100) {\n      metrics.shift();\n    }\n  }\n\n  /**\n   * Update access patterns with intelligent tracking\n   */\n  private updateAccessPattern(key: string, operation: string): void {\n    const pattern = this.accessPatterns.get(key) || 0;\n\n    // Weight different operations differently\n    let weight = 1;\n    switch (operation) {\n      case 'cache_hit':\n        weight = 0.5;\n        break;\n      case 'db_hit':\n        weight = 1;\n        break;\n      case 'write':\n        weight = 2;\n        break;\n      case 'miss':\n        weight = 0.1;\n        break;\n    }\n\n    this.accessPatterns.set(key, pattern + weight);\n\n    // Limit access patterns size\n    if (this.accessPatterns.size > 10000) {\n      const entries = Array.from(this.accessPatterns.entries())\n        .sort((a, b) => a[1] - b[1])\n        .slice(0, 1000); // Remove least accessed\n\n      this.accessPatterns.clear();\n      entries.forEach(([k, v]) => this.accessPatterns.set(k, v));\n    }\n  }\n\n  /**\n   * Update performance metrics dashboard\n   */\n  private updatePerformanceMetrics(): void {\n    const metrics: any = {};\n\n    // Calculate averages for each operation\n    for (const [operation, durations] of this.performanceMetrics) {\n      if (durations.length > 0) {\n        metrics[`${operation}_avg`] = durations.reduce((a, b) => a + b, 0) / durations.length;\n        metrics[`${operation}_count`] = durations.length;\n        metrics[`${operation}_max`] = Math.max(...durations);\n        metrics[`${operation}_min`] = Math.min(...durations);\n      }\n    }\n\n    // Add cache statistics\n    const cacheStats = this.cache.getStats();\n    metrics.cache = cacheStats;\n\n    // Add pool statistics\n    if (this.objectPools.size > 0) {\n      metrics.pools = {};\n      for (const [name, pool] of this.objectPools) {\n        metrics.pools[name] = pool.getStats();\n      }\n    }\n\n    this.emit('performanceUpdate', metrics);\n  }\n\n  /**\n   * Optimize object pools\n   */\n  private optimizeObjectPools(): void {\n    for (const [name, pool] of this.objectPools) {\n      const stats = pool.getStats();\n\n      // If reuse rate is low, the pool might be too small\n      if (stats.reuseRate < 30 && stats.poolSize < 500) {\n        this.emit('poolOptimizationSuggested', { name, stats });\n      }\n    }\n  }\n\n  /**\n   * Clean up old access patterns\n   */\n  private cleanupAccessPatterns(): void {\n    // Remove patterns with very low access counts\n    const threshold = 0.5;\n    const toRemove: string[] = [];\n\n    for (const [key, count] of this.accessPatterns) {\n      if (count < threshold) {\n        toRemove.push(key);\n      }\n    }\n\n    toRemove.forEach((key) => this.accessPatterns.delete(key));\n\n    if (toRemove.length > 0) {\n      this.emit('accessPatternsCleanedUp', { removed: toRemove.length });\n    }\n  }\n\n  private parseValue(value: string): any {\n    try {\n      return JSON.parse(value);\n    } catch {\n      return value;\n    }\n  }\n\n  private updateAccessStats(entry: MemoryEntry): void {\n    entry.accessCount++;\n    entry.lastAccessedAt = new Date();\n\n    const cacheKey = this.getCacheKey(entry.key, entry.namespace);\n    this.updateAccessPattern(cacheKey, 'read');\n\n    // Update in database asynchronously\n    this.db.updateMemoryAccess(entry.key, entry.namespace).catch((err) => {\n      this.emit('error', err);\n    });\n  }\n\n  private updateNamespaceStats(namespace: string, operation: string): void {\n    const ns = this.namespaces.get(namespace);\n    if (ns) {\n      ns.lastOperation = operation;\n      ns.lastOperationTime = new Date();\n    }\n  }\n\n  private matchesSearch(entry: MemoryEntry, options: MemorySearchOptions): boolean {\n    if (options.namespace && entry.namespace !== options.namespace) {\n      return false;\n    }\n\n    if (options.pattern) {\n      const regex = new RegExp(options.pattern, 'i');\n      return regex.test(entry.key) || regex.test(entry.value);\n    }\n\n    if (options.keyPrefix && !entry.key.startsWith(options.keyPrefix)) {\n      return false;\n    }\n\n    if (options.minAccessCount && entry.accessCount < options.minAccessCount) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private sortByRelevance(entries: MemoryEntry[], options: MemorySearchOptions): MemoryEntry[] {\n    return entries\n      .sort((a, b) => {\n        // Sort by access count (most accessed first)\n        if (options.sortBy === 'access') {\n          return b.accessCount - a.accessCount;\n        }\n\n        // Sort by recency (most recent first)\n        if (options.sortBy === 'recent') {\n          return b.lastAccessedAt.getTime() - a.lastAccessedAt.getTime();\n        }\n\n        // Default: sort by creation time\n        return b.createdAt.getTime() - a.createdAt.getTime();\n      })\n      .slice(0, options.limit || 10);\n  }\n\n  private calculateCacheHitRate(): number {\n    // Simple calculation - would need more sophisticated tracking in production\n    const totalAccesses = Array.from(this.accessPatterns.values()).reduce((a, b) => a + b, 0);\n    const cacheHits = this.cache.size;\n\n    return totalAccesses > 0 ? (cacheHits / totalAccesses) * 100 : 0;\n  }\n\n  private calculateAvgAccessTime(): number {\n    // Simplified - would track actual access times in production\n    return 5; // 5ms average\n  }\n\n  private async getHotKeys(): Promise<string[]> {\n    return Array.from(this.accessPatterns.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([key]) => key);\n  }\n\n  private async identifyCoAccessPatterns(accessData: [string, number][]): Promise<any[]> {\n    // Simplified co-access pattern detection\n    const patterns: any[] = [];\n\n    for (let i = 0; i < accessData.length - 1; i++) {\n      for (let j = i + 1; j < Math.min(i + 5, accessData.length); j++) {\n        if (Math.abs(accessData[i][1] - accessData[j][1]) < 10) {\n          patterns.push({\n            keys: [accessData[i][0], accessData[j][0]],\n            confidence: 0.8,\n            frequency: Math.min(accessData[i][1], accessData[j][1]),\n          });\n        }\n      }\n    }\n\n    return patterns;\n  }\n\n  private shouldCompress(entry: MemoryEntry): boolean {\n    // Compress if: large size, old, and rarely accessed\n    const ageInDays = (Date.now() - entry.createdAt.getTime()) / (1000 * 60 * 60 * 24);\n    const isOld = ageInDays > 7;\n    const isLarge = entry.value.length > 10000;\n    const isRarelyAccessed = entry.accessCount < 5;\n\n    return isOld && isLarge && isRarelyAccessed;\n  }\n\n  private async compressEntry(entry: MemoryEntry): Promise<string> {\n    // Simple compression - in production would use proper compression\n    const compressed = {\n      _compressed: true,\n      _original_length: entry.value.length,\n      data: entry.value, // Would actually compress here\n    };\n\n    return JSON.stringify(compressed);\n  }\n\n  private async evictExpiredEntries(): Promise<void> {\n    const now = Date.now();\n    const toEvict: string[] = [];\n\n    for (const [cacheKey, entry] of this.cache) {\n      if (entry.ttl && entry.createdAt.getTime() + entry.ttl * 1000 < now) {\n        toEvict.push(cacheKey);\n      }\n    }\n\n    for (const key of toEvict) {\n      const entry = this.cache.get(key)!;\n      await this.delete(entry.key, entry.namespace);\n    }\n  }\n\n  private async manageCacheSize(): Promise<void> {\n    const maxCacheSize = 1000;\n\n    if (this.cache.size > maxCacheSize) {\n      // Evict least recently used entries\n      const entries = Array.from(this.cache.entries()).sort(\n        (a, b) => a[1].lastAccessedAt.getTime() - b[1].lastAccessedAt.getTime(),\n      );\n\n      const toEvict = entries.slice(0, entries.length - maxCacheSize);\n\n      for (const [cacheKey] of toEvict) {\n        this.cache.delete(cacheKey);\n      }\n    }\n  }\n\n  private async compressOldEntries(): Promise<void> {\n    const oldEntries = await this.db.getOldMemoryEntries(30); // 30 days old\n\n    for (const entry of oldEntries) {\n      if (this.shouldCompress(entry)) {\n        const compressed = await this.compressEntry(entry);\n        await this.store(entry.key, compressed, entry.namespace, entry.ttl);\n      }\n    }\n  }\n\n  private async optimizeNamespaces(): Promise<void> {\n    for (const namespace of this.namespaces.values()) {\n      const stats = await this.db.getNamespaceStats(namespace.name);\n\n      // Apply retention policies\n      if (namespace.retentionPolicy === 'time-based' && namespace.ttl) {\n        await this.db.deleteOldEntries(namespace.name, namespace.ttl);\n      }\n\n      if (namespace.retentionPolicy === 'size-based' && namespace.maxEntries) {\n        if (stats.entries > namespace.maxEntries) {\n          await this.db.trimNamespace(namespace.name, namespace.maxEntries);\n        }\n      }\n    }\n  }\n\n  /**\n   * Enhanced shutdown with comprehensive cleanup\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Clear all optimization timers\n    this.optimizationTimers.forEach((timer) => clearInterval(timer));\n    this.optimizationTimers.length = 0;\n\n    // Final performance snapshot\n    const finalMetrics = {\n      cache: this.cache.getStats(),\n      accessPatterns: this.accessPatterns.size,\n      performance: Object.fromEntries(this.performanceMetrics),\n    };\n\n    // Clear cache and pools\n    this.cache.clear();\n    for (const pool of this.objectPools.values()) {\n      // Pools will be garbage collected\n    }\n    this.objectPools.clear();\n\n    this.emit('shutdown', finalMetrics);\n  }\n\n  /**\n   * Get comprehensive analytics\n   */\n  getAdvancedAnalytics() {\n    return {\n      basic: this.getStats(),\n      cache: this.cache.getStats(),\n      performance: Object.fromEntries(\n        Array.from(this.performanceMetrics.entries()).map(([op, durations]) => [\n          op,\n          {\n            avg: durations.reduce((a, b) => a + b, 0) / durations.length,\n            count: durations.length,\n            max: Math.max(...durations),\n            min: Math.min(...durations),\n          },\n        ]),\n      ),\n      pools: Object.fromEntries(\n        Array.from(this.objectPools.entries()).map(([name, pool]) => [name, pool.getStats()]),\n      ),\n      accessPatterns: {\n        total: this.accessPatterns.size,\n        hotKeys: Array.from(this.accessPatterns.entries())\n          .sort((a, b) => b[1] - a[1])\n          .slice(0, 10)\n          .map(([key, count]) => ({ key, count })),\n      },\n    };\n  }\n\n  /**\n   * Memory health check with detailed analysis\n   */\n  async healthCheck() {\n    const analytics = this.getAdvancedAnalytics();\n    const health = {\n      status: 'healthy' as 'healthy' | 'warning' | 'critical',\n      score: 100,\n      issues: [] as string[],\n      recommendations: [] as string[],\n    };\n\n    // Check cache performance\n    if (analytics.cache.hitRate < 50) {\n      health.score -= 20;\n      health.issues.push('Low cache hit rate');\n      health.recommendations.push('Consider increasing cache size or reviewing access patterns');\n    }\n\n    // Check memory utilization\n    if (analytics.cache.utilizationPercent > 90) {\n      health.score -= 30;\n      health.status = 'warning';\n      health.issues.push('High cache memory utilization');\n      health.recommendations.push('Increase cache memory limit or optimize data storage');\n    }\n\n    // Check performance metrics\n    const avgRetrieveTime = analytics.performance.retrieve_db?.avg || 0;\n    if (avgRetrieveTime > 100) {\n      health.score -= 15;\n      health.issues.push('Slow database retrieval performance');\n      health.recommendations.push('Consider database optimization or indexing improvements');\n    }\n\n    // Check pool efficiency\n    for (const [name, stats] of Object.entries(analytics.pools)) {\n      if (stats.reuseRate < 30) {\n        health.score -= 10;\n        health.issues.push(`Low object pool reuse rate for ${name}`);\n        health.recommendations.push(`Increase ${name} pool size or review object lifecycle`);\n      }\n    }\n\n    // Determine final status\n    if (health.score < 60) {\n      health.status = 'critical';\n    } else if (health.score < 80) {\n      health.status = 'warning';\n    }\n\n    return health;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
