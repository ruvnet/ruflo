{
  "version": 3,
  "sources": ["../../src/coordination/load-balancer.ts"],
  "sourcesContent": ["import {\n  getErrorMessage,\n  hasAgentLoad,\n  hasAgentTask,\n  hasWorkStealingData,\n} from '../utils/type-guards.js';\n/**\n * Advanced load balancing and work stealing implementation\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  AgentId,\n  AgentState,\n  TaskDefinition,\n  TaskId,\n  LoadBalancingStrategy,\n} from '../swarm/types.js';\nimport { WorkStealingCoordinator } from './work-stealing.js';\n\nexport interface LoadBalancerConfig {\n  strategy: LoadBalancingStrategy;\n  enableWorkStealing: boolean;\n  stealThreshold: number;\n  maxStealBatch: number;\n  rebalanceInterval: number;\n  loadSamplingInterval: number;\n  affinityWeight: number;\n  performanceWeight: number;\n  loadWeight: number;\n  latencyWeight: number;\n  queueDepthThreshold: number;\n  adaptiveThresholds: boolean;\n  predictiveEnabled: boolean;\n  debugMode: boolean;\n}\n\nexport interface AgentLoad {\n  agentId: string;\n  queueDepth: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  taskCount: number;\n  averageResponseTime: number;\n  throughput: number;\n  lastUpdated: Date;\n  capacity: number;\n  utilization: number;\n  efficiency: number;\n  affinityScore: number;\n}\n\nexport interface LoadBalancingDecision {\n  selectedAgent: AgentId;\n  reason: string;\n  confidence: number;\n  alternatives: Array<{\n    agent: AgentId;\n    score: number;\n    reason: string;\n  }>;\n  loadBefore: Record<string, number>;\n  predictedLoadAfter: Record<string, number>;\n  timestamp: Date;\n}\n\nexport interface WorkStealingOperation {\n  id: string;\n  sourceAgent: AgentId;\n  targetAgent: AgentId;\n  tasks: TaskId[];\n  reason: string;\n  status: 'planned' | 'executing' | 'completed' | 'failed';\n  startTime: Date;\n  endTime?: Date;\n  metrics: {\n    tasksStolen: number;\n    loadReduction: number;\n    latencyImprovement: number;\n  };\n}\n\nexport interface LoadPrediction {\n  agentId: string;\n  currentLoad: number;\n  predictedLoad: number;\n  confidence: number;\n  timeHorizon: number;\n  factors: Record<string, number>;\n}\n\n/**\n * Advanced load balancing system with work stealing and predictive capabilities\n */\nexport class LoadBalancer extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: LoadBalancerConfig;\n  private workStealer: WorkStealingCoordinator;\n\n  // Load tracking\n  private agentLoads = new Map<string, AgentLoad>();\n  private loadHistory = new Map<string, Array<{ timestamp: Date; load: number }>>();\n  private taskQueues = new Map<string, TaskDefinition[]>();\n\n  // Monitoring and statistics\n  private loadSamplingInterval?: NodeJS.Timeout;\n  private rebalanceInterval?: NodeJS.Timeout;\n  private decisions: LoadBalancingDecision[] = [];\n  private stealOperations = new Map<string, WorkStealingOperation>();\n\n  // Predictive modeling\n  private loadPredictors = new Map<string, LoadPredictor>();\n  private performanceBaselines = new Map<string, PerformanceBaseline>();\n\n  constructor(config: Partial<LoadBalancerConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      strategy: 'hybrid',\n      enableWorkStealing: true,\n      stealThreshold: 3,\n      maxStealBatch: 5,\n      rebalanceInterval: 10000,\n      loadSamplingInterval: 5000,\n      affinityWeight: 0.3,\n      performanceWeight: 0.3,\n      loadWeight: 0.25,\n      latencyWeight: 0.15,\n      queueDepthThreshold: 10,\n      adaptiveThresholds: true,\n      predictiveEnabled: true,\n      debugMode: false,\n      ...config,\n    };\n\n    this.workStealer = new WorkStealingCoordinator(\n      {\n        enabled: this.config.enableWorkStealing,\n        stealThreshold: this.config.stealThreshold,\n        maxStealBatch: this.config.maxStealBatch,\n        stealInterval: this.config.rebalanceInterval,\n      },\n      this.eventBus,\n      this.logger,\n    );\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('agent:load-update', (data) => {\n      if (hasAgentLoad(data)) {\n        this.updateAgentLoad(data.agentId, data.load);\n      }\n    });\n\n    this.eventBus.on('task:queued', (data) => {\n      if (hasAgentTask(data)) {\n        this.updateTaskQueue(data.agentId, data.task, 'add');\n      }\n    });\n\n    this.eventBus.on('task:started', (data) => {\n      if (hasAgentTask(data)) {\n        this.updateTaskQueue(data.agentId, data.task, 'remove');\n      }\n    });\n\n    this.eventBus.on('workstealing:request', (data) => {\n      if (hasWorkStealingData(data)) {\n        this.executeWorkStealing(data.sourceAgent, data.targetAgent, data.taskCount);\n      }\n    });\n\n    this.eventBus.on('agent:performance-update', (data) => {\n      this.updatePerformanceBaseline(data.agentId, data.metrics);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing load balancer', {\n      strategy: this.config.strategy,\n      workStealing: this.config.enableWorkStealing,\n      predictive: this.config.predictiveEnabled,\n    });\n\n    // Initialize work stealer\n    await this.workStealer.initialize();\n\n    // Start monitoring\n    this.startLoadSampling();\n    this.startRebalancing();\n\n    this.emit('loadbalancer:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down load balancer');\n\n    // Stop monitoring\n    if (this.loadSamplingInterval) clearInterval(this.loadSamplingInterval);\n    if (this.rebalanceInterval) clearInterval(this.rebalanceInterval);\n\n    // Shutdown work stealer\n    await this.workStealer.shutdown();\n\n    this.emit('loadbalancer:shutdown');\n  }\n\n  // === AGENT SELECTION ===\n\n  async selectAgent(\n    task: TaskDefinition,\n    availableAgents: AgentState[],\n    constraints?: {\n      excludeAgents?: AgentId[];\n      preferredAgents?: AgentId[];\n      maxLoad?: number;\n      requireCapabilities?: string[];\n    },\n  ): Promise<LoadBalancingDecision> {\n    const startTime = Date.now();\n\n    try {\n      // Filter agents based on constraints\n      let candidates = this.filterAgentsByConstraints(availableAgents, task, constraints);\n\n      if (candidates.length === 0) {\n        throw new Error('No suitable agents available for task');\n      }\n\n      // Apply selection strategy\n      const decision = await this.applySelectionStrategy(task, candidates);\n\n      // Record decision\n      this.decisions.push(decision);\n\n      // Keep only last 1000 decisions\n      if (this.decisions.length > 1000) {\n        this.decisions.shift();\n      }\n\n      const selectionTime = Date.now() - startTime;\n      this.logger.debug('Agent selected', {\n        taskId: task.id.id,\n        selectedAgent: decision.selectedAgent.id,\n        reason: decision.reason,\n        confidence: decision.confidence,\n        selectionTime,\n      });\n\n      this.emit('agent:selected', { task, decision, selectionTime });\n\n      return decision;\n    } catch (error) {\n      this.logger.error('Agent selection failed', { taskId: task.id.id, error });\n      throw error;\n    }\n  }\n\n  private filterAgentsByConstraints(\n    agents: AgentState[],\n    task: TaskDefinition,\n    constraints?: {\n      excludeAgents?: AgentId[];\n      preferredAgents?: AgentId[];\n      maxLoad?: number;\n      requireCapabilities?: string[];\n    },\n  ): AgentState[] {\n    return agents.filter((agent) => {\n      // Exclude specific agents\n      if (constraints?.excludeAgents?.some((excluded) => excluded.id === agent.id.id)) {\n        return false;\n      }\n\n      // Check maximum load\n      const load = this.agentLoads.get(agent.id.id);\n      if (constraints?.maxLoad && load && load.utilization > constraints.maxLoad) {\n        return false;\n      }\n\n      // Check required capabilities\n      if (constraints?.requireCapabilities) {\n        const hasAllCapabilities = constraints.requireCapabilities.every(\n          (cap) =>\n            agent.capabilities.domains.includes(cap) ||\n            agent.capabilities.tools.includes(cap) ||\n            agent.capabilities.languages.includes(cap),\n        );\n        if (!hasAllCapabilities) {\n          return false;\n        }\n      }\n\n      // Check task type compatibility\n      if (!this.isAgentCompatible(agent, task)) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  private async applySelectionStrategy(\n    task: TaskDefinition,\n    candidates: AgentState[],\n  ): Promise<LoadBalancingDecision> {\n    const scores = new Map<string, number>();\n    const reasons = new Map<string, string>();\n    const loadBefore: Record<string, number> = {};\n    const predictedLoadAfter: Record<string, number> = {};\n\n    // Calculate scores for each candidate\n    for (const agent of candidates) {\n      const agentId = agent.id.id;\n      const load = this.agentLoads.get(agentId) || this.createDefaultLoad(agentId);\n\n      loadBefore[agentId] = load.utilization;\n\n      let score = 0;\n      const scoreComponents: string[] = [];\n\n      switch (this.config.strategy) {\n        case 'load-based':\n          score = this.calculateLoadScore(agent, load);\n          scoreComponents.push(`load:${score.toFixed(2)}`);\n          break;\n\n        case 'performance-based':\n          score = this.calculatePerformanceScore(agent, load);\n          scoreComponents.push(`perf:${score.toFixed(2)}`);\n          break;\n\n        case 'capability-based':\n          score = this.calculateCapabilityScore(agent, task);\n          scoreComponents.push(`cap:${score.toFixed(2)}`);\n          break;\n\n        case 'affinity-based':\n          score = this.calculateAffinityScore(agent, task);\n          scoreComponents.push(`affinity:${score.toFixed(2)}`);\n          break;\n\n        case 'cost-based':\n          score = this.calculateCostScore(agent, task);\n          scoreComponents.push(`cost:${score.toFixed(2)}`);\n          break;\n\n        case 'hybrid':\n          score = this.calculateHybridScore(agent, task, load);\n          scoreComponents.push(`hybrid:${score.toFixed(2)}`);\n          break;\n\n        default:\n          score = Math.random(); // Random fallback\n          scoreComponents.push(`random:${score.toFixed(2)}`);\n      }\n\n      // Apply predictive modeling if enabled\n      if (this.config.predictiveEnabled) {\n        const prediction = this.predictLoad(agentId, task);\n        const predictiveScore = this.calculatePredictiveScore(prediction);\n        score = score * 0.7 + predictiveScore * 0.3;\n        predictedLoadAfter[agentId] = prediction.predictedLoad;\n        scoreComponents.push(`pred:${predictiveScore.toFixed(2)}`);\n      } else {\n        predictedLoadAfter[agentId] = load.utilization + 0.1; // Simple estimate\n      }\n\n      scores.set(agentId, score);\n      reasons.set(agentId, scoreComponents.join(','));\n    }\n\n    // Select agent with highest score\n    const sortedCandidates = candidates.sort((a, b) => {\n      const scoreA = scores.get(a.id.id) || 0;\n      const scoreB = scores.get(b.id.id) || 0;\n      return scoreB - scoreA;\n    });\n\n    const selectedAgent = sortedCandidates[0];\n    const selectedScore = scores.get(selectedAgent.id.id) || 0;\n    const selectedReason = reasons.get(selectedAgent.id.id) || 'unknown';\n\n    // Build alternatives list\n    const alternatives = sortedCandidates.slice(1, 4).map((agent) => ({\n      agent: agent.id,\n      score: scores.get(agent.id.id) || 0,\n      reason: reasons.get(agent.id.id) || 'unknown',\n    }));\n\n    // Calculate confidence based on score gap\n    const secondBestScore = alternatives.length > 0 ? alternatives[0].score : 0;\n    const confidence = Math.min(1, selectedScore - secondBestScore + 0.5);\n\n    return {\n      selectedAgent: selectedAgent.id,\n      reason: selectedReason,\n      confidence,\n      alternatives,\n      loadBefore,\n      predictedLoadAfter,\n      timestamp: new Date(),\n    };\n  }\n\n  // === SCORING ALGORITHMS ===\n\n  private calculateLoadScore(agent: AgentState, load: AgentLoad): number {\n    // Higher score for lower load (inverted)\n    return 1 - load.utilization;\n  }\n\n  private calculatePerformanceScore(agent: AgentState, load: AgentLoad): number {\n    const baseline = this.performanceBaselines.get(agent.id.id);\n    if (!baseline) return 0.5;\n\n    // Combine throughput, efficiency, and response time\n    const throughputScore = Math.min(1, load.throughput / baseline.expectedThroughput);\n    const efficiencyScore = load.efficiency;\n    const responseScore = Math.min(1, baseline.expectedResponseTime / load.averageResponseTime);\n\n    return (throughputScore + efficiencyScore + responseScore) / 3;\n  }\n\n  private calculateCapabilityScore(agent: AgentState, task: TaskDefinition): number {\n    let score = 0;\n    let totalChecks = 0;\n\n    // Check language compatibility\n    if (task.requirements.capabilities.includes('coding')) {\n      const hasLanguage = agent.capabilities.languages.some(\n        (lang) => task.context.language === lang,\n      );\n      score += hasLanguage ? 1 : 0;\n      totalChecks++;\n    }\n\n    // Check framework compatibility\n    if (task.context.framework) {\n      const hasFramework = agent.capabilities.frameworks.includes(task.context.framework);\n      score += hasFramework ? 1 : 0;\n      totalChecks++;\n    }\n\n    // Check domain expertise\n    const domainMatch = agent.capabilities.domains.some(\n      (domain) => task.type.includes(domain) || task.requirements.capabilities.includes(domain),\n    );\n    score += domainMatch ? 1 : 0;\n    totalChecks++;\n\n    // Check required tools\n    const hasTools = task.requirements.tools.every((tool) =>\n      agent.capabilities.tools.includes(tool),\n    );\n    score += hasTools ? 1 : 0;\n    totalChecks++;\n\n    return totalChecks > 0 ? score / totalChecks : 0;\n  }\n\n  private calculateAffinityScore(agent: AgentState, task: TaskDefinition): number {\n    const load = this.agentLoads.get(agent.id.id);\n    if (!load) return 0;\n\n    return load.affinityScore || 0.5;\n  }\n\n  private calculateCostScore(agent: AgentState, task: TaskDefinition): number {\n    // Simple cost model - could be enhanced\n    const baseCost = 1.0;\n    const performanceFactor = agent.capabilities.speed;\n    const reliabilityFactor = agent.capabilities.reliability;\n\n    const cost = baseCost / (performanceFactor * reliabilityFactor);\n    return Math.max(0, 1 - cost / 2); // Normalize and invert\n  }\n\n  private calculateHybridScore(agent: AgentState, task: TaskDefinition, load: AgentLoad): number {\n    const loadScore = this.calculateLoadScore(agent, load);\n    const performanceScore = this.calculatePerformanceScore(agent, load);\n    const capabilityScore = this.calculateCapabilityScore(agent, task);\n    const affinityScore = this.calculateAffinityScore(agent, task);\n\n    return (\n      loadScore * this.config.loadWeight +\n      performanceScore * this.config.performanceWeight +\n      capabilityScore * this.config.affinityWeight +\n      affinityScore * this.config.latencyWeight\n    );\n  }\n\n  private calculatePredictiveScore(prediction: LoadPrediction): number {\n    // Higher score for lower predicted load\n    const loadScore = 1 - prediction.predictedLoad;\n    const confidenceBonus = prediction.confidence * 0.2;\n    return Math.min(1, loadScore + confidenceBonus);\n  }\n\n  // === WORK STEALING ===\n\n  private async executeWorkStealing(\n    sourceAgentId: string,\n    targetAgentId: string,\n    taskCount: number,\n  ): Promise<void> {\n    const operationId = `steal-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n\n    const operation: WorkStealingOperation = {\n      id: operationId,\n      sourceAgent: { id: sourceAgentId, swarmId: 'default', type: 'coordinator', instance: 1 },\n      targetAgent: { id: targetAgentId, swarmId: 'default', type: 'coordinator', instance: 1 },\n      tasks: [],\n      reason: 'load_imbalance',\n      status: 'planned',\n      startTime: new Date(),\n      metrics: {\n        tasksStolen: 0,\n        loadReduction: 0,\n        latencyImprovement: 0,\n      },\n    };\n\n    this.stealOperations.set(operationId, operation);\n\n    try {\n      operation.status = 'executing';\n\n      // Get source queue\n      const sourceQueue = this.taskQueues.get(sourceAgentId) || [];\n      if (sourceQueue.length === 0) {\n        throw new Error('Source agent has no tasks to steal');\n      }\n\n      // Select tasks to steal (lowest priority first)\n      const tasksToSteal = sourceQueue\n        .sort((a, b) => (a.priority === b.priority ? 0 : a.priority === 'low' ? -1 : 1))\n        .slice(0, Math.min(taskCount, this.config.maxStealBatch));\n\n      // Remove tasks from source\n      for (const task of tasksToSteal) {\n        this.updateTaskQueue(sourceAgentId, task, 'remove');\n        this.updateTaskQueue(targetAgentId, task, 'add');\n        operation.tasks.push(task.id);\n      }\n\n      // Update metrics\n      operation.metrics.tasksStolen = tasksToSteal.length;\n      operation.metrics.loadReduction = this.calculateLoadReduction(\n        sourceAgentId,\n        tasksToSteal.length,\n      );\n      operation.status = 'completed';\n      operation.endTime = new Date();\n\n      this.logger.info('Work stealing completed', {\n        operationId,\n        sourceAgent: sourceAgentId,\n        targetAgent: targetAgentId,\n        tasksStolen: operation.metrics.tasksStolen,\n      });\n\n      this.emit('workstealing:completed', { operation });\n    } catch (error) {\n      operation.status = 'failed';\n      operation.endTime = new Date();\n\n      this.logger.error('Work stealing failed', {\n        operationId,\n        sourceAgent: sourceAgentId,\n        targetAgent: targetAgentId,\n        error,\n      });\n\n      this.emit('workstealing:failed', { operation, error });\n    }\n  }\n\n  // === LOAD MONITORING ===\n\n  private startLoadSampling(): void {\n    this.loadSamplingInterval = setInterval(() => {\n      this.sampleAgentLoads();\n    }, this.config.loadSamplingInterval);\n\n    this.logger.info('Started load sampling', {\n      interval: this.config.loadSamplingInterval,\n    });\n  }\n\n  private startRebalancing(): void {\n    this.rebalanceInterval = setInterval(() => {\n      this.performRebalancing();\n    }, this.config.rebalanceInterval);\n\n    this.logger.info('Started rebalancing', {\n      interval: this.config.rebalanceInterval,\n    });\n  }\n\n  private async sampleAgentLoads(): Promise<void> {\n    // Sample current loads from all agents\n    for (const [agentId, load] of this.agentLoads) {\n      // Update load history\n      const history = this.loadHistory.get(agentId) || [];\n      history.push({ timestamp: new Date(), load: load.utilization });\n\n      // Keep only last 100 samples\n      if (history.length > 100) {\n        history.shift();\n      }\n\n      this.loadHistory.set(agentId, history);\n\n      // Update predictive models\n      if (this.config.predictiveEnabled) {\n        this.updateLoadPredictor(agentId, load);\n      }\n    }\n  }\n\n  private async performRebalancing(): Promise<void> {\n    if (!this.config.enableWorkStealing) return;\n\n    try {\n      // Find overloaded and underloaded agents\n      const loads = Array.from(this.agentLoads.entries());\n      const overloaded = loads.filter(\n        ([_, load]) => load.utilization > 0.8 && load.queueDepth > this.config.queueDepthThreshold,\n      );\n      const underloaded = loads.filter(\n        ([_, load]) => load.utilization < 0.3 && load.queueDepth < 2,\n      );\n\n      if (overloaded.length === 0 || underloaded.length === 0) {\n        return; // No rebalancing needed\n      }\n\n      // Perform work stealing\n      for (const [overloadedId, overloadedLoad] of overloaded) {\n        // Find best underloaded target\n        const target = underloaded.sort((a, b) => a[1].utilization - b[1].utilization)[0];\n\n        if (target) {\n          const [targetId] = target;\n          const tasksToSteal = Math.min(\n            Math.floor((overloadedLoad.queueDepth - targetId.length) / 2),\n            this.config.maxStealBatch,\n          );\n\n          if (tasksToSteal > 0) {\n            await this.executeWorkStealing(overloadedId, targetId, tasksToSteal);\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('Rebalancing failed', error);\n    }\n  }\n\n  // === PREDICTIVE MODELING ===\n\n  private predictLoad(agentId: string, task: TaskDefinition): LoadPrediction {\n    const predictor = this.loadPredictors.get(agentId);\n    const currentLoad = this.agentLoads.get(agentId)?.utilization || 0;\n\n    if (!predictor) {\n      // Simple fallback prediction\n      return {\n        agentId,\n        currentLoad,\n        predictedLoad: Math.min(1, currentLoad + 0.1),\n        confidence: 0.5,\n        timeHorizon: 60000, // 1 minute\n        factors: { task_complexity: 0.1 },\n      };\n    }\n\n    return predictor.predict(task);\n  }\n\n  private updateLoadPredictor(agentId: string, load: AgentLoad): void {\n    let predictor = this.loadPredictors.get(agentId);\n    if (!predictor) {\n      predictor = new LoadPredictor(agentId);\n      this.loadPredictors.set(agentId, predictor);\n    }\n\n    predictor.update(load);\n  }\n\n  // === UTILITY METHODS ===\n\n  private isAgentCompatible(agent: AgentState, task: TaskDefinition): boolean {\n    // Check basic type compatibility\n    const typeCompatible = this.checkTypeCompatibility(agent.type, task.type);\n    if (!typeCompatible) return false;\n\n    // Check capability requirements\n    const hasRequiredCapabilities = task.requirements.capabilities.every((cap) => {\n      return (\n        agent.capabilities.domains.includes(cap) ||\n        agent.capabilities.tools.includes(cap) ||\n        agent.capabilities.languages.includes(cap)\n      );\n    });\n\n    return hasRequiredCapabilities;\n  }\n\n  private checkTypeCompatibility(agentType: string, taskType: string): boolean {\n    const compatibilityMap: Record<string, string[]> = {\n      researcher: ['research', 'analysis', 'documentation'],\n      coder: ['coding', 'testing', 'integration', 'deployment'],\n      analyst: ['analysis', 'validation', 'review'],\n      reviewer: ['review', 'validation', 'documentation'],\n      coordinator: ['coordination', 'monitoring', 'management'],\n      tester: ['testing', 'validation', 'integration'],\n      specialist: ['custom', 'optimization', 'maintenance'],\n    };\n\n    const compatibleTypes = compatibilityMap[agentType] || [];\n    return compatibleTypes.some((type) => taskType.includes(type));\n  }\n\n  private updateAgentLoad(agentId: string, loadData: Partial<AgentLoad>): void {\n    const existing = this.agentLoads.get(agentId) || this.createDefaultLoad(agentId);\n    const updated = { ...existing, ...loadData, lastUpdated: new Date() };\n\n    // Recalculate utilization\n    updated.utilization = this.calculateUtilization(updated);\n\n    this.agentLoads.set(agentId, updated);\n  }\n\n  private updateTaskQueue(\n    agentId: string,\n    task: TaskDefinition,\n    operation: 'add' | 'remove',\n  ): void {\n    const queue = this.taskQueues.get(agentId) || [];\n\n    if (operation === 'add') {\n      queue.push(task);\n    } else {\n      const index = queue.findIndex((t) => t.id.id === task.id.id);\n      if (index >= 0) {\n        queue.splice(index, 1);\n      }\n    }\n\n    this.taskQueues.set(agentId, queue);\n\n    // Update agent load\n    this.updateAgentLoad(agentId, {\n      queueDepth: queue.length,\n      taskCount: queue.length,\n    });\n  }\n\n  private updatePerformanceBaseline(agentId: string, metrics: any): void {\n    const baseline = this.performanceBaselines.get(agentId) || {\n      expectedThroughput: 10,\n      expectedResponseTime: 5000,\n      expectedQuality: 0.8,\n    };\n\n    // Update baseline with exponential moving average\n    const alpha = 0.1;\n    baseline.expectedThroughput =\n      baseline.expectedThroughput * (1 - alpha) + metrics.throughput * alpha;\n    baseline.expectedResponseTime =\n      baseline.expectedResponseTime * (1 - alpha) + metrics.responseTime * alpha;\n\n    this.performanceBaselines.set(agentId, baseline);\n  }\n\n  private calculateUtilization(load: AgentLoad): number {\n    // Combine multiple factors to calculate overall utilization\n    const queueFactor = Math.min(1, load.queueDepth / 10);\n    const cpuFactor = load.cpuUsage / 100;\n    const memoryFactor = load.memoryUsage / 100;\n    const taskFactor = Math.min(1, load.taskCount / load.capacity);\n\n    return (queueFactor + cpuFactor + memoryFactor + taskFactor) / 4;\n  }\n\n  private calculateLoadReduction(agentId: string, tasksRemoved: number): number {\n    const load = this.agentLoads.get(agentId);\n    if (!load) return 0;\n\n    const oldUtilization = load.utilization;\n    const newUtilization = this.calculateUtilization({\n      ...load,\n      queueDepth: load.queueDepth - tasksRemoved,\n      taskCount: load.taskCount - tasksRemoved,\n    });\n\n    return oldUtilization - newUtilization;\n  }\n\n  private createDefaultLoad(agentId: string): AgentLoad {\n    return {\n      agentId,\n      queueDepth: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      taskCount: 0,\n      averageResponseTime: 5000,\n      throughput: 0,\n      lastUpdated: new Date(),\n      capacity: 10,\n      utilization: 0,\n      efficiency: 1.0,\n      affinityScore: 0.5,\n    };\n  }\n\n  // === PUBLIC API ===\n\n  getAgentLoad(agentId: string): AgentLoad | undefined {\n    return this.agentLoads.get(agentId);\n  }\n\n  getAllLoads(): AgentLoad[] {\n    return Array.from(this.agentLoads.values());\n  }\n\n  getRecentDecisions(limit: number = 10): LoadBalancingDecision[] {\n    return this.decisions.slice(-limit);\n  }\n\n  getStealOperations(): WorkStealingOperation[] {\n    return Array.from(this.stealOperations.values());\n  }\n\n  getLoadStatistics(): {\n    totalAgents: number;\n    averageUtilization: number;\n    overloadedAgents: number;\n    underloadedAgents: number;\n    totalStealOperations: number;\n    successfulSteals: number;\n  } {\n    const loads = Array.from(this.agentLoads.values());\n    const avgUtilization =\n      loads.reduce((sum, load) => sum + load.utilization, 0) / loads.length || 0;\n    const overloaded = loads.filter((load) => load.utilization > 0.8).length;\n    const underloaded = loads.filter((load) => load.utilization < 0.3).length;\n    const successfulSteals = Array.from(this.stealOperations.values()).filter(\n      (op) => op.status === 'completed',\n    ).length;\n\n    return {\n      totalAgents: loads.length,\n      averageUtilization: avgUtilization,\n      overloadedAgents: overloaded,\n      underloadedAgents: underloaded,\n      totalStealOperations: this.stealOperations.size,\n      successfulSteals,\n    };\n  }\n\n  // Force rebalance\n  async forceRebalance(): Promise<void> {\n    await this.performRebalancing();\n  }\n}\n\n// === HELPER CLASSES ===\n\nclass LoadPredictor {\n  private agentId: string;\n  private history: Array<{ timestamp: Date; load: number }> = [];\n  private model: SimpleLinearModel;\n\n  constructor(agentId: string) {\n    this.agentId = agentId;\n    this.model = new SimpleLinearModel();\n  }\n\n  update(load: AgentLoad): void {\n    this.history.push({ timestamp: new Date(), load: load.utilization });\n\n    // Keep only last 50 samples\n    if (this.history.length > 50) {\n      this.history.shift();\n    }\n\n    // Update model if we have enough data\n    if (this.history.length >= 10) {\n      this.model.train(this.history);\n    }\n  }\n\n  predict(task: TaskDefinition): LoadPrediction {\n    const currentLoad = this.history.length > 0 ? this.history[this.history.length - 1].load : 0;\n\n    let predictedLoad = currentLoad;\n    let confidence = 0.5;\n\n    if (this.history.length >= 10) {\n      const prediction = this.model.predict();\n      predictedLoad = prediction.value;\n      confidence = prediction.confidence;\n    }\n\n    // Adjust for task complexity\n    const taskComplexity = this.estimateTaskComplexity(task);\n    predictedLoad = Math.min(1, predictedLoad + taskComplexity * 0.1);\n\n    return {\n      agentId: this.agentId,\n      currentLoad,\n      predictedLoad,\n      confidence,\n      timeHorizon: 60000,\n      factors: {\n        task_complexity: taskComplexity,\n        historical_trend: predictedLoad - currentLoad,\n      },\n    };\n  }\n\n  private estimateTaskComplexity(task: TaskDefinition): number {\n    // Simple complexity estimation\n    let complexity = 0.5;\n\n    if (task.requirements.estimatedDuration && task.requirements.estimatedDuration > 300000) {\n      complexity += 0.3; // Long-running task\n    }\n\n    if (task.requirements.memoryRequired && task.requirements.memoryRequired > 512 * 1024 * 1024) {\n      complexity += 0.2; // Memory-intensive\n    }\n\n    if (task.requirements.capabilities.length > 3) {\n      complexity += 0.2; // Requires multiple capabilities\n    }\n\n    return Math.min(1, complexity);\n  }\n}\n\nclass SimpleLinearModel {\n  private slope = 0;\n  private intercept = 0;\n  private r2 = 0;\n\n  train(data: Array<{ timestamp: Date; load: number }>): void {\n    if (data.length < 2) return;\n\n    // Convert timestamps to relative time points\n    const startTime = data[0].timestamp.getTime();\n    const points = data.map((point, index) => ({\n      x: index, // Use index as x for simplicity\n      y: point.load,\n    }));\n\n    // Calculate linear regression\n    const n = points.length;\n    const sumX = points.reduce((sum, p) => sum + p.x, 0);\n    const sumY = points.reduce((sum, p) => sum + p.y, 0);\n    const sumXY = points.reduce((sum, p) => sum + p.x * p.y, 0);\n    const sumXX = points.reduce((sum, p) => sum + p.x * p.x, 0);\n\n    this.slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    this.intercept = (sumY - this.slope * sumX) / n;\n\n    // Calculate R\u00B2\n    const meanY = sumY / n;\n    const ssTotal = points.reduce((sum, p) => sum + Math.pow(p.y - meanY, 2), 0);\n    const ssRes = points.reduce((sum, p) => {\n      const predicted = this.slope * p.x + this.intercept;\n      return sum + Math.pow(p.y - predicted, 2);\n    }, 0);\n\n    this.r2 = 1 - ssRes / ssTotal;\n  }\n\n  predict(): { value: number; confidence: number } {\n    // Predict next value (x = n)\n    const nextValue = this.slope * 1 + this.intercept; // Predict 1 step ahead\n    const confidence = Math.max(0, this.r2); // Use R\u00B2 as confidence\n\n    return {\n      value: Math.max(0, Math.min(1, nextValue)),\n      confidence,\n    };\n  }\n}\n\ninterface PerformanceBaseline {\n  expectedThroughput: number;\n  expectedResponseTime: number;\n  expectedQuality: number;\n}\n"],
  "mappings": "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",
  "names": []
}
