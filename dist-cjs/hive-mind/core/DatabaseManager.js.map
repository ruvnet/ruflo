{
  "version": 3,
  "sources": ["../../../src/hive-mind/core/DatabaseManager.ts"],
  "sourcesContent": ["/**\n * DatabaseManager Class\n *\n * Manages all database operations for the Hive Mind system\n * using SQLite as the persistence layer.\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { EventEmitter } from 'events';\nimport { fileURLToPath } from 'url';\n\n// ES module compatibility - define __dirname\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Dynamic import for SQLite wrapper\nlet createDatabase: any;\nlet isSQLiteAvailable: any;\nlet isWindows: any;\n\nasync function loadSQLiteWrapper() {\n  const module = await import('../../memory/sqlite-wrapper.js');\n  createDatabase = module.createDatabase;\n  isSQLiteAvailable = module.isSQLiteAvailable;\n  isWindows = module.isWindows;\n}\n\nexport class DatabaseManager extends EventEmitter {\n  private static instance: DatabaseManager;\n  private db: any; // Database instance or in-memory fallback\n  private statements: Map<string, any>;\n  private dbPath: string;\n  private isInMemory: boolean = false;\n  private memoryStore: any = null;\n\n  private constructor() {\n    super();\n    this.statements = new Map();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static async getInstance(): Promise<DatabaseManager> {\n    if (!DatabaseManager.instance) {\n      DatabaseManager.instance = new DatabaseManager();\n      await DatabaseManager.instance.initialize();\n    }\n    return DatabaseManager.instance;\n  }\n\n  /**\n   * Initialize database\n   */\n  async initialize(): Promise<void> {\n    // Load SQLite wrapper functions\n    await loadSQLiteWrapper();\n    \n    // Check if SQLite is available\n    const sqliteAvailable = await isSQLiteAvailable();\n    \n    if (!sqliteAvailable) {\n      console.warn('SQLite not available, using in-memory storage for Hive Mind');\n      this.initializeInMemoryFallback();\n      return;\n    }\n\n    try {\n      // Ensure data directory exists\n      const dataDir = path.join(process.cwd(), 'data');\n      await fs.mkdir(dataDir, { recursive: true });\n\n      // Set database path\n      this.dbPath = path.join(dataDir, 'hive-mind.db');\n\n      // Open database\n      this.db = await createDatabase(this.dbPath);\n\n      // Enable foreign keys\n      this.db.pragma('foreign_keys = ON');\n\n      // Load schema\n      await this.loadSchema();\n\n      // Prepare statements\n      this.prepareStatements();\n\n      this.emit('initialized');\n    } catch (error) {\n      console.error('Failed to initialize SQLite database:', error);\n      console.warn('Falling back to in-memory storage');\n      this.initializeInMemoryFallback();\n    }\n  }\n\n  /**\n   * Initialize in-memory fallback\n   */\n  private initializeInMemoryFallback(): void {\n    this.isInMemory = true;\n    this.memoryStore = {\n      swarms: new Map(),\n      agents: new Map(),\n      tasks: new Map(),\n      memory: new Map(),\n      communications: new Map(),\n      performance_metrics: new Map(),\n      consensus: new Map()\n    };\n\n    // Create mock statement methods\n    this.statements = new Map();\n    \n    if (isWindows && isWindows()) {\n      console.info(`\nNote: Hive Mind data will not persist between runs on Windows without SQLite.\nFor persistent storage options, see: https://github.com/ruvnet/claude-code-flow/docs/windows-installation.md\n`);\n    }\n\n    this.emit('initialized');\n  }\n\n  /**\n   * Load database schema\n   */\n  private async loadSchema(): Promise<void> {\n    const schemaPath = path.join(__dirname, '..', '..', 'db', 'hive-mind-schema.sql');\n    const schema = await fs.readFile(schemaPath, 'utf-8');\n\n    // Execute schema\n    this.db.exec(schema);\n  }\n\n  /**\n   * Prepare common SQL statements\n   */\n  private prepareStatements(): void {\n    // Swarm statements\n    this.statements.set(\n      'createSwarm',\n      this.db.prepare(`\n      INSERT INTO swarms (id, name, topology, queen_mode, max_agents, consensus_threshold, memory_ttl, config)\n      VALUES (@id, @name, @topology, @queenMode, @maxAgents, @consensusThreshold, @memoryTTL, @config)\n    `),\n    );\n\n    this.statements.set(\n      'getSwarm',\n      this.db.prepare(`\n      SELECT * FROM swarms WHERE id = ?\n    `),\n    );\n\n    this.statements.set(\n      'getActiveSwarm',\n      this.db.prepare(`\n      SELECT id FROM swarms WHERE is_active = 1 LIMIT 1\n    `),\n    );\n\n    this.statements.set(\n      'setActiveSwarm',\n      this.db.prepare(`\n      UPDATE swarms SET is_active = CASE WHEN id = ? THEN 1 ELSE 0 END\n    `),\n    );\n\n    // Agent statements\n    this.statements.set(\n      'createAgent',\n      this.db.prepare(`\n      INSERT INTO agents (id, swarm_id, name, type, status, capabilities, metadata)\n      VALUES (@id, @swarmId, @name, @type, @status, @capabilities, @metadata)\n    `),\n    );\n\n    this.statements.set(\n      'getAgent',\n      this.db.prepare(`\n      SELECT * FROM agents WHERE id = ?\n    `),\n    );\n\n    this.statements.set(\n      'getAgents',\n      this.db.prepare(`\n      SELECT * FROM agents WHERE swarm_id = ?\n    `),\n    );\n\n    this.statements.set(\n      'updateAgent',\n      this.db.prepare(`\n      UPDATE agents SET ? WHERE id = ?\n    `),\n    );\n\n    // Task statements\n    this.statements.set(\n      'createTask',\n      this.db.prepare(`\n      INSERT INTO tasks (\n        id, swarm_id, description, priority, strategy, status, \n        dependencies, assigned_agents, require_consensus, max_agents, \n        required_capabilities, metadata\n      ) VALUES (\n        @id, @swarmId, @description, @priority, @strategy, @status,\n        @dependencies, @assignedAgents, @requireConsensus, @maxAgents,\n        @requiredCapabilities, @metadata\n      )\n    `),\n    );\n\n    this.statements.set(\n      'getTask',\n      this.db.prepare(`\n      SELECT * FROM tasks WHERE id = ?\n    `),\n    );\n\n    this.statements.set(\n      'getTasks',\n      this.db.prepare(`\n      SELECT * FROM tasks WHERE swarm_id = ? ORDER BY created_at DESC\n    `),\n    );\n\n    this.statements.set(\n      'updateTaskStatus',\n      this.db.prepare(`\n      UPDATE tasks SET status = ? WHERE id = ?\n    `),\n    );\n\n    // Memory statements\n    this.statements.set(\n      'storeMemory',\n      this.db.prepare(`\n      INSERT OR REPLACE INTO memory (key, namespace, value, ttl, metadata)\n      VALUES (@key, @namespace, @value, @ttl, @metadata)\n    `),\n    );\n\n    this.statements.set(\n      'getMemory',\n      this.db.prepare(`\n      SELECT * FROM memory WHERE key = ? AND namespace = ?\n    `),\n    );\n\n    this.statements.set(\n      'searchMemory',\n      this.db.prepare(`\n      SELECT * FROM memory \n      WHERE namespace = ? AND (key LIKE ? OR value LIKE ?)\n      ORDER BY last_accessed_at DESC\n      LIMIT ?\n    `),\n    );\n\n    // Communication statements\n    this.statements.set(\n      'createCommunication',\n      this.db.prepare(`\n      INSERT INTO communications (\n        from_agent_id, to_agent_id, swarm_id, message_type, \n        content, priority, requires_response\n      ) VALUES (\n        @from_agent_id, @to_agent_id, @swarm_id, @message_type,\n        @content, @priority, @requires_response\n      )\n    `),\n    );\n\n    // Performance statements\n    this.statements.set(\n      'storeMetric',\n      this.db.prepare(`\n      INSERT INTO performance_metrics (swarm_id, agent_id, metric_type, metric_value, metadata)\n      VALUES (@swarm_id, @agent_id, @metric_type, @metric_value, @metadata)\n    `),\n    );\n  }\n\n  /**\n   * Raw SQL helper for complex updates\n   */\n  raw(sql: string): any {\n    return { _raw: sql };\n  }\n\n  // Swarm operations\n\n  async createSwarm(data: any): Promise<void> {\n    this.statements.get('createSwarm')!.run(data);\n  }\n\n  async getSwarm(id: string): Promise<any> {\n    return this.statements.get('getSwarm')!.get(id);\n  }\n\n  async getActiveSwarmId(): Promise<string | null> {\n    const result = this.statements.get('getActiveSwarm')!.get();\n    return result ? result.id : null;\n  }\n\n  async setActiveSwarm(id: string): Promise<void> {\n    this.statements.get('setActiveSwarm')!.run(id);\n  }\n\n  async getAllSwarms(): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT s.*, COUNT(a.id) as agentCount \n      FROM swarms s \n      LEFT JOIN agents a ON s.id = a.swarm_id \n      GROUP BY s.id \n      ORDER BY s.created_at DESC\n    `,\n      )\n      .all();\n  }\n\n  // Agent operations\n\n  async createAgent(data: any): Promise<void> {\n    this.statements.get('createAgent')!.run(data);\n  }\n\n  async getAgent(id: string): Promise<any> {\n    return this.statements.get('getAgent')!.get(id);\n  }\n\n  async getAgents(swarmId: string): Promise<any[]> {\n    return this.statements.get('getAgents')!.all(swarmId);\n  }\n\n  async updateAgent(id: string, updates: any): Promise<void> {\n    const setClauses: string[] = [];\n    const values: any[] = [];\n\n    for (const [key, value] of Object.entries(updates)) {\n      if (value && typeof value === 'object' && value._raw) {\n        setClauses.push(`${key} = ${value._raw}`);\n      } else {\n        setClauses.push(`${key} = ?`);\n        values.push(value);\n      }\n    }\n\n    values.push(id);\n\n    const stmt = this.db.prepare(`\n      UPDATE agents SET ${setClauses.join(', ')} WHERE id = ?\n    `);\n\n    stmt.run(...values);\n  }\n\n  async updateAgentStatus(id: string, status: string): Promise<void> {\n    this.db.prepare('UPDATE agents SET status = ? WHERE id = ?').run(status, id);\n  }\n\n  async getAgentPerformance(agentId: string): Promise<any> {\n    const agent = await this.getAgent(agentId);\n    if (!agent) return null;\n\n    return {\n      successRate: agent.success_count / (agent.success_count + agent.error_count) || 0,\n      totalTasks: agent.success_count + agent.error_count,\n      messageCount: agent.message_count,\n    };\n  }\n\n  // Task operations\n\n  async createTask(data: any): Promise<void> {\n    this.statements.get('createTask')!.run({\n      ...data,\n      requireConsensus: data.requireConsensus ? 1 : 0,\n    });\n  }\n\n  async getTask(id: string): Promise<any> {\n    return this.statements.get('getTask')!.get(id);\n  }\n\n  async getTasks(swarmId: string): Promise<any[]> {\n    return this.statements.get('getTasks')!.all(swarmId);\n  }\n\n  async updateTask(id: string, updates: any): Promise<void> {\n    const setClauses: string[] = [];\n    const values: any[] = [];\n\n    for (const [key, value] of Object.entries(updates)) {\n      setClauses.push(`${key} = ?`);\n      values.push(value);\n    }\n\n    values.push(id);\n\n    const stmt = this.db.prepare(`\n      UPDATE tasks SET ${setClauses.join(', ')} WHERE id = ?\n    `);\n\n    stmt.run(...values);\n  }\n\n  async updateTaskStatus(id: string, status: string): Promise<void> {\n    this.statements.get('updateTaskStatus')!.run(status, id);\n  }\n\n  async getPendingTasks(swarmId: string): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM tasks \n      WHERE swarm_id = ? AND status = 'pending'\n      ORDER BY \n        CASE priority \n          WHEN 'critical' THEN 1 \n          WHEN 'high' THEN 2 \n          WHEN 'medium' THEN 3 \n          WHEN 'low' THEN 4 \n        END,\n        created_at ASC\n    `,\n      )\n      .all(swarmId);\n  }\n\n  async getActiveTasks(swarmId: string): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM tasks \n      WHERE swarm_id = ? AND status IN ('assigned', 'in_progress')\n    `,\n      )\n      .all(swarmId);\n  }\n\n  async reassignTask(taskId: string, newAgentId: string): Promise<void> {\n    const task = await this.getTask(taskId);\n    if (!task) return;\n\n    const assignedAgents = JSON.parse(task.assigned_agents || '[]');\n    if (!assignedAgents.includes(newAgentId)) {\n      assignedAgents.push(newAgentId);\n    }\n\n    await this.updateTask(taskId, {\n      assigned_agents: JSON.stringify(assignedAgents),\n    });\n  }\n\n  // Memory operations\n\n  async storeMemory(data: any): Promise<void> {\n    this.statements.get('storeMemory')!.run(data);\n  }\n\n  async getMemory(key: string, namespace: string): Promise<any> {\n    return this.statements.get('getMemory')!.get(key, namespace);\n  }\n\n  async updateMemoryAccess(key: string, namespace: string): Promise<void> {\n    this.db\n      .prepare(\n        `\n      UPDATE memory \n      SET access_count = access_count + 1, last_accessed_at = CURRENT_TIMESTAMP\n      WHERE key = ? AND namespace = ?\n    `,\n      )\n      .run(key, namespace);\n  }\n\n  async searchMemory(options: any): Promise<any[]> {\n    const pattern = `%${options.pattern || ''}%`;\n    return this.statements\n      .get('searchMemory')!\n      .all(options.namespace || 'default', pattern, pattern, options.limit || 10);\n  }\n\n  async deleteMemory(key: string, namespace: string): Promise<void> {\n    this.db.prepare('DELETE FROM memory WHERE key = ? AND namespace = ?').run(key, namespace);\n  }\n\n  async listMemory(namespace: string, limit: number): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM memory \n      WHERE namespace = ? \n      ORDER BY last_accessed_at DESC \n      LIMIT ?\n    `,\n      )\n      .all(namespace, limit);\n  }\n\n  async getMemoryStats(): Promise<any> {\n    const result = this.db\n      .prepare(\n        `\n      SELECT \n        COUNT(*) as totalEntries,\n        SUM(LENGTH(value)) as totalSize\n      FROM memory\n    `,\n      )\n      .get();\n\n    return result || { totalEntries: 0, totalSize: 0 };\n  }\n\n  async getNamespaceStats(namespace: string): Promise<any> {\n    return (\n      this.db\n        .prepare(\n          `\n      SELECT \n        COUNT(*) as entries,\n        SUM(LENGTH(value)) as size,\n        AVG(ttl) as avgTTL\n      FROM memory\n      WHERE namespace = ?\n    `,\n        )\n        .get(namespace) || { entries: 0, size: 0, avgTTL: 0 }\n    );\n  }\n\n  async getAllMemoryEntries(): Promise<any[]> {\n    return this.db.prepare('SELECT * FROM memory').all();\n  }\n\n  async getRecentMemoryEntries(limit: number): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM memory \n      ORDER BY last_accessed_at DESC \n      LIMIT ?\n    `,\n      )\n      .all(limit);\n  }\n\n  async getOldMemoryEntries(daysOld: number): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM memory \n      WHERE created_at < datetime('now', '-' || ? || ' days')\n    `,\n      )\n      .all(daysOld);\n  }\n\n  async updateMemoryEntry(entry: any): Promise<void> {\n    this.db\n      .prepare(\n        `\n      UPDATE memory \n      SET value = ?, access_count = ?, last_accessed_at = ?\n      WHERE key = ? AND namespace = ?\n    `,\n      )\n      .run(entry.value, entry.accessCount, entry.lastAccessedAt, entry.key, entry.namespace);\n  }\n\n  async clearMemory(swarmId: string): Promise<void> {\n    // Clear memory related to a specific swarm\n    this.db\n      .prepare(\n        `\n      DELETE FROM memory \n      WHERE metadata LIKE '%\"swarmId\":\"${swarmId}\"%'\n    `,\n      )\n      .run();\n  }\n\n  async deleteOldEntries(namespace: string, ttl: number): Promise<void> {\n    this.db\n      .prepare(\n        `\n      DELETE FROM memory \n      WHERE namespace = ? AND created_at < datetime('now', '-' || ? || ' seconds')\n    `,\n      )\n      .run(namespace, ttl);\n  }\n\n  async trimNamespace(namespace: string, maxEntries: number): Promise<void> {\n    this.db\n      .prepare(\n        `\n      DELETE FROM memory \n      WHERE namespace = ? AND key NOT IN (\n        SELECT key FROM memory \n        WHERE namespace = ? \n        ORDER BY last_accessed_at DESC \n        LIMIT ?\n      )\n    `,\n      )\n      .run(namespace, namespace, maxEntries);\n  }\n\n  // Communication operations\n\n  async createCommunication(data: any): Promise<void> {\n    this.statements.get('createCommunication')!.run(data);\n  }\n\n  async getPendingMessages(agentId: string): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM communications \n      WHERE to_agent_id = ? AND delivered_at IS NULL\n      ORDER BY \n        CASE priority \n          WHEN 'urgent' THEN 1 \n          WHEN 'high' THEN 2 \n          WHEN 'normal' THEN 3 \n          WHEN 'low' THEN 4 \n        END,\n        timestamp ASC\n    `,\n      )\n      .all(agentId);\n  }\n\n  async markMessageDelivered(messageId: string): Promise<void> {\n    this.db\n      .prepare(\n        `\n      UPDATE communications \n      SET delivered_at = CURRENT_TIMESTAMP \n      WHERE id = ?\n    `,\n      )\n      .run(messageId);\n  }\n\n  async markMessageRead(messageId: string): Promise<void> {\n    this.db\n      .prepare(\n        `\n      UPDATE communications \n      SET read_at = CURRENT_TIMESTAMP \n      WHERE id = ?\n    `,\n      )\n      .run(messageId);\n  }\n\n  async getRecentMessages(swarmId: string, timeWindow: number): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM communications \n      WHERE swarm_id = ? AND timestamp > datetime('now', '-' || ? || ' milliseconds')\n    `,\n      )\n      .all(swarmId, timeWindow);\n  }\n\n  // Consensus operations\n\n  async createConsensusProposal(proposal: any): Promise<void> {\n    this.db\n      .prepare(\n        `\n      INSERT INTO consensus (\n        id, swarm_id, task_id, proposal, required_threshold, \n        status, deadline_at\n      ) VALUES (\n        @id, @swarmId, @taskId, @proposal, @requiredThreshold,\n        'pending', @deadline\n      )\n    `,\n      )\n      .run({\n        id: proposal.id,\n        swarmId: proposal.swarmId,\n        taskId: proposal.taskId || null,\n        proposal: JSON.stringify(proposal.proposal),\n        requiredThreshold: proposal.requiredThreshold,\n        deadline: proposal.deadline,\n      });\n  }\n\n  async submitConsensusVote(\n    proposalId: string,\n    agentId: string,\n    vote: boolean,\n    reason?: string,\n  ): Promise<void> {\n    const proposal = this.db.prepare('SELECT * FROM consensus WHERE id = ?').get(proposalId);\n    if (!proposal) return;\n\n    const votes = JSON.parse(proposal.votes || '{}');\n    votes[agentId] = { vote, reason: reason || '', timestamp: new Date() };\n\n    const totalVoters = Object.keys(votes).length;\n    const positiveVotes = Object.values(votes).filter((v: any) => v.vote).length;\n    const currentRatio = positiveVotes / totalVoters;\n\n    const status = currentRatio >= proposal.required_threshold ? 'achieved' : 'pending';\n\n    this.db\n      .prepare(\n        `\n      UPDATE consensus \n      SET votes = ?, current_votes = ?, total_voters = ?, status = ?\n      WHERE id = ?\n    `,\n      )\n      .run(JSON.stringify(votes), positiveVotes, totalVoters, status, proposalId);\n  }\n\n  // Performance operations\n\n  async storePerformanceMetric(data: any): Promise<void> {\n    this.statements.get('storeMetric')!.run({\n      ...data,\n      metadata: data.metadata ? JSON.stringify(data.metadata) : null,\n    });\n  }\n\n  async getSwarmStats(swarmId: string): Promise<any> {\n    const agentStats = this.db\n      .prepare(\n        `\n      SELECT \n        COUNT(*) as agentCount,\n        SUM(CASE WHEN status = 'busy' THEN 1 ELSE 0 END) as busyAgents\n      FROM agents \n      WHERE swarm_id = ?\n    `,\n      )\n      .get(swarmId);\n\n    const taskStats = this.db\n      .prepare(\n        `\n      SELECT \n        COUNT(*) as taskBacklog\n      FROM tasks \n      WHERE swarm_id = ? AND status IN ('pending', 'assigned')\n    `,\n      )\n      .get(swarmId);\n\n    return {\n      ...agentStats,\n      ...taskStats,\n      agentUtilization:\n        agentStats.agentCount > 0 ? agentStats.busyAgents / agentStats.agentCount : 0,\n    };\n  }\n\n  async getStrategyPerformance(swarmId: string): Promise<any> {\n    const results = this.db\n      .prepare(\n        `\n      SELECT \n        strategy,\n        COUNT(*) as totalTasks,\n        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful,\n        AVG(JULIANDAY(completed_at) - JULIANDAY(created_at)) * 24 * 60 * 60 * 1000 as avgCompletionTime\n      FROM tasks \n      WHERE swarm_id = ? AND completed_at IS NOT NULL\n      GROUP BY strategy\n    `,\n      )\n      .all(swarmId);\n\n    const performance: any = {};\n    for (const result of results) {\n      performance[result.strategy] = {\n        successRate: result.successful / result.totalTasks,\n        avgCompletionTime: result.avgCompletionTime,\n        totalTasks: result.totalTasks,\n      };\n    }\n\n    return performance;\n  }\n\n  async getSuccessfulDecisions(swarmId: string): Promise<any[]> {\n    return this.db\n      .prepare(\n        `\n      SELECT * FROM memory \n      WHERE namespace = 'queen-decisions' \n      AND key LIKE 'decision/%'\n      AND metadata LIKE '%\"swarmId\":\"${swarmId}\"%'\n      ORDER BY created_at DESC\n      LIMIT 100\n    `,\n      )\n      .all();\n  }\n\n  // Utility operations\n\n  async deleteMemoryEntry(key: string, namespace: string): Promise<void> {\n    const startTime = performance.now();\n\n    try {\n      this.db.prepare('DELETE FROM memory WHERE key = ? AND namespace = ?').run(key, namespace);\n\n      const duration = performance.now() - startTime;\n      this.recordPerformance('delete_memory', duration);\n    } catch (error) {\n      this.recordPerformance('delete_memory_error', performance.now() - startTime);\n      throw error;\n    }\n  }\n\n  /**\n   * Get database analytics\n   */\n  getDatabaseAnalytics(): any {\n    try {\n      const stats = this.db.prepare('PRAGMA table_info(swarms)').all();\n      return {\n        fragmentation: 0, // Placeholder - could implement actual fragmentation detection\n        tableCount: stats.length,\n        schemaVersion: '1.0.0',\n      };\n    } catch (error) {\n      return {\n        fragmentation: 0,\n        tableCount: 0,\n        schemaVersion: 'unknown',\n      };\n    }\n  }\n\n  /**\n   * Record performance metric\n   */\n  private recordPerformance(operation: string, duration: number): void {\n    // Simple performance tracking - could be expanded\n    console.debug(`DB Operation ${operation}: ${duration.toFixed(2)}ms`);\n  }\n\n  /**\n   * Close database connection\n   */\n  close(): void {\n    this.db.close();\n  }\n}\n"],
  "mappings": "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",
  "names": ["path", "module", "fs", "performance"]
}
