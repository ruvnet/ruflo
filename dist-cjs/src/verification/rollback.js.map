{"version":3,"sources":["../../../src/verification/rollback.ts"],"sourcesContent":["/**\r\n * Comprehensive Rollback Manager System\r\n * \r\n * Provides atomic rollback operations with state management, automated recovery,\r\n * and git integration for maintaining system integrity.\r\n * \r\n * Features:\r\n * - StateManager: Captures and manages system snapshots\r\n * - RollbackTrigger: Configurable thresholds and automated monitoring\r\n * - AutomatedRecovery: Multi-tier recovery strategies\r\n * - RollbackHistory: Compressed history tracking with TTL\r\n * - Git Integration: Code rollbacks with atomic commits\r\n */\r\n\r\nimport { promises as fs } from 'fs';\r\nimport { join } from 'path';\r\nimport { exec, spawn } from 'child_process';\r\nimport { promisify } from 'util';\r\nimport { createHash } from 'crypto';\r\nimport { EventEmitter } from 'events';\r\nimport { gzip, gunzip } from 'zlib';\r\n\r\nconst execAsync = promisify(exec);\r\nconst gzipAsync = promisify(gzip);\r\nconst gunzipAsync = promisify(gunzip);\r\n\r\n// ============================================================================\r\n// Type Definitions\r\n// ============================================================================\r\n\r\nexport interface SystemSnapshot {\r\n  id: string;\r\n  timestamp: number;\r\n  version: string;\r\n  metadata: {\r\n    description: string;\r\n    tags: string[];\r\n    triggeredBy: string;\r\n    severity: 'low' | 'medium' | 'high' | 'critical';\r\n  };\r\n  state: {\r\n    config: Record<string, any>;\r\n    memory: Record<string, any>;\r\n    processes: ProcessState[];\r\n    files: FileSnapshot[];\r\n    git: GitState;\r\n  };\r\n  integrity: {\r\n    checksum: string;\r\n    compressed: boolean;\r\n    size: number;\r\n  };\r\n}\r\n\r\nexport interface ProcessState {\r\n  pid: number;\r\n  name: string;\r\n  status: string;\r\n  memory: number;\r\n  cpu: number;\r\n  env: Record<string, string>;\r\n}\r\n\r\nexport interface FileSnapshot {\r\n  path: string;\r\n  content: string | Buffer;\r\n  stats: {\r\n    size: number;\r\n    mtime: number;\r\n    mode: number;\r\n  };\r\n  checksum: string;\r\n}\r\n\r\nexport interface GitState {\r\n  branch: string;\r\n  commit: string;\r\n  status: string;\r\n  staged: string[];\r\n  modified: string[];\r\n  untracked: string[];\r\n}\r\n\r\nexport interface RollbackTriggerConfig {\r\n  enabled: boolean;\r\n  thresholds: {\r\n    errorRate: number;           // Errors per minute\r\n    memoryUsage: number;         // Percentage\r\n    cpuUsage: number;            // Percentage\r\n    responseTime: number;        // Milliseconds\r\n    diskSpace: number;           // Percentage free\r\n    consecutiveFailures: number; // Count\r\n  };\r\n  monitoring: {\r\n    interval: number;            // Monitoring check interval (ms)\r\n    cooldown: number;            // Cooldown period after rollback (ms)\r\n    gracePeriod: number;         // Grace period before triggering (ms)\r\n  };\r\n  notifications: {\r\n    webhook?: string;\r\n    email?: string[];\r\n    slack?: string;\r\n  };\r\n}\r\n\r\nexport interface RecoveryStrategy {\r\n  name: string;\r\n  priority: number;\r\n  enabled: boolean;\r\n  timeout: number;\r\n  retries: number;\r\n  conditions: (metrics: SystemMetrics) => boolean;\r\n  execute: (snapshot: SystemSnapshot, context: RecoveryContext) => Promise<boolean>;\r\n}\r\n\r\nexport interface SystemMetrics {\r\n  timestamp: number;\r\n  errors: {\r\n    count: number;\r\n    rate: number;\r\n    recent: Error[];\r\n  };\r\n  performance: {\r\n    memory: { used: number; total: number; percentage: number; };\r\n    cpu: { usage: number; load: number[]; };\r\n    disk: { used: number; total: number; free: number; };\r\n    network: { in: number; out: number; };\r\n  };\r\n  health: {\r\n    status: 'healthy' | 'degraded' | 'critical';\r\n    score: number;\r\n    checks: HealthCheck[];\r\n  };\r\n}\r\n\r\nexport interface HealthCheck {\r\n  name: string;\r\n  status: 'pass' | 'fail' | 'warn';\r\n  message: string;\r\n  duration: number;\r\n}\r\n\r\nexport interface RecoveryContext {\r\n  triggeredBy: string;\r\n  reason: string;\r\n  metrics: SystemMetrics;\r\n  previousAttempts: RecoveryAttempt[];\r\n}\r\n\r\nexport interface RecoveryAttempt {\r\n  strategy: string;\r\n  timestamp: number;\r\n  success: boolean;\r\n  error?: string;\r\n  duration: number;\r\n}\r\n\r\nexport interface RollbackHistoryEntry {\r\n  id: string;\r\n  timestamp: number;\r\n  snapshot: SystemSnapshot;\r\n  trigger: {\r\n    type: 'manual' | 'automatic';\r\n    reason: string;\r\n    metrics?: SystemMetrics;\r\n  };\r\n  recovery: {\r\n    strategy: string;\r\n    success: boolean;\r\n    duration: number;\r\n    attempts: RecoveryAttempt[];\r\n  };\r\n  verification: {\r\n    passed: boolean;\r\n    checks: HealthCheck[];\r\n    rollbackRequired: boolean;\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// StateManager - Captures and manages system snapshots\r\n// ============================================================================\r\n\r\nexport class StateManager extends EventEmitter {\r\n  private snapshots: Map<string, SystemSnapshot> = new Map();\r\n  private snapshotDir: string;\r\n  private maxSnapshots: number;\r\n  private compressionEnabled: boolean;\r\n\r\n  constructor(\r\n    snapshotDir: string = './snapshots',\r\n    maxSnapshots: number = 100,\r\n    compressionEnabled: boolean = true\r\n  ) {\r\n    super();\r\n    this.snapshotDir = snapshotDir;\r\n    this.maxSnapshots = maxSnapshots;\r\n    this.compressionEnabled = compressionEnabled;\r\n    this.initializeStorage();\r\n  }\r\n\r\n  private async initializeStorage(): Promise<void> {\r\n    try {\r\n      await fs.mkdir(this.snapshotDir, { recursive: true });\r\n      await this.loadExistingSnapshots();\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to initialize storage: ${error}`));\r\n    }\r\n  }\r\n\r\n  private async loadExistingSnapshots(): Promise<void> {\r\n    try {\r\n      const files = await fs.readdir(this.snapshotDir);\r\n      const snapshotFiles = files.filter(f => f.endsWith('.snapshot.json'));\r\n      \r\n      for (const file of snapshotFiles) {\r\n        try {\r\n          const content = await fs.readFile(join(this.snapshotDir, file), 'utf-8');\r\n          const snapshot: SystemSnapshot = JSON.parse(content);\r\n          this.snapshots.set(snapshot.id, snapshot);\r\n        } catch (error) {\r\n          console.warn(`Failed to load snapshot ${file}:`, error);\r\n        }\r\n      }\r\n      \r\n      this.emit('snapshots_loaded', this.snapshots.size);\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to load snapshots: ${error}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a comprehensive system snapshot with atomic operations\r\n   */\r\n  public async captureSnapshot(\r\n    description: string,\r\n    tags: string[] = [],\r\n    triggeredBy: string = 'manual'\r\n  ): Promise<SystemSnapshot> {\r\n    const id = this.generateSnapshotId();\r\n    const timestamp = Date.now();\r\n\r\n    try {\r\n      // Capture system state atomically\r\n      const [config, memory, processes, files, git] = await Promise.all([\r\n        this.captureConfig(),\r\n        this.captureMemory(),\r\n        this.captureProcesses(),\r\n        this.captureFiles(),\r\n        this.captureGitState()\r\n      ]);\r\n\r\n      const snapshot: SystemSnapshot = {\r\n        id,\r\n        timestamp,\r\n        version: '1.0.0',\r\n        metadata: {\r\n          description,\r\n          tags,\r\n          triggeredBy,\r\n          severity: 'medium'\r\n        },\r\n        state: {\r\n          config,\r\n          memory,\r\n          processes,\r\n          files,\r\n          git\r\n        },\r\n        integrity: {\r\n          checksum: '',\r\n          compressed: this.compressionEnabled,\r\n          size: 0\r\n        }\r\n      };\r\n\r\n      // Calculate integrity checksum\r\n      const serialized = JSON.stringify(snapshot.state);\r\n      snapshot.integrity.checksum = createHash('sha256').update(serialized).digest('hex');\r\n      snapshot.integrity.size = Buffer.byteLength(serialized, 'utf8');\r\n\r\n      // Store snapshot\r\n      await this.storeSnapshot(snapshot);\r\n      this.snapshots.set(id, snapshot);\r\n\r\n      // Cleanup old snapshots\r\n      await this.cleanupOldSnapshots();\r\n\r\n      this.emit('snapshot_created', snapshot);\r\n      return snapshot;\r\n\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to capture snapshot: ${error}`));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async captureConfig(): Promise<Record<string, any>> {\r\n    try {\r\n      // Capture application configuration\r\n      const configPaths = [\r\n        './claude-flow.config.json',\r\n        './package.json',\r\n        './tsconfig.json',\r\n        './.env'\r\n      ];\r\n\r\n      const config: Record<string, any> = {};\r\n      \r\n      for (const path of configPaths) {\r\n        try {\r\n          const content = await fs.readFile(path, 'utf-8');\r\n          config[path] = JSON.parse(content);\r\n        } catch {\r\n          // File might not exist or be invalid JSON\r\n        }\r\n      }\r\n\r\n      return config;\r\n    } catch (error) {\r\n      return {};\r\n    }\r\n  }\r\n\r\n  private async captureMemory(): Promise<Record<string, any>> {\r\n    try {\r\n      // Capture memory-related state\r\n      const memoryPaths = [\r\n        './memory/memory-store.json',\r\n        './memory/claude-flow-data.json',\r\n        './swarm-memory/state.json'\r\n      ];\r\n\r\n      const memory: Record<string, any> = {};\r\n      \r\n      for (const path of memoryPaths) {\r\n        try {\r\n          const content = await fs.readFile(path, 'utf-8');\r\n          memory[path] = JSON.parse(content);\r\n        } catch {\r\n          // File might not exist\r\n        }\r\n      }\r\n\r\n      return memory;\r\n    } catch (error) {\r\n      return {};\r\n    }\r\n  }\r\n\r\n  private async captureProcesses(): Promise<ProcessState[]> {\r\n    try {\r\n      // Capture running processes related to claude-flow\r\n      const { stdout } = await execAsync('ps aux | grep -E \"(claude-flow|node)\" | grep -v grep');\r\n      const lines = stdout.trim().split('\\n');\r\n      \r\n      return lines.map(line => {\r\n        const parts = line.trim().split(/\\s+/);\r\n        return {\r\n          pid: parseInt(parts[1]) || 0,\r\n          name: parts[10] || 'unknown',\r\n          status: 'running',\r\n          memory: parseFloat(parts[5]) || 0,\r\n          cpu: parseFloat(parts[2]) || 0,\r\n          env: process.env as Record<string, string>\r\n        };\r\n      });\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private async captureFiles(): Promise<FileSnapshot[]> {\r\n    try {\r\n      // Capture critical files\r\n      const criticalPaths = [\r\n        './src/verification/rollback.ts',\r\n        './src/core/orchestrator.ts',\r\n        './src/memory/manager.ts',\r\n        './src/mcp/server.ts'\r\n      ];\r\n\r\n      const files: FileSnapshot[] = [];\r\n      \r\n      for (const path of criticalPaths) {\r\n        try {\r\n          const [content, stats] = await Promise.all([\r\n            fs.readFile(path, 'utf-8'),\r\n            fs.stat(path)\r\n          ]);\r\n          \r\n          files.push({\r\n            path,\r\n            content,\r\n            stats: {\r\n              size: stats.size,\r\n              mtime: stats.mtime.getTime(),\r\n              mode: stats.mode\r\n            },\r\n            checksum: createHash('md5').update(content).digest('hex')\r\n          });\r\n        } catch {\r\n          // File might not exist\r\n        }\r\n      }\r\n\r\n      return files;\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private async captureGitState(): Promise<GitState> {\r\n    try {\r\n      const [branch, commit, status, staged, modified, untracked] = await Promise.all([\r\n        execAsync('git rev-parse --abbrev-ref HEAD').then(r => r.stdout.trim()).catch(() => 'unknown'),\r\n        execAsync('git rev-parse HEAD').then(r => r.stdout.trim()).catch(() => 'unknown'),\r\n        execAsync('git status --porcelain').then(r => r.stdout.trim()).catch(() => ''),\r\n        execAsync('git diff --cached --name-only').then(r => r.stdout.trim().split('\\n').filter(Boolean)).catch(() => []),\r\n        execAsync('git diff --name-only').then(r => r.stdout.trim().split('\\n').filter(Boolean)).catch(() => []),\r\n        execAsync('git ls-files --others --exclude-standard').then(r => r.stdout.trim().split('\\n').filter(Boolean)).catch(() => [])\r\n      ]);\r\n\r\n      return {\r\n        branch,\r\n        commit,\r\n        status,\r\n        staged,\r\n        modified,\r\n        untracked\r\n      };\r\n    } catch {\r\n      return {\r\n        branch: 'unknown',\r\n        commit: 'unknown',\r\n        status: '',\r\n        staged: [],\r\n        modified: [],\r\n        untracked: []\r\n      };\r\n    }\r\n  }\r\n\r\n  private async storeSnapshot(snapshot: SystemSnapshot): Promise<void> {\r\n    const filename = `${snapshot.id}.snapshot.json`;\r\n    const filepath = join(this.snapshotDir, filename);\r\n\r\n    const content = JSON.stringify(snapshot, null, 2);\r\n    \r\n    if (this.compressionEnabled) {\r\n      const compressed = await gzipAsync(Buffer.from(content, 'utf-8'));\r\n      await fs.writeFile(filepath + '.gz', compressed);\r\n    } else {\r\n      await fs.writeFile(filepath, content);\r\n    }\r\n  }\r\n\r\n  private async cleanupOldSnapshots(): Promise<void> {\r\n    if (this.snapshots.size <= this.maxSnapshots) return;\r\n\r\n    const sorted = Array.from(this.snapshots.values())\r\n      .sort((a, b) => a.timestamp - b.timestamp);\r\n    \r\n    const toDelete = sorted.slice(0, sorted.length - this.maxSnapshots);\r\n    \r\n    for (const snapshot of toDelete) {\r\n      try {\r\n        const filename = `${snapshot.id}.snapshot.json`;\r\n        const filepath = join(this.snapshotDir, filename);\r\n        \r\n        await fs.unlink(filepath).catch(() => {});\r\n        await fs.unlink(filepath + '.gz').catch(() => {});\r\n        \r\n        this.snapshots.delete(snapshot.id);\r\n      } catch (error) {\r\n        console.warn(`Failed to delete snapshot ${snapshot.id}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private generateSnapshotId(): string {\r\n    return `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  public async getSnapshot(id: string): Promise<SystemSnapshot | null> {\r\n    return this.snapshots.get(id) || null;\r\n  }\r\n\r\n  public listSnapshots(): SystemSnapshot[] {\r\n    return Array.from(this.snapshots.values())\r\n      .sort((a, b) => b.timestamp - a.timestamp);\r\n  }\r\n\r\n  public async deleteSnapshot(id: string): Promise<boolean> {\r\n    try {\r\n      const filename = `${id}.snapshot.json`;\r\n      const filepath = join(this.snapshotDir, filename);\r\n      \r\n      await fs.unlink(filepath).catch(() => {});\r\n      await fs.unlink(filepath + '.gz').catch(() => {});\r\n      \r\n      this.snapshots.delete(id);\r\n      this.emit('snapshot_deleted', id);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// RollbackTrigger - Configurable thresholds and monitoring\r\n// ============================================================================\r\n\r\nexport class RollbackTrigger extends EventEmitter {\r\n  private config: RollbackTriggerConfig;\r\n  private monitoring: boolean = false;\r\n  private metrics: SystemMetrics[] = [];\r\n  private monitoringInterval?: NodeJS.Timeout;\r\n  private lastRollback: number = 0;\r\n\r\n  constructor(config: Partial<RollbackTriggerConfig> = {}) {\r\n    super();\r\n    this.config = this.mergeConfig(config);\r\n  }\r\n\r\n  private mergeConfig(config: Partial<RollbackTriggerConfig>): RollbackTriggerConfig {\r\n    return {\r\n      enabled: config.enabled ?? true,\r\n      thresholds: {\r\n        errorRate: config.thresholds?.errorRate ?? 10,\r\n        memoryUsage: config.thresholds?.memoryUsage ?? 90,\r\n        cpuUsage: config.thresholds?.cpuUsage ?? 95,\r\n        responseTime: config.thresholds?.responseTime ?? 5000,\r\n        diskSpace: config.thresholds?.diskSpace ?? 10,\r\n        consecutiveFailures: config.thresholds?.consecutiveFailures ?? 3\r\n      },\r\n      monitoring: {\r\n        interval: config.monitoring?.interval ?? 30000,\r\n        cooldown: config.monitoring?.cooldown ?? 300000,\r\n        gracePeriod: config.monitoring?.gracePeriod ?? 60000\r\n      },\r\n      notifications: {\r\n        webhook: config.notifications?.webhook,\r\n        email: config.notifications?.email,\r\n        slack: config.notifications?.slack\r\n      }\r\n    };\r\n  }\r\n\r\n  public startMonitoring(): void {\r\n    if (this.monitoring) return;\r\n    \r\n    this.monitoring = true;\r\n    this.monitoringInterval = setInterval(\r\n      () => this.checkThresholds(),\r\n      this.config.monitoring.interval\r\n    );\r\n    \r\n    this.emit('monitoring_started');\r\n  }\r\n\r\n  public stopMonitoring(): void {\r\n    if (!this.monitoring) return;\r\n    \r\n    this.monitoring = false;\r\n    if (this.monitoringInterval) {\r\n      clearInterval(this.monitoringInterval);\r\n      this.monitoringInterval = undefined;\r\n    }\r\n    \r\n    this.emit('monitoring_stopped');\r\n  }\r\n\r\n  private async checkThresholds(): Promise<void> {\r\n    if (!this.config.enabled) return;\r\n    \r\n    // Check cooldown period\r\n    if (Date.now() - this.lastRollback < this.config.monitoring.cooldown) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const metrics = await this.collectMetrics();\r\n      this.metrics.push(metrics);\r\n      \r\n      // Keep only recent metrics (last hour)\r\n      const oneHourAgo = Date.now() - 3600000;\r\n      this.metrics = this.metrics.filter(m => m.timestamp > oneHourAgo);\r\n      \r\n      const violations = this.evaluateThresholds(metrics);\r\n      \r\n      if (violations.length > 0) {\r\n        this.emit('threshold_violated', { metrics, violations });\r\n        \r\n        // Check grace period\r\n        const recentViolations = this.metrics\r\n          .filter(m => m.timestamp > Date.now() - this.config.monitoring.gracePeriod)\r\n          .filter(m => this.evaluateThresholds(m).length > 0);\r\n        \r\n        if (recentViolations.length >= 2) {\r\n          this.triggerRollback(metrics, violations);\r\n        }\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.emit('monitoring_error', error);\r\n    }\r\n  }\r\n\r\n  private async collectMetrics(): Promise<SystemMetrics> {\r\n    const timestamp = Date.now();\r\n    \r\n    try {\r\n      const [memInfo, cpuInfo, diskInfo] = await Promise.all([\r\n        this.getMemoryInfo(),\r\n        this.getCpuInfo(),\r\n        this.getDiskInfo()\r\n      ]);\r\n\r\n      return {\r\n        timestamp,\r\n        errors: {\r\n          count: 0, // Would be tracked by error handler\r\n          rate: 0,\r\n          recent: []\r\n        },\r\n        performance: {\r\n          memory: memInfo,\r\n          cpu: cpuInfo,\r\n          disk: diskInfo,\r\n          network: { in: 0, out: 0 }\r\n        },\r\n        health: {\r\n          status: 'healthy',\r\n          score: 100,\r\n          checks: []\r\n        }\r\n      };\r\n      \r\n    } catch (error) {\r\n      return {\r\n        timestamp,\r\n        errors: { count: 1, rate: 1, recent: [error as Error] },\r\n        performance: {\r\n          memory: { used: 0, total: 0, percentage: 0 },\r\n          cpu: { usage: 0, load: [0, 0, 0] },\r\n          disk: { used: 0, total: 0, free: 0 },\r\n          network: { in: 0, out: 0 }\r\n        },\r\n        health: {\r\n          status: 'critical',\r\n          score: 0,\r\n          checks: [{ name: 'metrics_collection', status: 'fail', message: error?.toString() || 'Unknown error', duration: 0 }]\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  private async getMemoryInfo() {\r\n    try {\r\n      const meminfo = await fs.readFile('/proc/meminfo', 'utf-8');\r\n      const lines = meminfo.split('\\n');\r\n      \r\n      const memTotal = parseInt(lines.find(l => l.startsWith('MemTotal:'))?.split(/\\s+/)[1] || '0') * 1024;\r\n      const memAvailable = parseInt(lines.find(l => l.startsWith('MemAvailable:'))?.split(/\\s+/)[1] || '0') * 1024;\r\n      const memUsed = memTotal - memAvailable;\r\n      \r\n      return {\r\n        used: memUsed,\r\n        total: memTotal,\r\n        percentage: memTotal > 0 ? (memUsed / memTotal) * 100 : 0\r\n      };\r\n    } catch {\r\n      return { used: 0, total: 0, percentage: 0 };\r\n    }\r\n  }\r\n\r\n  private async getCpuInfo() {\r\n    try {\r\n      const loadavg = await fs.readFile('/proc/loadavg', 'utf-8');\r\n      const loads = loadavg.trim().split(' ').slice(0, 3).map(parseFloat);\r\n      \r\n      return {\r\n        usage: loads[0] * 100, // Approximate CPU usage from 1-min load\r\n        load: loads\r\n      };\r\n    } catch {\r\n      return { usage: 0, load: [0, 0, 0] };\r\n    }\r\n  }\r\n\r\n  private async getDiskInfo() {\r\n    try {\r\n      const { stdout } = await execAsync('df -h . | tail -1');\r\n      const parts = stdout.trim().split(/\\s+/);\r\n      \r\n      const total = this.parseSize(parts[1]);\r\n      const used = this.parseSize(parts[2]);\r\n      const free = this.parseSize(parts[3]);\r\n      \r\n      return { used, total, free };\r\n    } catch {\r\n      return { used: 0, total: 0, free: 0 };\r\n    }\r\n  }\r\n\r\n  private parseSize(sizeStr: string): number {\r\n    const match = sizeStr.match(/^(\\d+(?:\\.\\d+)?)(K|M|G|T)?$/);\r\n    if (!match) return 0;\r\n    \r\n    const value = parseFloat(match[1]);\r\n    const unit = match[2] || '';\r\n    \r\n    const multipliers: Record<string, number> = {\r\n      '': 1,\r\n      'K': 1024,\r\n      'M': 1024 * 1024,\r\n      'G': 1024 * 1024 * 1024,\r\n      'T': 1024 * 1024 * 1024 * 1024\r\n    };\r\n    \r\n    return value * (multipliers[unit] || 1);\r\n  }\r\n\r\n  private evaluateThresholds(metrics: SystemMetrics): string[] {\r\n    const violations: string[] = [];\r\n    \r\n    if (metrics.performance.memory.percentage > this.config.thresholds.memoryUsage) {\r\n      violations.push(`Memory usage: ${metrics.performance.memory.percentage.toFixed(1)}% > ${this.config.thresholds.memoryUsage}%`);\r\n    }\r\n    \r\n    if (metrics.performance.cpu.usage > this.config.thresholds.cpuUsage) {\r\n      violations.push(`CPU usage: ${metrics.performance.cpu.usage.toFixed(1)}% > ${this.config.thresholds.cpuUsage}%`);\r\n    }\r\n    \r\n    const diskFreePercentage = (metrics.performance.disk.free / metrics.performance.disk.total) * 100;\r\n    if (diskFreePercentage < this.config.thresholds.diskSpace) {\r\n      violations.push(`Disk space: ${diskFreePercentage.toFixed(1)}% free < ${this.config.thresholds.diskSpace}%`);\r\n    }\r\n    \r\n    if (metrics.errors.rate > this.config.thresholds.errorRate) {\r\n      violations.push(`Error rate: ${metrics.errors.rate}/min > ${this.config.thresholds.errorRate}/min`);\r\n    }\r\n    \r\n    return violations;\r\n  }\r\n\r\n  private async triggerRollback(metrics: SystemMetrics, violations: string[]): Promise<void> {\r\n    this.lastRollback = Date.now();\r\n    \r\n    this.emit('rollback_triggered', {\r\n      reason: 'threshold_violations',\r\n      violations,\r\n      metrics\r\n    });\r\n    \r\n    // Send notifications\r\n    await this.sendNotifications(violations, metrics);\r\n  }\r\n\r\n  private async sendNotifications(violations: string[], metrics: SystemMetrics): Promise<void> {\r\n    const message = `ðŸš¨ Rollback triggered due to threshold violations:\\n${violations.join('\\n')}`;\r\n    \r\n    try {\r\n      if (this.config.notifications.webhook) {\r\n        // Send webhook notification\r\n        // Implementation would depend on the webhook service\r\n      }\r\n      \r\n      if (this.config.notifications.slack) {\r\n        // Send Slack notification\r\n        // Implementation would depend on Slack integration\r\n      }\r\n      \r\n      if (this.config.notifications.email) {\r\n        // Send email notification\r\n        // Implementation would depend on email service\r\n      }\r\n    } catch (error) {\r\n      this.emit('notification_error', error);\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: Partial<RollbackTriggerConfig>): void {\r\n    this.config = this.mergeConfig(config);\r\n    this.emit('config_updated', this.config);\r\n  }\r\n\r\n  public getCurrentMetrics(): SystemMetrics | null {\r\n    return this.metrics[this.metrics.length - 1] || null;\r\n  }\r\n\r\n  public getMetricsHistory(): SystemMetrics[] {\r\n    return [...this.metrics];\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// AutomatedRecovery - Multi-tier recovery strategies\r\n// ============================================================================\r\n\r\nexport class AutomatedRecovery extends EventEmitter {\r\n  private strategies: Map<string, RecoveryStrategy> = new Map();\r\n  private recoveryHistory: RecoveryAttempt[] = [];\r\n  private stateManager: StateManager;\r\n  private isRecovering: boolean = false;\r\n\r\n  constructor(stateManager: StateManager) {\r\n    super();\r\n    this.stateManager = stateManager;\r\n    this.initializeDefaultStrategies();\r\n  }\r\n\r\n  private initializeDefaultStrategies(): void {\r\n    // Strategy 1: Service Restart\r\n    this.registerStrategy({\r\n      name: 'service_restart',\r\n      priority: 1,\r\n      enabled: true,\r\n      timeout: 30000,\r\n      retries: 2,\r\n      conditions: (metrics) => metrics.health.status === 'degraded',\r\n      execute: async (snapshot, context) => {\r\n        try {\r\n          this.emit('recovery_step', { strategy: 'service_restart', action: 'restarting_services' });\r\n          \r\n          // Restart critical services\r\n          await execAsync('pkill -f \"claude-flow\" && sleep 2');\r\n          \r\n          // Wait for services to restart\r\n          await new Promise(resolve => setTimeout(resolve, 5000));\r\n          \r\n          return true;\r\n        } catch (error) {\r\n          this.emit('recovery_error', { strategy: 'service_restart', error });\r\n          return false;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Strategy 2: Memory Cleanup\r\n    this.registerStrategy({\r\n      name: 'memory_cleanup',\r\n      priority: 2,\r\n      enabled: true,\r\n      timeout: 15000,\r\n      retries: 1,\r\n      conditions: (metrics) => metrics.performance.memory.percentage > 85,\r\n      execute: async (snapshot, context) => {\r\n        try {\r\n          this.emit('recovery_step', { strategy: 'memory_cleanup', action: 'clearing_memory' });\r\n          \r\n          // Force garbage collection\r\n          if (global.gc) {\r\n            global.gc();\r\n          }\r\n          \r\n          // Clear caches\r\n          await this.clearApplicationCaches();\r\n          \r\n          return true;\r\n        } catch (error) {\r\n          this.emit('recovery_error', { strategy: 'memory_cleanup', error });\r\n          return false;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Strategy 3: Configuration Reset\r\n    this.registerStrategy({\r\n      name: 'config_reset',\r\n      priority: 3,\r\n      enabled: true,\r\n      timeout: 20000,\r\n      retries: 1,\r\n      conditions: (metrics) => metrics.health.status === 'critical',\r\n      execute: async (snapshot, context) => {\r\n        try {\r\n          this.emit('recovery_step', { strategy: 'config_reset', action: 'resetting_config' });\r\n          \r\n          // Restore configuration from snapshot\r\n          await this.restoreConfiguration(snapshot);\r\n          \r\n          return true;\r\n        } catch (error) {\r\n          this.emit('recovery_error', { strategy: 'config_reset', error });\r\n          return false;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Strategy 4: Full State Rollback\r\n    this.registerStrategy({\r\n      name: 'full_rollback',\r\n      priority: 10,\r\n      enabled: true,\r\n      timeout: 60000,\r\n      retries: 1,\r\n      conditions: () => true, // Last resort\r\n      execute: async (snapshot, context) => {\r\n        try {\r\n          this.emit('recovery_step', { strategy: 'full_rollback', action: 'rolling_back_state' });\r\n          \r\n          // Full system rollback\r\n          await this.performFullRollback(snapshot);\r\n          \r\n          return true;\r\n        } catch (error) {\r\n          this.emit('recovery_error', { strategy: 'full_rollback', error });\r\n          return false;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public registerStrategy(strategy: RecoveryStrategy): void {\r\n    this.strategies.set(strategy.name, strategy);\r\n    this.emit('strategy_registered', strategy.name);\r\n  }\r\n\r\n  public async executeRecovery(\r\n    metrics: SystemMetrics,\r\n    triggerReason: string,\r\n    preferredSnapshot?: string\r\n  ): Promise<boolean> {\r\n    if (this.isRecovering) {\r\n      this.emit('recovery_blocked', 'Recovery already in progress');\r\n      return false;\r\n    }\r\n\r\n    this.isRecovering = true;\r\n    \r\n    try {\r\n      this.emit('recovery_started', { reason: triggerReason, metrics });\r\n      \r\n      // Get appropriate snapshot\r\n      const snapshots = this.stateManager.listSnapshots();\r\n      const snapshot = preferredSnapshot \r\n        ? await this.stateManager.getSnapshot(preferredSnapshot)\r\n        : snapshots[0]; // Most recent snapshot\r\n      \r\n      if (!snapshot) {\r\n        throw new Error('No snapshot available for recovery');\r\n      }\r\n\r\n      // Get applicable strategies\r\n      const applicableStrategies = Array.from(this.strategies.values())\r\n        .filter(s => s.enabled && s.conditions(metrics))\r\n        .sort((a, b) => a.priority - b.priority);\r\n\r\n      if (applicableStrategies.length === 0) {\r\n        throw new Error('No applicable recovery strategies found');\r\n      }\r\n\r\n      const context: RecoveryContext = {\r\n        triggeredBy: triggerReason,\r\n        reason: triggerReason,\r\n        metrics,\r\n        previousAttempts: this.recoveryHistory.slice(-10) // Last 10 attempts\r\n      };\r\n\r\n      // Execute strategies in priority order\r\n      for (const strategy of applicableStrategies) {\r\n        const success = await this.executeStrategy(strategy, snapshot, context);\r\n        \r\n        if (success) {\r\n          this.emit('recovery_success', { \r\n            strategy: strategy.name, \r\n            snapshot: snapshot.id,\r\n            duration: Date.now() - metrics.timestamp \r\n          });\r\n          return true;\r\n        }\r\n      }\r\n\r\n      throw new Error('All recovery strategies failed');\r\n      \r\n    } catch (error) {\r\n      this.emit('recovery_failed', { error: error?.toString(), metrics });\r\n      return false;\r\n    } finally {\r\n      this.isRecovering = false;\r\n    }\r\n  }\r\n\r\n  private async executeStrategy(\r\n    strategy: RecoveryStrategy,\r\n    snapshot: SystemSnapshot,\r\n    context: RecoveryContext\r\n  ): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt <= strategy.retries; attempt++) {\r\n      try {\r\n        this.emit('strategy_attempt', { \r\n          strategy: strategy.name, \r\n          attempt: attempt + 1,\r\n          maxAttempts: strategy.retries + 1\r\n        });\r\n        \r\n        // Execute with timeout\r\n        const success = await Promise.race([\r\n          strategy.execute(snapshot, context),\r\n          new Promise<boolean>((_, reject) => \r\n            setTimeout(() => reject(new Error('Strategy timeout')), strategy.timeout)\r\n          )\r\n        ]);\r\n\r\n        const duration = Date.now() - startTime;\r\n        \r\n        const recoveryAttempt: RecoveryAttempt = {\r\n          strategy: strategy.name,\r\n          timestamp: Date.now(),\r\n          success,\r\n          duration\r\n        };\r\n        \r\n        this.recoveryHistory.push(recoveryAttempt);\r\n        \r\n        if (success) {\r\n          this.emit('strategy_success', { strategy: strategy.name, attempt, duration });\r\n          return true;\r\n        }\r\n        \r\n      } catch (error) {\r\n        const duration = Date.now() - startTime;\r\n        \r\n        const recoveryAttempt: RecoveryAttempt = {\r\n          strategy: strategy.name,\r\n          timestamp: Date.now(),\r\n          success: false,\r\n          error: error?.toString(),\r\n          duration\r\n        };\r\n        \r\n        this.recoveryHistory.push(recoveryAttempt);\r\n        \r\n        this.emit('strategy_failed', { \r\n          strategy: strategy.name, \r\n          attempt, \r\n          error: error?.toString(),\r\n          duration \r\n        });\r\n        \r\n        if (attempt === strategy.retries) {\r\n          return false; // All retries exhausted\r\n        }\r\n        \r\n        // Wait before retry\r\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  private async clearApplicationCaches(): Promise<void> {\r\n    try {\r\n      // Clear memory caches\r\n      const memoryPaths = [\r\n        './memory/cache',\r\n        './swarm-memory/cache',\r\n        './temp'\r\n      ];\r\n      \r\n      for (const path of memoryPaths) {\r\n        try {\r\n          await fs.rm(path, { recursive: true, force: true });\r\n          await fs.mkdir(path, { recursive: true });\r\n        } catch {\r\n          // Path might not exist\r\n        }\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Failed to clear caches: ${error}`);\r\n    }\r\n  }\r\n\r\n  private async restoreConfiguration(snapshot: SystemSnapshot): Promise<void> {\r\n    try {\r\n      // Restore configuration files from snapshot\r\n      for (const [path, content] of Object.entries(snapshot.state.config)) {\r\n        try {\r\n          await fs.writeFile(path, JSON.stringify(content, null, 2));\r\n        } catch (error) {\r\n          console.warn(`Failed to restore config file ${path}:`, error);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Failed to restore configuration: ${error}`);\r\n    }\r\n  }\r\n\r\n  private async performFullRollback(snapshot: SystemSnapshot): Promise<void> {\r\n    try {\r\n      // 1. Stop services\r\n      await execAsync('pkill -f \"claude-flow\"').catch(() => {});\r\n      \r\n      // 2. Restore files\r\n      for (const file of snapshot.state.files) {\r\n        try {\r\n          await fs.writeFile(file.path, file.content);\r\n          await fs.chmod(file.path, file.stats.mode);\r\n        } catch (error) {\r\n          console.warn(`Failed to restore file ${file.path}:`, error);\r\n        }\r\n      }\r\n      \r\n      // 3. Restore memory\r\n      for (const [path, content] of Object.entries(snapshot.state.memory)) {\r\n        try {\r\n          await fs.writeFile(path, JSON.stringify(content, null, 2));\r\n        } catch (error) {\r\n          console.warn(`Failed to restore memory file ${path}:`, error);\r\n        }\r\n      }\r\n      \r\n      // 4. Git rollback if needed\r\n      if (snapshot.state.git.commit !== 'unknown') {\r\n        try {\r\n          await execAsync(`git reset --hard ${snapshot.state.git.commit}`);\r\n        } catch (error) {\r\n          console.warn('Failed to perform git rollback:', error);\r\n        }\r\n      }\r\n      \r\n      // 5. Restart services\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n      \r\n    } catch (error) {\r\n      throw new Error(`Failed to perform full rollback: ${error}`);\r\n    }\r\n  }\r\n\r\n  public getStrategyNames(): string[] {\r\n    return Array.from(this.strategies.keys());\r\n  }\r\n\r\n  public getStrategy(name: string): RecoveryStrategy | undefined {\r\n    return this.strategies.get(name);\r\n  }\r\n\r\n  public enableStrategy(name: string): boolean {\r\n    const strategy = this.strategies.get(name);\r\n    if (strategy) {\r\n      strategy.enabled = true;\r\n      this.emit('strategy_enabled', name);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public disableStrategy(name: string): boolean {\r\n    const strategy = this.strategies.get(name);\r\n    if (strategy) {\r\n      strategy.enabled = false;\r\n      this.emit('strategy_disabled', name);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public getRecoveryHistory(): RecoveryAttempt[] {\r\n    return [...this.recoveryHistory];\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// RollbackHistory - Compressed history tracking with TTL\r\n// ============================================================================\r\n\r\nexport class RollbackHistory extends EventEmitter {\r\n  private history: Map<string, RollbackHistoryEntry> = new Map();\r\n  private historyDir: string;\r\n  private maxHistorySize: number;\r\n  private compressionEnabled: boolean;\r\n  private ttlMs: number;\r\n  private cleanupInterval?: NodeJS.Timeout;\r\n\r\n  constructor(\r\n    historyDir: string = './rollback-history',\r\n    maxHistorySize: number = 1000,\r\n    ttlDays: number = 30,\r\n    compressionEnabled: boolean = true\r\n  ) {\r\n    super();\r\n    this.historyDir = historyDir;\r\n    this.maxHistorySize = maxHistorySize;\r\n    this.ttlMs = ttlDays * 24 * 60 * 60 * 1000; // Convert days to ms\r\n    this.compressionEnabled = compressionEnabled;\r\n    \r\n    this.initializeStorage();\r\n    this.startCleanupInterval();\r\n  }\r\n\r\n  private async initializeStorage(): Promise<void> {\r\n    try {\r\n      await fs.mkdir(this.historyDir, { recursive: true });\r\n      await this.loadExistingHistory();\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to initialize history storage: ${error}`));\r\n    }\r\n  }\r\n\r\n  private async loadExistingHistory(): Promise<void> {\r\n    try {\r\n      const files = await fs.readdir(this.historyDir);\r\n      const historyFiles = files.filter(f => f.endsWith('.history.json') || f.endsWith('.history.json.gz'));\r\n      \r\n      for (const file of historyFiles) {\r\n        try {\r\n          const filepath = join(this.historyDir, file);\r\n          let content: string;\r\n          \r\n          if (file.endsWith('.gz')) {\r\n            const compressed = await fs.readFile(filepath);\r\n            const decompressed = await gunzipAsync(compressed);\r\n            content = decompressed.toString('utf-8');\r\n          } else {\r\n            content = await fs.readFile(filepath, 'utf-8');\r\n          }\r\n          \r\n          const entry: RollbackHistoryEntry = JSON.parse(content);\r\n          this.history.set(entry.id, entry);\r\n        } catch (error) {\r\n          console.warn(`Failed to load history entry ${file}:`, error);\r\n        }\r\n      }\r\n      \r\n      this.emit('history_loaded', this.history.size);\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to load history: ${error}`));\r\n    }\r\n  }\r\n\r\n  private startCleanupInterval(): void {\r\n    // Run cleanup every 6 hours\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanupExpiredEntries();\r\n    }, 6 * 60 * 60 * 1000);\r\n  }\r\n\r\n  public async addEntry(\r\n    snapshot: SystemSnapshot,\r\n    triggerType: 'manual' | 'automatic',\r\n    triggerReason: string,\r\n    triggerMetrics: SystemMetrics | undefined,\r\n    recoveryStrategy: string,\r\n    recoverySuccess: boolean,\r\n    recoveryDuration: number,\r\n    recoveryAttempts: RecoveryAttempt[],\r\n    verificationChecks: HealthCheck[],\r\n    verificationPassed: boolean,\r\n    rollbackRequired: boolean\r\n  ): Promise<string> {\r\n    const id = this.generateHistoryId();\r\n    \r\n    const entry: RollbackHistoryEntry = {\r\n      id,\r\n      timestamp: Date.now(),\r\n      snapshot,\r\n      trigger: {\r\n        type: triggerType,\r\n        reason: triggerReason,\r\n        metrics: triggerMetrics\r\n      },\r\n      recovery: {\r\n        strategy: recoveryStrategy,\r\n        success: recoverySuccess,\r\n        duration: recoveryDuration,\r\n        attempts: recoveryAttempts\r\n      },\r\n      verification: {\r\n        passed: verificationPassed,\r\n        checks: verificationChecks,\r\n        rollbackRequired\r\n      }\r\n    };\r\n\r\n    try {\r\n      await this.storeHistoryEntry(entry);\r\n      this.history.set(id, entry);\r\n      \r\n      // Cleanup if we exceed max size\r\n      await this.cleanupOldEntries();\r\n      \r\n      this.emit('entry_added', entry);\r\n      return id;\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to add history entry: ${error}`));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async storeHistoryEntry(entry: RollbackHistoryEntry): Promise<void> {\r\n    const filename = `${entry.id}.history.json`;\r\n    const filepath = join(this.historyDir, filename);\r\n\r\n    const content = JSON.stringify(entry, null, 2);\r\n    \r\n    if (this.compressionEnabled) {\r\n      const compressed = await gzipAsync(Buffer.from(content, 'utf-8'));\r\n      await fs.writeFile(filepath + '.gz', compressed);\r\n    } else {\r\n      await fs.writeFile(filepath, content);\r\n    }\r\n  }\r\n\r\n  private async cleanupExpiredEntries(): Promise<void> {\r\n    const now = Date.now();\r\n    const expiredEntries: string[] = [];\r\n    \r\n    for (const [id, entry] of this.history.entries()) {\r\n      if (now - entry.timestamp > this.ttlMs) {\r\n        expiredEntries.push(id);\r\n      }\r\n    }\r\n    \r\n    for (const id of expiredEntries) {\r\n      await this.deleteEntry(id);\r\n    }\r\n    \r\n    if (expiredEntries.length > 0) {\r\n      this.emit('entries_expired', expiredEntries.length);\r\n    }\r\n  }\r\n\r\n  private async cleanupOldEntries(): Promise<void> {\r\n    if (this.history.size <= this.maxHistorySize) return;\r\n\r\n    const sorted = Array.from(this.history.values())\r\n      .sort((a, b) => a.timestamp - b.timestamp);\r\n    \r\n    const toDelete = sorted.slice(0, sorted.length - this.maxHistorySize);\r\n    \r\n    for (const entry of toDelete) {\r\n      await this.deleteEntry(entry.id);\r\n    }\r\n  }\r\n\r\n  private async deleteEntry(id: string): Promise<void> {\r\n    try {\r\n      const filename = `${id}.history.json`;\r\n      const filepath = join(this.historyDir, filename);\r\n      \r\n      await fs.unlink(filepath).catch(() => {});\r\n      await fs.unlink(filepath + '.gz').catch(() => {});\r\n      \r\n      this.history.delete(id);\r\n    } catch (error) {\r\n      console.warn(`Failed to delete history entry ${id}:`, error);\r\n    }\r\n  }\r\n\r\n  private generateHistoryId(): string {\r\n    return `history_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  public getEntry(id: string): RollbackHistoryEntry | null {\r\n    return this.history.get(id) || null;\r\n  }\r\n\r\n  public getRecentEntries(limit: number = 50): RollbackHistoryEntry[] {\r\n    return Array.from(this.history.values())\r\n      .sort((a, b) => b.timestamp - a.timestamp)\r\n      .slice(0, limit);\r\n  }\r\n\r\n  public getEntriesByDateRange(startDate: Date, endDate: Date): RollbackHistoryEntry[] {\r\n    const startTime = startDate.getTime();\r\n    const endTime = endDate.getTime();\r\n    \r\n    return Array.from(this.history.values())\r\n      .filter(entry => entry.timestamp >= startTime && entry.timestamp <= endTime)\r\n      .sort((a, b) => b.timestamp - a.timestamp);\r\n  }\r\n\r\n  public getSuccessRate(timeframe: number = 24 * 60 * 60 * 1000): number {\r\n    const cutoff = Date.now() - timeframe;\r\n    const recentEntries = Array.from(this.history.values())\r\n      .filter(entry => entry.timestamp > cutoff);\r\n    \r\n    if (recentEntries.length === 0) return 100;\r\n    \r\n    const successCount = recentEntries.filter(entry => entry.recovery.success).length;\r\n    return (successCount / recentEntries.length) * 100;\r\n  }\r\n\r\n  public getStatistics(): {\r\n    totalEntries: number;\r\n    successRate: number;\r\n    averageRecoveryTime: number;\r\n    mostCommonFailureReason: string;\r\n    rollbacksByTrigger: Record<string, number>;\r\n  } {\r\n    const entries = Array.from(this.history.values());\r\n    \r\n    if (entries.length === 0) {\r\n      return {\r\n        totalEntries: 0,\r\n        successRate: 100,\r\n        averageRecoveryTime: 0,\r\n        mostCommonFailureReason: 'none',\r\n        rollbacksByTrigger: {}\r\n      };\r\n    }\r\n    \r\n    const successCount = entries.filter(e => e.recovery.success).length;\r\n    const successRate = (successCount / entries.length) * 100;\r\n    \r\n    const totalRecoveryTime = entries.reduce((sum, e) => sum + e.recovery.duration, 0);\r\n    const averageRecoveryTime = totalRecoveryTime / entries.length;\r\n    \r\n    const failureReasons = entries\r\n      .filter(e => !e.recovery.success)\r\n      .map(e => e.trigger.reason);\r\n    \r\n    const reasonCounts = failureReasons.reduce((acc, reason) => {\r\n      acc[reason] = (acc[reason] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n    \r\n    const mostCommonFailureReason = Object.entries(reasonCounts)\r\n      .sort(([,a], [,b]) => b - a)[0]?.[0] || 'none';\r\n    \r\n    const rollbacksByTrigger = entries.reduce((acc, entry) => {\r\n      acc[entry.trigger.type] = (acc[entry.trigger.type] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n    \r\n    return {\r\n      totalEntries: entries.length,\r\n      successRate,\r\n      averageRecoveryTime,\r\n      mostCommonFailureReason,\r\n      rollbacksByTrigger\r\n    };\r\n  }\r\n\r\n  public destroy(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = undefined;\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// GitRollbackManager - Git integration for code rollbacks\r\n// ============================================================================\r\n\r\nexport class GitRollbackManager extends EventEmitter {\r\n  private gitDir: string;\r\n  private backupBranch: string;\r\n  private safetyChecks: boolean;\r\n\r\n  constructor(\r\n    gitDir: string = './',\r\n    backupBranch: string = 'rollback-backup',\r\n    safetyChecks: boolean = true\r\n  ) {\r\n    super();\r\n    this.gitDir = gitDir;\r\n    this.backupBranch = backupBranch;\r\n    this.safetyChecks = safetyChecks;\r\n  }\r\n\r\n  /**\r\n   * Creates an atomic git commit with rollback marker\r\n   */\r\n  public async createRollbackPoint(\r\n    message: string = 'Automated rollback point',\r\n    tags: string[] = []\r\n  ): Promise<string> {\r\n    try {\r\n      // Ensure we're in a git repository\r\n      await this.ensureGitRepo();\r\n      \r\n      if (this.safetyChecks) {\r\n        await this.performSafetyChecks();\r\n      }\r\n      \r\n      // Create backup branch\r\n      await this.createBackupBranch();\r\n      \r\n      // Stage all changes\r\n      await execAsync('git add -A', { cwd: this.gitDir });\r\n      \r\n      // Create commit with rollback metadata\r\n      const rollbackMessage = this.formatRollbackMessage(message, tags);\r\n      await execAsync(`git commit -m \"${rollbackMessage}\"`, { cwd: this.gitDir });\r\n      \r\n      // Get commit hash\r\n      const { stdout: commitHash } = await execAsync('git rev-parse HEAD', { cwd: this.gitDir });\r\n      const hash = commitHash.trim();\r\n      \r\n      // Create tag for easy reference\r\n      const tagName = `rollback-${Date.now()}`;\r\n      await execAsync(`git tag -a \"${tagName}\" -m \"Rollback point: ${message}\"`, { cwd: this.gitDir });\r\n      \r\n      this.emit('rollback_point_created', { hash, tag: tagName, message });\r\n      return hash;\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to create rollback point: ${error}`));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Performs atomic rollback to a specific commit\r\n   */\r\n  public async rollbackToCommit(\r\n    commitHash: string,\r\n    strategy: 'hard' | 'soft' | 'mixed' = 'mixed',\r\n    preserveUntracked: boolean = true\r\n  ): Promise<boolean> {\r\n    try {\r\n      if (this.safetyChecks) {\r\n        await this.performSafetyChecks();\r\n        await this.validateCommit(commitHash);\r\n      }\r\n      \r\n      // Stash any current changes if preserving untracked files\r\n      let stashRef: string | null = null;\r\n      if (preserveUntracked) {\r\n        try {\r\n          await execAsync('git stash push -u -m \"Pre-rollback stash\"', { cwd: this.gitDir });\r\n          stashRef = await this.getLastStashRef();\r\n        } catch {\r\n          // No changes to stash\r\n        }\r\n      }\r\n      \r\n      // Perform the rollback\r\n      await execAsync(`git reset --${strategy} ${commitHash}`, { cwd: this.gitDir });\r\n      \r\n      // If hard reset and preserving untracked, restore stashed files\r\n      if (strategy === 'hard' && stashRef && preserveUntracked) {\r\n        try {\r\n          // Only restore untracked files from stash\r\n          await execAsync(`git stash show -p ${stashRef} | git apply --index`, { cwd: this.gitDir });\r\n          await execAsync(`git stash drop ${stashRef}`, { cwd: this.gitDir });\r\n        } catch {\r\n          // Stash restoration failed, but rollback succeeded\r\n          this.emit('warning', 'Rollback completed but failed to restore untracked files');\r\n        }\r\n      }\r\n      \r\n      // Verify rollback success\r\n      const { stdout: currentHash } = await execAsync('git rev-parse HEAD', { cwd: this.gitDir });\r\n      const success = currentHash.trim() === commitHash;\r\n      \r\n      if (success) {\r\n        this.emit('rollback_completed', { commitHash, strategy });\r\n      } else {\r\n        throw new Error('Rollback verification failed');\r\n      }\r\n      \r\n      return success;\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Rollback failed: ${error}`));\r\n      \r\n      // Attempt emergency recovery\r\n      try {\r\n        await this.emergencyRecovery();\r\n      } catch (recoveryError) {\r\n        this.emit('error', new Error(`Emergency recovery failed: ${recoveryError}`));\r\n      }\r\n      \r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rolls back specific files to their state at a given commit\r\n   */\r\n  public async rollbackFiles(\r\n    files: string[],\r\n    commitHash: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      if (this.safetyChecks) {\r\n        await this.validateCommit(commitHash);\r\n        await this.validateFiles(files);\r\n      }\r\n      \r\n      // Backup current state of files\r\n      const backupStash = await this.createFileBackup(files);\r\n      \r\n      try {\r\n        // Rollback each file\r\n        for (const file of files) {\r\n          await execAsync(`git checkout ${commitHash} -- \"${file}\"`, { cwd: this.gitDir });\r\n        }\r\n        \r\n        this.emit('files_rolled_back', { files, commitHash });\r\n        return true;\r\n        \r\n      } catch (error) {\r\n        // Restore from backup on failure\r\n        if (backupStash) {\r\n          await this.restoreFileBackup(backupStash, files);\r\n        }\r\n        throw error;\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`File rollback failed: ${error}`));\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a branch from current state for safe rollback testing\r\n   */\r\n  public async createTestBranch(name?: string): Promise<string> {\r\n    try {\r\n      const branchName = name || `rollback-test-${Date.now()}`;\r\n      \r\n      await execAsync(`git checkout -b \"${branchName}\"`, { cwd: this.gitDir });\r\n      \r\n      this.emit('test_branch_created', branchName);\r\n      return branchName;\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to create test branch: ${error}`));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Lists available rollback points (commits with rollback markers)\r\n   */\r\n  public async listRollbackPoints(): Promise<Array<{\r\n    hash: string;\r\n    date: Date;\r\n    message: string;\r\n    tags: string[];\r\n  }>> {\r\n    try {\r\n      // Get commits with rollback markers\r\n      const { stdout } = await execAsync(\r\n        'git log --grep=\"\\\\[ROLLBACK\\\\]\" --oneline --format=\"%H|%ai|%s\" -n 50',\r\n        { cwd: this.gitDir }\r\n      );\r\n      \r\n      const commits = stdout.trim().split('\\n').filter(Boolean).map(line => {\r\n        const [hash, dateStr, message] = line.split('|');\r\n        return {\r\n          hash,\r\n          date: new Date(dateStr),\r\n          message: message.replace(/\\[ROLLBACK\\]/, '').trim(),\r\n          tags: this.extractTagsFromMessage(message)\r\n        };\r\n      });\r\n      \r\n      // Also get tagged rollback points\r\n      const { stdout: tagOutput } = await execAsync(\r\n        'git tag -l \"rollback-*\" --format=\"%(refname:short)|%(creatordate)|%(subject)\"',\r\n        { cwd: this.gitDir }\r\n      ).catch(() => ({ stdout: '' }));\r\n      \r\n      const taggedCommits = tagOutput.trim().split('\\n').filter(Boolean).map(line => {\r\n        const [tag, dateStr, message] = line.split('|');\r\n        return {\r\n          hash: tag,\r\n          date: new Date(dateStr),\r\n          message: message || 'Tagged rollback point',\r\n          tags: [tag]\r\n        };\r\n      });\r\n      \r\n      return [...commits, ...taggedCommits].sort((a, b) => b.date.getTime() - a.date.getTime());\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to list rollback points: ${error}`));\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private async ensureGitRepo(): Promise<void> {\r\n    try {\r\n      await execAsync('git rev-parse --git-dir', { cwd: this.gitDir });\r\n    } catch {\r\n      throw new Error('Not a git repository');\r\n    }\r\n  }\r\n\r\n  private async performSafetyChecks(): Promise<void> {\r\n    // Check for uncommitted changes\r\n    const { stdout: status } = await execAsync('git status --porcelain', { cwd: this.gitDir });\r\n    if (status.trim()) {\r\n      this.emit('warning', 'Uncommitted changes detected');\r\n    }\r\n    \r\n    // Check if we're on a protected branch\r\n    const { stdout: branch } = await execAsync('git rev-parse --abbrev-ref HEAD', { cwd: this.gitDir });\r\n    const currentBranch = branch.trim();\r\n    \r\n    const protectedBranches = ['main', 'master', 'production', 'release'];\r\n    if (protectedBranches.includes(currentBranch)) {\r\n      this.emit('warning', `Operating on protected branch: ${currentBranch}`);\r\n    }\r\n  }\r\n\r\n  private async createBackupBranch(): Promise<void> {\r\n    try {\r\n      // Delete existing backup branch if it exists\r\n      await execAsync(`git branch -D \"${this.backupBranch}\"`, { cwd: this.gitDir }).catch(() => {});\r\n      \r\n      // Create new backup branch\r\n      await execAsync(`git checkout -b \"${this.backupBranch}\"`, { cwd: this.gitDir });\r\n      \r\n      // Switch back to original branch\r\n      await execAsync('git checkout -', { cwd: this.gitDir });\r\n      \r\n    } catch (error) {\r\n      this.emit('warning', `Failed to create backup branch: ${error}`);\r\n    }\r\n  }\r\n\r\n  private formatRollbackMessage(message: string, tags: string[]): string {\r\n    const tagStr = tags.length > 0 ? ` [${tags.join(', ')}]` : '';\r\n    return `[ROLLBACK] ${message}${tagStr}`;\r\n  }\r\n\r\n  private extractTagsFromMessage(message: string): string[] {\r\n    const match = message.match(/\\[([^\\]]+)\\]/g);\r\n    if (!match) return [];\r\n    \r\n    return match.map(tag => tag.slice(1, -1)).filter(tag => tag !== 'ROLLBACK');\r\n  }\r\n\r\n  private async validateCommit(commitHash: string): Promise<void> {\r\n    try {\r\n      await execAsync(`git cat-file -e ${commitHash}`, { cwd: this.gitDir });\r\n    } catch {\r\n      throw new Error(`Invalid commit hash: ${commitHash}`);\r\n    }\r\n  }\r\n\r\n  private async validateFiles(files: string[]): Promise<void> {\r\n    for (const file of files) {\r\n      try {\r\n        await fs.access(join(this.gitDir, file));\r\n      } catch {\r\n        throw new Error(`File not found: ${file}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async getLastStashRef(): Promise<string> {\r\n    const { stdout } = await execAsync('git stash list -1 --format=\"%H\"', { cwd: this.gitDir });\r\n    return stdout.trim();\r\n  }\r\n\r\n  private async createFileBackup(files: string[]): Promise<string | null> {\r\n    try {\r\n      // Create a stash with only the specified files\r\n      for (const file of files) {\r\n        await execAsync(`git add \"${file}\"`, { cwd: this.gitDir });\r\n      }\r\n      \r\n      await execAsync('git stash push -m \"File backup before rollback\"', { cwd: this.gitDir });\r\n      return await this.getLastStashRef();\r\n      \r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private async restoreFileBackup(stashRef: string, files: string[]): Promise<void> {\r\n    try {\r\n      // Restore files from stash\r\n      await execAsync(`git stash show -p ${stashRef} | git apply`, { cwd: this.gitDir });\r\n      await execAsync(`git stash drop ${stashRef}`, { cwd: this.gitDir });\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to restore file backup: ${error}`));\r\n    }\r\n  }\r\n\r\n  private async emergencyRecovery(): Promise<void> {\r\n    try {\r\n      // Try to recover using backup branch\r\n      if (this.backupBranch) {\r\n        await execAsync(`git checkout \"${this.backupBranch}\"`, { cwd: this.gitDir });\r\n        await execAsync('git checkout -b \"emergency-recovery\"', { cwd: this.gitDir });\r\n        this.emit('emergency_recovery_completed', 'emergency-recovery');\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Emergency recovery failed: ${error}`);\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Main RollbackManager - Orchestrates all rollback components\r\n// ============================================================================\r\n\r\nexport class RollbackManager extends EventEmitter {\r\n  private stateManager: StateManager;\r\n  private rollbackTrigger: RollbackTrigger;\r\n  private automatedRecovery: AutomatedRecovery;\r\n  private rollbackHistory: RollbackHistory;\r\n  private gitRollbackManager: GitRollbackManager;\r\n  private isInitialized: boolean = false;\r\n\r\n  constructor(config: {\r\n    snapshotDir?: string;\r\n    historyDir?: string;\r\n    gitDir?: string;\r\n    maxSnapshots?: number;\r\n    maxHistorySize?: number;\r\n    historyTtlDays?: number;\r\n    compressionEnabled?: boolean;\r\n    triggerConfig?: Partial<RollbackTriggerConfig>;\r\n  } = {}) {\r\n    super();\r\n    \r\n    // Initialize components\r\n    this.stateManager = new StateManager(\r\n      config.snapshotDir,\r\n      config.maxSnapshots,\r\n      config.compressionEnabled\r\n    );\r\n    \r\n    this.rollbackTrigger = new RollbackTrigger(config.triggerConfig);\r\n    this.automatedRecovery = new AutomatedRecovery(this.stateManager);\r\n    \r\n    this.rollbackHistory = new RollbackHistory(\r\n      config.historyDir,\r\n      config.maxHistorySize,\r\n      config.historyTtlDays,\r\n      config.compressionEnabled\r\n    );\r\n    \r\n    this.gitRollbackManager = new GitRollbackManager(config.gitDir);\r\n    \r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    // Connect rollback trigger to automated recovery\r\n    this.rollbackTrigger.on('rollback_triggered', async (event) => {\r\n      await this.handleAutomaticRollback(event.metrics, event.reason);\r\n    });\r\n    \r\n    // Forward important events\r\n    this.stateManager.on('error', (error) => this.emit('error', error));\r\n    this.rollbackTrigger.on('error', (error) => this.emit('error', error));\r\n    this.automatedRecovery.on('error', (error) => this.emit('error', error));\r\n    this.rollbackHistory.on('error', (error) => this.emit('error', error));\r\n    this.gitRollbackManager.on('error', (error) => this.emit('error', error));\r\n    \r\n    // Aggregate events\r\n    this.stateManager.on('snapshot_created', (snapshot) => \r\n      this.emit('snapshot_created', snapshot));\r\n    this.automatedRecovery.on('recovery_success', (event) => \r\n      this.emit('recovery_success', event));\r\n    this.gitRollbackManager.on('rollback_completed', (event) => \r\n      this.emit('git_rollback_completed', event));\r\n  }\r\n\r\n  public async initialize(): Promise<void> {\r\n    if (this.isInitialized) return;\r\n    \r\n    try {\r\n      // Start monitoring\r\n      this.rollbackTrigger.startMonitoring();\r\n      \r\n      this.isInitialized = true;\r\n      this.emit('initialized');\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to initialize RollbackManager: ${error}`));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async shutdown(): Promise<void> {\r\n    if (!this.isInitialized) return;\r\n    \r\n    try {\r\n      this.rollbackTrigger.stopMonitoring();\r\n      this.rollbackHistory.destroy();\r\n      \r\n      this.isInitialized = false;\r\n      this.emit('shutdown');\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to shutdown RollbackManager: ${error}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a comprehensive system checkpoint\r\n   */\r\n  public async createCheckpoint(\r\n    description: string,\r\n    tags: string[] = []\r\n  ): Promise<string> {\r\n    try {\r\n      // Create system snapshot\r\n      const snapshot = await this.stateManager.captureSnapshot(\r\n        description,\r\n        tags,\r\n        'manual_checkpoint'\r\n      );\r\n      \r\n      // Create git rollback point\r\n      await this.gitRollbackManager.createRollbackPoint(\r\n        description,\r\n        tags\r\n      );\r\n      \r\n      this.emit('checkpoint_created', { snapshot: snapshot.id, description, tags });\r\n      return snapshot.id;\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to create checkpoint: ${error}`));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Performs a manual rollback to a specific checkpoint\r\n   */\r\n  public async rollbackToCheckpoint(\r\n    snapshotId: string,\r\n    strategy: 'graceful' | 'immediate' = 'graceful'\r\n  ): Promise<boolean> {\r\n    try {\r\n      const snapshot = await this.stateManager.getSnapshot(snapshotId);\r\n      if (!snapshot) {\r\n        throw new Error(`Snapshot not found: ${snapshotId}`);\r\n      }\r\n      \r\n      const startTime = Date.now();\r\n      \r\n      // Execute rollback based on strategy\r\n      let success: boolean;\r\n      if (strategy === 'graceful') {\r\n        success = await this.performGracefulRollback(snapshot);\r\n      } else {\r\n        success = await this.performImmediateRollback(snapshot);\r\n      }\r\n      \r\n      const duration = Date.now() - startTime;\r\n      \r\n      // Record in history\r\n      await this.rollbackHistory.addEntry(\r\n        snapshot,\r\n        'manual',\r\n        `Manual rollback to checkpoint ${snapshotId}`,\r\n        undefined, // No trigger metrics for manual rollback\r\n        strategy,\r\n        success,\r\n        duration,\r\n        [], // No recovery attempts for manual rollback\r\n        [], // Would need to run verification\r\n        success,\r\n        !success\r\n      );\r\n      \r\n      if (success) {\r\n        this.emit('manual_rollback_success', { snapshotId, strategy, duration });\r\n      } else {\r\n        this.emit('manual_rollback_failed', { snapshotId, strategy, duration });\r\n      }\r\n      \r\n      return success;\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Manual rollback failed: ${error}`));\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async handleAutomaticRollback(\r\n    metrics: SystemMetrics,\r\n    reason: string\r\n  ): Promise<void> {\r\n    try {\r\n      const success = await this.automatedRecovery.executeRecovery(metrics, reason);\r\n      \r\n      if (success) {\r\n        this.emit('automatic_rollback_success', { reason, metrics });\r\n      } else {\r\n        this.emit('automatic_rollback_failed', { reason, metrics });\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.emit('error', new Error(`Automatic rollback failed: ${error}`));\r\n    }\r\n  }\r\n\r\n  private async performGracefulRollback(snapshot: SystemSnapshot): Promise<boolean> {\r\n    try {\r\n      // 1. Create backup of current state\r\n      await this.stateManager.captureSnapshot(\r\n        'Pre-rollback backup',\r\n        ['auto-backup'],\r\n        'rollback_backup'\r\n      );\r\n      \r\n      // 2. Gradually restore components\r\n      const restoreSteps = [\r\n        () => this.restoreConfiguration(snapshot),\r\n        () => this.restoreMemoryState(snapshot),\r\n        () => this.restoreFileSystem(snapshot),\r\n        () => this.performGitRollback(snapshot)\r\n      ];\r\n      \r\n      for (const step of restoreSteps) {\r\n        await step();\r\n        // Small delay between steps\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n      }\r\n      \r\n      return true;\r\n      \r\n    } catch (error) {\r\n      this.emit('graceful_rollback_error', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async performImmediateRollback(snapshot: SystemSnapshot): Promise<boolean> {\r\n    try {\r\n      // Perform all restoration steps in parallel for speed\r\n      await Promise.all([\r\n        this.restoreConfiguration(snapshot),\r\n        this.restoreMemoryState(snapshot),\r\n        this.restoreFileSystem(snapshot),\r\n        this.performGitRollback(snapshot)\r\n      ]);\r\n      \r\n      return true;\r\n      \r\n    } catch (error) {\r\n      this.emit('immediate_rollback_error', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async restoreConfiguration(snapshot: SystemSnapshot): Promise<void> {\r\n    for (const [path, content] of Object.entries(snapshot.state.config)) {\r\n      try {\r\n        await fs.writeFile(path, JSON.stringify(content, null, 2));\r\n      } catch (error) {\r\n        console.warn(`Failed to restore config ${path}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async restoreMemoryState(snapshot: SystemSnapshot): Promise<void> {\r\n    for (const [path, content] of Object.entries(snapshot.state.memory)) {\r\n      try {\r\n        await fs.writeFile(path, JSON.stringify(content, null, 2));\r\n      } catch (error) {\r\n        console.warn(`Failed to restore memory ${path}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async restoreFileSystem(snapshot: SystemSnapshot): Promise<void> {\r\n    for (const file of snapshot.state.files) {\r\n      try {\r\n        await fs.writeFile(file.path, file.content);\r\n        await fs.chmod(file.path, file.stats.mode);\r\n      } catch (error) {\r\n        console.warn(`Failed to restore file ${file.path}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async performGitRollback(snapshot: SystemSnapshot): Promise<void> {\r\n    if (snapshot.state.git.commit !== 'unknown') {\r\n      try {\r\n        await this.gitRollbackManager.rollbackToCommit(snapshot.state.git.commit);\r\n      } catch (error) {\r\n        console.warn('Git rollback failed:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Public API methods\r\n  public getStateManager(): StateManager { return this.stateManager; }\r\n  public getRollbackTrigger(): RollbackTrigger { return this.rollbackTrigger; }\r\n  public getAutomatedRecovery(): AutomatedRecovery { return this.automatedRecovery; }\r\n  public getRollbackHistory(): RollbackHistory { return this.rollbackHistory; }\r\n  public getGitRollbackManager(): GitRollbackManager { return this.gitRollbackManager; }\r\n\r\n  public async getSystemStatus(): Promise<{\r\n    isMonitoring: boolean;\r\n    snapshotCount: number;\r\n    historyEntries: number;\r\n    lastCheckpoint: string | null;\r\n    healthScore: number;\r\n  }> {\r\n    const snapshots = this.stateManager.listSnapshots();\r\n    const recentEntries = this.rollbackHistory.getRecentEntries(10);\r\n    const successRate = this.rollbackHistory.getSuccessRate();\r\n    \r\n    return {\r\n      isMonitoring: this.rollbackTrigger.getCurrentMetrics() !== null,\r\n      snapshotCount: snapshots.length,\r\n      historyEntries: recentEntries.length,\r\n      lastCheckpoint: snapshots[0]?.id || null,\r\n      healthScore: successRate\r\n    };\r\n  }\r\n}\r\n\r\n// Export the main class and interfaces\r\nexport default RollbackManager;"],"names":["promises","fs","join","exec","promisify","createHash","EventEmitter","gzip","gunzip","execAsync","gzipAsync","gunzipAsync","StateManager","snapshots","Map","snapshotDir","maxSnapshots","compressionEnabled","initializeStorage","mkdir","recursive","loadExistingSnapshots","error","emit","Error","files","readdir","snapshotFiles","filter","f","endsWith","file","content","readFile","snapshot","JSON","parse","set","id","console","warn","size","captureSnapshot","description","tags","triggeredBy","generateSnapshotId","timestamp","Date","now","config","memory","processes","git","Promise","all","captureConfig","captureMemory","captureProcesses","captureFiles","captureGitState","version","metadata","severity","state","integrity","checksum","compressed","serialized","stringify","update","digest","Buffer","byteLength","storeSnapshot","cleanupOldSnapshots","configPaths","path","memoryPaths","stdout","lines","trim","split","map","line","parts","pid","parseInt","name","status","parseFloat","cpu","env","process","criticalPaths","stats","stat","push","mtime","getTime","mode","branch","commit","staged","modified","untracked","then","r","catch","Boolean","filename","filepath","from","writeFile","sorted","Array","values","sort","a","b","toDelete","slice","length","unlink","delete","Math","random","toString","substr","getSnapshot","get","listSnapshots","deleteSnapshot","RollbackTrigger","monitoring","metrics","monitoringInterval","lastRollback","mergeConfig","enabled","thresholds","errorRate","memoryUsage","cpuUsage","responseTime","diskSpace","consecutiveFailures","interval","cooldown","gracePeriod","notifications","webhook","email","slack","startMonitoring","setInterval","checkThresholds","stopMonitoring","clearInterval","undefined","collectMetrics","oneHourAgo","m","violations","evaluateThresholds","recentViolations","triggerRollback","memInfo","cpuInfo","diskInfo","getMemoryInfo","getCpuInfo","getDiskInfo","errors","count","rate","recent","performance","disk","network","in","out","health","score","checks","used","total","percentage","usage","load","free","message","duration","meminfo","memTotal","find","l","startsWith","memAvailable","memUsed","loadavg","loads","parseSize","sizeStr","match","value","unit","multipliers","toFixed","diskFreePercentage","reason","sendNotifications","updateConfig","getCurrentMetrics","getMetricsHistory","AutomatedRecovery","strategies","recoveryHistory","stateManager","isRecovering","initializeDefaultStrategies","registerStrategy","priority","timeout","retries","conditions","execute","context","strategy","action","resolve","setTimeout","global","gc","clearApplicationCaches","restoreConfiguration","performFullRollback","executeRecovery","triggerReason","preferredSnapshot","applicableStrategies","s","previousAttempts","success","executeStrategy","startTime","attempt","maxAttempts","race","_","reject","recoveryAttempt","rm","force","Object","entries","chmod","getStrategyNames","keys","getStrategy","enableStrategy","disableStrategy","getRecoveryHistory","RollbackHistory","history","historyDir","maxHistorySize","ttlMs","cleanupInterval","ttlDays","startCleanupInterval","loadExistingHistory","historyFiles","decompressed","entry","cleanupExpiredEntries","addEntry","triggerType","triggerMetrics","recoveryStrategy","recoverySuccess","recoveryDuration","recoveryAttempts","verificationChecks","verificationPassed","rollbackRequired","generateHistoryId","trigger","type","recovery","attempts","verification","passed","storeHistoryEntry","cleanupOldEntries","expiredEntries","deleteEntry","getEntry","getRecentEntries","limit","getEntriesByDateRange","startDate","endDate","endTime","getSuccessRate","timeframe","cutoff","recentEntries","successCount","getStatistics","totalEntries","successRate","averageRecoveryTime","mostCommonFailureReason","rollbacksByTrigger","e","totalRecoveryTime","reduce","sum","failureReasons","reasonCounts","acc","destroy","GitRollbackManager","gitDir","backupBranch","safetyChecks","createRollbackPoint","ensureGitRepo","performSafetyChecks","createBackupBranch","cwd","rollbackMessage","formatRollbackMessage","commitHash","hash","tagName","tag","rollbackToCommit","preserveUntracked","validateCommit","stashRef","getLastStashRef","currentHash","emergencyRecovery","recoveryError","rollbackFiles","validateFiles","backupStash","createFileBackup","restoreFileBackup","createTestBranch","branchName","listRollbackPoints","commits","dateStr","date","replace","extractTagsFromMessage","tagOutput","taggedCommits","currentBranch","protectedBranches","includes","tagStr","access","RollbackManager","rollbackTrigger","automatedRecovery","rollbackHistory","gitRollbackManager","isInitialized","triggerConfig","historyTtlDays","setupEventHandlers","on","event","handleAutomaticRollback","initialize","shutdown","createCheckpoint","rollbackToCheckpoint","snapshotId","performGracefulRollback","performImmediateRollback","restoreSteps","restoreMemoryState","restoreFileSystem","performGitRollback","step","getStateManager","getRollbackTrigger","getAutomatedRecovery","getRollbackHistory","getGitRollbackManager","getSystemStatus","isMonitoring","snapshotCount","historyEntries","lastCheckpoint","healthScore"],"mappings":"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"}