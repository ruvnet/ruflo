{
  "version": 3,
  "sources": ["../../../src/services/agentic-flow-hooks/hook-manager.ts"],
  "sourcesContent": ["/**\n * Agentic Flow Hook Manager\n * \n * Central manager for all agentic-flow hooks, providing registration,\n * execution, and lifecycle management.\n */\n\nimport { EventEmitter } from 'events';\nimport { Logger } from '../../core/logger.js';\nimport type {\n  AgenticHookContext,\n  AgenticHookType,\n  HookFilter,\n  HookHandler,\n  HookHandlerResult,\n  HookOptions,\n  HookPayload,\n  HookPipeline,\n  HookRegistration,\n  HookRegistry,\n  PipelineMetrics,\n  PipelineStage,\n  SideEffect,\n} from './types.js';\n\nconst logger = new Logger({ \n  level: 'info',\n  format: 'text',\n  destination: 'console'\n}, { prefix: 'AgenticHookManager' });\n\nexport class AgenticHookManager extends EventEmitter implements HookRegistry {\n  private hooks: Map<AgenticHookType, HookRegistration[]> = new Map();\n  private pipelines: Map<string, HookPipeline> = new Map();\n  private metrics: Map<string, any> = new Map();\n  private activeExecutions: Set<string> = new Set();\n  \n  constructor() {\n    super();\n    this.initializeMetrics();\n  }\n\n  /**\n   * Register a new hook\n   */\n  register(registration: HookRegistration): void {\n    const { type, id } = registration;\n    \n    // Validate registration\n    this.validateRegistration(registration);\n    \n    // Get or create hook list for type\n    if (!this.hooks.has(type)) {\n      this.hooks.set(type, []);\n    }\n    \n    const hookList = this.hooks.get(type)!;\n    \n    // Check for duplicate ID\n    if (hookList.some(h => h.id === id)) {\n      throw new Error(`Hook with ID '${id}' already registered for type '${type}'`);\n    }\n    \n    // Insert hook sorted by priority (higher priority first)\n    const insertIndex = hookList.findIndex(h => h.priority < registration.priority);\n    if (insertIndex === -1) {\n      hookList.push(registration);\n    } else {\n      hookList.splice(insertIndex, 0, registration);\n    }\n    \n    logger.info(`Registered hook '${id}' for type '${type}' with priority ${registration.priority}`);\n    this.emit('hook:registered', { type, registration });\n    \n    // Update metrics\n    this.updateMetric('hooks.registered', 1);\n  }\n\n  /**\n   * Unregister a hook\n   */\n  unregister(id: string): void {\n    let found = false;\n    \n    for (const [type, hookList] of this.hooks.entries()) {\n      const index = hookList.findIndex(h => h.id === id);\n      if (index !== -1) {\n        hookList.splice(index, 1);\n        found = true;\n        \n        logger.info(`Unregistered hook '${id}' from type '${type}'`);\n        this.emit('hook:unregistered', { type, id });\n        \n        // Clean up empty lists\n        if (hookList.length === 0) {\n          this.hooks.delete(type);\n        }\n        \n        break;\n      }\n    }\n    \n    if (!found) {\n      throw new Error(`Hook with ID '${id}' not found`);\n    }\n    \n    this.updateMetric('hooks.unregistered', 1);\n  }\n\n  /**\n   * Get hooks by type with optional filtering\n   */\n  getHooks(type: AgenticHookType, filter?: HookFilter): HookRegistration[] {\n    const hookList = this.hooks.get(type) || [];\n    \n    if (!filter) {\n      return [...hookList];\n    }\n    \n    return hookList.filter(hook => this.matchesFilter(hook, filter));\n  }\n\n  /**\n   * Execute hooks for a given type\n   */\n  async executeHooks(\n    type: AgenticHookType,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    const executionId = this.generateExecutionId();\n    this.activeExecutions.add(executionId);\n    \n    const startTime = Date.now();\n    const results: HookHandlerResult[] = [];\n    \n    try {\n      // Get applicable hooks\n      const hooks = this.getHooks(type, this.createFilterFromPayload(payload));\n      \n      logger.debug(`Executing ${hooks.length} hooks for type '${type}'`);\n      this.emit('hooks:executing', { type, count: hooks.length, executionId });\n      \n      // Execute hooks in order\n      let modifiedPayload = payload;\n      for (const hook of hooks) {\n        try {\n          const result = await this.executeHook(hook, modifiedPayload, context);\n          results.push(result);\n          \n          // Handle side effects\n          if (result.sideEffects) {\n            await this.processSideEffects(result.sideEffects, context);\n          }\n          \n          // Update payload if modified\n          if (result.modified && result.payload) {\n            modifiedPayload = result.payload;\n          }\n          \n          // Check if we should continue\n          if (!result.continue) {\n            logger.debug(`Hook '${hook.id}' halted execution chain`);\n            break;\n          }\n        } catch (error) {\n          await this.handleHookError(hook, error as Error, context);\n          \n          // Determine if we should continue after error\n          if (hook.options?.errorHandler) {\n            hook.options.errorHandler(error as Error);\n          } else {\n            throw error; // Re-throw if no error handler\n          }\n        }\n      }\n      \n      // Update metrics\n      const duration = Date.now() - startTime;\n      this.updateMetric('hooks.executions', 1);\n      this.updateMetric('hooks.totalDuration', duration);\n      this.updateMetric(`hooks.${type}.executions`, 1);\n      this.updateMetric(`hooks.${type}.duration`, duration);\n      \n      this.emit('hooks:executed', { \n        type, \n        results, \n        duration, \n        executionId \n      });\n      \n      return results;\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Create a new hook pipeline\n   */\n  createPipeline(config: Partial<HookPipeline>): HookPipeline {\n    const pipeline: HookPipeline = {\n      id: config.id || this.generatePipelineId(),\n      name: config.name || 'Unnamed Pipeline',\n      stages: config.stages || [],\n      errorStrategy: config.errorStrategy || 'fail-fast',\n      metrics: {\n        executions: 0,\n        avgDuration: 0,\n        errorRate: 0,\n        throughput: 0,\n      },\n    };\n    \n    this.pipelines.set(pipeline.id, pipeline);\n    logger.info(`Created pipeline '${pipeline.name}' with ID '${pipeline.id}'`);\n    \n    return pipeline;\n  }\n\n  /**\n   * Execute a pipeline\n   */\n  async executePipeline(\n    pipelineId: string,\n    initialPayload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    const pipeline = this.pipelines.get(pipelineId);\n    if (!pipeline) {\n      throw new Error(`Pipeline '${pipelineId}' not found`);\n    }\n    \n    const startTime = Date.now();\n    const results: HookHandlerResult[] = [];\n    let currentPayload = initialPayload;\n    \n    try {\n      for (const stage of pipeline.stages) {\n        // Check stage condition\n        if (stage.condition && !stage.condition(context)) {\n          logger.debug(`Skipping stage '${stage.name}' due to condition`);\n          continue;\n        }\n        \n        // Execute stage hooks\n        const stageResults = await this.executeStage(\n          stage, \n          currentPayload, \n          context\n        );\n        \n        // Apply stage transform if provided\n        if (stage.transform) {\n          for (let i = 0; i < stageResults.length; i++) {\n            stageResults[i] = stage.transform(stageResults[i]);\n          }\n        }\n        \n        results.push(...stageResults);\n        \n        // Update payload for next stage\n        const lastModified = stageResults\n          .reverse()\n          .find(r => r.modified && r.payload);\n        if (lastModified) {\n          currentPayload = lastModified.payload;\n        }\n      }\n      \n      // Update pipeline metrics\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, false);\n      \n      return results;\n    } catch (error) {\n      // Update error metrics\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, true);\n      \n      // Handle error based on strategy\n      if (pipeline.errorStrategy === 'rollback') {\n        await this.rollbackPipeline(pipeline, results, context);\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): Record<string, any> {\n    const metrics: Record<string, any> = {};\n    \n    for (const [key, value] of this.metrics.entries()) {\n      metrics[key] = value;\n    }\n    \n    // Add computed metrics\n    metrics['hooks.count'] = this.getTotalHookCount();\n    metrics['hooks.types'] = Array.from(this.hooks.keys());\n    metrics['pipelines.count'] = this.pipelines.size;\n    metrics['executions.active'] = this.activeExecutions.size;\n    \n    return metrics;\n  }\n\n  // ===== Private Methods =====\n\n  private validateRegistration(registration: HookRegistration): void {\n    if (!registration.id) {\n      throw new Error('Hook registration must have an ID');\n    }\n    \n    if (!registration.type) {\n      throw new Error('Hook registration must have a type');\n    }\n    \n    if (typeof registration.handler !== 'function') {\n      throw new Error('Hook registration must have a handler function');\n    }\n    \n    if (registration.priority < 0) {\n      throw new Error('Hook priority must be non-negative');\n    }\n  }\n\n  private matchesFilter(hook: HookRegistration, filter: HookFilter): boolean {\n    if (!hook.filter) {\n      return true; // No filter means hook applies to all\n    }\n    \n    // Check providers\n    if (filter.providers && hook.filter.providers) {\n      const hasProvider = filter.providers.some(p => \n        hook.filter!.providers!.includes(p)\n      );\n      if (!hasProvider) return false;\n    }\n    \n    // Check models\n    if (filter.models && hook.filter.models) {\n      const hasModel = filter.models.some(m => \n        hook.filter!.models!.includes(m)\n      );\n      if (!hasModel) return false;\n    }\n    \n    // Check patterns\n    if (filter.patterns && hook.filter.patterns) {\n      // Complex pattern matching logic here\n      // For now, simplified version\n      return true;\n    }\n    \n    // Check conditions\n    if (filter.conditions && hook.filter.conditions) {\n      // Evaluate conditions\n      // Simplified for now\n      return true;\n    }\n    \n    return true;\n  }\n\n  private createFilterFromPayload(payload: HookPayload): HookFilter | undefined {\n    const filter: HookFilter = {};\n    \n    // Extract filter criteria from payload\n    if ('provider' in payload) {\n      filter.providers = [payload.provider];\n    }\n    \n    if ('model' in payload) {\n      filter.models = [payload.model];\n    }\n    \n    if ('operation' in payload) {\n      filter.operations = [payload.operation];\n    }\n    \n    if ('namespace' in payload) {\n      filter.namespaces = [payload.namespace];\n    }\n    \n    return Object.keys(filter).length > 0 ? filter : undefined;\n  }\n\n  private async executeHook(\n    hook: HookRegistration,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Check cache if enabled\n      if (hook.options?.cache?.enabled) {\n        const cacheKey = hook.options.cache.key(payload);\n        const cached = this.getCachedResult(hook.id, cacheKey);\n        if (cached) {\n          this.updateMetric('hooks.cacheHits', 1);\n          return cached;\n        }\n      }\n      \n      // Execute with timeout if specified\n      let resultPromise = hook.handler(payload, context);\n      \n      if (hook.options?.timeout) {\n        resultPromise = this.withTimeout(\n          resultPromise, \n          hook.options.timeout,\n          `Hook '${hook.id}' timed out`\n        );\n      }\n      \n      const result = await resultPromise;\n      \n      // Cache result if enabled\n      if (hook.options?.cache?.enabled && result) {\n        const cacheKey = hook.options.cache.key(payload);\n        this.cacheResult(hook.id, cacheKey, result, hook.options.cache.ttl);\n      }\n      \n      // Update hook-specific metrics\n      const duration = Date.now() - startTime;\n      this.updateMetric(`hooks.${hook.id}.executions`, 1);\n      this.updateMetric(`hooks.${hook.id}.duration`, duration);\n      \n      return result;\n    } catch (error) {\n      // Handle retries if configured\n      if (hook.options?.retries && hook.options.retries > 0) {\n        logger.warn(`Hook '${hook.id}' failed, retrying...`);\n        return this.retryHook(hook, payload, context, hook.options.retries);\n      }\n      \n      // Use fallback if provided\n      if (hook.options?.fallback) {\n        logger.warn(`Hook '${hook.id}' failed, using fallback`);\n        return hook.options.fallback(payload, context);\n      }\n      \n      throw error;\n    }\n  }\n\n  private async retryHook(\n    hook: HookRegistration,\n    payload: HookPayload,\n    context: AgenticHookContext,\n    retriesLeft: number\n  ): Promise<HookHandlerResult> {\n    for (let i = 0; i < retriesLeft; i++) {\n      try {\n        await this.delay(Math.pow(2, i) * 1000); // Exponential backoff\n        return await hook.handler(payload, context);\n      } catch (error) {\n        if (i === retriesLeft - 1) {\n          throw error; // Last retry failed\n        }\n      }\n    }\n    \n    // Should not reach here\n    throw new Error('Retry logic error');\n  }\n\n  private async processSideEffects(\n    sideEffects: SideEffect[],\n    context: AgenticHookContext\n  ): Promise<void> {\n    for (const effect of sideEffects) {\n      try {\n        await this.processSideEffect(effect, context);\n      } catch (error) {\n        logger.error(`Failed to process side effect: ${effect.type}`, error);\n        // Continue processing other side effects\n      }\n    }\n  }\n\n  private async processSideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    switch (effect.type) {\n      case 'memory':\n        await this.processMemorySideEffect(effect, context);\n        break;\n      \n      case 'neural':\n        await this.processNeuralSideEffect(effect, context);\n        break;\n      \n      case 'metric':\n        this.processMetricSideEffect(effect);\n        break;\n      \n      case 'notification':\n        this.processNotificationSideEffect(effect);\n        break;\n      \n      case 'log':\n        this.processLogSideEffect(effect);\n        break;\n    }\n  }\n\n  private async processMemorySideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Implement memory side effect processing\n    // This would integrate with the memory service\n    logger.debug(`Processing memory side effect: ${effect.action}`, effect.data);\n  }\n\n  private async processNeuralSideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Implement neural side effect processing\n    // This would integrate with the neural service\n    logger.debug(`Processing neural side effect: ${effect.action}`, effect.data);\n  }\n\n  private processMetricSideEffect(effect: SideEffect): void {\n    if (effect.action === 'update') {\n      this.updateMetric(effect.data.name, effect.data.value);\n    } else if (effect.action === 'increment') {\n      this.updateMetric(effect.data.name, 1);\n    }\n  }\n\n  private processNotificationSideEffect(effect: SideEffect): void {\n    this.emit('notification', effect.data);\n  }\n\n  private processLogSideEffect(effect: SideEffect): void {\n    const { level = 'info', message, data } = effect.data;\n    logger[level as keyof Logger](message, data);\n  }\n\n  private async handleHookError(\n    hook: HookRegistration,\n    error: Error,\n    context: AgenticHookContext\n  ): Promise<void> {\n    logger.error(`Hook '${hook.id}' error:`, error);\n    \n    this.updateMetric('hooks.errors', 1);\n    this.updateMetric(`hooks.${hook.id}.errors`, 1);\n    \n    this.emit('hook:error', {\n      hookId: hook.id,\n      type: hook.type,\n      error,\n      context,\n    });\n  }\n\n  private async executeStage(\n    stage: PipelineStage,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    if (stage.parallel) {\n      // Execute hooks in parallel\n      const promises = stage.hooks.map(hook => \n        this.executeHook(hook, payload, context)\n      );\n      return Promise.all(promises);\n    } else {\n      // Execute hooks sequentially\n      const results: HookHandlerResult[] = [];\n      let currentPayload = payload;\n      \n      for (const hook of stage.hooks) {\n        const result = await this.executeHook(hook, currentPayload, context);\n        results.push(result);\n        \n        if (result.modified && result.payload) {\n          currentPayload = result.payload;\n        }\n        \n        if (!result.continue) {\n          break;\n        }\n      }\n      \n      return results;\n    }\n  }\n\n  private updatePipelineMetrics(\n    pipeline: HookPipeline,\n    duration: number,\n    hasError: boolean\n  ): void {\n    const metrics = pipeline.metrics;\n    \n    metrics.executions++;\n    metrics.avgDuration = \n      (metrics.avgDuration * (metrics.executions - 1) + duration) / \n      metrics.executions;\n    \n    if (hasError) {\n      metrics.errorRate = \n        (metrics.errorRate * (metrics.executions - 1) + 1) / \n        metrics.executions;\n    } else {\n      metrics.errorRate = \n        (metrics.errorRate * (metrics.executions - 1)) / \n        metrics.executions;\n    }\n    \n    // Calculate throughput (executions per minute)\n    const timeWindow = 60000; // 1 minute\n    metrics.throughput = (metrics.executions / duration) * timeWindow;\n  }\n\n  private async rollbackPipeline(\n    pipeline: HookPipeline,\n    results: HookHandlerResult[],\n    context: AgenticHookContext\n  ): Promise<void> {\n    logger.warn(`Rolling back pipeline '${pipeline.name}'`);\n    // Implement rollback logic based on side effects in results\n    // This is a placeholder for actual rollback implementation\n  }\n\n  private getTotalHookCount(): number {\n    let count = 0;\n    for (const hookList of this.hooks.values()) {\n      count += hookList.length;\n    }\n    return count;\n  }\n\n  private initializeMetrics(): void {\n    this.metrics.set('hooks.registered', 0);\n    this.metrics.set('hooks.unregistered', 0);\n    this.metrics.set('hooks.executions', 0);\n    this.metrics.set('hooks.errors', 0);\n    this.metrics.set('hooks.cacheHits', 0);\n    this.metrics.set('hooks.totalDuration', 0);\n  }\n\n  private updateMetric(key: string, value: number): void {\n    const current = this.metrics.get(key) || 0;\n    this.metrics.set(key, current + value);\n  }\n\n  private generateExecutionId(): string {\n    return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generatePipelineId(): string {\n    return `pipe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getCachedResult(\n    hookId: string, \n    cacheKey: string\n  ): HookHandlerResult | null {\n    // Implement cache retrieval\n    // This is a placeholder\n    return null;\n  }\n\n  private cacheResult(\n    hookId: string,\n    cacheKey: string,\n    result: HookHandlerResult,\n    ttl: number\n  ): void {\n    // Implement cache storage\n    // This is a placeholder\n  }\n\n  private async withTimeout<T>(\n    promise: Promise<T>,\n    timeout: number,\n    message: string\n  ): Promise<T> {\n    return Promise.race([\n      promise,\n      new Promise<T>((_, reject) => \n        setTimeout(() => reject(new Error(message)), timeout)\n      ),\n    ]);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Export singleton instance\nexport const agenticHookManager = new AgenticHookManager();"],
  "mappings": "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",
  "names": []
}
