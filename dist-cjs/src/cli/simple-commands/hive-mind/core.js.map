{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/core.js"],"sourcesContent":["/**\r\n * Hive Mind Core System\r\n * Central orchestration and coordination logic\r\n */\r\n\r\nimport EventEmitter from 'events';\r\nimport { MCPToolWrapper } from './mcp-wrapper.js';\r\nimport { PerformanceOptimizer } from './performance-optimizer.js';\r\n\r\n/**\r\n * HiveMindCore - Main orchestration class\r\n */\r\nexport class HiveMindCore extends EventEmitter {\r\n  constructor(config = {}) {\r\n    super();\r\n\r\n    this.config = {\r\n      objective: '',\r\n      name: `hive-${Date.now()}`,\r\n      queenType: 'strategic',\r\n      maxWorkers: 8,\r\n      consensusAlgorithm: 'majority',\r\n      autoScale: true,\r\n      encryption: false,\r\n      memorySize: 100, // MB\r\n      taskTimeout: 60, // minutes\r\n      ...config,\r\n    };\r\n\r\n    this.state = {\r\n      status: 'initializing',\r\n      swarmId: null,\r\n      queen: null,\r\n      workers: new Map(),\r\n      tasks: new Map(),\r\n      memory: new Map(),\r\n      decisions: new Map(),\r\n      metrics: {\r\n        tasksCreated: 0,\r\n        tasksCompleted: 0,\r\n        decisionsReached: 0,\r\n        memoryUsage: 0,\r\n      },\r\n    };\r\n\r\n    this.mcpWrapper = new MCPToolWrapper({\r\n      parallel: true,\r\n      timeout: this.config.taskTimeout * 60 * 1000,\r\n    });\r\n\r\n    // Initialize performance optimizer\r\n    this.performanceOptimizer = new PerformanceOptimizer({\r\n      enableAsyncQueue: true,\r\n      enableBatchProcessing: true,\r\n      enableAutoTuning: true,\r\n      asyncQueueConcurrency: Math.min(this.config.maxWorkers * 2, 20),\r\n      batchMaxSize: 50,\r\n      metricsInterval: 30000,\r\n    });\r\n\r\n    this._initializeEventHandlers();\r\n    this._initializePerformanceMonitoring();\r\n  }\r\n\r\n  /**\r\n   * Initialize event handlers\r\n   */\r\n  _initializeEventHandlers() {\r\n    this.on('task:created', (task) => {\r\n      this.state.metrics.tasksCreated++;\r\n      this._checkAutoScale();\r\n    });\r\n\r\n    this.on('task:completed', (task) => {\r\n      this.state.metrics.tasksCompleted++;\r\n      this._updatePerformanceMetrics();\r\n    });\r\n\r\n    this.on('task:failed', (data) => {\r\n      console.warn(`Task failed: ${data.task.id}`, data.error);\r\n      this._handleTaskFailure(data.task, data.error);\r\n    });\r\n\r\n    this.on('decision:reached', (decision) => {\r\n      this.state.metrics.decisionsReached++;\r\n    });\r\n\r\n    this.on('worker:idle', (workerId) => {\r\n      this._assignNextTask(workerId);\r\n    });\r\n\r\n    this.on('error', (error) => {\r\n      console.error('Hive Mind Error:', error);\r\n      this._handleError(error);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize performance monitoring\r\n   */\r\n  _initializePerformanceMonitoring() {\r\n    // Listen to performance optimizer events\r\n    this.performanceOptimizer.on('auto_tune', (data) => {\r\n      this.emit('performance:auto_tuned', data);\r\n    });\r\n\r\n    this.performanceOptimizer.on('error', (error) => {\r\n      console.error('Performance optimizer error:', error);\r\n      this.emit('error', { type: 'performance_optimizer_error', error });\r\n    });\r\n\r\n    // Periodic performance reporting\r\n    setInterval(() => {\r\n      const stats = this.performanceOptimizer.getPerformanceStats();\r\n      this.emit('performance:stats', stats);\r\n\r\n      // Log performance warnings\r\n      if (parseFloat(stats.asyncQueue.utilization) > 90) {\r\n        console.warn('High async queue utilization:', stats.asyncQueue.utilization + '%');\r\n      }\r\n\r\n      if (parseFloat(stats.asyncQueue.successRate) < 95) {\r\n        console.warn('Low async operation success rate:', stats.asyncQueue.successRate + '%');\r\n      }\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * Handle task failure with recovery logic\r\n   */\r\n  _handleTaskFailure(task, error) {\r\n    // Update metrics\r\n    this.state.metrics.tasksFailed = (this.state.metrics.tasksFailed || 0) + 1;\r\n\r\n    // Attempt task retry for recoverable failures\r\n    if (task.retryCount < 2 && this._isRecoverableError(error)) {\r\n      task.retryCount = (task.retryCount || 0) + 1;\r\n      task.status = 'pending';\r\n\r\n      // Find another worker for retry\r\n      setTimeout(() => {\r\n        const worker = this._findBestWorker(task);\r\n        if (worker) {\r\n          this._assignTask(worker.id, task.id);\r\n        }\r\n      }, 5000); // Wait 5 seconds before retry\r\n\r\n      console.log(`Retrying task ${task.id} (attempt ${task.retryCount})`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if error is recoverable\r\n   */\r\n  _isRecoverableError(error) {\r\n    const recoverableErrors = ['timeout', 'network', 'temporary', 'connection'];\r\n\r\n    return recoverableErrors.some((type) => error.message.toLowerCase().includes(type));\r\n  }\r\n\r\n  /**\r\n   * Initialize the hive mind swarm\r\n   */\r\n  async initialize() {\r\n    try {\r\n      this.state.status = 'initializing';\r\n\r\n      // Initialize swarm with MCP tools\r\n      const [swarmInit, memoryInit, neuralInit] = await this.mcpWrapper.initializeSwarm({\r\n        topology: this._determineTopology(),\r\n        maxAgents: this.config.maxWorkers + 1, // +1 for queen\r\n        swarmId: this.config.name,\r\n      });\r\n\r\n      this.state.swarmId = swarmInit.swarmId;\r\n\r\n      // Store initial configuration in memory\r\n      await this.mcpWrapper.storeMemory(this.state.swarmId, 'config', this.config, 'system');\r\n\r\n      this.state.status = 'ready';\r\n      this.emit('initialized', { swarmId: this.state.swarmId });\r\n\r\n      return this.state.swarmId;\r\n    } catch (error) {\r\n      this.state.status = 'error';\r\n      this.emit('error', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine optimal topology based on objective\r\n   */\r\n  _determineTopology() {\r\n    const objective = this.config.objective.toLowerCase();\r\n\r\n    // Heuristic topology selection\r\n    if (objective.includes('research') || objective.includes('analysis')) {\r\n      return 'mesh'; // Peer-to-peer for collaborative research\r\n    } else if (objective.includes('build') || objective.includes('develop')) {\r\n      return 'hierarchical'; // Clear command structure for development\r\n    } else if (objective.includes('monitor') || objective.includes('maintain')) {\r\n      return 'ring'; // Circular for continuous monitoring\r\n    } else if (objective.includes('coordinate') || objective.includes('orchestrate')) {\r\n      return 'star'; // Centralized for coordination\r\n    }\r\n\r\n    return 'hierarchical'; // Default\r\n  }\r\n\r\n  /**\r\n   * Spawn the queen coordinator\r\n   */\r\n  async spawnQueen(queenData) {\r\n    const [spawnResult] = await this.mcpWrapper.spawnAgents(['coordinator'], this.state.swarmId);\r\n\r\n    this.state.queen = {\r\n      id: queenData.id,\r\n      agentId: spawnResult.agentId,\r\n      type: this.config.queenType,\r\n      status: 'active',\r\n      decisions: 0,\r\n      tasks: 0,\r\n    };\r\n\r\n    // Store queen info in memory\r\n    await this.mcpWrapper.storeMemory(this.state.swarmId, 'queen', this.state.queen, 'system');\r\n\r\n    this.emit('queen:spawned', this.state.queen);\r\n    return this.state.queen;\r\n  }\r\n\r\n  /**\r\n   * Spawn worker agents with batch optimization\r\n   */\r\n  async spawnWorkers(workerTypes) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Batch spawn agents in parallel with optimized chunking\r\n      const chunkSize = Math.min(workerTypes.length, 5); // Optimal batch size\r\n      const chunks = [];\r\n\r\n      for (let i = 0; i < workerTypes.length; i += chunkSize) {\r\n        chunks.push(workerTypes.slice(i, i + chunkSize));\r\n      }\r\n\r\n      // Process chunks in parallel with Promise.all\r\n      const allResults = await Promise.all(\r\n        chunks.map((chunk) => this.mcpWrapper.spawnAgents(chunk, this.state.swarmId)),\r\n      );\r\n\r\n      // Flatten results\r\n      const spawnResults = allResults.flat();\r\n\r\n      // Batch create worker objects\r\n      const workers = [];\r\n      const workerUpdates = [];\r\n\r\n      spawnResults.forEach((result, index) => {\r\n        const worker = {\r\n          id: `worker-${index}`,\r\n          agentId: result.agentId,\r\n          type: workerTypes[index],\r\n          status: 'idle',\r\n          tasksCompleted: 0,\r\n          currentTask: null,\r\n          spawnedAt: Date.now(),\r\n          performance: {\r\n            avgTaskTime: 0,\r\n            successRate: 1.0,\r\n          },\r\n        };\r\n\r\n        workers.push(worker);\r\n        this.state.workers.set(worker.id, worker);\r\n\r\n        workerUpdates.push({\r\n          type: 'worker_spawned',\r\n          workerId: worker.id,\r\n          workerType: worker.type,\r\n          timestamp: worker.spawnedAt,\r\n        });\r\n      });\r\n\r\n      // Batch memory operations\r\n      await Promise.all([\r\n        this.mcpWrapper.storeMemory(this.state.swarmId, 'workers', workers, 'system'),\r\n        this.mcpWrapper.storeMemory(\r\n          this.state.swarmId,\r\n          'worker_spawn_batch',\r\n          {\r\n            count: workers.length,\r\n            types: workerTypes,\r\n            spawnTime: Date.now() - startTime,\r\n            updates: workerUpdates,\r\n          },\r\n          'metrics',\r\n        ),\r\n      ]);\r\n\r\n      // Emit batch completion event\r\n      this.emit('workers:spawned', {\r\n        count: this.state.workers.size,\r\n        batchSize: workers.length,\r\n        spawnTime: Date.now() - startTime,\r\n        workers: workers,\r\n      });\r\n\r\n      return workers;\r\n    } catch (error) {\r\n      this.emit('error', {\r\n        type: 'spawn_batch_failed',\r\n        error,\r\n        workerTypes,\r\n        spawnTime: Date.now() - startTime,\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create and distribute task with performance optimization\r\n   */\r\n  async createTask(description, priority = 5, metadata = {}) {\r\n    const timestamp = Date.now();\r\n    const randomPart = Math.random().toString(36).substring(2, 11); // Use substring instead of substr\r\n    const taskId = `task-${timestamp}-${randomPart}`;\r\n    const createdAt = Date.now();\r\n\r\n    const task = {\r\n      id: taskId,\r\n      swarmId: this.state.swarmId,\r\n      description,\r\n      priority,\r\n      status: 'pending',\r\n      createdAt: new Date(createdAt).toISOString(),\r\n      assignedTo: null,\r\n      result: null,\r\n      metadata: {\r\n        estimatedDuration: this._estimateTaskDuration(description),\r\n        complexity: this._analyzeTaskComplexity(description),\r\n        ...metadata,\r\n      },\r\n    };\r\n\r\n    // Parallel operations: task storage, orchestration, and worker finding\r\n    const [orchestrateResult, bestWorker] = await Promise.all([\r\n      this.mcpWrapper.orchestrateTask(description, 'adaptive'),\r\n      this._findBestWorkerAsync(task),\r\n      // Store task immediately in parallel\r\n      (async () => {\r\n        this.state.tasks.set(task.id, task);\r\n        await this.mcpWrapper.storeMemory(this.state.swarmId, `task-${task.id}`, task, 'task');\r\n      })(),\r\n    ]);\r\n\r\n    task.orchestrationId = orchestrateResult[0].taskId;\r\n\r\n    this.emit('task:created', task);\r\n\r\n    // Assign task if worker available\r\n    if (bestWorker) {\r\n      // Use non-blocking assignment\r\n      setImmediate(() => this._assignTask(bestWorker.id, task.id));\r\n    }\r\n\r\n    return task;\r\n  }\r\n\r\n  /**\r\n   * Estimate task duration based on description analysis\r\n   */\r\n  _estimateTaskDuration(description) {\r\n    const words = description.toLowerCase().split(/\\s+/);\r\n    const complexityKeywords = {\r\n      simple: ['list', 'show', 'display', 'get', 'read'],\r\n      medium: ['create', 'update', 'modify', 'change', 'build'],\r\n      complex: ['analyze', 'optimize', 'refactor', 'implement', 'design'],\r\n    };\r\n\r\n    let score = 1;\r\n    for (const word of words) {\r\n      if (complexityKeywords.complex.includes(word)) score += 3;\r\n      else if (complexityKeywords.medium.includes(word)) score += 2;\r\n      else if (complexityKeywords.simple.includes(word)) score += 1;\r\n    }\r\n\r\n    return Math.min(score * 5000, 60000); // Cap at 1 minute\r\n  }\r\n\r\n  /**\r\n   * Analyze task complexity\r\n   */\r\n  _analyzeTaskComplexity(description) {\r\n    const words = description.toLowerCase().split(/\\s+/);\r\n    const indicators = {\r\n      high: ['optimize', 'refactor', 'architecture', 'design', 'algorithm'],\r\n      medium: ['implement', 'build', 'create', 'develop', 'integrate'],\r\n      low: ['list', 'show', 'get', 'read', 'display'],\r\n    };\r\n\r\n    for (const [level, keywords] of Object.entries(indicators)) {\r\n      if (keywords.some((keyword) => words.includes(keyword))) {\r\n        return level;\r\n      }\r\n    }\r\n\r\n    return 'medium';\r\n  }\r\n\r\n  /**\r\n   * Find best worker for task (optimized async version)\r\n   */\r\n  async _findBestWorkerAsync(task) {\r\n    const availableWorkers = Array.from(this.state.workers.values()).filter(\r\n      (w) => w.status === 'idle',\r\n    );\r\n\r\n    if (availableWorkers.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Use cached analysis if available\r\n    const cacheKey = `worker_match_${task.description.substring(0, 50)}`;\r\n    const cachedMatch = await this.mcpWrapper.retrieveMemory(this.state.swarmId, cacheKey);\r\n\r\n    if (cachedMatch && cachedMatch.timestamp > Date.now() - 300000) {\r\n      // 5 min cache\r\n      const cachedWorker = availableWorkers.find((w) => w.type === cachedMatch.workerType);\r\n      if (cachedWorker) return cachedWorker;\r\n    }\r\n\r\n    // Enhanced matching algorithm with performance scoring\r\n    const taskLower = task.description.toLowerCase();\r\n    const taskWords = taskLower.split(/\\s+/);\r\n\r\n    // Enhanced priority mapping with weights\r\n    const priorityMap = {\r\n      researcher: {\r\n        keywords: ['research', 'investigate', 'analyze', 'study', 'explore'],\r\n        weight: 1.2,\r\n      },\r\n      coder: {\r\n        keywords: ['code', 'implement', 'build', 'develop', 'fix', 'create', 'program'],\r\n        weight: 1.0,\r\n      },\r\n      analyst: {\r\n        keywords: ['analyze', 'data', 'metrics', 'performance', 'report', 'statistics'],\r\n        weight: 1.1,\r\n      },\r\n      tester: { keywords: ['test', 'validate', 'check', 'verify', 'quality', 'qa'], weight: 1.0 },\r\n      architect: {\r\n        keywords: ['design', 'architecture', 'structure', 'plan', 'system'],\r\n        weight: 1.3,\r\n      },\r\n      reviewer: { keywords: ['review', 'feedback', 'improve', 'refactor', 'audit'], weight: 1.0 },\r\n      optimizer: {\r\n        keywords: ['optimize', 'performance', 'speed', 'efficiency', 'enhance'],\r\n        weight: 1.4,\r\n      },\r\n      documenter: { keywords: ['document', 'explain', 'write', 'describe', 'manual'], weight: 0.9 },\r\n    };\r\n\r\n    // Calculate scores for each worker\r\n    const workerScores = availableWorkers.map((worker) => {\r\n      const typeInfo = priorityMap[worker.type] || { keywords: [], weight: 1.0 };\r\n\r\n      // Keyword matching score\r\n      const keywordScore = typeInfo.keywords.reduce((score, keyword) => {\r\n        return score + (taskWords.includes(keyword) ? 1 : 0);\r\n      }, 0);\r\n\r\n      // Performance history score\r\n      const performanceScore = worker.performance\r\n        ? worker.performance.successRate * 0.5 + (1 / (worker.performance.avgTaskTime + 1)) * 0.5\r\n        : 0.5;\r\n\r\n      // Task completion rate\r\n      const completionScore =\r\n        worker.tasksCompleted > 0 ? Math.min(worker.tasksCompleted / 10, 1) : 0;\r\n\r\n      // Combined score\r\n      const totalScore =\r\n        (keywordScore * 2 + // Keyword relevance\r\n          performanceScore * 1.5 + // Historical performance\r\n          completionScore * 1.0) * // Experience\r\n        typeInfo.weight;\r\n\r\n      return {\r\n        worker,\r\n        score: totalScore,\r\n        breakdown: {\r\n          keyword: keywordScore,\r\n          performance: performanceScore,\r\n          completion: completionScore,\r\n          weight: typeInfo.weight,\r\n        },\r\n      };\r\n    });\r\n\r\n    // Sort by score and select best\r\n    workerScores.sort((a, b) => b.score - a.score);\r\n    const bestMatch = workerScores[0];\r\n\r\n    // Cache the result for future use\r\n    if (bestMatch.score > 0) {\r\n      setImmediate(async () => {\r\n        await this.mcpWrapper.storeMemory(\r\n          this.state.swarmId,\r\n          cacheKey,\r\n          {\r\n            workerType: bestMatch.worker.type,\r\n            score: bestMatch.score,\r\n            timestamp: Date.now(),\r\n          },\r\n          'cache',\r\n        );\r\n      });\r\n    }\r\n\r\n    return bestMatch ? bestMatch.worker : availableWorkers[0];\r\n  }\r\n\r\n  /**\r\n   * Synchronous version for backward compatibility\r\n   */\r\n  _findBestWorker(task) {\r\n    const availableWorkers = Array.from(this.state.workers.values()).filter(\r\n      (w) => w.status === 'idle',\r\n    );\r\n\r\n    if (availableWorkers.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Simplified scoring for sync version\r\n    const taskLower = task.description.toLowerCase();\r\n    const priorityMap = {\r\n      researcher: ['research', 'investigate', 'analyze', 'study'],\r\n      coder: ['code', 'implement', 'build', 'develop', 'fix', 'create'],\r\n      analyst: ['analyze', 'data', 'metrics', 'performance', 'report'],\r\n      tester: ['test', 'validate', 'check', 'verify', 'quality'],\r\n      architect: ['design', 'architecture', 'structure', 'plan'],\r\n      reviewer: ['review', 'feedback', 'improve', 'refactor'],\r\n      optimizer: ['optimize', 'performance', 'speed', 'efficiency'],\r\n      documenter: ['document', 'explain', 'write', 'describe'],\r\n    };\r\n\r\n    let bestWorker = null;\r\n    let bestScore = 0;\r\n\r\n    for (const worker of availableWorkers) {\r\n      const keywords = priorityMap[worker.type] || [];\r\n      const keywordScore = keywords.filter((k) => taskLower.includes(k)).length;\r\n      const performanceBonus = worker.performance ? worker.performance.successRate * 0.5 : 0;\r\n      const totalScore = keywordScore + performanceBonus;\r\n\r\n      if (totalScore > bestScore) {\r\n        bestScore = totalScore;\r\n        bestWorker = worker;\r\n      }\r\n    }\r\n\r\n    return bestWorker || availableWorkers[0];\r\n  }\r\n\r\n  /**\r\n   * Assign task to worker\r\n   */\r\n  async _assignTask(workerId, taskId) {\r\n    const worker = this.state.workers.get(workerId);\r\n    const task = this.state.tasks.get(taskId);\r\n\r\n    if (!worker || !task) return;\r\n\r\n    worker.status = 'busy';\r\n    worker.currentTask = taskId;\r\n    task.status = 'in_progress';\r\n    task.assignedTo = workerId;\r\n\r\n    // Store assignment in memory\r\n    await this.mcpWrapper.storeMemory(\r\n      this.state.swarmId,\r\n      `assignment-${taskId}`,\r\n      { workerId, taskId, timestamp: Date.now() },\r\n      'task',\r\n    );\r\n\r\n    this.emit('task:assigned', { workerId, taskId });\r\n\r\n    // Simulate task execution\r\n    this._executeTask(workerId, taskId);\r\n  }\r\n\r\n  /**\r\n   * Execute task with performance optimization\r\n   */\r\n  async _executeTask(workerId, taskId) {\r\n    const worker = this.state.workers.get(workerId);\r\n    const task = this.state.tasks.get(taskId);\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Use performance optimizer for async execution\r\n      const result = await this.performanceOptimizer.optimizeAsyncOperation(\r\n        async () => {\r\n          // Simulate task execution based on complexity\r\n          const baseDuration = {\r\n            low: 5000,\r\n            medium: 15000,\r\n            high: 30000,\r\n          }[task.metadata?.complexity || 'medium'];\r\n\r\n          const duration = baseDuration + Math.random() * baseDuration * 0.5;\r\n\r\n          return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n              resolve({\r\n                status: 'completed',\r\n                result: `Task completed by ${worker.type} worker`,\r\n                processingTime: Date.now() - startTime,\r\n                complexity: task.metadata?.complexity || 'medium',\r\n              });\r\n            }, duration);\r\n          });\r\n        },\r\n        { priority: task.priority },\r\n      );\r\n\r\n      // Update task and worker\r\n      task.status = 'completed';\r\n      task.completedAt = new Date().toISOString();\r\n      task.result = result.result;\r\n      task.actualDuration = result.processingTime;\r\n\r\n      worker.status = 'idle';\r\n      worker.currentTask = null;\r\n      worker.tasksCompleted++;\r\n\r\n      // Update worker performance metrics\r\n      if (!worker.performance.avgTaskTime) {\r\n        worker.performance.avgTaskTime = result.processingTime;\r\n      } else {\r\n        worker.performance.avgTaskTime =\r\n          (worker.performance.avgTaskTime * (worker.tasksCompleted - 1) + result.processingTime) /\r\n          worker.tasksCompleted;\r\n      }\r\n\r\n      // Batch store results for better performance\r\n      await this.performanceOptimizer.optimizeBatchOperation(\r\n        'task_results',\r\n        {\r\n          key: `result-${taskId}`,\r\n          value: task,\r\n          type: 'result',\r\n        },\r\n        async (items) => {\r\n          // Batch store all results\r\n          await Promise.all(\r\n            items.map((item) =>\r\n              this.mcpWrapper.storeMemory(this.state.swarmId, item.key, item.value, item.type),\r\n            ),\r\n          );\r\n          return items.map(() => ({ success: true }));\r\n        },\r\n      );\r\n\r\n      this.emit('task:completed', task);\r\n      this.emit('worker:idle', workerId);\r\n    } catch (error) {\r\n      // Handle task failure\r\n      task.status = 'failed';\r\n      task.error = error.message;\r\n      task.failedAt = new Date().toISOString();\r\n\r\n      worker.status = 'idle';\r\n      worker.currentTask = null;\r\n      worker.performance.successRate =\r\n        (worker.performance.successRate * worker.tasksCompleted) / (worker.tasksCompleted + 1);\r\n\r\n      this.emit('task:failed', { task, error });\r\n      this.emit('worker:idle', workerId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign next task to idle worker\r\n   */\r\n  _assignNextTask(workerId) {\r\n    const pendingTasks = Array.from(this.state.tasks.values())\r\n      .filter((t) => t.status === 'pending')\r\n      .sort((a, b) => b.priority - a.priority);\r\n\r\n    if (pendingTasks.length > 0) {\r\n      this._assignTask(workerId, pendingTasks[0].id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build consensus for decision\r\n   */\r\n  async buildConsensus(topic, options) {\r\n    const decision = {\r\n      id: `decision-${Date.now()}`,\r\n      swarmId: this.state.swarmId,\r\n      topic,\r\n      options,\r\n      votes: new Map(),\r\n      algorithm: this.config.consensusAlgorithm,\r\n      status: 'voting',\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n\r\n    this.state.decisions.set(decision.id, decision);\r\n\r\n    // Simulate voting process\r\n    const workers = Array.from(this.state.workers.values());\r\n    const votes = {};\r\n\r\n    // Each worker votes\r\n    workers.forEach((worker) => {\r\n      const vote = options[Math.floor(Math.random() * options.length)];\r\n      votes[worker.id] = vote;\r\n      decision.votes.set(worker.id, vote);\r\n    });\r\n\r\n    // Queen gets weighted vote\r\n    const queenVote = options[Math.floor(Math.random() * options.length)];\r\n    votes['queen'] = queenVote;\r\n    decision.votes.set('queen', queenVote);\r\n\r\n    // Calculate consensus\r\n    const result = this._calculateConsensus(decision);\r\n    decision.result = result.decision;\r\n    decision.confidence = result.confidence;\r\n    decision.status = 'completed';\r\n\r\n    // Convert Map to plain object for proper JSON serialization\r\n    const decisionForStorage = {\r\n      ...decision,\r\n      votes: decision.votes instanceof Map ? Object.fromEntries(decision.votes) : decision.votes,\r\n    };\r\n\r\n    // Store decision in memory\r\n    await this.mcpWrapper.storeMemory(\r\n      this.state.swarmId,\r\n      `decision-${decision.id}`,\r\n      decisionForStorage,\r\n      'consensus',\r\n    );\r\n\r\n    this.emit('decision:reached', decision);\r\n    return decision;\r\n  }\r\n\r\n  /**\r\n   * Calculate consensus based on algorithm\r\n   */\r\n  _calculateConsensus(decision) {\r\n    const votes = Array.from(decision.votes.values());\r\n    const voteCount = {};\r\n\r\n    // Count votes\r\n    votes.forEach((vote) => {\r\n      voteCount[vote] = (voteCount[vote] || 0) + 1;\r\n    });\r\n\r\n    switch (decision.algorithm) {\r\n      case 'majority':\r\n        // Simple majority\r\n        const sorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);\r\n        const winner = sorted[0];\r\n        return {\r\n          decision: winner[0],\r\n          confidence: winner[1] / votes.length,\r\n        };\r\n\r\n      case 'weighted':\r\n        // Weight queen vote more heavily\r\n        const queenVote = decision.votes.get('queen');\r\n        voteCount[queenVote] = (voteCount[queenVote] || 0) + 2; // Queen counts as 3 votes\r\n\r\n        const weightedSorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);\r\n        const weightedWinner = weightedSorted[0];\r\n        return {\r\n          decision: weightedWinner[0],\r\n          confidence: weightedWinner[1] / (votes.length + 2),\r\n        };\r\n\r\n      case 'byzantine':\r\n        // Requires 2/3 majority\r\n        const byzantineSorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);\r\n        const byzantineWinner = byzantineSorted[0];\r\n        const byzantineConfidence = byzantineWinner[1] / votes.length;\r\n\r\n        if (byzantineConfidence >= 0.67) {\r\n          return {\r\n            decision: byzantineWinner[0],\r\n            confidence: byzantineConfidence,\r\n          };\r\n        } else {\r\n          return {\r\n            decision: 'no_consensus',\r\n            confidence: 0,\r\n          };\r\n        }\r\n\r\n      default:\r\n        return {\r\n          decision: 'unknown',\r\n          confidence: 0,\r\n        };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if auto-scaling is needed\r\n   */\r\n  async _checkAutoScale() {\r\n    if (!this.config.autoScale) return;\r\n\r\n    const pendingTasks = Array.from(this.state.tasks.values()).filter(\r\n      (t) => t.status === 'pending',\r\n    ).length;\r\n\r\n    const idleWorkers = Array.from(this.state.workers.values()).filter(\r\n      (w) => w.status === 'idle',\r\n    ).length;\r\n\r\n    // Scale up if too many pending tasks\r\n    if (pendingTasks > idleWorkers * 2 && this.state.workers.size < this.config.maxWorkers) {\r\n      const newWorkerType = this._determineWorkerType();\r\n      await this.spawnWorkers([newWorkerType]);\r\n      console.log(`Auto-scaled: Added ${newWorkerType} worker`);\r\n    }\r\n\r\n    // Scale down if too many idle workers\r\n    if (idleWorkers > pendingTasks + 2 && this.state.workers.size > 2) {\r\n      // TODO: Implement worker removal\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine worker type for auto-scaling\r\n   */\r\n  _determineWorkerType() {\r\n    // Analyze pending tasks to determine needed worker type\r\n    const pendingTasks = Array.from(this.state.tasks.values()).filter(\r\n      (t) => t.status === 'pending',\r\n    );\r\n\r\n    // Simple heuristic based on task descriptions\r\n    const typeScores = {};\r\n\r\n    pendingTasks.forEach((task) => {\r\n      const taskLower = task.description.toLowerCase();\r\n\r\n      if (taskLower.includes('code') || taskLower.includes('implement')) {\r\n        typeScores.coder = (typeScores.coder || 0) + 1;\r\n      }\r\n      if (taskLower.includes('test') || taskLower.includes('validate')) {\r\n        typeScores.tester = (typeScores.tester || 0) + 1;\r\n      }\r\n      if (taskLower.includes('analyze') || taskLower.includes('data')) {\r\n        typeScores.analyst = (typeScores.analyst || 0) + 1;\r\n      }\r\n      if (taskLower.includes('research') || taskLower.includes('investigate')) {\r\n        typeScores.researcher = (typeScores.researcher || 0) + 1;\r\n      }\r\n    });\r\n\r\n    // Return type with highest score\r\n    const sorted = Object.entries(typeScores).sort((a, b) => b[1] - a[1]);\r\n    return sorted.length > 0 ? sorted[0][0] : 'coder'; // Default to coder\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   */\r\n  async _updatePerformanceMetrics() {\r\n    // Calculate performance metrics\r\n    const completionRate = this.state.metrics.tasksCompleted / this.state.metrics.tasksCreated;\r\n    const avgTasksPerWorker = this.state.metrics.tasksCompleted / this.state.workers.size;\r\n\r\n    // Store metrics in memory\r\n    await this.mcpWrapper.storeMemory(\r\n      this.state.swarmId,\r\n      'metrics',\r\n      {\r\n        ...this.state.metrics,\r\n        completionRate,\r\n        avgTasksPerWorker,\r\n        timestamp: Date.now(),\r\n      },\r\n      'metrics',\r\n    );\r\n\r\n    // Analyze performance if needed\r\n    if (this.state.metrics.tasksCompleted % 10 === 0) {\r\n      await this.mcpWrapper.analyzePerformance(this.state.swarmId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle errors\r\n   */\r\n  _handleError(error) {\r\n    // Log error to memory\r\n    this.mcpWrapper\r\n      .storeMemory(\r\n        this.state.swarmId,\r\n        `error-${Date.now()}`,\r\n        {\r\n          message: error.message,\r\n          stack: error.stack,\r\n          timestamp: Date.now(),\r\n        },\r\n        'error',\r\n      )\r\n      .catch(console.error);\r\n  }\r\n\r\n  /**\r\n   * Get current status with performance metrics\r\n   */\r\n  getStatus() {\r\n    const tasks = Array.from(this.state.tasks.values());\r\n    const workers = Array.from(this.state.workers.values());\r\n\r\n    return {\r\n      swarmId: this.state.swarmId,\r\n      status: this.state.status,\r\n      queen: this.state.queen,\r\n      workers: workers,\r\n      tasks: {\r\n        total: this.state.tasks.size,\r\n        pending: tasks.filter((t) => t.status === 'pending').length,\r\n        inProgress: tasks.filter((t) => t.status === 'in_progress').length,\r\n        completed: tasks.filter((t) => t.status === 'completed').length,\r\n        failed: tasks.filter((t) => t.status === 'failed').length,\r\n      },\r\n      metrics: {\r\n        ...this.state.metrics,\r\n        averageTaskTime: this._calculateAverageTaskTime(tasks),\r\n        workerEfficiency: this._calculateWorkerEfficiency(workers),\r\n        throughput: this._calculateThroughput(tasks),\r\n      },\r\n      decisions: this.state.decisions.size,\r\n      performance: this.performanceOptimizer.getPerformanceStats(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate average task completion time\r\n   */\r\n  _calculateAverageTaskTime(tasks) {\r\n    const completedTasks = tasks.filter((t) => t.status === 'completed' && t.actualDuration);\r\n    if (completedTasks.length === 0) return 0;\r\n\r\n    const totalTime = completedTasks.reduce((sum, task) => sum + task.actualDuration, 0);\r\n    return Math.round(totalTime / completedTasks.length);\r\n  }\r\n\r\n  /**\r\n   * Calculate worker efficiency\r\n   */\r\n  _calculateWorkerEfficiency(workers) {\r\n    if (workers.length === 0) return 0;\r\n\r\n    const efficiencies = workers.map((worker) => worker.performance?.successRate || 1.0);\r\n    return ((efficiencies.reduce((sum, eff) => sum + eff, 0) / workers.length) * 100).toFixed(2);\r\n  }\r\n\r\n  /**\r\n   * Calculate system throughput (tasks per minute)\r\n   */\r\n  _calculateThroughput(tasks) {\r\n    const completedTasks = tasks.filter((t) => t.status === 'completed' && t.completedAt);\r\n    if (completedTasks.length < 2) return 0;\r\n\r\n    const firstCompleted = new Date(completedTasks[0].completedAt).getTime();\r\n    const lastCompleted = new Date(completedTasks[completedTasks.length - 1].completedAt).getTime();\r\n    const timeSpanMinutes = (lastCompleted - firstCompleted) / (1000 * 60);\r\n\r\n    return timeSpanMinutes > 0 ? (completedTasks.length / timeSpanMinutes).toFixed(2) : 0;\r\n  }\r\n\r\n  /**\r\n   * Shutdown hive mind with cleanup\r\n   */\r\n  async shutdown() {\r\n    this.state.status = 'shutting_down';\r\n\r\n    try {\r\n      // Generate final performance report\r\n      const performanceReport = this.performanceOptimizer.generatePerformanceReport();\r\n\r\n      // Save final state and performance report\r\n      await Promise.all([\r\n        this.mcpWrapper.storeMemory(this.state.swarmId, 'final_state', this.getStatus(), 'system'),\r\n        this.mcpWrapper.storeMemory(\r\n          this.state.swarmId,\r\n          'final_performance_report',\r\n          performanceReport,\r\n          'metrics',\r\n        ),\r\n      ]);\r\n\r\n      // Close performance optimizer\r\n      await this.performanceOptimizer.close();\r\n\r\n      // Destroy swarm\r\n      await this.mcpWrapper.destroySwarm(this.state.swarmId);\r\n\r\n      this.state.status = 'shutdown';\r\n      this.emit('shutdown', { performanceReport });\r\n    } catch (error) {\r\n      this.emit('error', { type: 'shutdown_failed', error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get performance insights and recommendations\r\n   */\r\n  getPerformanceInsights() {\r\n    return this.performanceOptimizer.generatePerformanceReport();\r\n  }\r\n}\r\n"],"names":["EventEmitter","MCPToolWrapper","PerformanceOptimizer","HiveMindCore","config","objective","name","Date","now","queenType","maxWorkers","consensusAlgorithm","autoScale","encryption","memorySize","taskTimeout","state","status","swarmId","queen","workers","Map","tasks","memory","decisions","metrics","tasksCreated","tasksCompleted","decisionsReached","memoryUsage","mcpWrapper","parallel","timeout","performanceOptimizer","enableAsyncQueue","enableBatchProcessing","enableAutoTuning","asyncQueueConcurrency","Math","min","batchMaxSize","metricsInterval","_initializeEventHandlers","_initializePerformanceMonitoring","on","task","_checkAutoScale","_updatePerformanceMetrics","data","console","warn","id","error","_handleTaskFailure","decision","workerId","_assignNextTask","_handleError","emit","type","setInterval","stats","getPerformanceStats","parseFloat","asyncQueue","utilization","successRate","tasksFailed","retryCount","_isRecoverableError","setTimeout","worker","_findBestWorker","_assignTask","log","recoverableErrors","some","message","toLowerCase","includes","initialize","swarmInit","memoryInit","neuralInit","initializeSwarm","topology","_determineTopology","maxAgents","storeMemory","spawnQueen","queenData","spawnResult","spawnAgents","agentId","spawnWorkers","workerTypes","startTime","chunkSize","length","chunks","i","push","slice","allResults","Promise","all","map","chunk","spawnResults","flat","workerUpdates","forEach","result","index","currentTask","spawnedAt","performance","avgTaskTime","set","workerType","timestamp","count","types","spawnTime","updates","size","batchSize","createTask","description","priority","metadata","randomPart","random","toString","substring","taskId","createdAt","toISOString","assignedTo","estimatedDuration","_estimateTaskDuration","complexity","_analyzeTaskComplexity","orchestrateResult","bestWorker","orchestrateTask","_findBestWorkerAsync","orchestrationId","setImmediate","words","split","complexityKeywords","simple","medium","complex","score","word","indicators","high","low","level","keywords","Object","entries","keyword","availableWorkers","Array","from","values","filter","w","cacheKey","cachedMatch","retrieveMemory","cachedWorker","find","taskLower","taskWords","priorityMap","researcher","weight","coder","analyst","tester","architect","reviewer","optimizer","documenter","workerScores","typeInfo","keywordScore","reduce","performanceScore","completionScore","totalScore","breakdown","completion","sort","a","b","bestMatch","bestScore","k","performanceBonus","get","_executeTask","optimizeAsyncOperation","baseDuration","duration","resolve","processingTime","completedAt","actualDuration","optimizeBatchOperation","key","value","items","item","success","failedAt","pendingTasks","t","buildConsensus","topic","options","votes","algorithm","vote","floor","queenVote","_calculateConsensus","confidence","decisionForStorage","fromEntries","voteCount","sorted","winner","weightedSorted","weightedWinner","byzantineSorted","byzantineWinner","byzantineConfidence","idleWorkers","newWorkerType","_determineWorkerType","typeScores","completionRate","avgTasksPerWorker","analyzePerformance","stack","catch","getStatus","total","pending","inProgress","completed","failed","averageTaskTime","_calculateAverageTaskTime","workerEfficiency","_calculateWorkerEfficiency","throughput","_calculateThroughput","completedTasks","totalTime","sum","round","efficiencies","eff","toFixed","firstCompleted","getTime","lastCompleted","timeSpanMinutes","shutdown","performanceReport","generatePerformanceReport","close","destroySwarm","getPerformanceInsights"],"mappings":"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"}