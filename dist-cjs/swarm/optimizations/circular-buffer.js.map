{
  "version": 3,
  "sources": ["../../../src/swarm/optimizations/circular-buffer.ts"],
  "sourcesContent": ["/**\n * Circular Buffer Implementation\n * Fixed-size buffer that overwrites oldest entries when full\n */\n\nexport class CircularBuffer<T> {\n  private buffer: (T | undefined)[];\n  private writeIndex = 0;\n  private size = 0;\n  private totalItemsWritten = 0;\n\n  constructor(private capacity: number) {\n    if (capacity <= 0) {\n      throw new Error('Capacity must be greater than 0');\n    }\n    this.buffer = new Array(capacity);\n  }\n\n  push(item: T): void {\n    this.buffer[this.writeIndex] = item;\n    this.writeIndex = (this.writeIndex + 1) % this.capacity;\n    this.size = Math.min(this.size + 1, this.capacity);\n    this.totalItemsWritten++;\n  }\n\n  pushMany(items: T[]): void {\n    for (const item of items) {\n      this.push(item);\n    }\n  }\n\n  get(index: number): T | undefined {\n    if (index < 0 || index >= this.size) {\n      return undefined;\n    }\n\n    // Calculate actual buffer index based on current state\n    const actualIndex =\n      this.size < this.capacity ? index : (this.writeIndex + index) % this.capacity;\n\n    return this.buffer[actualIndex];\n  }\n\n  getRecent(count: number): T[] {\n    const result: T[] = [];\n    const itemsToReturn = Math.min(count, this.size);\n\n    // Calculate starting position for most recent items\n    const start =\n      this.size < this.capacity\n        ? Math.max(0, this.size - itemsToReturn)\n        : (this.writeIndex - itemsToReturn + this.capacity) % this.capacity;\n\n    for (let i = 0; i < itemsToReturn; i++) {\n      const index = (start + i) % this.capacity;\n      const item = this.buffer[index];\n      if (item !== undefined) {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n\n  getAll(): T[] {\n    const result: T[] = [];\n\n    if (this.size < this.capacity) {\n      // Buffer not full yet, return items in order\n      for (let i = 0; i < this.size; i++) {\n        const item = this.buffer[i];\n        if (item !== undefined) {\n          result.push(item);\n        }\n      }\n    } else {\n      // Buffer is full, start from oldest item\n      for (let i = 0; i < this.capacity; i++) {\n        const index = (this.writeIndex + i) % this.capacity;\n        const item = this.buffer[index];\n        if (item !== undefined) {\n          result.push(item);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  find(predicate: (item: T) => boolean): T | undefined {\n    const all = this.getAll();\n    return all.find(predicate);\n  }\n\n  filter(predicate: (item: T) => boolean): T[] {\n    const all = this.getAll();\n    return all.filter(predicate);\n  }\n\n  clear(): void {\n    this.buffer = new Array(this.capacity);\n    this.writeIndex = 0;\n    this.size = 0;\n  }\n\n  isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  isFull(): boolean {\n    return this.size === this.capacity;\n  }\n\n  getSize(): number {\n    return this.size;\n  }\n\n  getCapacity(): number {\n    return this.capacity;\n  }\n\n  getTotalItemsWritten(): number {\n    return this.totalItemsWritten;\n  }\n\n  getOverwrittenCount(): number {\n    return Math.max(0, this.totalItemsWritten - this.capacity);\n  }\n\n  /**\n   * Get estimated memory usage of the buffer\n   */\n  getMemoryUsage(): number {\n    if (this.size === 0) return 0;\n\n    // Sample first item to estimate size\n    const sample = this.buffer[0];\n    if (sample === undefined) return 0;\n\n    try {\n      // Rough estimation based on JSON serialization\n      const sampleSize = JSON.stringify(sample).length * 2; // 2 bytes per character\n      return sampleSize * this.size;\n    } catch {\n      // If serialization fails, return a default estimate\n      return this.size * 1024; // 1KB per item default\n    }\n  }\n\n  /**\n   * Create a snapshot of the current buffer state\n   */\n  snapshot(): {\n    items: T[];\n    capacity: number;\n    size: number;\n    totalItemsWritten: number;\n    overwrittenCount: number;\n    memoryUsage: number;\n  } {\n    return {\n      items: this.getAll(),\n      capacity: this.capacity,\n      size: this.size,\n      totalItemsWritten: this.totalItemsWritten,\n      overwrittenCount: this.getOverwrittenCount(),\n      memoryUsage: this.getMemoryUsage(),\n    };\n  }\n\n  /**\n   * Resize the buffer (creates a new buffer with the new capacity)\n   */\n  resize(newCapacity: number): void {\n    if (newCapacity <= 0) {\n      throw new Error('New capacity must be greater than 0');\n    }\n\n    const items = this.getAll();\n    this.capacity = newCapacity;\n    this.buffer = new Array(newCapacity);\n    this.writeIndex = 0;\n    this.size = 0;\n\n    // Re-add items (newest items will be kept if newCapacity < items.length)\n    const itemsToKeep = items.slice(-newCapacity);\n    this.pushMany(itemsToKeep);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
