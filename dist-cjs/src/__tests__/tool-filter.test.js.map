{"version":3,"sources":["../../../src/__tests__/tool-filter.test.ts"],"sourcesContent":["/**\n * Tool Filter Tests\n *\n * Comprehensive test suite for MCP tool filtering system.\n * Supports allowlist, denylist, category filtering, and priority-based limiting.\n */\n\nimport { describe, it, expect, beforeEach, afterEach } from '@jest/globals';\nimport type { MCPTool, MCPContext } from '../utils/types.js';\n\n// ===== Type Definitions for Tool Filter =====\n\n/**\n * Tool category definitions for semantic grouping\n */\nexport type ToolCategory =\n  | 'system'\n  | 'swarm'\n  | 'memory'\n  | 'neural'\n  | 'github'\n  | 'workflow'\n  | 'analysis'\n  | 'coordination'\n  | 'other';\n\n/**\n * Configuration for MCP tool filtering\n */\nexport interface MCPToolFilterConfig {\n  /** Whether filtering is enabled */\n  enabled: boolean;\n\n  /** Filter mode: allowlist includes only listed, denylist excludes listed */\n  mode: 'allowlist' | 'denylist';\n\n  /** Tool name patterns to match (supports glob-like patterns) */\n  patterns: string[];\n\n  /** Categories to include/exclude based on mode */\n  categories?: ToolCategory[];\n\n  /** Maximum number of tools to expose */\n  maxTools?: number;\n\n  /** Priority ordering for tools when limiting (higher = more important) */\n  toolPriorities?: Record<string, number>;\n\n  /** Enable statistics tracking */\n  trackStats?: boolean;\n}\n\n/**\n * Statistics about filter operations\n */\nexport interface FilterStats {\n  totalTools: number;\n  filteredTools: number;\n  matchedPatterns: string[];\n  filterTime: number;\n  lastFiltered: Date;\n}\n\n/**\n * Result of a filter operation\n */\nexport interface FilterResult {\n  tools: MCPTool[];\n  stats: FilterStats;\n}\n\n// ===== Tool Filter Implementation (Mock for Testing) =====\n\n/**\n * Tool Filter class for filtering MCP tools based on configuration\n */\nexport class ToolFilter {\n  private config: MCPToolFilterConfig;\n  private lastStats?: FilterStats;\n  private categoryMap: Map<string, ToolCategory> = new Map();\n\n  constructor(config: MCPToolFilterConfig) {\n    this.config = config;\n    this.initializeCategoryMap();\n  }\n\n  /**\n   * Initialize category mapping based on tool name prefixes\n   */\n  private initializeCategoryMap(): void {\n    // Category detection patterns\n    const categoryPatterns: Record<string, ToolCategory> = {\n      'swarm_': 'swarm',\n      'agent_': 'swarm',\n      'memory_': 'memory',\n      'neural_': 'neural',\n      'github_': 'github',\n      'workflow_': 'workflow',\n      'task_': 'coordination',\n      'daa_': 'coordination',\n      'benchmark_': 'analysis',\n      'features_': 'system',\n      'system_': 'system',\n    };\n\n    this.categoryMap = new Map(Object.entries(categoryPatterns));\n  }\n\n  /**\n   * Get the category for a tool based on its name\n   */\n  getToolCategory(toolName: string): ToolCategory {\n    for (const [prefix, category] of this.categoryMap.entries()) {\n      if (toolName.startsWith(prefix)) {\n        return category;\n      }\n    }\n    return 'other';\n  }\n\n  /**\n   * Check if a tool name matches a pattern\n   * Supports glob-like patterns: * (any), ? (single char)\n   */\n  matchPattern(toolName: string, pattern: string): boolean {\n    // Exact match\n    if (pattern === toolName) {\n      return true;\n    }\n\n    // Wildcard match\n    if (pattern === '*') {\n      return true;\n    }\n\n    // Convert glob pattern to regex\n    const regexPattern = pattern\n      .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape special regex chars\n      .replace(/\\*/g, '.*')  // * matches any characters\n      .replace(/\\?/g, '.');  // ? matches single character\n\n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(toolName);\n  }\n\n  /**\n   * Filter tools based on configuration\n   */\n  filter(tools: MCPTool[]): FilterResult {\n    const startTime = performance.now();\n\n    // If filtering is disabled, return all tools\n    if (!this.config.enabled) {\n      const stats: FilterStats = {\n        totalTools: tools.length,\n        filteredTools: tools.length,\n        matchedPatterns: [],\n        filterTime: performance.now() - startTime,\n        lastFiltered: new Date(),\n      };\n      this.lastStats = stats;\n      return { tools, stats };\n    }\n\n    const matchedPatterns: string[] = [];\n    let filteredTools: MCPTool[];\n\n    if (this.config.mode === 'allowlist') {\n      // Allowlist mode: only include tools matching patterns\n      filteredTools = tools.filter(tool => {\n        const matches = this.config.patterns.some(pattern => {\n          const isMatch = this.matchPattern(tool.name, pattern);\n          if (isMatch && !matchedPatterns.includes(pattern)) {\n            matchedPatterns.push(pattern);\n          }\n          return isMatch;\n        });\n\n        // Also check category filter if specified\n        if (matches && this.config.categories && this.config.categories.length > 0) {\n          const category = this.getToolCategory(tool.name);\n          return this.config.categories.includes(category);\n        }\n\n        return matches;\n      });\n    } else {\n      // Denylist mode: exclude tools matching patterns\n      filteredTools = tools.filter(tool => {\n        const shouldExclude = this.config.patterns.some(pattern => {\n          const isMatch = this.matchPattern(tool.name, pattern);\n          if (isMatch && !matchedPatterns.includes(pattern)) {\n            matchedPatterns.push(pattern);\n          }\n          return isMatch;\n        });\n\n        // Also check category filter if specified (exclude matching categories)\n        if (!shouldExclude && this.config.categories && this.config.categories.length > 0) {\n          const category = this.getToolCategory(tool.name);\n          return !this.config.categories.includes(category);\n        }\n\n        return !shouldExclude;\n      });\n    }\n\n    // Apply maxTools limit with priority ordering\n    if (this.config.maxTools && filteredTools.length > this.config.maxTools) {\n      const priorities = this.config.toolPriorities || {};\n\n      // Sort by priority (higher first), then by name for stable ordering\n      filteredTools.sort((a, b) => {\n        const priorityA = priorities[a.name] ?? 0;\n        const priorityB = priorities[b.name] ?? 0;\n        if (priorityA !== priorityB) {\n          return priorityB - priorityA; // Higher priority first\n        }\n        return a.name.localeCompare(b.name);\n      });\n\n      filteredTools = filteredTools.slice(0, this.config.maxTools);\n    }\n\n    const stats: FilterStats = {\n      totalTools: tools.length,\n      filteredTools: filteredTools.length,\n      matchedPatterns,\n      filterTime: performance.now() - startTime,\n      lastFiltered: new Date(),\n    };\n\n    this.lastStats = stats;\n    return { tools: filteredTools, stats };\n  }\n\n  /**\n   * Get the last filter statistics\n   */\n  getStats(): FilterStats | undefined {\n    return this.lastStats;\n  }\n\n  /**\n   * Update filter configuration\n   */\n  updateConfig(config: Partial<MCPToolFilterConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Get current configuration (deep copy to prevent mutation)\n   */\n  getConfig(): MCPToolFilterConfig {\n    return {\n      ...this.config,\n      patterns: [...this.config.patterns],\n      categories: this.config.categories ? [...this.config.categories] : undefined,\n      toolPriorities: this.config.toolPriorities\n        ? { ...this.config.toolPriorities }\n        : undefined,\n    };\n  }\n}\n\n/**\n * Factory function to create a ToolFilter instance\n */\nexport function createToolFilter(config: MCPToolFilterConfig): ToolFilter {\n  return new ToolFilter(config);\n}\n\n// ===== Test Helpers =====\n\n/**\n * Create a mock MCP tool with the given name\n */\nfunction createMockTool(name: string, description?: string): MCPTool {\n  return {\n    name,\n    description: description ?? `Description for ${name}`,\n    inputSchema: { type: 'object', properties: {} },\n    handler: async () => ({}),\n  };\n}\n\n/**\n * Create a set of mock tools for testing\n */\nfunction createMockToolSet(): MCPTool[] {\n  return [\n    createMockTool('swarm_init'),\n    createMockTool('swarm_status'),\n    createMockTool('swarm_monitor'),\n    createMockTool('agent_spawn'),\n    createMockTool('agent_list'),\n    createMockTool('agent_metrics'),\n    createMockTool('memory_usage'),\n    createMockTool('memory_search'),\n    createMockTool('memory_persist'),\n    createMockTool('neural_status'),\n    createMockTool('neural_train'),\n    createMockTool('neural_patterns'),\n    createMockTool('github_repo_analyze'),\n    createMockTool('github_pr_manage'),\n    createMockTool('workflow_create'),\n    createMockTool('workflow_execute'),\n    createMockTool('task_orchestrate'),\n    createMockTool('task_status'),\n    createMockTool('daa_agent_create'),\n    createMockTool('benchmark_run'),\n    createMockTool('features_detect'),\n    createMockTool('system_health'),\n  ];\n}\n\n// ===== Tests =====\n\ndescribe('ToolFilter', () => {\n  let mockTools: MCPTool[];\n\n  beforeEach(() => {\n    mockTools = createMockToolSet();\n  });\n\n  afterEach(() => {\n    // Clear any mock state if needed\n  });\n\n  describe('No Filtering (Disabled)', () => {\n    it('should return all tools when filtering is disabled', () => {\n      const filter = createToolFilter({\n        enabled: false,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(mockTools.length);\n      expect(result.tools).toEqual(mockTools);\n      expect(result.stats.totalTools).toBe(mockTools.length);\n      expect(result.stats.filteredTools).toBe(mockTools.length);\n    });\n\n    it('should track timing even when disabled', () => {\n      const filter = createToolFilter({\n        enabled: false,\n        mode: 'allowlist',\n        patterns: [],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.filterTime).toBeGreaterThanOrEqual(0);\n      expect(result.stats.lastFiltered).toBeInstanceOf(Date);\n    });\n  });\n\n  describe('Allowlist Mode - Exact Matching', () => {\n    it('should include only exactly matched tools', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_init', 'swarm_status'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(2);\n      expect(result.tools.map(t => t.name)).toEqual(['swarm_init', 'swarm_status']);\n    });\n\n    it('should return empty array when no tools match', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['nonexistent_tool'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(0);\n      expect(result.stats.filteredTools).toBe(0);\n    });\n  });\n\n  describe('Allowlist Mode - Glob Pattern Matching', () => {\n    it('should match tools using wildcard pattern', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t => t.name.startsWith('swarm_'))).toBe(true);\n      expect(result.tools.map(t => t.name)).toEqual([\n        'swarm_init',\n        'swarm_status',\n        'swarm_monitor',\n      ]);\n    });\n\n    it('should match tools using multiple wildcard patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*', 'agent_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(6);\n      expect(result.tools.every(t =>\n        t.name.startsWith('swarm_') || t.name.startsWith('agent_')\n      )).toBe(true);\n    });\n\n    it('should match all tools with global wildcard', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(mockTools.length);\n    });\n\n    it('should handle complex patterns with prefix and suffix', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*_status'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t => t.name.endsWith('_status'))).toBe(true);\n      expect(result.tools.map(t => t.name)).toEqual([\n        'swarm_status',\n        'neural_status',\n        'task_status',\n      ]);\n    });\n\n    it('should match middle wildcard patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*_*_*'],  // Tools with at least 2 underscores\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t =>\n        t.name.split('_').length >= 3\n      )).toBe(true);\n    });\n  });\n\n  describe('Denylist Mode', () => {\n    it('should exclude exactly matched tools', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['swarm_init', 'swarm_status'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.some(t => t.name === 'swarm_init')).toBe(false);\n      expect(result.tools.some(t => t.name === 'swarm_status')).toBe(false);\n      expect(result.tools).toHaveLength(mockTools.length - 2);\n    });\n\n    it('should exclude tools matching wildcard patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['swarm_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t => !t.name.startsWith('swarm_'))).toBe(true);\n      expect(result.tools).toHaveLength(mockTools.length - 3);\n    });\n\n    it('should exclude all tools with global wildcard', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(0);\n    });\n\n    it('should exclude multiple pattern groups', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: ['swarm_*', 'agent_*', 'neural_*'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t =>\n        !t.name.startsWith('swarm_') &&\n        !t.name.startsWith('agent_') &&\n        !t.name.startsWith('neural_')\n      )).toBe(true);\n      // Original has 3 swarm, 3 agent, 3 neural = 9 tools to exclude\n      expect(result.tools).toHaveLength(mockTools.length - 9);\n    });\n  });\n\n  describe('Category Filtering', () => {\n    it('should filter by category in allowlist mode', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        categories: ['swarm'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // swarm_* and agent_* both map to 'swarm' category\n      expect(result.tools.every(t =>\n        t.name.startsWith('swarm_') || t.name.startsWith('agent_')\n      )).toBe(true);\n    });\n\n    it('should filter by multiple categories', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        categories: ['swarm', 'memory'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Should include swarm, agent (swarm category) and memory tools\n      const toolNames = result.tools.map(t => t.name);\n      expect(toolNames.some(n => n.startsWith('swarm_'))).toBe(true);\n      expect(toolNames.some(n => n.startsWith('agent_'))).toBe(true);\n      expect(toolNames.some(n => n.startsWith('memory_'))).toBe(true);\n    });\n\n    it('should exclude categories in denylist mode', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: [],  // No pattern exclusions\n        categories: ['neural', 'github'],\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools.every(t =>\n        !t.name.startsWith('neural_') && !t.name.startsWith('github_')\n      )).toBe(true);\n    });\n\n    it('should correctly detect tool categories', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n      });\n\n      expect(filter.getToolCategory('swarm_init')).toBe('swarm');\n      expect(filter.getToolCategory('agent_spawn')).toBe('swarm');\n      expect(filter.getToolCategory('memory_usage')).toBe('memory');\n      expect(filter.getToolCategory('neural_train')).toBe('neural');\n      expect(filter.getToolCategory('github_pr_manage')).toBe('github');\n      expect(filter.getToolCategory('workflow_create')).toBe('workflow');\n      expect(filter.getToolCategory('task_orchestrate')).toBe('coordination');\n      expect(filter.getToolCategory('daa_agent_create')).toBe('coordination');\n      expect(filter.getToolCategory('benchmark_run')).toBe('analysis');\n      expect(filter.getToolCategory('features_detect')).toBe('system');\n      expect(filter.getToolCategory('unknown_tool')).toBe('other');\n    });\n  });\n\n  describe('maxTools Limit', () => {\n    it('should limit the number of tools returned', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 5,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(5);\n    });\n\n    it('should not affect result when under limit', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n        maxTools: 10,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.tools).toHaveLength(3); // Only 3 swarm tools\n    });\n\n    it('should maintain stable ordering when limiting', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 5,\n      });\n\n      const result1 = filter.filter(mockTools);\n      const result2 = filter.filter(mockTools);\n\n      expect(result1.tools.map(t => t.name)).toEqual(result2.tools.map(t => t.name));\n    });\n  });\n\n  describe('Priority Ordering', () => {\n    it('should order tools by priority when limiting', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 3,\n        toolPriorities: {\n          'neural_train': 100,\n          'swarm_init': 50,\n          'memory_usage': 75,\n        },\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Should include highest priority tools\n      const names = result.tools.map(t => t.name);\n      expect(names).toContain('neural_train');\n      expect(names).toContain('memory_usage');\n      expect(names).toContain('swarm_init');\n    });\n\n    it('should use name ordering for tools without explicit priority', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        maxTools: 5,\n        toolPriorities: {\n          'neural_train': 100, // Only this has priority\n        },\n      });\n\n      const result = filter.filter(mockTools);\n\n      // neural_train should be first due to high priority\n      expect(result.tools[0].name).toBe('neural_train');\n    });\n\n    it('should handle equal priorities by name', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*', 'agent_*'],\n        maxTools: 4,\n        toolPriorities: {\n          'swarm_init': 50,\n          'swarm_status': 50,\n          'agent_spawn': 50,\n          'agent_list': 50,\n        },\n      });\n\n      const result = filter.filter(mockTools);\n\n      // With equal priorities, should be alphabetically sorted\n      const names = result.tools.map(t => t.name);\n      const sortedNames = [...names].sort();\n      expect(names).toEqual(sortedNames);\n    });\n  });\n\n  describe('Filter Statistics Tracking', () => {\n    it('should track total and filtered tool counts', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n        trackStats: true,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.totalTools).toBe(mockTools.length);\n      expect(result.stats.filteredTools).toBe(3);\n    });\n\n    it('should track matched patterns', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*', 'agent_*', 'nonexistent_*'],\n        trackStats: true,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.matchedPatterns).toContain('swarm_*');\n      expect(result.stats.matchedPatterns).toContain('agent_*');\n      expect(result.stats.matchedPatterns).not.toContain('nonexistent_*');\n    });\n\n    it('should record filter execution time', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        trackStats: true,\n      });\n\n      const result = filter.filter(mockTools);\n\n      expect(result.stats.filterTime).toBeGreaterThanOrEqual(0);\n      expect(result.stats.filterTime).toBeLessThan(100); // Should be fast\n    });\n\n    it('should record timestamp of filter operation', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n        trackStats: true,\n      });\n\n      const before = new Date();\n      const result = filter.filter(mockTools);\n      const after = new Date();\n\n      expect(result.stats.lastFiltered.getTime()).toBeGreaterThanOrEqual(before.getTime());\n      expect(result.stats.lastFiltered.getTime()).toBeLessThanOrEqual(after.getTime());\n    });\n\n    it('should provide stats via getStats()', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n        trackStats: true,\n      });\n\n      // Before filtering, no stats\n      expect(filter.getStats()).toBeUndefined();\n\n      filter.filter(mockTools);\n\n      const stats = filter.getStats();\n      expect(stats).toBeDefined();\n      expect(stats?.filteredTools).toBe(3);\n    });\n  });\n\n  describe('Empty Tool List Handling', () => {\n    it('should handle empty input gracefully', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['*'],\n      });\n\n      const result = filter.filter([]);\n\n      expect(result.tools).toHaveLength(0);\n      expect(result.stats.totalTools).toBe(0);\n      expect(result.stats.filteredTools).toBe(0);\n    });\n\n    it('should handle empty patterns array', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: [],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Empty patterns in allowlist mode = nothing matches\n      expect(result.tools).toHaveLength(0);\n    });\n\n    it('should handle empty patterns in denylist mode', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'denylist',\n        patterns: [],\n      });\n\n      const result = filter.filter(mockTools);\n\n      // Empty patterns in denylist mode = nothing excluded\n      expect(result.tools).toHaveLength(mockTools.length);\n    });\n  });\n\n  describe('Configuration Management', () => {\n    it('should update configuration dynamically', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result1 = filter.filter(mockTools);\n      expect(result1.tools).toHaveLength(3);\n\n      filter.updateConfig({\n        patterns: ['agent_*'],\n      });\n\n      const result2 = filter.filter(mockTools);\n      expect(result2.tools).toHaveLength(3);\n      expect(result2.tools.every(t => t.name.startsWith('agent_'))).toBe(true);\n    });\n\n    it('should toggle enabled state', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result1 = filter.filter(mockTools);\n      expect(result1.tools).toHaveLength(3);\n\n      filter.updateConfig({ enabled: false });\n\n      const result2 = filter.filter(mockTools);\n      expect(result2.tools).toHaveLength(mockTools.length);\n    });\n\n    it('should switch modes', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const result1 = filter.filter(mockTools);\n      expect(result1.tools).toHaveLength(3);\n\n      filter.updateConfig({ mode: 'denylist' });\n\n      const result2 = filter.filter(mockTools);\n      expect(result2.tools).toHaveLength(mockTools.length - 3);\n    });\n\n    it('should return current config via getConfig()', () => {\n      const originalConfig: MCPToolFilterConfig = {\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['test_*'],\n        categories: ['swarm'],\n        maxTools: 10,\n      };\n\n      const filter = createToolFilter(originalConfig);\n      const config = filter.getConfig();\n\n      expect(config.enabled).toBe(true);\n      expect(config.mode).toBe('allowlist');\n      expect(config.patterns).toEqual(['test_*']);\n      expect(config.categories).toEqual(['swarm']);\n      expect(config.maxTools).toBe(10);\n    });\n\n    it('should not mutate internal config when returning', () => {\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['swarm_*'],\n      });\n\n      const config = filter.getConfig();\n      config.patterns.push('hacked_*');\n\n      // Internal config should be unchanged\n      const config2 = filter.getConfig();\n      expect(config2.patterns).toEqual(['swarm_*']);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle special characters in tool names', () => {\n      const specialTools = [\n        createMockTool('tool-with-dashes'),\n        createMockTool('tool.with.dots'),\n        createMockTool('tool_with_underscores'),\n        createMockTool('Tool123WithNumbers'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool*'],\n      });\n\n      const result = filter.filter(specialTools);\n\n      expect(result.tools).toHaveLength(3); // Matches tool- tool. tool_\n    });\n\n    it('should handle very long tool names', () => {\n      const longName = 'a'.repeat(1000);\n      const longTools = [createMockTool(longName)];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['a*'],\n      });\n\n      const result = filter.filter(longTools);\n\n      expect(result.tools).toHaveLength(1);\n    });\n\n    it('should handle many patterns efficiently', () => {\n      const patterns = Array.from({ length: 100 }, (_, i) => `pattern_${i}_*`);\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns,\n      });\n\n      const start = performance.now();\n      const result = filter.filter(mockTools);\n      const elapsed = performance.now() - start;\n\n      expect(elapsed).toBeLessThan(50); // Should complete quickly\n      expect(result.tools).toHaveLength(0); // None match\n    });\n\n    it('should handle many tools efficiently', () => {\n      const manyTools = Array.from({ length: 1000 }, (_, i) =>\n        createMockTool(`tool_${i}`)\n      );\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool_*'],\n      });\n\n      const start = performance.now();\n      const result = filter.filter(manyTools);\n      const elapsed = performance.now() - start;\n\n      expect(elapsed).toBeLessThan(100); // Should complete quickly\n      expect(result.tools).toHaveLength(1000);\n    });\n  });\n\n  describe('Pattern Edge Cases', () => {\n    it('should handle single character wildcard', () => {\n      const tools = [\n        createMockTool('tool_a'),\n        createMockTool('tool_b'),\n        createMockTool('tool_ab'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool_?'],\n      });\n\n      const result = filter.filter(tools);\n\n      expect(result.tools.map(t => t.name)).toEqual(['tool_a', 'tool_b']);\n    });\n\n    it('should handle mixed wildcards', () => {\n      const tools = [\n        createMockTool('a1x'),\n        createMockTool('a2y'),\n        createMockTool('a12x'),\n        createMockTool('b1x'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['a?*'],\n      });\n\n      const result = filter.filter(tools);\n\n      expect(result.tools.map(t => t.name)).toEqual(['a1x', 'a2y', 'a12x']);\n    });\n\n    it('should handle escaped regex special characters', () => {\n      const tools = [\n        createMockTool('tool.name'),\n        createMockTool('tool_name'),\n        createMockTool('toolXname'),\n      ];\n\n      const filter = createToolFilter({\n        enabled: true,\n        mode: 'allowlist',\n        patterns: ['tool.name'],  // Should match literal dot\n      });\n\n      const result = filter.filter(tools);\n\n      expect(result.tools).toHaveLength(1);\n      expect(result.tools[0].name).toBe('tool.name');\n    });\n  });\n});\n\ndescribe('createToolFilter Factory', () => {\n  it('should create a ToolFilter instance', () => {\n    const filter = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['*'],\n    });\n\n    expect(filter).toBeInstanceOf(ToolFilter);\n  });\n\n  it('should create independent instances', () => {\n    const filter1 = createToolFilter({\n      enabled: true,\n      mode: 'allowlist',\n      patterns: ['swarm_*'],\n    });\n\n    const filter2 = createToolFilter({\n      enabled: true,\n      mode: 'denylist',\n      patterns: ['agent_*'],\n    });\n\n    expect(filter1.getConfig().mode).toBe('allowlist');\n    expect(filter2.getConfig().mode).toBe('denylist');\n  });\n});\n"],"names":["describe","it","expect","beforeEach","afterEach","ToolFilter","config","lastStats","categoryMap","Map","initializeCategoryMap","categoryPatterns","Object","entries","getToolCategory","toolName","prefix","category","startsWith","matchPattern","pattern","regexPattern","replace","regex","RegExp","test","filter","tools","startTime","performance","now","enabled","stats","totalTools","length","filteredTools","matchedPatterns","filterTime","lastFiltered","Date","mode","tool","matches","patterns","some","isMatch","name","includes","push","categories","shouldExclude","maxTools","priorities","toolPriorities","sort","a","b","priorityA","priorityB","localeCompare","slice","getStats","updateConfig","getConfig","undefined","createToolFilter","createMockTool","description","inputSchema","type","properties","handler","createMockToolSet","mockTools","result","toHaveLength","toEqual","toBe","toBeGreaterThanOrEqual","toBeInstanceOf","map","t","every","endsWith","split","toolNames","n","result1","result2","names","toContain","sortedNames","trackStats","not","toBeLessThan","before","after","getTime","toBeLessThanOrEqual","toBeUndefined","toBeDefined","originalConfig","config2","specialTools","longName","repeat","longTools","Array","from","_","i","start","elapsed","manyTools","filter1","filter2"],"mappings":"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"}