{"version":3,"sources":["../../../src/verification/system-tracker.ts"],"sourcesContent":["/**\r\n * System Truth Tracker - System-wide truth accuracy monitoring and analysis\r\n * \r\n * Tracks overall system performance, distributional metrics, and system health\r\n * with real-time monitoring and predictive analytics capabilities.\r\n */\r\n\r\nimport type { ILogger } from '../core/logger.js';\r\nimport type {\r\n  TruthMetric,\r\n  SystemTruthMetrics,\r\n  DistributionMetrics,\r\n  TruthTelemetryConfig,\r\n} from './telemetry.js';\r\n\r\nexport interface SystemHealthIndicators {\r\n  timestamp: Date;\r\n  overallHealth: number; // 0-1\r\n  subsystemHealth: {\r\n    collection: number;\r\n    validation: number;\r\n    scoring: number;\r\n    alerting: number;\r\n    persistence: number;\r\n  };\r\n  performanceIndicators: {\r\n    latency: number;\r\n    throughput: number;\r\n    errorRate: number;\r\n    availability: number;\r\n  };\r\n  capacityMetrics: {\r\n    currentLoad: number;\r\n    maxCapacity: number;\r\n    utilizationRate: number;\r\n    queueDepth: number;\r\n  };\r\n}\r\n\r\nexport interface SystemTrend {\r\n  metric: string;\r\n  timeframe: string;\r\n  currentValue: number;\r\n  previousValue: number;\r\n  changePercent: number;\r\n  direction: 'improving' | 'declining' | 'stable';\r\n  significance: 'low' | 'medium' | 'high';\r\n  prediction: {\r\n    nextValue: number;\r\n    confidence: number;\r\n    timeToTarget?: Date;\r\n  };\r\n}\r\n\r\nexport interface DistributionAnalysis {\r\n  metric: string;\r\n  distribution: {\r\n    min: number;\r\n    max: number;\r\n    mean: number;\r\n    median: number;\r\n    mode: number;\r\n    stdDev: number;\r\n    percentiles: Record<string, number>;\r\n  };\r\n  outliers: {\r\n    values: number[];\r\n    count: number;\r\n    percentage: number;\r\n  };\r\n  normalityTest: {\r\n    isNormal: boolean;\r\n    pValue: number;\r\n    testStatistic: number;\r\n  };\r\n}\r\n\r\nexport interface SystemPrediction {\r\n  metric: string;\r\n  currentValue: number;\r\n  predictions: {\r\n    shortTerm: { value: number; confidence: number; timeframe: string };\r\n    mediumTerm: { value: number; confidence: number; timeframe: string };\r\n    longTerm: { value: number; confidence: number; timeframe: string };\r\n  };\r\n  factors: PredictionFactor[];\r\n  recommendations: string[];\r\n}\r\n\r\nexport interface PredictionFactor {\r\n  name: string;\r\n  impact: number; // -1 to 1\r\n  confidence: number; // 0 to 1\r\n  description: string;\r\n}\r\n\r\nexport interface SystemAlert {\r\n  id: string;\r\n  timestamp: Date;\r\n  type: 'performance' | 'quality' | 'capacity' | 'health';\r\n  severity: 'info' | 'warning' | 'critical' | 'emergency';\r\n  message: string;\r\n  metrics: Record<string, number>;\r\n  threshold: number;\r\n  currentValue: number;\r\n  trend: string;\r\n  impact: string;\r\n  recommendedActions: string[];\r\n}\r\n\r\nexport class SystemTruthTracker {\r\n  private config: TruthTelemetryConfig;\r\n  private logger: ILogger;\r\n  \r\n  // System state\r\n  private systemMetrics: SystemTruthMetrics;\r\n  private healthIndicators: SystemHealthIndicators;\r\n  private historicalMetrics: TruthMetric[] = [];\r\n  private systemTrends = new Map<string, SystemTrend>();\r\n  private distributionAnalyses = new Map<string, DistributionAnalysis>();\r\n  private predictions = new Map<string, SystemPrediction>();\r\n  \r\n  // Analytics state\r\n  private metricsBuffer: TruthMetric[] = [];\r\n  private analysisInterval?: NodeJS.Timeout;\r\n  private predictionInterval?: NodeJS.Timeout;\r\n  \r\n  // Performance tracking\r\n  private lastAnalysisTime = new Date();\r\n  private totalMetricsProcessed = 0;\r\n  private systemStartTime = new Date();\r\n  \r\n  constructor(config: TruthTelemetryConfig, logger: ILogger) {\r\n    this.config = config;\r\n    this.logger = logger;\r\n    \r\n    this.initializeSystemMetrics();\r\n    this.initializeHealthIndicators();\r\n  }\r\n  \r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing System Truth Tracker');\r\n    \r\n    // Start analysis processes\r\n    this.startPeriodicAnalysis();\r\n    this.startPredictiveAnalysis();\r\n    \r\n    this.logger.info('System Truth Tracker initialized successfully');\r\n  }\r\n  \r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down System Truth Tracker');\r\n    \r\n    // Stop intervals\r\n    if (this.analysisInterval) clearInterval(this.analysisInterval);\r\n    if (this.predictionInterval) clearInterval(this.predictionInterval);\r\n    \r\n    // Final analysis\r\n    await this.performComprehensiveAnalysis();\r\n    \r\n    this.logger.info('System Truth Tracker shutdown complete');\r\n  }\r\n  \r\n  async updateSystemMetric(metric: TruthMetric): Promise<void> {\r\n    // Add to buffer for batch processing\r\n    this.metricsBuffer.push(metric);\r\n    this.totalMetricsProcessed++;\r\n    \r\n    // Add to historical data\r\n    this.historicalMetrics.push(metric);\r\n    \r\n    // Keep historical data within limits\r\n    if (this.historicalMetrics.length > 100000) {\r\n      this.historicalMetrics = this.historicalMetrics.slice(-50000);\r\n    }\r\n    \r\n    // Real-time updates for critical metrics\r\n    if (this.isCriticalMetric(metric)) {\r\n      await this.updateRealTimeMetrics();\r\n    }\r\n  }\r\n  \r\n  private async updateRealTimeMetrics(): Promise<void> {\r\n    const recentMetrics = this.getRecentMetrics(60 * 60 * 1000); // Last hour\r\n    \r\n    if (recentMetrics.length === 0) return;\r\n    \r\n    // Update overall accuracy\r\n    const accuracyMetrics = recentMetrics.filter(m => m.metricType === 'accuracy');\r\n    if (accuracyMetrics.length > 0) {\r\n      this.systemMetrics.overallAccuracy = \r\n        accuracyMetrics.reduce((sum, m) => sum + m.value, 0) / accuracyMetrics.length;\r\n    }\r\n    \r\n    // Update human intervention rate\r\n    const totalTasks = recentMetrics.length;\r\n    const humanInterventions = recentMetrics.filter(\r\n      m => m.context.verificationMethod === 'human' || m.context.verificationMethod === 'hybrid'\r\n    ).length;\r\n    \r\n    this.systemMetrics.humanInterventionRate = totalTasks > 0 ? humanInterventions / totalTasks : 0;\r\n    \r\n    // Update system reliability\r\n    const validTasks = recentMetrics.filter(m => m.validation.isValid).length;\r\n    this.systemMetrics.systemReliability = totalTasks > 0 ? validTasks / totalTasks : 1;\r\n    \r\n    // Update agent counts\r\n    const uniqueAgents = new Set(recentMetrics.map(m => m.agentId));\r\n    this.systemMetrics.activeAgents = uniqueAgents.size;\r\n    \r\n    // Update task counts\r\n    this.systemMetrics.totalTasks = this.historicalMetrics.length;\r\n    this.systemMetrics.verifiedTasks = this.historicalMetrics.filter(m => m.validation.isValid).length;\r\n    \r\n    // Update critical failures\r\n    const criticalErrors = recentMetrics.filter(\r\n      m => m.validation.errors.some(e => e.severity === 'critical')\r\n    ).length;\r\n    this.systemMetrics.criticalFailures = criticalErrors;\r\n    \r\n    // Update efficiency\r\n    this.systemMetrics.efficiency = this.calculateSystemEfficiency(recentMetrics);\r\n    \r\n    // Update timestamp\r\n    this.systemMetrics.timestamp = new Date();\r\n  }\r\n  \r\n  private startPeriodicAnalysis(): void {\r\n    this.analysisInterval = setInterval(async () => {\r\n      await this.performPeriodicAnalysis();\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n    \r\n    this.logger.info('Started periodic system analysis');\r\n  }\r\n  \r\n  private startPredictiveAnalysis(): void {\r\n    this.predictionInterval = setInterval(async () => {\r\n      await this.performPredictiveAnalysis();\r\n    }, 15 * 60 * 1000); // Every 15 minutes\r\n    \r\n    this.logger.info('Started predictive analysis');\r\n  }\r\n  \r\n  private async performPeriodicAnalysis(): Promise<void> {\r\n    try {\r\n      // Process buffered metrics\r\n      await this.processMetricsBuffer();\r\n      \r\n      // Update distribution metrics\r\n      await this.updateDistributionMetrics();\r\n      \r\n      // Analyze trends\r\n      await this.analyzeTrends();\r\n      \r\n      // Update health indicators\r\n      await this.updateHealthIndicators();\r\n      \r\n      // Update timestamp\r\n      this.lastAnalysisTime = new Date();\r\n      \r\n    } catch (error) {\r\n      this.logger.error('Error in periodic analysis', error);\r\n    }\r\n  }\r\n  \r\n  private async processMetricsBuffer(): Promise<void> {\r\n    if (this.metricsBuffer.length === 0) return;\r\n    \r\n    const batch = this.metricsBuffer.splice(0);\r\n    \r\n    // Update system metrics based on batch\r\n    await this.updateSystemMetricsFromBatch(batch);\r\n    \r\n    // Analyze distribution for each metric type\r\n    await this.analyzeDistributions(batch);\r\n  }\r\n  \r\n  private async updateSystemMetricsFromBatch(metrics: TruthMetric[]): Promise<void> {\r\n    if (metrics.length === 0) return;\r\n    \r\n    // Group metrics by type\r\n    const metricsByType = new Map<string, TruthMetric[]>();\r\n    metrics.forEach(metric => {\r\n      if (!metricsByType.has(metric.metricType)) {\r\n        metricsByType.set(metric.metricType, []);\r\n      }\r\n      metricsByType.get(metric.metricType)!.push(metric);\r\n    });\r\n    \r\n    // Update accuracy\r\n    const accuracyMetrics = metricsByType.get('accuracy') || [];\r\n    if (accuracyMetrics.length > 0) {\r\n      const weightedSum = accuracyMetrics.reduce(\r\n        (sum, m) => sum + (m.value * m.confidence), 0\r\n      );\r\n      const totalWeight = accuracyMetrics.reduce((sum, m) => sum + m.confidence, 0);\r\n      \r\n      if (totalWeight > 0) {\r\n        this.systemMetrics.overallAccuracy = weightedSum / totalWeight;\r\n      }\r\n    }\r\n    \r\n    // Update throughput\r\n    const timeSpan = this.getTimeSpan(metrics);\r\n    if (timeSpan > 0) {\r\n      this.systemMetrics.throughput = metrics.length / (timeSpan / (60 * 60 * 1000)); // per hour\r\n    }\r\n    \r\n    // Update latency (average validation time)\r\n    const validationTimes = metrics\r\n      .map(m => m.validation.automatedChecks.reduce((sum, c) => sum + c.executionTime, 0))\r\n      .filter(t => t > 0);\r\n    \r\n    if (validationTimes.length > 0) {\r\n      this.systemMetrics.latency = validationTimes.reduce((sum, t) => sum + t, 0) / validationTimes.length;\r\n    }\r\n    \r\n    // Update error rate\r\n    const errorCount = metrics.reduce(\r\n      (sum, m) => sum + m.validation.errors.length, 0\r\n    );\r\n    this.systemMetrics.errorRate = metrics.length > 0 ? errorCount / metrics.length : 0;\r\n    \r\n    // Update success rate\r\n    const successCount = metrics.filter(m => m.validation.isValid).length;\r\n    this.systemMetrics.successRate = metrics.length > 0 ? \r\n      (successCount / metrics.length) * 100 : 100;\r\n  }\r\n  \r\n  private async updateDistributionMetrics(): Promise<void> {\r\n    const recentMetrics = this.getRecentMetrics(24 * 60 * 60 * 1000); // Last 24 hours\r\n    \r\n    if (recentMetrics.length === 0) return;\r\n    \r\n    // Task type distribution\r\n    const taskTypes = new Map<string, number>();\r\n    recentMetrics.forEach(metric => {\r\n      const taskType = metric.context.taskType;\r\n      taskTypes.set(taskType, (taskTypes.get(taskType) || 0) + 1);\r\n    });\r\n    this.systemMetrics.distributionMetrics.taskDistribution = Object.fromEntries(taskTypes);\r\n    \r\n    // Accuracy distribution (by ranges)\r\n    const accuracyRanges = new Map<string, number>();\r\n    recentMetrics\r\n      .filter(m => m.metricType === 'accuracy')\r\n      .forEach(metric => {\r\n        const range = this.getAccuracyRange(metric.value);\r\n        accuracyRanges.set(range, (accuracyRanges.get(range) || 0) + 1);\r\n      });\r\n    this.systemMetrics.distributionMetrics.accuracyDistribution = Object.fromEntries(accuracyRanges);\r\n    \r\n    // Complexity distribution\r\n    const complexityTypes = new Map<string, number>();\r\n    recentMetrics.forEach(metric => {\r\n      const complexity = metric.context.complexity;\r\n      complexityTypes.set(complexity, (complexityTypes.get(complexity) || 0) + 1);\r\n    });\r\n    this.systemMetrics.distributionMetrics.complexityDistribution = Object.fromEntries(complexityTypes);\r\n    \r\n    // Error type distribution\r\n    const errorTypes = new Map<string, number>();\r\n    recentMetrics.forEach(metric => {\r\n      metric.validation.errors.forEach(error => {\r\n        errorTypes.set(error.type, (errorTypes.get(error.type) || 0) + 1);\r\n      });\r\n    });\r\n    this.systemMetrics.distributionMetrics.errorTypeDistribution = Object.fromEntries(errorTypes);\r\n  }\r\n  \r\n  private async analyzeTrends(): Promise<void> {\r\n    const metrics = ['overallAccuracy', 'humanInterventionRate', 'systemReliability', 'efficiency'];\r\n    \r\n    for (const metric of metrics) {\r\n      const trend = await this.calculateTrend(metric);\r\n      if (trend) {\r\n        this.systemTrends.set(metric, trend);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private async calculateTrend(metricName: string): Promise<SystemTrend | null> {\r\n    const historicalValues = await this.getHistoricalValues(metricName, 168); // Last 7 days\r\n    \r\n    if (historicalValues.length < 10) return null; // Need sufficient data\r\n    \r\n    // Calculate current and previous period averages\r\n    const midpoint = Math.floor(historicalValues.length / 2);\r\n    const earlierPeriod = historicalValues.slice(0, midpoint);\r\n    const laterPeriod = historicalValues.slice(midpoint);\r\n    \r\n    const previousValue = earlierPeriod.reduce((sum, v) => sum + v.value, 0) / earlierPeriod.length;\r\n    const currentValue = laterPeriod.reduce((sum, v) => sum + v.value, 0) / laterPeriod.length;\r\n    \r\n    const changePercent = previousValue !== 0 ? \r\n      ((currentValue - previousValue) / previousValue) * 100 : 0;\r\n    \r\n    // Determine direction and significance\r\n    let direction: 'improving' | 'declining' | 'stable';\r\n    let significance: 'low' | 'medium' | 'high';\r\n    \r\n    if (Math.abs(changePercent) < 1) {\r\n      direction = 'stable';\r\n      significance = 'low';\r\n    } else {\r\n      direction = changePercent > 0 ? 'improving' : 'declining';\r\n      \r\n      if (Math.abs(changePercent) > 10) significance = 'high';\r\n      else if (Math.abs(changePercent) > 5) significance = 'medium';\r\n      else significance = 'low';\r\n    }\r\n    \r\n    // Make prediction\r\n    const prediction = await this.predictNextValue(historicalValues);\r\n    \r\n    return {\r\n      metric: metricName,\r\n      timeframe: '7d',\r\n      currentValue,\r\n      previousValue,\r\n      changePercent,\r\n      direction,\r\n      significance,\r\n      prediction,\r\n    };\r\n  }\r\n  \r\n  private async predictNextValue(values: { timestamp: Date; value: number }[]): Promise<{\r\n    nextValue: number;\r\n    confidence: number;\r\n    timeToTarget?: Date;\r\n  }> {\r\n    if (values.length < 5) {\r\n      return { nextValue: values[values.length - 1].value, confidence: 0.3 };\r\n    }\r\n    \r\n    // Simple linear regression for prediction\r\n    const n = values.length;\r\n    const x = values.map((_, i) => i);\r\n    const y = values.map(v => v.value);\r\n    \r\n    const sumX = x.reduce((sum, val) => sum + val, 0);\r\n    const sumY = y.reduce((sum, val) => sum + val, 0);\r\n    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);\r\n    const sumX2 = x.reduce((sum, val) => sum + val * val, 0);\r\n    \r\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\r\n    const intercept = (sumY - slope * sumX) / n;\r\n    \r\n    // Predict next value\r\n    const nextValue = slope * n + intercept;\r\n    \r\n    // Calculate confidence based on R-squared\r\n    const yMean = sumY / n;\r\n    const ssRes = y.reduce((sum, val, i) => {\r\n      const predicted = slope * i + intercept;\r\n      return sum + Math.pow(val - predicted, 2);\r\n    }, 0);\r\n    const ssTot = y.reduce((sum, val) => sum + Math.pow(val - yMean, 2), 0);\r\n    \r\n    const rSquared = ssTot !== 0 ? 1 - (ssRes / ssTot) : 0;\r\n    const confidence = Math.max(0, Math.min(1, rSquared));\r\n    \r\n    return { nextValue, confidence };\r\n  }\r\n  \r\n  private async updateHealthIndicators(): Promise<void> {\r\n    const now = new Date();\r\n    const uptime = now.getTime() - this.systemStartTime.getTime();\r\n    \r\n    // Calculate subsystem health scores\r\n    const subsystemHealth = {\r\n      collection: this.calculateCollectionHealth(),\r\n      validation: this.calculateValidationHealth(),\r\n      scoring: this.calculateScoringHealth(),\r\n      alerting: this.calculateAlertingHealth(),\r\n      persistence: this.calculatePersistenceHealth(),\r\n    };\r\n    \r\n    // Calculate overall health\r\n    const healthValues = Object.values(subsystemHealth);\r\n    const overallHealth = healthValues.reduce((sum, h) => sum + h, 0) / healthValues.length;\r\n    \r\n    // Calculate performance indicators\r\n    const recentMetrics = this.getRecentMetrics(60 * 60 * 1000); // Last hour\r\n    const performanceIndicators = {\r\n      latency: this.systemMetrics.latency,\r\n      throughput: this.systemMetrics.throughput,\r\n      errorRate: this.systemMetrics.errorRate,\r\n      availability: this.calculateAvailability(uptime),\r\n    };\r\n    \r\n    // Calculate capacity metrics\r\n    const capacityMetrics = {\r\n      currentLoad: this.calculateCurrentLoad(),\r\n      maxCapacity: this.calculateMaxCapacity(),\r\n      utilizationRate: this.calculateUtilizationRate(),\r\n      queueDepth: this.metricsBuffer.length,\r\n    };\r\n    \r\n    this.healthIndicators = {\r\n      timestamp: now,\r\n      overallHealth,\r\n      subsystemHealth,\r\n      performanceIndicators,\r\n      capacityMetrics,\r\n    };\r\n  }\r\n  \r\n  private async performPredictiveAnalysis(): Promise<void> {\r\n    try {\r\n      const metrics = ['overallAccuracy', 'humanInterventionRate', 'systemReliability'];\r\n      \r\n      for (const metric of metrics) {\r\n        const prediction = await this.generatePrediction(metric);\r\n        if (prediction) {\r\n          this.predictions.set(metric, prediction);\r\n        }\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.logger.error('Error in predictive analysis', error);\r\n    }\r\n  }\r\n  \r\n  private async generatePrediction(metricName: string): Promise<SystemPrediction | null> {\r\n    const historicalValues = await this.getHistoricalValues(metricName, 336); // Last 2 weeks\r\n    \r\n    if (historicalValues.length < 20) return null;\r\n    \r\n    const currentValue = historicalValues[historicalValues.length - 1].value;\r\n    \r\n    // Generate predictions for different timeframes\r\n    const shortTerm = await this.predictValue(historicalValues, 24); // 1 day\r\n    const mediumTerm = await this.predictValue(historicalValues, 168); // 1 week\r\n    const longTerm = await this.predictValue(historicalValues, 720); // 1 month\r\n    \r\n    // Identify factors affecting the prediction\r\n    const factors = await this.identifyPredictionFactors(metricName, historicalValues);\r\n    \r\n    // Generate recommendations\r\n    const recommendations = this.generatePredictionRecommendations(metricName, shortTerm, factors);\r\n    \r\n    return {\r\n      metric: metricName,\r\n      currentValue,\r\n      predictions: {\r\n        shortTerm: { ...shortTerm, timeframe: '1 day' },\r\n        mediumTerm: { ...mediumTerm, timeframe: '1 week' },\r\n        longTerm: { ...longTerm, timeframe: '1 month' },\r\n      },\r\n      factors,\r\n      recommendations,\r\n    };\r\n  }\r\n  \r\n  private async predictValue(\r\n    values: { timestamp: Date; value: number }[],\r\n    hoursAhead: number\r\n  ): Promise<{ value: number; confidence: number }> {\r\n    // Use exponential smoothing for prediction\r\n    const alpha = 0.3; // Smoothing parameter\r\n    let smoothedValue = values[0].value;\r\n    \r\n    for (let i = 1; i < values.length; i++) {\r\n      smoothedValue = alpha * values[i].value + (1 - alpha) * smoothedValue;\r\n    }\r\n    \r\n    // Simple confidence calculation based on recent variance\r\n    const recentValues = values.slice(-20).map(v => v.value);\r\n    const variance = this.calculateVariance(recentValues);\r\n    const confidence = Math.max(0.1, Math.min(0.9, 1 - Math.sqrt(variance)));\r\n    \r\n    return { value: smoothedValue, confidence };\r\n  }\r\n  \r\n  private async identifyPredictionFactors(\r\n    metricName: string,\r\n    values: { timestamp: Date; value: number }[]\r\n  ): Promise<PredictionFactor[]> {\r\n    const factors: PredictionFactor[] = [];\r\n    \r\n    // Trend factor\r\n    const trend = this.systemTrends.get(metricName);\r\n    if (trend) {\r\n      factors.push({\r\n        name: 'Historical Trend',\r\n        impact: trend.direction === 'improving' ? 0.3 : trend.direction === 'declining' ? -0.3 : 0,\r\n        confidence: trend.significance === 'high' ? 0.8 : trend.significance === 'medium' ? 0.6 : 0.4,\r\n        description: `${trend.direction} trend with ${trend.significance} significance`,\r\n      });\r\n    }\r\n    \r\n    // System load factor\r\n    const currentLoad = this.healthIndicators.capacityMetrics.utilizationRate;\r\n    if (currentLoad > 0.8) {\r\n      factors.push({\r\n        name: 'High System Load',\r\n        impact: -0.2,\r\n        confidence: 0.7,\r\n        description: 'High system utilization may impact performance',\r\n      });\r\n    }\r\n    \r\n    // Error rate factor\r\n    if (this.systemMetrics.errorRate > 0.05) {\r\n      factors.push({\r\n        name: 'Elevated Error Rate',\r\n        impact: -0.4,\r\n        confidence: 0.8,\r\n        description: 'High error rate may continue to impact metrics',\r\n      });\r\n    }\r\n    \r\n    return factors;\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Utility Methods\r\n  // ========================================================================================\r\n  \r\n  private getRecentMetrics(timeWindowMs: number): TruthMetric[] {\r\n    const cutoff = new Date(Date.now() - timeWindowMs);\r\n    return this.historicalMetrics.filter(m => m.timestamp >= cutoff);\r\n  }\r\n  \r\n  private async getHistoricalValues(\r\n    metricName: string,\r\n    hoursBack: number\r\n  ): Promise<{ timestamp: Date; value: number }[]> {\r\n    // This would typically query a time-series database\r\n    // For now, simulate historical data based on current metrics\r\n    const values: { timestamp: Date; value: number }[] = [];\r\n    const now = Date.now();\r\n    const hourMs = 60 * 60 * 1000;\r\n    \r\n    let currentValue = (this.systemMetrics as any)[metricName] || 0.8;\r\n    \r\n    for (let i = hoursBack; i >= 0; i--) {\r\n      const timestamp = new Date(now - (i * hourMs));\r\n      \r\n      // Add some realistic variation\r\n      const variation = (Math.random() - 0.5) * 0.1;\r\n      const value = Math.max(0, Math.min(1, currentValue + variation));\r\n      \r\n      values.push({ timestamp, value });\r\n      currentValue = value;\r\n    }\r\n    \r\n    return values;\r\n  }\r\n  \r\n  private getTimeSpan(metrics: TruthMetric[]): number {\r\n    if (metrics.length < 2) return 0;\r\n    \r\n    const timestamps = metrics.map(m => m.timestamp.getTime()).sort((a, b) => a - b);\r\n    return timestamps[timestamps.length - 1] - timestamps[0];\r\n  }\r\n  \r\n  private getAccuracyRange(accuracy: number): string {\r\n    if (accuracy >= 0.95) return '95-100%';\r\n    if (accuracy >= 0.90) return '90-95%';\r\n    if (accuracy >= 0.80) return '80-90%';\r\n    if (accuracy >= 0.70) return '70-80%';\r\n    return '<70%';\r\n  }\r\n  \r\n  private calculateSystemEfficiency(metrics: TruthMetric[]): number {\r\n    if (metrics.length === 0) return 0.8;\r\n    \r\n    // Efficiency based on validation success rate and automation rate\r\n    const successRate = metrics.filter(m => m.validation.isValid).length / metrics.length;\r\n    const automationRate = metrics.filter(\r\n      m => m.context.verificationMethod === 'automated'\r\n    ).length / metrics.length;\r\n    \r\n    return (successRate * 0.6) + (automationRate * 0.4);\r\n  }\r\n  \r\n  private calculateVariance(values: number[]): number {\r\n    if (values.length === 0) return 0;\r\n    \r\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));\r\n    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;\r\n  }\r\n  \r\n  private isCriticalMetric(metric: TruthMetric): boolean {\r\n    return (\r\n      metric.metricType === 'accuracy' ||\r\n      metric.value < 0.7 ||\r\n      metric.validation.errors.some(e => e.severity === 'critical')\r\n    );\r\n  }\r\n  \r\n  private calculateCollectionHealth(): number {\r\n    // Health based on collection throughput and error rate\r\n    const targetThroughput = 100; // metrics per hour\r\n    const currentThroughput = this.systemMetrics.throughput;\r\n    const throughputScore = Math.min(1, currentThroughput / targetThroughput);\r\n    \r\n    const errorScore = Math.max(0, 1 - (this.systemMetrics.errorRate * 10));\r\n    \r\n    return (throughputScore * 0.7) + (errorScore * 0.3);\r\n  }\r\n  \r\n  private calculateValidationHealth(): number {\r\n    // Health based on validation success rate and processing time\r\n    const successRate = this.systemMetrics.successRate / 100;\r\n    const latencyScore = this.systemMetrics.latency > 0 ? \r\n      Math.max(0.1, Math.min(1, 5000 / this.systemMetrics.latency)) : 1;\r\n    \r\n    return (successRate * 0.8) + (latencyScore * 0.2);\r\n  }\r\n  \r\n  private calculateScoringHealth(): number {\r\n    // Health based on scoring coverage and accuracy\r\n    const coverageScore = this.systemMetrics.agentCount > 0 ? \r\n      Math.min(1, this.systemMetrics.activeAgents / this.systemMetrics.agentCount) : 1;\r\n    \r\n    return coverageScore;\r\n  }\r\n  \r\n  private calculateAlertingHealth(): number {\r\n    // Health based on alert responsiveness\r\n    return 0.95; // Placeholder\r\n  }\r\n  \r\n  private calculatePersistenceHealth(): number {\r\n    // Health based on data persistence success\r\n    return 0.98; // Placeholder\r\n  }\r\n  \r\n  private calculateAvailability(uptimeMs: number): number {\r\n    // Simple availability calculation\r\n    const uptimeHours = uptimeMs / (60 * 60 * 1000);\r\n    return Math.min(1, uptimeHours / (uptimeHours + 0.1)); // Assume minimal downtime\r\n  }\r\n  \r\n  private calculateCurrentLoad(): number {\r\n    // Load based on current processing\r\n    return this.metricsBuffer.length;\r\n  }\r\n  \r\n  private calculateMaxCapacity(): number {\r\n    // Maximum capacity based on configuration\r\n    return this.config.bufferSize;\r\n  }\r\n  \r\n  private calculateUtilizationRate(): number {\r\n    // Utilization rate\r\n    const maxCapacity = this.calculateMaxCapacity();\r\n    return maxCapacity > 0 ? this.calculateCurrentLoad() / maxCapacity : 0;\r\n  }\r\n  \r\n  private generatePredictionRecommendations(\r\n    metricName: string,\r\n    prediction: { value: number; confidence: number },\r\n    factors: PredictionFactor[]\r\n  ): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    // Low confidence recommendations\r\n    if (prediction.confidence < 0.5) {\r\n      recommendations.push('Increase data collection frequency for better predictions');\r\n      recommendations.push('Implement additional monitoring points');\r\n    }\r\n    \r\n    // Metric-specific recommendations\r\n    if (metricName === 'overallAccuracy' && prediction.value < 0.9) {\r\n      recommendations.push('Implement additional validation checks');\r\n      recommendations.push('Consider agent retraining or calibration');\r\n    }\r\n    \r\n    if (metricName === 'humanInterventionRate' && prediction.value > 0.15) {\r\n      recommendations.push('Analyze common intervention patterns');\r\n      recommendations.push('Improve automated decision-making capabilities');\r\n    }\r\n    \r\n    // Factor-based recommendations\r\n    factors.forEach(factor => {\r\n      if (factor.impact < -0.3) {\r\n        recommendations.push(`Address ${factor.name}: ${factor.description}`);\r\n      }\r\n    });\r\n    \r\n    return recommendations;\r\n  }\r\n  \r\n  private initializeSystemMetrics(): void {\r\n    this.systemMetrics = {\r\n      timestamp: new Date(),\r\n      overallAccuracy: 0.95,\r\n      humanInterventionRate: 0.05,\r\n      systemReliability: 0.98,\r\n      agentCount: 0,\r\n      activeAgents: 0,\r\n      totalTasks: 0,\r\n      verifiedTasks: 0,\r\n      criticalFailures: 0,\r\n      recoveryTime: 0,\r\n      efficiency: 0.85,\r\n      distributionMetrics: {\r\n        taskDistribution: {},\r\n        accuracyDistribution: {},\r\n        complexityDistribution: {},\r\n        errorTypeDistribution: {},\r\n      },\r\n    };\r\n  }\r\n  \r\n  private initializeHealthIndicators(): void {\r\n    this.healthIndicators = {\r\n      timestamp: new Date(),\r\n      overallHealth: 0.95,\r\n      subsystemHealth: {\r\n        collection: 0.95,\r\n        validation: 0.92,\r\n        scoring: 0.90,\r\n        alerting: 0.98,\r\n        persistence: 0.96,\r\n      },\r\n      performanceIndicators: {\r\n        latency: 500,\r\n        throughput: 50,\r\n        errorRate: 0.02,\r\n        availability: 0.99,\r\n      },\r\n      capacityMetrics: {\r\n        currentLoad: 0,\r\n        maxCapacity: 1000,\r\n        utilizationRate: 0,\r\n        queueDepth: 0,\r\n      },\r\n    };\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Public API\r\n  // ========================================================================================\r\n  \r\n  getSystemMetrics(): SystemTruthMetrics {\r\n    return { ...this.systemMetrics };\r\n  }\r\n  \r\n  getHealthIndicators(): SystemHealthIndicators {\r\n    return { ...this.healthIndicators };\r\n  }\r\n  \r\n  getSystemTrends(): SystemTrend[] {\r\n    return Array.from(this.systemTrends.values());\r\n  }\r\n  \r\n  getTrend(metricName: string): SystemTrend | undefined {\r\n    return this.systemTrends.get(metricName);\r\n  }\r\n  \r\n  getPredictions(): SystemPrediction[] {\r\n    return Array.from(this.predictions.values());\r\n  }\r\n  \r\n  getPrediction(metricName: string): SystemPrediction | undefined {\r\n    return this.predictions.get(metricName);\r\n  }\r\n  \r\n  getDistributionAnalysis(metricName: string): DistributionAnalysis | undefined {\r\n    return this.distributionAnalyses.get(metricName);\r\n  }\r\n  \r\n  async performComprehensiveAnalysis(): Promise<{\r\n    systemHealth: SystemHealthIndicators;\r\n    trends: SystemTrend[];\r\n    predictions: SystemPrediction[];\r\n    recommendations: string[];\r\n  }> {\r\n    await this.performPeriodicAnalysis();\r\n    await this.performPredictiveAnalysis();\r\n    \r\n    const recommendations = this.generateSystemRecommendations();\r\n    \r\n    return {\r\n      systemHealth: this.healthIndicators,\r\n      trends: Array.from(this.systemTrends.values()),\r\n      predictions: Array.from(this.predictions.values()),\r\n      recommendations,\r\n    };\r\n  }\r\n  \r\n  private generateSystemRecommendations(): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    // Health-based recommendations\r\n    if (this.healthIndicators.overallHealth < 0.8) {\r\n      recommendations.push('System health is degraded - investigate subsystem issues');\r\n    }\r\n    \r\n    // Performance-based recommendations\r\n    if (this.healthIndicators.performanceIndicators.errorRate > 0.05) {\r\n      recommendations.push('High error rate detected - review validation processes');\r\n    }\r\n    \r\n    // Capacity-based recommendations\r\n    if (this.healthIndicators.capacityMetrics.utilizationRate > 0.8) {\r\n      recommendations.push('High system utilization - consider scaling resources');\r\n    }\r\n    \r\n    // Trend-based recommendations\r\n    this.systemTrends.forEach(trend => {\r\n      if (trend.direction === 'declining' && trend.significance === 'high') {\r\n        recommendations.push(`${trend.metric} is declining significantly - immediate attention required`);\r\n      }\r\n    });\r\n    \r\n    return recommendations;\r\n  }\r\n  \r\n  getSystemStatistics(): {\r\n    totalMetricsProcessed: number;\r\n    systemUptime: number;\r\n    averageProcessingRate: number;\r\n    healthScore: number;\r\n    lastAnalysis: Date;\r\n  } {\r\n    const uptime = Date.now() - this.systemStartTime.getTime();\r\n    const processingRate = uptime > 0 ? (this.totalMetricsProcessed / (uptime / 1000)) : 0;\r\n    \r\n    return {\r\n      totalMetricsProcessed: this.totalMetricsProcessed,\r\n      systemUptime: uptime,\r\n      averageProcessingRate: processingRate,\r\n      healthScore: this.healthIndicators.overallHealth,\r\n      lastAnalysis: this.lastAnalysisTime,\r\n    };\r\n  }\r\n}"],"names":["SystemTruthTracker","config","logger","systemMetrics","healthIndicators","historicalMetrics","systemTrends","Map","distributionAnalyses","predictions","metricsBuffer","analysisInterval","predictionInterval","lastAnalysisTime","Date","totalMetricsProcessed","systemStartTime","initializeSystemMetrics","initializeHealthIndicators","initialize","info","startPeriodicAnalysis","startPredictiveAnalysis","shutdown","clearInterval","performComprehensiveAnalysis","updateSystemMetric","metric","push","length","slice","isCriticalMetric","updateRealTimeMetrics","recentMetrics","getRecentMetrics","accuracyMetrics","filter","m","metricType","overallAccuracy","reduce","sum","value","totalTasks","humanInterventions","context","verificationMethod","humanInterventionRate","validTasks","validation","isValid","systemReliability","uniqueAgents","Set","map","agentId","activeAgents","size","verifiedTasks","criticalErrors","errors","some","e","severity","criticalFailures","efficiency","calculateSystemEfficiency","timestamp","setInterval","performPeriodicAnalysis","performPredictiveAnalysis","processMetricsBuffer","updateDistributionMetrics","analyzeTrends","updateHealthIndicators","error","batch","splice","updateSystemMetricsFromBatch","analyzeDistributions","metrics","metricsByType","forEach","has","set","get","weightedSum","confidence","totalWeight","timeSpan","getTimeSpan","throughput","validationTimes","automatedChecks","c","executionTime","t","latency","errorCount","errorRate","successCount","successRate","taskTypes","taskType","distributionMetrics","taskDistribution","Object","fromEntries","accuracyRanges","range","getAccuracyRange","accuracyDistribution","complexityTypes","complexity","complexityDistribution","errorTypes","type","errorTypeDistribution","trend","calculateTrend","metricName","historicalValues","getHistoricalValues","midpoint","Math","floor","earlierPeriod","laterPeriod","previousValue","v","currentValue","changePercent","direction","significance","abs","prediction","predictNextValue","timeframe","values","nextValue","n","x","_","i","y","sumX","val","sumY","sumXY","sumX2","slope","intercept","yMean","ssRes","predicted","pow","ssTot","rSquared","max","min","now","uptime","getTime","subsystemHealth","collection","calculateCollectionHealth","calculateValidationHealth","scoring","calculateScoringHealth","alerting","calculateAlertingHealth","persistence","calculatePersistenceHealth","healthValues","overallHealth","h","performanceIndicators","availability","calculateAvailability","capacityMetrics","currentLoad","calculateCurrentLoad","maxCapacity","calculateMaxCapacity","utilizationRate","calculateUtilizationRate","queueDepth","generatePrediction","shortTerm","predictValue","mediumTerm","longTerm","factors","identifyPredictionFactors","recommendations","generatePredictionRecommendations","hoursAhead","alpha","smoothedValue","recentValues","variance","calculateVariance","sqrt","name","impact","description","timeWindowMs","cutoff","hoursBack","hourMs","variation","random","timestamps","sort","a","b","accuracy","automationRate","mean","squaredDiffs","diff","targetThroughput","currentThroughput","throughputScore","errorScore","latencyScore","coverageScore","agentCount","uptimeMs","uptimeHours","bufferSize","factor","recoveryTime","getSystemMetrics","getHealthIndicators","getSystemTrends","Array","from","getTrend","getPredictions","getPrediction","getDistributionAnalysis","generateSystemRecommendations","systemHealth","trends","getSystemStatistics","processingRate","systemUptime","averageProcessingRate","healthScore","lastAnalysis"],"mappings":"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"}