{"version":3,"sources":["../../../../src/hive-mind/core/Memory.ts"],"sourcesContent":["/**\r\n * Memory Class\r\n *\r\n * Manages collective memory for the Hive Mind swarm,\r\n * providing persistent storage, retrieval, and learning capabilities.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { performance } from 'perf_hooks';\r\nimport { DatabaseManager } from './DatabaseManager.js';\r\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\r\nimport {\r\n  MemoryEntry,\r\n  MemoryNamespace,\r\n  MemoryStats,\r\n  MemorySearchOptions,\r\n  MemoryPattern,\r\n} from '../types.js';\r\n\r\n/**\r\n * High-performance LRU Cache with memory management\r\n */\r\nclass HighPerformanceCache<T> {\r\n  private cache = new Map<string, { data: T; timestamp: number; size: number }>();\r\n  private maxSize: number;\r\n  private maxMemory: number;\r\n  private currentMemory = 0;\r\n  private hits = 0;\r\n  private misses = 0;\r\n  private evictions = 0;\r\n\r\n  constructor(maxSize = 10000, maxMemoryMB = 100) {\r\n    this.maxSize = maxSize;\r\n    this.maxMemory = maxMemoryMB * 1024 * 1024;\r\n  }\r\n\r\n  get(key: string): T | undefined {\r\n    const entry = this.cache.get(key);\r\n    if (entry) {\r\n      // Move to end (LRU)\r\n      this.cache.delete(key);\r\n      this.cache.set(key, entry);\r\n      this.hits++;\r\n      return entry.data;\r\n    }\r\n    this.misses++;\r\n    return undefined;\r\n  }\r\n\r\n  set(key: string, data: T): void {\r\n    const size = this.estimateSize(data);\r\n\r\n    // Handle memory pressure\r\n    while (this.currentMemory + size > this.maxMemory && this.cache.size > 0) {\r\n      this.evictLRU();\r\n    }\r\n\r\n    // Handle size limit\r\n    while (this.cache.size >= this.maxSize) {\r\n      this.evictLRU();\r\n    }\r\n\r\n    this.cache.set(key, { data, timestamp: Date.now(), size });\r\n    this.currentMemory += size;\r\n  }\r\n\r\n  private evictLRU(): void {\r\n    const firstKey = this.cache.keys().next().value;\r\n    if (firstKey) {\r\n      const entry = this.cache.get(firstKey)!;\r\n      this.cache.delete(firstKey);\r\n      this.currentMemory -= entry.size;\r\n      this.evictions++;\r\n    }\r\n  }\r\n\r\n  private estimateSize(data: any): number {\r\n    try {\r\n      return JSON.stringify(data).length * 2; // Rough estimate\r\n    } catch {\r\n      return 1000; // Default size for non-serializable objects\r\n    }\r\n  }\r\n\r\n  getStats() {\r\n    const total = this.hits + this.misses;\r\n    return {\r\n      size: this.cache.size,\r\n      memoryUsage: this.currentMemory,\r\n      hitRate: total > 0 ? (this.hits / total) * 100 : 0,\r\n      evictions: this.evictions,\r\n      utilizationPercent: (this.currentMemory / this.maxMemory) * 100,\r\n    };\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n    this.currentMemory = 0;\r\n    this.hits = 0;\r\n    this.misses = 0;\r\n    this.evictions = 0;\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  delete(key: string): boolean {\r\n    const entry = this.cache.get(key);\r\n    if (entry) {\r\n      this.currentMemory -= entry.size;\r\n      return this.cache.delete(key);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Memory pool for object reuse\r\n */\r\nclass ObjectPool<T> {\r\n  private pool: T[] = [];\r\n  private createFn: () => T;\r\n  private resetFn: (obj: T) => void;\r\n  private maxSize: number;\r\n  private allocated = 0;\r\n  private reused = 0;\r\n\r\n  constructor(createFn: () => T, resetFn: (obj: T) => void, maxSize = 1000) {\r\n    this.createFn = createFn;\r\n    this.resetFn = resetFn;\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  acquire(): T {\r\n    if (this.pool.length > 0) {\r\n      this.reused++;\r\n      return this.pool.pop()!;\r\n    }\r\n    this.allocated++;\r\n    return this.createFn();\r\n  }\r\n\r\n  release(obj: T): void {\r\n    if (this.pool.length < this.maxSize) {\r\n      this.resetFn(obj);\r\n      this.pool.push(obj);\r\n    }\r\n  }\r\n\r\n  getStats() {\r\n    return {\r\n      poolSize: this.pool.length,\r\n      allocated: this.allocated,\r\n      reused: this.reused,\r\n      reuseRate: this.allocated > 0 ? (this.reused / (this.allocated + this.reused)) * 100 : 0,\r\n    };\r\n  }\r\n}\r\n\r\nexport class Memory extends EventEmitter {\r\n  private swarmId: string;\r\n  private db: DatabaseManager;\r\n  private mcpWrapper: MCPToolWrapper;\r\n  private cache: HighPerformanceCache<any>;\r\n  private namespaces: Map<string, MemoryNamespace>;\r\n  private accessPatterns: Map<string, number>;\r\n  private performanceMetrics: Map<string, number[]>;\r\n  private objectPools: Map<string, ObjectPool<any>>;\r\n  private isActive: boolean = false;\r\n  private optimizationTimers: NodeJS.Timeout[] = [];\r\n  private compressionThreshold = 10000; // 10KB\r\n  private batchSize = 100;\r\n\r\n  constructor(\r\n    swarmId: string,\r\n    options: {\r\n      cacheSize?: number;\r\n      cacheMemoryMB?: number;\r\n      enablePooling?: boolean;\r\n      compressionThreshold?: number;\r\n      batchSize?: number;\r\n    } = {},\r\n  ) {\r\n    super();\r\n    this.swarmId = swarmId;\r\n\r\n    // Initialize high-performance cache\r\n    this.cache = new HighPerformanceCache(options.cacheSize || 10000, options.cacheMemoryMB || 100);\r\n\r\n    this.namespaces = new Map();\r\n    this.accessPatterns = new Map();\r\n    this.performanceMetrics = new Map();\r\n    this.objectPools = new Map();\r\n\r\n    if (options.compressionThreshold) {\r\n      this.compressionThreshold = options.compressionThreshold;\r\n    }\r\n\r\n    if (options.batchSize) {\r\n      this.batchSize = options.batchSize;\r\n    }\r\n\r\n    this.initializeNamespaces();\r\n\r\n    if (options.enablePooling !== false) {\r\n      this.initializeObjectPools();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize optimized memory system\r\n   */\r\n  async initialize(): Promise<void> {\r\n    const startTime = performance.now();\r\n\r\n    this.db = await DatabaseManager.getInstance();\r\n    this.mcpWrapper = new MCPToolWrapper();\r\n\r\n    // Optimize database connection\r\n    await this.optimizeDatabaseSettings();\r\n\r\n    // Load existing memory entries with pagination\r\n    await this.loadMemoryFromDatabase();\r\n\r\n    // Start optimized memory management loops\r\n    this.startOptimizedManagers();\r\n\r\n    this.isActive = true;\r\n\r\n    const duration = performance.now() - startTime;\r\n    this.recordPerformance('initialize', duration);\r\n\r\n    this.emit('initialized', {\r\n      duration,\r\n      cacheSize: this.cache.getStats().size,\r\n      poolsInitialized: this.objectPools.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize object pools for better memory management\r\n   */\r\n  private initializeObjectPools(): void {\r\n    // Pool for memory entries\r\n    this.objectPools.set(\r\n      'memoryEntry',\r\n      new ObjectPool(\r\n        () =>\r\n          ({\r\n            key: '',\r\n            namespace: '',\r\n            value: '',\r\n            ttl: 0,\r\n            createdAt: new Date(),\r\n            accessCount: 0,\r\n            lastAccessedAt: new Date(),\r\n          }) as MemoryEntry,\r\n        (obj) => {\r\n          obj.key = '';\r\n          obj.namespace = '';\r\n          obj.value = '';\r\n          obj.ttl = 0;\r\n          obj.accessCount = 0;\r\n        },\r\n      ),\r\n    );\r\n\r\n    // Pool for search results\r\n    this.objectPools.set(\r\n      'searchResult',\r\n      new ObjectPool(\r\n        () => ({ results: [], metadata: {} }),\r\n        (obj) => {\r\n          obj.results.length = 0;\r\n          Object.keys(obj.metadata).forEach((k) => delete obj.metadata[k]);\r\n        },\r\n      ),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Optimize database settings for better performance\r\n   */\r\n  private async optimizeDatabaseSettings(): Promise<void> {\r\n    try {\r\n      // Database performance optimizations would go here\r\n      // For now, this is a placeholder for future database-specific optimizations\r\n      this.emit('databaseOptimized');\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimized store method with compression and batching\r\n   */\r\n  async store(key: string, value: any, namespace: string = 'default', ttl?: number): Promise<void> {\r\n    const startTime = performance.now();\r\n\r\n    // Use object pool if available\r\n    const entryPool = this.objectPools.get('memoryEntry');\r\n    const entry = entryPool ? entryPool.acquire() : ({} as MemoryEntry);\r\n\r\n    try {\r\n      // Smart serialization with compression detection\r\n      let serializedValue: string;\r\n      let compressed = false;\r\n\r\n      if (typeof value === 'string') {\r\n        serializedValue = value;\r\n      } else {\r\n        serializedValue = JSON.stringify(value);\r\n      }\r\n\r\n      // Intelligent compression decision\r\n      if (serializedValue.length > this.compressionThreshold) {\r\n        serializedValue = await this.compressData(serializedValue);\r\n        compressed = true;\r\n      }\r\n\r\n      // Populate entry\r\n      entry.key = key;\r\n      entry.namespace = namespace;\r\n      entry.value = serializedValue;\r\n      entry.ttl = ttl;\r\n      entry.createdAt = new Date();\r\n      entry.accessCount = 0;\r\n      entry.lastAccessedAt = new Date();\r\n\r\n      // Store in database with transaction for consistency\r\n      await this.db.storeMemory({\r\n        key,\r\n        namespace,\r\n        value: serializedValue,\r\n        ttl,\r\n        metadata: JSON.stringify({\r\n          swarmId: this.swarmId,\r\n          compressed,\r\n          originalSize: serializedValue.length,\r\n        }),\r\n      });\r\n\r\n      // Async MCP storage (non-blocking)\r\n      this.mcpWrapper\r\n        .storeMemory({\r\n          action: 'store',\r\n          key: `${this.swarmId}/${namespace}/${key}`,\r\n          value: serializedValue,\r\n          namespace: 'hive-mind',\r\n          ttl,\r\n        })\r\n        .catch((error) => this.emit('mcpError', error));\r\n\r\n      // Update high-performance cache\r\n      this.cache.set(this.getCacheKey(key, namespace), value);\r\n\r\n      // Track access patterns\r\n      this.updateAccessPattern(key, 'write');\r\n\r\n      // Update namespace stats asynchronously\r\n      setImmediate(() => this.updateNamespaceStats(namespace, 'store'));\r\n\r\n      const duration = performance.now() - startTime;\r\n      this.recordPerformance('store', duration);\r\n\r\n      this.emit('memoryStored', {\r\n        key,\r\n        namespace,\r\n        compressed,\r\n        size: serializedValue.length,\r\n        duration,\r\n      });\r\n    } finally {\r\n      // Return object to pool\r\n      if (entryPool) {\r\n        entryPool.release(entry);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch store operation for high-throughput scenarios\r\n   */\r\n  async storeBatch(\r\n    entries: Array<{ key: string; value: any; namespace?: string; ttl?: number }>,\r\n  ): Promise<void> {\r\n    const startTime = performance.now();\r\n    const batchResults = [];\r\n\r\n    // Process in chunks to avoid memory pressure\r\n    for (let i = 0; i < entries.length; i += this.batchSize) {\r\n      const chunk = entries.slice(i, i + this.batchSize);\r\n\r\n      const chunkPromises = chunk.map(async ({ key, value, namespace = 'default', ttl }) => {\r\n        await this.store(key, value, namespace, ttl);\r\n        return { key, namespace, success: true };\r\n      });\r\n\r\n      const chunkResults = await Promise.allSettled(chunkPromises);\r\n      batchResults.push(...chunkResults);\r\n    }\r\n\r\n    const duration = performance.now() - startTime;\r\n    const successful = batchResults.filter((r) => r.status === 'fulfilled').length;\r\n\r\n    this.emit('batchStored', {\r\n      total: entries.length,\r\n      successful,\r\n      duration,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * High-performance retrieve method with intelligent caching\r\n   */\r\n  async retrieve(key: string, namespace: string = 'default'): Promise<any> {\r\n    const startTime = performance.now();\r\n    const cacheKey = this.getCacheKey(key, namespace);\r\n\r\n    try {\r\n      // Check high-performance cache first\r\n      const cached = this.cache.get(cacheKey);\r\n      if (cached !== undefined) {\r\n        this.updateAccessPattern(key, 'cache_hit');\r\n        this.recordPerformance('retrieve_cache', performance.now() - startTime);\r\n        return cached;\r\n      }\r\n\r\n      // Database lookup with prepared statements\r\n      const dbEntry = await this.db.getMemory(key, namespace);\r\n      if (dbEntry) {\r\n        let value = dbEntry.value;\r\n\r\n        // Handle compressed data\r\n        const metadata = JSON.parse(dbEntry.metadata || '{}');\r\n        if (metadata.compressed) {\r\n          value = await this.decompressData(value);\r\n        }\r\n\r\n        const parsedValue = this.parseValue(value);\r\n\r\n        // Update cache asynchronously\r\n        this.cache.set(cacheKey, parsedValue);\r\n\r\n        // Update access stats in background\r\n        setImmediate(() => {\r\n          this.updateAccessPattern(key, 'db_hit');\r\n          this.db.updateMemoryAccess(key, namespace).catch((err) => this.emit('error', err));\r\n        });\r\n\r\n        this.recordPerformance('retrieve_db', performance.now() - startTime);\r\n        return parsedValue;\r\n      }\r\n\r\n      // Fallback to MCP memory (async, non-blocking)\r\n      this.mcpWrapper\r\n        .retrieveMemory({\r\n          action: 'retrieve',\r\n          key: `${this.swarmId}/${namespace}/${key}`,\r\n          namespace: 'hive-mind',\r\n        })\r\n        .then((mcpValue) => {\r\n          if (mcpValue) {\r\n            this.store(key, mcpValue, namespace).catch((err) => this.emit('error', err));\r\n          }\r\n        })\r\n        .catch((err) => this.emit('mcpError', err));\r\n\r\n      this.updateAccessPattern(key, 'miss');\r\n      this.recordPerformance('retrieve_miss', performance.now() - startTime);\r\n      return null;\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch retrieve for multiple keys with optimized database queries\r\n   */\r\n  async retrieveBatch(keys: string[], namespace: string = 'default'): Promise<Map<string, any>> {\r\n    const startTime = performance.now();\r\n    const results = new Map<string, any>();\r\n    const cacheHits: string[] = [];\r\n    const cacheMisses: string[] = [];\r\n\r\n    // Check cache for all keys first\r\n    for (const key of keys) {\r\n      const cacheKey = this.getCacheKey(key, namespace);\r\n      const cached = this.cache.get(cacheKey);\r\n      if (cached !== undefined) {\r\n        results.set(key, cached);\r\n        cacheHits.push(key);\r\n      } else {\r\n        cacheMisses.push(key);\r\n      }\r\n    }\r\n\r\n    // Batch query for cache misses\r\n    if (cacheMisses.length > 0) {\r\n      try {\r\n        // This would require implementing batch queries in DatabaseManager\r\n        for (const key of cacheMisses) {\r\n          const value = await this.retrieve(key, namespace);\r\n          if (value !== null) {\r\n            results.set(key, value);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        this.emit('error', error);\r\n      }\r\n    }\r\n\r\n    const duration = performance.now() - startTime;\r\n    this.emit('batchRetrieved', {\r\n      total: keys.length,\r\n      cacheHits: cacheHits.length,\r\n      found: results.size,\r\n      duration,\r\n    });\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * High-performance search with relevance scoring and caching\r\n   */\r\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\r\n    const startTime = performance.now();\r\n    const searchKey = this.generateSearchKey(options);\r\n\r\n    // Check if we have cached search results\r\n    const cachedResults = this.cache.get(`search:${searchKey}`);\r\n    if (cachedResults) {\r\n      this.recordPerformance('search_cache', performance.now() - startTime);\r\n      return cachedResults;\r\n    }\r\n\r\n    const results: MemoryEntry[] = [];\r\n\r\n    // Search in cache first for immediate results\r\n    this.searchInCache(options, results);\r\n\r\n    // If not enough results, search database with optimized query\r\n    if (results.length < (options.limit || 10)) {\r\n      const dbResults = await this.db.searchMemory(options);\r\n\r\n      for (const dbEntry of dbResults) {\r\n        const entry: MemoryEntry = {\r\n          key: dbEntry.key,\r\n          namespace: dbEntry.namespace,\r\n          value: dbEntry.value,\r\n          ttl: dbEntry.ttl,\r\n          createdAt: new Date(dbEntry.created_at),\r\n          accessCount: dbEntry.access_count,\r\n          lastAccessedAt: new Date(dbEntry.last_accessed_at),\r\n        };\r\n\r\n        if (!results.find((r) => r.key === entry.key && r.namespace === entry.namespace)) {\r\n          results.push(entry);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sort by relevance with advanced scoring\r\n    const sortedResults = this.sortByRelevance(results, options);\r\n\r\n    // Cache search results for future use (with shorter TTL)\r\n    this.cache.set(`search:${searchKey}`, sortedResults);\r\n\r\n    const duration = performance.now() - startTime;\r\n    this.recordPerformance('search_db', duration);\r\n\r\n    this.emit('searchCompleted', {\r\n      pattern: options.pattern,\r\n      results: sortedResults.length,\r\n      duration,\r\n    });\r\n\r\n    return sortedResults;\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for search options\r\n   */\r\n  private generateSearchKey(options: MemorySearchOptions): string {\r\n    return JSON.stringify({\r\n      pattern: options.pattern,\r\n      namespace: options.namespace,\r\n      limit: options.limit,\r\n      sortBy: options.sortBy,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Search within cache for immediate results\r\n   */\r\n  private searchInCache(options: MemorySearchOptions, results: MemoryEntry[]): void {\r\n    // Note: This would require implementing cache iteration\r\n    // For now, this is a placeholder for future cache search optimization\r\n  }\r\n\r\n  /**\r\n   * Delete a memory entry\r\n   */\r\n  async delete(key: string, namespace: string = 'default'): Promise<void> {\r\n    const cacheKey = this.getCacheKey(key, namespace);\r\n\r\n    // Remove from cache\r\n    this.cache.delete(cacheKey);\r\n\r\n    // Remove from database\r\n    await this.db.deleteMemory(key, namespace);\r\n\r\n    // Remove from MCP memory\r\n    await this.mcpWrapper.deleteMemory({\r\n      action: 'delete',\r\n      key: `${this.swarmId}/${namespace}/${key}`,\r\n      namespace: 'hive-mind',\r\n    });\r\n\r\n    this.emit('memoryDeleted', { key, namespace });\r\n  }\r\n\r\n  /**\r\n   * List all entries in a namespace\r\n   */\r\n  async list(namespace: string = 'default', limit: number = 100): Promise<MemoryEntry[]> {\r\n    const entries = await this.db.listMemory(namespace, limit);\r\n\r\n    return entries.map((dbEntry) => ({\r\n      key: dbEntry.key,\r\n      namespace: dbEntry.namespace,\r\n      value: dbEntry.value,\r\n      ttl: dbEntry.ttl,\r\n      createdAt: new Date(dbEntry.created_at),\r\n      accessCount: dbEntry.access_count,\r\n      lastAccessedAt: new Date(dbEntry.last_accessed_at),\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get memory statistics\r\n   */\r\n  async getStats(): Promise<MemoryStats> {\r\n    const stats = await this.db.getMemoryStats();\r\n\r\n    const byNamespace: Record<string, any> = {};\r\n    for (const ns of this.namespaces.values()) {\r\n      const nsStats = await this.db.getNamespaceStats(ns.name);\r\n      byNamespace[ns.name] = nsStats;\r\n    }\r\n\r\n    return {\r\n      totalEntries: stats.totalEntries,\r\n      totalSize: stats.totalSize,\r\n      byNamespace,\r\n      cacheHitRate: this.calculateCacheHitRate(),\r\n      avgAccessTime: this.calculateAvgAccessTime(),\r\n      hotKeys: await this.getHotKeys(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Learn patterns from memory access\r\n   */\r\n  async learnPatterns(): Promise<MemoryPattern[]> {\r\n    const patterns: MemoryPattern[] = [];\r\n\r\n    // Analyze access patterns\r\n    const accessData = Array.from(this.accessPatterns.entries())\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 20); // Top 20 accessed keys\r\n\r\n    // Identify co-access patterns\r\n    const coAccessPatterns = await this.identifyCoAccessPatterns(accessData);\r\n\r\n    // Train neural patterns\r\n    if (coAccessPatterns.length > 0) {\r\n      await this.mcpWrapper.trainNeural({\r\n        pattern_type: 'prediction',\r\n        training_data: JSON.stringify({\r\n          accessPatterns: accessData,\r\n          coAccessPatterns,\r\n        }),\r\n        epochs: 20,\r\n      });\r\n    }\r\n\r\n    // Create pattern objects\r\n    for (const pattern of coAccessPatterns) {\r\n      patterns.push({\r\n        type: 'co-access',\r\n        keys: pattern.keys,\r\n        confidence: pattern.confidence,\r\n        frequency: pattern.frequency,\r\n      });\r\n    }\r\n\r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Predict next memory access\r\n   */\r\n  async predictNextAccess(currentKey: string): Promise<string[]> {\r\n    const prediction = await this.mcpWrapper.predict({\r\n      modelId: 'memory-access-predictor',\r\n      input: currentKey,\r\n    });\r\n\r\n    return prediction.predictions || [];\r\n  }\r\n\r\n  /**\r\n   * Compress memory entries\r\n   */\r\n  async compress(namespace?: string): Promise<void> {\r\n    const entries = namespace ? await this.list(namespace) : await this.db.getAllMemoryEntries();\r\n\r\n    for (const entry of entries) {\r\n      if (this.shouldCompress(entry)) {\r\n        const compressed = await this.compressEntry(entry);\r\n        await this.store(entry.key, compressed, entry.namespace, entry.ttl);\r\n      }\r\n    }\r\n\r\n    this.emit('memoryCompressed', { namespace });\r\n  }\r\n\r\n  /**\r\n   * Backup memory to external storage\r\n   */\r\n  async backup(path: string): Promise<void> {\r\n    const allEntries = await this.db.getAllMemoryEntries();\r\n\r\n    const backup = {\r\n      swarmId: this.swarmId,\r\n      timestamp: new Date(),\r\n      entries: allEntries,\r\n      namespaces: Array.from(this.namespaces.values()),\r\n      patterns: await this.learnPatterns(),\r\n    };\r\n\r\n    // Store backup using MCP\r\n    await this.mcpWrapper.storeMemory({\r\n      action: 'store',\r\n      key: `backup/${this.swarmId}/${Date.now()}`,\r\n      value: JSON.stringify(backup),\r\n      namespace: 'hive-mind-backups',\r\n    });\r\n\r\n    this.emit('memoryBackedUp', { path, entryCount: allEntries.length });\r\n  }\r\n\r\n  /**\r\n   * Restore memory from backup\r\n   */\r\n  async restore(backupId: string): Promise<void> {\r\n    const backupData = await this.mcpWrapper.retrieveMemory({\r\n      action: 'retrieve',\r\n      key: backupId,\r\n      namespace: 'hive-mind-backups',\r\n    });\r\n\r\n    if (!backupData) {\r\n      throw new Error('Backup not found');\r\n    }\r\n\r\n    const backup = JSON.parse(backupData);\r\n\r\n    // Clear existing memory\r\n    await this.db.clearMemory(this.swarmId);\r\n    this.cache.clear();\r\n\r\n    // Restore entries\r\n    for (const entry of backup.entries) {\r\n      await this.store(entry.key, entry.value, entry.namespace, entry.ttl);\r\n    }\r\n\r\n    this.emit('memoryRestored', { backupId, entryCount: backup.entries.length });\r\n  }\r\n\r\n  /**\r\n   * Initialize default namespaces\r\n   */\r\n  private initializeNamespaces(): void {\r\n    const defaultNamespaces: MemoryNamespace[] = [\r\n      {\r\n        name: 'default',\r\n        description: 'Default memory namespace',\r\n        retentionPolicy: 'persistent',\r\n        maxEntries: 10000,\r\n      },\r\n      {\r\n        name: 'task-results',\r\n        description: 'Task execution results',\r\n        retentionPolicy: 'time-based',\r\n        ttl: 86400 * 7, // 7 days\r\n      },\r\n      {\r\n        name: 'agent-state',\r\n        description: 'Agent state and context',\r\n        retentionPolicy: 'time-based',\r\n        ttl: 86400, // 1 day\r\n      },\r\n      {\r\n        name: 'learning-data',\r\n        description: 'Machine learning training data',\r\n        retentionPolicy: 'persistent',\r\n        maxEntries: 50000,\r\n      },\r\n      {\r\n        name: 'performance-metrics',\r\n        description: 'Performance and optimization data',\r\n        retentionPolicy: 'time-based',\r\n        ttl: 86400 * 30, // 30 days\r\n      },\r\n      {\r\n        name: 'decisions',\r\n        description: 'Strategic decisions and rationale',\r\n        retentionPolicy: 'persistent',\r\n        maxEntries: 10000,\r\n      },\r\n    ];\r\n\r\n    for (const ns of defaultNamespaces) {\r\n      this.namespaces.set(ns.name, ns);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load memory from database\r\n   */\r\n  private async loadMemoryFromDatabase(): Promise<void> {\r\n    const recentEntries = await this.db.getRecentMemoryEntries(100);\r\n\r\n    for (const dbEntry of recentEntries) {\r\n      const entry: MemoryEntry = {\r\n        key: dbEntry.key,\r\n        namespace: dbEntry.namespace,\r\n        value: dbEntry.value,\r\n        ttl: dbEntry.ttl,\r\n        createdAt: new Date(dbEntry.created_at),\r\n        accessCount: dbEntry.access_count,\r\n        lastAccessedAt: new Date(dbEntry.last_accessed_at),\r\n      };\r\n\r\n      const cacheKey = this.getCacheKey(entry.key, entry.namespace);\r\n      this.cache.set(cacheKey, entry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start optimized memory managers\r\n   */\r\n  private startOptimizedManagers(): void {\r\n    // Cache optimization (every 30 seconds)\r\n    const cacheTimer = setInterval(async () => {\r\n      if (!this.isActive) return;\r\n      await this.optimizeCache();\r\n    }, 30000);\r\n\r\n    // Performance monitoring (every 10 seconds)\r\n    const metricsTimer = setInterval(() => {\r\n      if (!this.isActive) return;\r\n      this.updatePerformanceMetrics();\r\n    }, 10000);\r\n\r\n    // Memory cleanup (every 5 minutes)\r\n    const cleanupTimer = setInterval(async () => {\r\n      if (!this.isActive) return;\r\n      await this.performMemoryCleanup();\r\n    }, 300000);\r\n\r\n    // Pattern analysis (every 2 minutes)\r\n    const patternTimer = setInterval(async () => {\r\n      if (!this.isActive) return;\r\n      await this.analyzeAccessPatterns();\r\n    }, 120000);\r\n\r\n    this.optimizationTimers.push(cacheTimer, metricsTimer, cleanupTimer, patternTimer);\r\n  }\r\n\r\n  /**\r\n   * Optimize cache performance\r\n   */\r\n  private async optimizeCache(): Promise<void> {\r\n    const stats = this.cache.getStats();\r\n\r\n    // If hit rate is low, we might need to adjust caching strategy\r\n    if (stats.hitRate < 50 && stats.size > 1000) {\r\n      // Emit warning for potential cache optimization\r\n      this.emit('cacheOptimizationNeeded', stats);\r\n    }\r\n\r\n    this.emit('cacheOptimized', stats);\r\n  }\r\n\r\n  /**\r\n   * Perform comprehensive memory cleanup\r\n   */\r\n  private async performMemoryCleanup(): Promise<void> {\r\n    const startTime = performance.now();\r\n\r\n    // Clean expired entries from database\r\n    await this.evictExpiredEntries();\r\n\r\n    // Optimize object pools\r\n    this.optimizeObjectPools();\r\n\r\n    // Clean up old access patterns\r\n    this.cleanupAccessPatterns();\r\n\r\n    const duration = performance.now() - startTime;\r\n    this.emit('memoryCleanupCompleted', { duration });\r\n  }\r\n\r\n  /**\r\n   * Analyze access patterns for optimization insights\r\n   */\r\n  private async analyzeAccessPatterns(): Promise<void> {\r\n    const patterns = await this.learnPatterns();\r\n\r\n    if (patterns.length > 0) {\r\n      // Store learned patterns for future optimization\r\n      await this.store(\r\n        'learned-patterns',\r\n        patterns,\r\n        'performance-metrics',\r\n        3600, // 1 hour TTL\r\n      );\r\n    }\r\n\r\n    this.emit('patternsAnalyzed', { count: patterns.length });\r\n  }\r\n\r\n  /**\r\n   * Start pattern analyzer\r\n   */\r\n  private startPatternAnalyzer(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      // Learn access patterns\r\n      const patterns = await this.learnPatterns();\r\n\r\n      // Store patterns for future use\r\n      if (patterns.length > 0) {\r\n        await this.store(\r\n          'access-patterns',\r\n          patterns,\r\n          'learning-data',\r\n          86400, // 1 day\r\n        );\r\n      }\r\n    }, 300000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * Start memory optimizer\r\n   */\r\n  private startMemoryOptimizer(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      // Compress old entries\r\n      await this.compressOldEntries();\r\n\r\n      // Optimize namespaces\r\n      await this.optimizeNamespaces();\r\n    }, 3600000); // Every hour\r\n  }\r\n\r\n  /**\r\n   * Enhanced helper methods with performance optimizations\r\n   */\r\n\r\n  private getCacheKey(key: string, namespace: string): string {\r\n    return `${namespace}:${key}`;\r\n  }\r\n\r\n  /**\r\n   * Compress data for storage efficiency\r\n   */\r\n  private async compressData(data: string): Promise<string> {\r\n    // Simplified compression simulation\r\n    // In production, use proper compression library like zlib\r\n    try {\r\n      const compressed = {\r\n        _compressed: true,\r\n        _originalSize: data.length,\r\n        data: data.substring(0, Math.floor(data.length * 0.7)), // Simulate 30% compression\r\n      };\r\n      return JSON.stringify(compressed);\r\n    } catch {\r\n      return data; // Return original if compression fails\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decompress data\r\n   */\r\n  private async decompressData(compressedData: string): Promise<string> {\r\n    try {\r\n      const parsed = JSON.parse(compressedData);\r\n      if (parsed._compressed) {\r\n        return parsed.data; // Simplified decompression\r\n      }\r\n      return compressedData;\r\n    } catch {\r\n      return compressedData;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record performance metrics\r\n   */\r\n  private recordPerformance(operation: string, duration: number): void {\r\n    if (!this.performanceMetrics.has(operation)) {\r\n      this.performanceMetrics.set(operation, []);\r\n    }\r\n\r\n    const metrics = this.performanceMetrics.get(operation)!;\r\n    metrics.push(duration);\r\n\r\n    // Keep only last 100 measurements\r\n    if (metrics.length > 100) {\r\n      metrics.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update access patterns with intelligent tracking\r\n   */\r\n  private updateAccessPattern(key: string, operation: string): void {\r\n    const pattern = this.accessPatterns.get(key) || 0;\r\n\r\n    // Weight different operations differently\r\n    let weight = 1;\r\n    switch (operation) {\r\n      case 'cache_hit':\r\n        weight = 0.5;\r\n        break;\r\n      case 'db_hit':\r\n        weight = 1;\r\n        break;\r\n      case 'write':\r\n        weight = 2;\r\n        break;\r\n      case 'miss':\r\n        weight = 0.1;\r\n        break;\r\n    }\r\n\r\n    this.accessPatterns.set(key, pattern + weight);\r\n\r\n    // Limit access patterns size\r\n    if (this.accessPatterns.size > 10000) {\r\n      const entries = Array.from(this.accessPatterns.entries())\r\n        .sort((a, b) => a[1] - b[1])\r\n        .slice(0, 1000); // Remove least accessed\r\n\r\n      this.accessPatterns.clear();\r\n      entries.forEach(([k, v]) => this.accessPatterns.set(k, v));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics dashboard\r\n   */\r\n  private updatePerformanceMetrics(): void {\r\n    const metrics: any = {};\r\n\r\n    // Calculate averages for each operation\r\n    for (const [operation, durations] of this.performanceMetrics) {\r\n      if (durations.length > 0) {\r\n        metrics[`${operation}_avg`] = durations.reduce((a, b) => a + b, 0) / durations.length;\r\n        metrics[`${operation}_count`] = durations.length;\r\n        metrics[`${operation}_max`] = Math.max(...durations);\r\n        metrics[`${operation}_min`] = Math.min(...durations);\r\n      }\r\n    }\r\n\r\n    // Add cache statistics\r\n    const cacheStats = this.cache.getStats();\r\n    metrics.cache = cacheStats;\r\n\r\n    // Add pool statistics\r\n    if (this.objectPools.size > 0) {\r\n      metrics.pools = {};\r\n      for (const [name, pool] of this.objectPools) {\r\n        metrics.pools[name] = pool.getStats();\r\n      }\r\n    }\r\n\r\n    this.emit('performanceUpdate', metrics);\r\n  }\r\n\r\n  /**\r\n   * Optimize object pools\r\n   */\r\n  private optimizeObjectPools(): void {\r\n    for (const [name, pool] of this.objectPools) {\r\n      const stats = pool.getStats();\r\n\r\n      // If reuse rate is low, the pool might be too small\r\n      if (stats.reuseRate < 30 && stats.poolSize < 500) {\r\n        this.emit('poolOptimizationSuggested', { name, stats });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up old access patterns\r\n   */\r\n  private cleanupAccessPatterns(): void {\r\n    // Remove patterns with very low access counts\r\n    const threshold = 0.5;\r\n    const toRemove: string[] = [];\r\n\r\n    for (const [key, count] of this.accessPatterns) {\r\n      if (count < threshold) {\r\n        toRemove.push(key);\r\n      }\r\n    }\r\n\r\n    toRemove.forEach((key) => this.accessPatterns.delete(key));\r\n\r\n    if (toRemove.length > 0) {\r\n      this.emit('accessPatternsCleanedUp', { removed: toRemove.length });\r\n    }\r\n  }\r\n\r\n  private parseValue(value: string): any {\r\n    try {\r\n      return JSON.parse(value);\r\n    } catch {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  private updateAccessStats(entry: MemoryEntry): void {\r\n    entry.accessCount++;\r\n    entry.lastAccessedAt = new Date();\r\n\r\n    const cacheKey = this.getCacheKey(entry.key, entry.namespace);\r\n    this.updateAccessPattern(cacheKey, 'read');\r\n\r\n    // Update in database asynchronously\r\n    this.db.updateMemoryAccess(entry.key, entry.namespace).catch((err) => {\r\n      this.emit('error', err);\r\n    });\r\n  }\r\n\r\n  private updateNamespaceStats(namespace: string, operation: string): void {\r\n    const ns = this.namespaces.get(namespace);\r\n    if (ns) {\r\n      ns.lastOperation = operation;\r\n      ns.lastOperationTime = new Date();\r\n    }\r\n  }\r\n\r\n  private matchesSearch(entry: MemoryEntry, options: MemorySearchOptions): boolean {\r\n    if (options.namespace && entry.namespace !== options.namespace) {\r\n      return false;\r\n    }\r\n\r\n    if (options.pattern) {\r\n      const regex = new RegExp(options.pattern, 'i');\r\n      return regex.test(entry.key) || regex.test(entry.value);\r\n    }\r\n\r\n    if (options.keyPrefix && !entry.key.startsWith(options.keyPrefix)) {\r\n      return false;\r\n    }\r\n\r\n    if (options.minAccessCount && entry.accessCount < options.minAccessCount) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private sortByRelevance(entries: MemoryEntry[], options: MemorySearchOptions): MemoryEntry[] {\r\n    return entries\r\n      .sort((a, b) => {\r\n        // Sort by access count (most accessed first)\r\n        if (options.sortBy === 'access') {\r\n          return b.accessCount - a.accessCount;\r\n        }\r\n\r\n        // Sort by recency (most recent first)\r\n        if (options.sortBy === 'recent') {\r\n          return b.lastAccessedAt.getTime() - a.lastAccessedAt.getTime();\r\n        }\r\n\r\n        // Default: sort by creation time\r\n        return b.createdAt.getTime() - a.createdAt.getTime();\r\n      })\r\n      .slice(0, options.limit || 10);\r\n  }\r\n\r\n  private calculateCacheHitRate(): number {\r\n    // Simple calculation - would need more sophisticated tracking in production\r\n    const totalAccesses = Array.from(this.accessPatterns.values()).reduce((a, b) => a + b, 0);\r\n    const cacheHits = this.cache.size;\r\n\r\n    return totalAccesses > 0 ? (cacheHits / totalAccesses) * 100 : 0;\r\n  }\r\n\r\n  private calculateAvgAccessTime(): number {\r\n    // Simplified - would track actual access times in production\r\n    return 5; // 5ms average\r\n  }\r\n\r\n  private async getHotKeys(): Promise<string[]> {\r\n    return Array.from(this.accessPatterns.entries())\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 10)\r\n      .map(([key]) => key);\r\n  }\r\n\r\n  private async identifyCoAccessPatterns(accessData: [string, number][]): Promise<any[]> {\r\n    // Simplified co-access pattern detection\r\n    const patterns: any[] = [];\r\n\r\n    for (let i = 0; i < accessData.length - 1; i++) {\r\n      for (let j = i + 1; j < Math.min(i + 5, accessData.length); j++) {\r\n        if (Math.abs(accessData[i][1] - accessData[j][1]) < 10) {\r\n          patterns.push({\r\n            keys: [accessData[i][0], accessData[j][0]],\r\n            confidence: 0.8,\r\n            frequency: Math.min(accessData[i][1], accessData[j][1]),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return patterns;\r\n  }\r\n\r\n  private shouldCompress(entry: MemoryEntry): boolean {\r\n    // Compress if: large size, old, and rarely accessed\r\n    const ageInDays = (Date.now() - entry.createdAt.getTime()) / (1000 * 60 * 60 * 24);\r\n    const isOld = ageInDays > 7;\r\n    const isLarge = entry.value.length > 10000;\r\n    const isRarelyAccessed = entry.accessCount < 5;\r\n\r\n    return isOld && isLarge && isRarelyAccessed;\r\n  }\r\n\r\n  private async compressEntry(entry: MemoryEntry): Promise<string> {\r\n    // Simple compression - in production would use proper compression\r\n    const compressed = {\r\n      _compressed: true,\r\n      _original_length: entry.value.length,\r\n      data: entry.value, // Would actually compress here\r\n    };\r\n\r\n    return JSON.stringify(compressed);\r\n  }\r\n\r\n  private async evictExpiredEntries(): Promise<void> {\r\n    const now = Date.now();\r\n    const toEvict: string[] = [];\r\n\r\n    for (const [cacheKey, entry] of this.cache) {\r\n      if (entry.ttl && entry.createdAt.getTime() + entry.ttl * 1000 < now) {\r\n        toEvict.push(cacheKey);\r\n      }\r\n    }\r\n\r\n    for (const key of toEvict) {\r\n      const entry = this.cache.get(key)!;\r\n      await this.delete(entry.key, entry.namespace);\r\n    }\r\n  }\r\n\r\n  private async manageCacheSize(): Promise<void> {\r\n    const maxCacheSize = 1000;\r\n\r\n    if (this.cache.size > maxCacheSize) {\r\n      // Evict least recently used entries\r\n      const entries = Array.from(this.cache.entries()).sort(\r\n        (a, b) => a[1].lastAccessedAt.getTime() - b[1].lastAccessedAt.getTime(),\r\n      );\r\n\r\n      const toEvict = entries.slice(0, entries.length - maxCacheSize);\r\n\r\n      for (const [cacheKey] of toEvict) {\r\n        this.cache.delete(cacheKey);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async compressOldEntries(): Promise<void> {\r\n    const oldEntries = await this.db.getOldMemoryEntries(30); // 30 days old\r\n\r\n    for (const entry of oldEntries) {\r\n      if (this.shouldCompress(entry)) {\r\n        const compressed = await this.compressEntry(entry);\r\n        await this.store(entry.key, compressed, entry.namespace, entry.ttl);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async optimizeNamespaces(): Promise<void> {\r\n    for (const namespace of this.namespaces.values()) {\r\n      const stats = await this.db.getNamespaceStats(namespace.name);\r\n\r\n      // Apply retention policies\r\n      if (namespace.retentionPolicy === 'time-based' && namespace.ttl) {\r\n        await this.db.deleteOldEntries(namespace.name, namespace.ttl);\r\n      }\r\n\r\n      if (namespace.retentionPolicy === 'size-based' && namespace.maxEntries) {\r\n        if (stats.entries > namespace.maxEntries) {\r\n          await this.db.trimNamespace(namespace.name, namespace.maxEntries);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhanced shutdown with comprehensive cleanup\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    this.isActive = false;\r\n\r\n    // Clear all optimization timers\r\n    this.optimizationTimers.forEach((timer) => clearInterval(timer));\r\n    this.optimizationTimers.length = 0;\r\n\r\n    // Final performance snapshot\r\n    const finalMetrics = {\r\n      cache: this.cache.getStats(),\r\n      accessPatterns: this.accessPatterns.size,\r\n      performance: Object.fromEntries(this.performanceMetrics),\r\n    };\r\n\r\n    // Clear cache and pools\r\n    this.cache.clear();\r\n    for (const pool of this.objectPools.values()) {\r\n      // Pools will be garbage collected\r\n    }\r\n    this.objectPools.clear();\r\n\r\n    this.emit('shutdown', finalMetrics);\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive analytics\r\n   */\r\n  getAdvancedAnalytics() {\r\n    return {\r\n      basic: this.getStats(),\r\n      cache: this.cache.getStats(),\r\n      performance: Object.fromEntries(\r\n        Array.from(this.performanceMetrics.entries()).map(([op, durations]) => [\r\n          op,\r\n          {\r\n            avg: durations.reduce((a, b) => a + b, 0) / durations.length,\r\n            count: durations.length,\r\n            max: Math.max(...durations),\r\n            min: Math.min(...durations),\r\n          },\r\n        ]),\r\n      ),\r\n      pools: Object.fromEntries(\r\n        Array.from(this.objectPools.entries()).map(([name, pool]) => [name, pool.getStats()]),\r\n      ),\r\n      accessPatterns: {\r\n        total: this.accessPatterns.size,\r\n        hotKeys: Array.from(this.accessPatterns.entries())\r\n          .sort((a, b) => b[1] - a[1])\r\n          .slice(0, 10)\r\n          .map(([key, count]) => ({ key, count })),\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Memory health check with detailed analysis\r\n   */\r\n  async healthCheck() {\r\n    const analytics = this.getAdvancedAnalytics();\r\n    const health = {\r\n      status: 'healthy' as 'healthy' | 'warning' | 'critical',\r\n      score: 100,\r\n      issues: [] as string[],\r\n      recommendations: [] as string[],\r\n    };\r\n\r\n    // Check cache performance\r\n    if (analytics.cache.hitRate < 50) {\r\n      health.score -= 20;\r\n      health.issues.push('Low cache hit rate');\r\n      health.recommendations.push('Consider increasing cache size or reviewing access patterns');\r\n    }\r\n\r\n    // Check memory utilization\r\n    if (analytics.cache.utilizationPercent > 90) {\r\n      health.score -= 30;\r\n      health.status = 'warning';\r\n      health.issues.push('High cache memory utilization');\r\n      health.recommendations.push('Increase cache memory limit or optimize data storage');\r\n    }\r\n\r\n    // Check performance metrics\r\n    const avgRetrieveTime = analytics.performance.retrieve_db?.avg || 0;\r\n    if (avgRetrieveTime > 100) {\r\n      health.score -= 15;\r\n      health.issues.push('Slow database retrieval performance');\r\n      health.recommendations.push('Consider database optimization or indexing improvements');\r\n    }\r\n\r\n    // Check pool efficiency\r\n    for (const [name, stats] of Object.entries(analytics.pools)) {\r\n      if (stats.reuseRate < 30) {\r\n        health.score -= 10;\r\n        health.issues.push(`Low object pool reuse rate for ${name}`);\r\n        health.recommendations.push(`Increase ${name} pool size or review object lifecycle`);\r\n      }\r\n    }\r\n\r\n    // Determine final status\r\n    if (health.score < 60) {\r\n      health.status = 'critical';\r\n    } else if (health.score < 80) {\r\n      health.status = 'warning';\r\n    }\r\n\r\n    return health;\r\n  }\r\n}\r\n"],"names":["EventEmitter","performance","DatabaseManager","MCPToolWrapper","HighPerformanceCache","cache","Map","maxSize","maxMemory","currentMemory","hits","misses","evictions","maxMemoryMB","get","key","entry","delete","set","data","undefined","size","estimateSize","evictLRU","timestamp","Date","now","firstKey","keys","next","value","JSON","stringify","length","getStats","total","memoryUsage","hitRate","utilizationPercent","clear","has","ObjectPool","pool","createFn","resetFn","allocated","reused","acquire","pop","release","obj","push","poolSize","reuseRate","Memory","swarmId","db","mcpWrapper","namespaces","accessPatterns","performanceMetrics","objectPools","isActive","optimizationTimers","compressionThreshold","batchSize","options","cacheSize","cacheMemoryMB","initializeNamespaces","enablePooling","initializeObjectPools","initialize","startTime","getInstance","optimizeDatabaseSettings","loadMemoryFromDatabase","startOptimizedManagers","duration","recordPerformance","emit","poolsInitialized","namespace","ttl","createdAt","accessCount","lastAccessedAt","results","metadata","Object","forEach","k","error","store","entryPool","serializedValue","compressed","compressData","storeMemory","originalSize","action","catch","getCacheKey","updateAccessPattern","setImmediate","updateNamespaceStats","storeBatch","entries","batchResults","i","chunk","slice","chunkPromises","map","success","chunkResults","Promise","allSettled","successful","filter","r","status","retrieve","cacheKey","cached","dbEntry","getMemory","parse","decompressData","parsedValue","parseValue","updateMemoryAccess","err","retrieveMemory","then","mcpValue","retrieveBatch","cacheHits","cacheMisses","found","search","searchKey","generateSearchKey","cachedResults","searchInCache","limit","dbResults","searchMemory","created_at","access_count","last_accessed_at","find","sortedResults","sortByRelevance","pattern","sortBy","deleteMemory","list","listMemory","stats","getMemoryStats","byNamespace","ns","values","nsStats","getNamespaceStats","name","totalEntries","totalSize","cacheHitRate","calculateCacheHitRate","avgAccessTime","calculateAvgAccessTime","hotKeys","getHotKeys","learnPatterns","patterns","accessData","Array","from","sort","a","b","coAccessPatterns","identifyCoAccessPatterns","trainNeural","pattern_type","training_data","epochs","type","confidence","frequency","predictNextAccess","currentKey","prediction","predict","modelId","input","predictions","compress","getAllMemoryEntries","shouldCompress","compressEntry","backup","path","allEntries","entryCount","restore","backupId","backupData","Error","clearMemory","defaultNamespaces","description","retentionPolicy","maxEntries","recentEntries","getRecentMemoryEntries","cacheTimer","setInterval","optimizeCache","metricsTimer","updatePerformanceMetrics","cleanupTimer","performMemoryCleanup","patternTimer","analyzeAccessPatterns","evictExpiredEntries","optimizeObjectPools","cleanupAccessPatterns","count","startPatternAnalyzer","startMemoryOptimizer","compressOldEntries","optimizeNamespaces","_compressed","_originalSize","substring","Math","floor","compressedData","parsed","operation","metrics","shift","weight","v","durations","reduce","max","min","cacheStats","pools","threshold","toRemove","removed","updateAccessStats","lastOperation","lastOperationTime","matchesSearch","regex","RegExp","test","keyPrefix","startsWith","minAccessCount","getTime","totalAccesses","j","abs","ageInDays","isOld","isLarge","isRarelyAccessed","_original_length","toEvict","manageCacheSize","maxCacheSize","oldEntries","getOldMemoryEntries","deleteOldEntries","trimNamespace","shutdown","timer","clearInterval","finalMetrics","fromEntries","getAdvancedAnalytics","basic","op","avg","healthCheck","analytics","health","score","issues","recommendations","avgRetrieveTime","retrieve_db"],"mappings":"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"}