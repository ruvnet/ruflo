{
  "version": 3,
  "sources": ["../../src/mcp/claude-code-wrapper.ts"],
  "sourcesContent": ["#!/usr/bin/env node\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  Tool,\n  CallToolResult,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n} from '@modelcontextprotocol/sdk/types.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\nimport { SparcMode, loadSparcModes } from './sparc-modes.js';\n// Simple ID generation\nfunction generateId(): string {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\ninterface SparcContext {\n  memoryKey?: string;\n  parallel?: boolean;\n  timeout?: number;\n  workingDirectory?: string;\n}\n\ninterface SwarmAgent {\n  id: string;\n  mode: string;\n  task: string;\n  status: 'pending' | 'active' | 'completed' | 'failed';\n  result?: any;\n}\n\ninterface SwarmExecution {\n  id: string;\n  objective: string;\n  strategy: string;\n  mode: string;\n  agents: SwarmAgent[];\n  startTime: Date;\n  endTime?: Date;\n  status: 'active' | 'completed' | 'failed';\n}\n\nexport class ClaudeCodeMCPWrapper {\n  private server: Server;\n  private sparcModes: Map<string, SparcMode> = new Map();\n  private swarmExecutions: Map<string, SwarmExecution> = new Map();\n  private claudeCodeMCP: any; // Reference to Claude Code MCP client\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'claude-flow-wrapper',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    this.setupHandlers();\n    this.loadSparcModes();\n  }\n\n  private async loadSparcModes() {\n    try {\n      const modes = await loadSparcModes();\n      modes.forEach((mode) => {\n        this.sparcModes.set(mode.name, mode);\n      });\n    } catch (error) {\n      console.error('Failed to load SPARC modes:', error);\n    }\n  }\n\n  private setupHandlers() {\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({\n      tools: await this.getTools(),\n    }));\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =>\n      this.handleToolCall(request.params.name, request.params.arguments || {}),\n    );\n  }\n\n  private async getTools(): Promise<Tool[]> {\n    const tools: Tool[] = [];\n\n    // Add SPARC mode tools\n    for (const [name, mode] of this.sparcModes) {\n      tools.push({\n        name: `sparc_${name}`,\n        description: `Execute SPARC ${name} mode: ${mode.description}`,\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task: {\n              type: 'string',\n              description: 'The task description for the SPARC mode to execute',\n            },\n            context: {\n              type: 'object',\n              description: 'Optional context or parameters for the task',\n              properties: {\n                memoryKey: {\n                  type: 'string',\n                  description: 'Memory key to store results',\n                },\n                parallel: {\n                  type: 'boolean',\n                  description: 'Enable parallel execution',\n                },\n              },\n            },\n          },\n          required: ['task'],\n        },\n      });\n    }\n\n    // Add meta tools\n    tools.push(\n      {\n        name: 'sparc_list',\n        description: 'List all available SPARC modes',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            verbose: {\n              type: 'boolean',\n              description: 'Include detailed information',\n            },\n          },\n        },\n      },\n      {\n        name: 'sparc_swarm',\n        description: 'Coordinate multiple SPARC agents in a swarm',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            objective: {\n              type: 'string',\n              description: 'The swarm objective',\n            },\n            strategy: {\n              type: 'string',\n              enum: [\n                'research',\n                'development',\n                'analysis',\n                'testing',\n                'optimization',\n                'maintenance',\n              ],\n              description: 'Swarm execution strategy',\n            },\n            mode: {\n              type: 'string',\n              enum: ['centralized', 'distributed', 'hierarchical', 'mesh', 'hybrid'],\n              description: 'Coordination mode',\n            },\n            maxAgents: {\n              type: 'number',\n              description: 'Maximum number of agents',\n              default: 5,\n            },\n          },\n          required: ['objective', 'strategy'],\n        },\n      },\n      {\n        name: 'sparc_swarm_status',\n        description: 'Check status of running swarms and list created files',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            swarmId: {\n              type: 'string',\n              description: 'Optional swarm ID to check specific swarm',\n            },\n          },\n        },\n      },\n    );\n\n    return tools;\n  }\n\n  private async handleToolCall(toolName: string, args: any): Promise<CallToolResult> {\n    try {\n      if (toolName.startsWith('sparc_')) {\n        return await this.handleSparcTool(toolName, args);\n      }\n\n      // Pass through to Claude Code MCP\n      return this.forwardToClaudeCode(toolName, args);\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error: ${error instanceof Error ? error.message : String(error)}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n\n  private async handleSparcTool(toolName: string, args: any): Promise<CallToolResult> {\n    const mode = toolName.replace('sparc_', '');\n\n    // Handle special tools\n    if (mode === 'list') {\n      return this.listModes(args.verbose);\n    }\n    if (mode === 'swarm') {\n      return this.handleSwarm(args);\n    }\n    if (mode === 'swarm_status') {\n      return this.getSwarmStatus(args.swarmId);\n    }\n\n    // Standard SPARC mode execution\n    const sparcMode = this.sparcModes.get(mode);\n    if (!sparcMode) {\n      throw new Error(`Unknown SPARC mode: ${mode}`);\n    }\n\n    // Execute the SPARC mode directly\n    try {\n      // Import the execution function dynamically to avoid circular dependencies\n      // const { executeSparcMode } = await import('../cli/mcp-stdio-server.js');\n      // TODO: Implement proper SPARC mode execution or fix import path\n      const executeSparcMode = (mode: string, task: string, tools: any[], context: any) => {\n        throw new Error('SPARC mode execution not yet implemented in wrapper');\n      };\n\n      const result = await executeSparcMode(\n        mode,\n        args.task,\n        sparcMode.tools || [],\n        args.context || {},\n      );\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: result.output,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error executing SPARC ${mode}: ${error instanceof Error ? error.message : String(error)}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n\n  private buildEnhancedPrompt(mode: SparcMode, task: string, context?: SparcContext): string {\n    const parts: string[] = [];\n\n    // Add SPARC mode header\n    parts.push(`SPARC: ${mode.name}\\n`);\n    parts.push(`## Mode Description\\n${mode.description}\\n`);\n\n    // Add available tools\n    if (mode.tools && mode.tools.length > 0) {\n      parts.push(`## Available Tools`);\n      mode.tools.forEach((tool) => {\n        parts.push(`- **${tool}**: ${this.getToolDescription(tool)}`);\n      });\n      parts.push('');\n    }\n\n    // Add usage pattern\n    if (mode.usagePattern) {\n      parts.push(`## Usage Pattern\\n\\`\\`\\`javascript\\n${mode.usagePattern}\\n\\`\\`\\`\\n`);\n    }\n\n    // Add best practices\n    if (mode.bestPractices) {\n      parts.push(`## Best Practices`);\n      mode.bestPractices.forEach((practice) => {\n        parts.push(`- ${practice}`);\n      });\n      parts.push('');\n    }\n\n    // Add integration capabilities\n    if (mode.integrationCapabilities) {\n      parts.push(`## Integration Capabilities\\nThis mode integrates with:`);\n      mode.integrationCapabilities.forEach((capability) => {\n        parts.push(`- ${capability}`);\n      });\n      parts.push('');\n    }\n\n    // Add instructions\n    if (mode.instructions) {\n      parts.push(`## Instructions\\n${mode.instructions}\\n`);\n    }\n\n    // Add the actual task\n    parts.push(`## TASK: ${task}\\n`);\n\n    // Add SPARC methodology\n    parts.push(this.getSparcMethodology(mode.name, task, context));\n\n    // Add context if provided\n    if (context) {\n      if (context.memoryKey) {\n        parts.push(`**Memory Key:** \\`${context.memoryKey}\\``);\n      }\n      if (context.parallel) {\n        parts.push(`**Parallel Execution:** Enabled`);\n      }\n      if (context.workingDirectory) {\n        parts.push(`**Working Directory:** ${context.workingDirectory}`);\n      }\n    }\n\n    return parts.join('\\n');\n  }\n\n  private getToolDescription(tool: string): string {\n    const descriptions: Record<string, string> = {\n      TodoWrite: 'Create and manage task coordination',\n      TodoRead: 'Monitor task progress and status',\n      Task: 'Spawn and manage specialized agents',\n      Memory: 'Store and retrieve coordination data',\n      Bash: 'Execute system commands',\n      Read: 'Read file contents',\n      Write: 'Write files',\n      Edit: 'Edit existing files',\n      MultiEdit: 'Make multiple edits to a file',\n      Glob: 'Search for files by pattern',\n      Grep: 'Search file contents',\n      WebSearch: 'Search the web',\n      WebFetch: 'Fetch web content',\n    };\n    return descriptions[tool] || `${tool} tool`;\n  }\n\n  private getSparcMethodology(mode: string, task: string, context?: SparcContext): string {\n    return `\n# \uD83C\uDFAF SPARC METHODOLOGY EXECUTION FRAMEWORK\n\nYou are operating in **SPARC ${mode} mode**. Follow the SPARC Workflow precisely:\n\n## SPARC Workflow Steps\n\n### 1\uFE0F\u20E3 SPECIFICATION - Clarify goals, scope, constraints\n**Your Task:** ${task}\n\n**Analysis Required:**\n- Break down into clear, measurable objectives\n- Identify all requirements and constraints  \n- Define acceptance criteria\n- Never hard-code environment variables\n\n**Use TodoWrite to capture specifications:**\n\\`\\`\\`javascript\nTodoWrite([\n  {\n    id: \"specification\",\n    content: \"Clarify goals, scope, and constraints for: ${task}\",\n    status: \"pending\",\n    priority: \"high\"\n  },\n  {\n    id: \"acceptance_criteria\", \n    content: \"Define clear acceptance criteria and success metrics\",\n    status: \"pending\",\n    priority: \"high\"\n  }\n]);\n\\`\\`\\`\n\n### 2\uFE0F\u20E3 PSEUDOCODE - High-level logic with TDD anchors\n**Design Approach:**\n- Identify core functions and data structures\n- Create TDD test anchors before implementation\n- Map out component interactions\n\n### 3\uFE0F\u20E3 ARCHITECTURE - Design extensible systems\n**Architecture Requirements:**\n- Clear service boundaries\n- Define interfaces between components\n- Design for extensibility and maintainability\n- Mode-specific architecture: ${this.getModeSpecificArchitecture(mode)}\n\n### 4\uFE0F\u20E3 REFINEMENT - Iterate with TDD and security\n**Refinement Process:**\n- TDD implementation cycles\n- Security vulnerability checks (injection, XSS, CSRF)\n- Performance optimization\n- Code review and refactoring\n- All files must be \u2264 500 lines\n\n### 5\uFE0F\u20E3 COMPLETION - Integrate and verify\n**Completion Checklist:**\n- [ ] All acceptance criteria met\n- [ ] Tests passing (comprehensive test suite)\n- [ ] Security review completed\n- [ ] Documentation updated\n- [ ] Results stored in Memory: \\`sparc_${mode}_${Date.now()}\\`\n- [ ] No hard-coded secrets or env vars\n- [ ] Proper error handling in all code paths\n\n## \uD83D\uDE80 Execution Configuration\n\n**Mode:** ${mode}\n**Strategy:** ${this.getModeStrategy(mode)}\n**Memory Key:** \\`sparc_${mode}_${Date.now()}\\`\n**Batch Operations:** ${context?.parallel ? 'Enabled' : 'Standard operations'}\n**Primary Tools:** ${this.sparcModes.get(mode)?.tools?.join(', ') || 'Standard tools'}\n\n## \uD83D\uDCCB Must Block (Non-negotiable)\n- Every file \u2264 500 lines\n- No hard-coded secrets or env vars\n- All user inputs validated\n- No security vulnerabilities\n- Proper error handling in all paths\n- Each subtask ends with completion check\n\n## \uD83C\uDFAF IMMEDIATE ACTION REQUIRED\n\n**START NOW with SPARC Step 1 - SPECIFICATION:**\n\n1. Create comprehensive TodoWrite task breakdown following SPARC workflow\n2. Set \"specification\" task to \"in_progress\"\n3. Analyze requirements and define acceptance criteria\n4. Store initial analysis in Memory: \\`sparc_${mode}_${Date.now()}\\`\n\n**Remember:** You're in **${mode}** mode. Follow the SPARC workflow systematically:\nSpecification \u2192 Pseudocode \u2192 Architecture \u2192 Refinement \u2192 Completion\n\nUse the appropriate tools for each phase and maintain progress in TodoWrite.`;\n  }\n\n  private getModeSpecificArchitecture(mode: string): string {\n    const architectures: Record<string, string> = {\n      orchestrator: 'Design for parallel agent coordination with clear task boundaries',\n      coder: 'Focus on clean code architecture with proper abstractions',\n      researcher: 'Structure for data collection and analysis pipelines',\n      tdd: 'Test-first design with comprehensive test coverage',\n      architect: 'System-wide design patterns and component interactions',\n      reviewer: 'Code quality gates and review checkpoints',\n      debugger: 'Diagnostic and monitoring integration points',\n      tester: 'Test framework integration and coverage analysis',\n    };\n    return architectures[mode] || 'Design for the specific mode requirements';\n  }\n\n  private getModeStrategy(mode: string): string {\n    const strategies: Record<string, string> = {\n      orchestrator: 'Parallel coordination',\n      coder: 'Iterative development',\n      researcher: 'Deep analysis',\n      tdd: 'Test-driven cycles',\n      architect: 'System design',\n      reviewer: 'Quality assurance',\n      debugger: 'Systematic debugging',\n      tester: 'Comprehensive validation',\n    };\n    return strategies[mode] || 'Mode-specific execution';\n  }\n\n  private listModes(verbose: boolean): CallToolResult {\n    const modes = Array.from(this.sparcModes.values());\n\n    if (verbose) {\n      const content = modes.map((mode) => ({\n        name: mode.name,\n        description: mode.description,\n        tools: mode.tools,\n        bestPractices: mode.bestPractices,\n      }));\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(content, null, 2),\n          },\n        ],\n      };\n    }\n\n    const list = modes.map((m) => `- **${m.name}**: ${m.description}`).join('\\n');\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Available SPARC modes:\\n\\n${list}`,\n        },\n      ],\n    };\n  }\n\n  private async handleSwarm(args: any): Promise<CallToolResult> {\n    const { objective, strategy, mode = 'distributed', maxAgents = 5 } = args;\n    const swarmId = generateId();\n\n    // Plan swarm agents\n    const agents = this.planSwarmAgents(objective, strategy, maxAgents);\n\n    // Create swarm execution record\n    const execution: SwarmExecution = {\n      id: swarmId,\n      objective,\n      strategy,\n      mode,\n      agents,\n      startTime: new Date(),\n      status: 'active',\n    };\n\n    this.swarmExecutions.set(swarmId, execution);\n\n    // Launch agents based on coordination mode\n    if (mode === 'distributed' || mode === 'mesh') {\n      // Parallel execution\n      await Promise.all(agents.map((agent) => this.launchSwarmAgent(agent, execution)));\n    } else {\n      // Sequential execution\n      for (const agent of agents) {\n        await this.launchSwarmAgent(agent, execution);\n      }\n    }\n\n    execution.status = 'completed';\n    execution.endTime = new Date();\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify(\n            {\n              swarmId,\n              objective,\n              strategy,\n              mode,\n              agentCount: agents.length,\n              status: 'launched',\n              message: 'Swarm coordination initiated',\n            },\n            null,\n            2,\n          ),\n        },\n      ],\n    };\n  }\n\n  private planSwarmAgents(objective: string, strategy: string, maxAgents: number): SwarmAgent[] {\n    const agents: SwarmAgent[] = [];\n\n    // Strategy-based agent planning\n    switch (strategy) {\n      case 'research':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'researcher',\n            task: `Research: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'analyst',\n            task: `Analyze findings for: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'documenter',\n            task: `Document research results: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'development':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'architect',\n            task: `Design architecture: ${objective}`,\n            status: 'pending',\n          },\n          { id: generateId(), mode: 'coder', task: `Implement: ${objective}`, status: 'pending' },\n          {\n            id: generateId(),\n            mode: 'tester',\n            task: `Test implementation: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'reviewer',\n            task: `Review code: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'analysis':\n        agents.push(\n          { id: generateId(), mode: 'analyst', task: `Analyze: ${objective}`, status: 'pending' },\n          {\n            id: generateId(),\n            mode: 'optimizer',\n            task: `Optimize based on analysis: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'testing':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'tester',\n            task: `Create test suite: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'debugger',\n            task: `Debug issues: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'optimization':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'analyst',\n            task: `Performance analysis: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'optimizer',\n            task: `Optimize: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'maintenance':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'reviewer',\n            task: `Code review: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'debugger',\n            task: `Fix issues: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'documenter',\n            task: `Update documentation: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n    }\n\n    // Limit to maxAgents\n    return agents.slice(0, maxAgents);\n  }\n\n  private async launchSwarmAgent(agent: SwarmAgent, execution: SwarmExecution): Promise<void> {\n    agent.status = 'active';\n\n    try {\n      // Use the SPARC mode handler\n      const result = await this.handleSparcTool(`sparc_${agent.mode}`, {\n        task: agent.task,\n        context: {\n          memoryKey: `swarm_${execution.id}_${agent.id}`,\n          parallel: execution.mode === 'distributed',\n        },\n      });\n\n      agent.status = 'completed';\n      agent.result = result;\n    } catch (error) {\n      agent.status = 'failed';\n      agent.result = { error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n\n  private getSwarmStatus(swarmId?: string): CallToolResult {\n    if (swarmId) {\n      const execution = this.swarmExecutions.get(swarmId);\n      if (!execution) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No swarm found with ID: ${swarmId}`,\n            },\n          ],\n        };\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(execution, null, 2),\n          },\n        ],\n      };\n    }\n\n    // Return all swarms\n    const swarms = Array.from(this.swarmExecutions.values()).map((e) => ({\n      id: e.id,\n      objective: e.objective,\n      status: e.status,\n      agentCount: e.agents.length,\n      startTime: e.startTime,\n      endTime: e.endTime,\n    }));\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify(swarms, null, 2),\n        },\n      ],\n    };\n  }\n\n  private async forwardToClaudeCode(toolName: string, args: any): Promise<CallToolResult> {\n    // For SPARC tools that were already handled, this shouldn't be called\n    // For other tools, we execute them using the existing logic\n\n    if (toolName === 'Task') {\n      // This is a SPARC task that's been enhanced with prompts\n      // Extract the mode from the description if possible\n      const modeMatch = args.description?.match(/SPARC (\\w+)/);\n      if (modeMatch) {\n        const modeName = modeMatch[1];\n        const mode = this.sparcModes.get(modeName);\n        if (mode) {\n          // Execute using the existing SPARC execution logic\n          try {\n            const result = await executeSparcMode(\n              modeName,\n              args.prompt || '',\n              mode.tools || [],\n              {},\n            );\n\n            return {\n              content: [\n                {\n                  type: 'text',\n                  text: result.output,\n                },\n              ],\n            };\n          } catch (error) {\n            return {\n              content: [\n                {\n                  type: 'text',\n                  text: `Error executing SPARC ${modeName}: ${error instanceof Error ? error.message : String(error)}`,\n                },\n              ],\n              isError: true,\n            };\n          }\n        }\n      }\n    }\n\n    // For non-SPARC tools, return a message\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Tool ${toolName} is not available in this MCP server.`,\n        },\n      ],\n      isError: true,\n    };\n  }\n\n  async run() {\n    const transport = new StdioServerTransport();\n\n    // Log startup message\n    console.error('\uD83D\uDE80 Claude-Flow MCP Server (Wrapper Mode)');\n    console.error('\uD83D\uDCE6 Using Claude Code MCP pass-through with SPARC prompt injection');\n    console.error('\uD83D\uDD27 All SPARC tools available with enhanced AI capabilities');\n    console.error('\u2139\uFE0F  To use legacy mode, set CLAUDE_FLOW_LEGACY_MCP=true');\n    console.error('');\n\n    await this.server.connect(transport);\n  }\n}\n\n// Run the server if this is the main module\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const wrapper = new ClaudeCodeMCPWrapper();\n  wrapper.run().catch(console.error);\n}\n"],
  "mappings": "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",
  "names": ["executeSparcMode", "mode"]
}
