{
  "version": 3,
  "sources": ["../../src/coordination/hive-orchestrator.ts"],
  "sourcesContent": ["/**\n * Hive Mind Orchestrator - Advanced task coordination with consensus\n */\n\nimport { EventEmitter } from 'events';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface HiveTask {\n  id: string;\n  type: 'analysis' | 'design' | 'implementation' | 'testing' | 'documentation' | 'research';\n  description: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  dependencies: string[];\n  assignedTo?: string;\n  status: 'pending' | 'voting' | 'assigned' | 'executing' | 'reviewing' | 'completed' | 'failed';\n  votes: Map<string, { approve: boolean; confidence: number }>;\n  result?: any;\n  metrics?: {\n    startTime: number;\n    endTime?: number;\n    attempts: number;\n    quality?: number;\n  };\n}\n\nexport interface HiveDecision {\n  id: string;\n  type: 'task_assignment' | 'quality_check' | 'architecture' | 'consensus';\n  proposal: any;\n  votes: Map<string, boolean>;\n  result: 'approved' | 'rejected' | 'pending';\n  timestamp: number;\n}\n\nexport class HiveOrchestrator extends EventEmitter {\n  private tasks: Map<string, HiveTask> = new Map();\n  private decisions: Map<string, HiveDecision> = new Map();\n  private agentCapabilities: Map<string, Set<string>> = new Map();\n  private consensusThreshold: number;\n  private topology: string;\n\n  constructor(\n    options: {\n      consensusThreshold?: number;\n      topology?: 'hierarchical' | 'mesh' | 'ring' | 'star';\n    } = {},\n  ) {\n    super();\n    this.consensusThreshold = options.consensusThreshold || 0.6;\n    this.topology = options.topology || 'hierarchical';\n  }\n\n  /**\n   * Register agent capabilities for task matching\n   */\n  registerAgentCapabilities(agentId: string, capabilities: string[]) {\n    this.agentCapabilities.set(agentId, new Set(capabilities));\n    this.emit('agent:registered', { agentId, capabilities });\n  }\n\n  /**\n   * Decompose objective into coordinated tasks\n   */\n  async decomposeObjective(objective: string): Promise<HiveTask[]> {\n    const tasks: HiveTask[] = [];\n\n    // Analyze objective to determine task types\n    const needsResearch =\n      objective.toLowerCase().includes('research') || objective.toLowerCase().includes('analyze');\n    const needsDesign =\n      objective.toLowerCase().includes('build') ||\n      objective.toLowerCase().includes('create') ||\n      objective.toLowerCase().includes('develop');\n    const needsImplementation = needsDesign || objective.toLowerCase().includes('implement');\n\n    // Create task graph based on objective\n    if (needsResearch) {\n      tasks.push(\n        this.createTask(\n          'research',\n          `Research background and requirements for: ${objective}`,\n          'high',\n        ),\n      );\n    }\n\n    const analysisTask = this.createTask(\n      'analysis',\n      `Analyze requirements and constraints for: ${objective}`,\n      'critical',\n    );\n    tasks.push(analysisTask);\n\n    if (needsDesign) {\n      const designTask = this.createTask(\n        'design',\n        'Design system architecture and components',\n        'high',\n        [analysisTask.id],\n      );\n      tasks.push(designTask);\n\n      if (needsImplementation) {\n        const implTask = this.createTask('implementation', 'Implement core functionality', 'high', [\n          designTask.id,\n        ]);\n        tasks.push(implTask);\n\n        const testTask = this.createTask('testing', 'Test and validate implementation', 'high', [\n          implTask.id,\n        ]);\n        tasks.push(testTask);\n      }\n    }\n\n    // Always include documentation\n    const docTask = this.createTask(\n      'documentation',\n      'Document solution and decisions',\n      'medium',\n      tasks.filter((t) => t.type !== 'documentation').map((t) => t.id),\n    );\n    tasks.push(docTask);\n\n    // Apply topology-specific ordering\n    return this.applyTopologyOrdering(tasks);\n  }\n\n  /**\n   * Create a new task\n   */\n  private createTask(\n    type: HiveTask['type'],\n    description: string,\n    priority: HiveTask['priority'],\n    dependencies: string[] = [],\n  ): HiveTask {\n    const task: HiveTask = {\n      id: generateId('task'),\n      type,\n      description,\n      priority,\n      dependencies,\n      status: 'pending',\n      votes: new Map(),\n      metrics: {\n        startTime: Date.now(),\n        attempts: 0,\n      },\n    };\n\n    this.tasks.set(task.id, task);\n    this.emit('task:created', task);\n\n    return task;\n  }\n\n  /**\n   * Apply topology-specific task ordering\n   */\n  private applyTopologyOrdering(tasks: HiveTask[]): HiveTask[] {\n    switch (this.topology) {\n      case 'hierarchical':\n        // Priority-based ordering with dependency respect\n        return tasks.sort((a, b) => {\n          const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n          return priorityOrder[a.priority] - priorityOrder[b.priority];\n        });\n\n      case 'ring':\n        // Sequential ordering - each task depends on previous\n        for (let i = 1; i < tasks.length; i++) {\n          if (tasks[i].dependencies.length === 0) {\n            tasks[i].dependencies.push(tasks[i - 1].id);\n          }\n        }\n        return tasks;\n\n      case 'mesh':\n        // Parallel-friendly ordering - minimize dependencies\n        return tasks.sort((a, b) => a.dependencies.length - b.dependencies.length);\n\n      case 'star':\n        // Central coordination - all tasks report to analysis\n        const analysisTask = tasks.find((t) => t.type === 'analysis');\n        if (analysisTask) {\n          tasks.forEach((t) => {\n            if (t.id !== analysisTask.id && t.dependencies.length === 0) {\n              t.dependencies.push(analysisTask.id);\n            }\n          });\n        }\n        return tasks;\n\n      default:\n        return tasks;\n    }\n  }\n\n  /**\n   * Propose task assignment with voting\n   */\n  async proposeTaskAssignment(taskId: string, agentId: string): Promise<HiveDecision> {\n    const task = this.tasks.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} not found`);\n\n    const decision: HiveDecision = {\n      id: generateId('decision'),\n      type: 'task_assignment',\n      proposal: { taskId, agentId },\n      votes: new Map(),\n      result: 'pending',\n      timestamp: Date.now(),\n    };\n\n    this.decisions.set(decision.id, decision);\n    task.status = 'voting';\n\n    this.emit('decision:proposed', decision);\n\n    return decision;\n  }\n\n  /**\n   * Submit vote for a decision\n   */\n  submitVote(decisionId: string, agentId: string, vote: boolean) {\n    const decision = this.decisions.get(decisionId);\n    if (!decision) throw new Error(`Decision ${decisionId} not found`);\n\n    decision.votes.set(agentId, vote);\n\n    // Check if we have enough votes\n    const totalAgents = this.agentCapabilities.size;\n    const votesReceived = decision.votes.size;\n\n    if (votesReceived >= totalAgents * 0.8) {\n      // 80% participation required\n      this.evaluateDecision(decision);\n    }\n  }\n\n  /**\n   * Evaluate decision based on votes\n   */\n  private evaluateDecision(decision: HiveDecision) {\n    const approvals = Array.from(decision.votes.values()).filter((v) => v).length;\n    const totalVotes = decision.votes.size;\n    const approvalRate = approvals / totalVotes;\n\n    decision.result = approvalRate >= this.consensusThreshold ? 'approved' : 'rejected';\n\n    if (decision.result === 'approved' && decision.type === 'task_assignment') {\n      const { taskId, agentId } = decision.proposal;\n      const task = this.tasks.get(taskId);\n      if (task) {\n        task.assignedTo = agentId;\n        task.status = 'assigned';\n        this.emit('task:assigned', { task, agentId });\n      }\n    }\n\n    this.emit('decision:resolved', decision);\n  }\n\n  /**\n   * Get optimal agent for task based on capabilities\n   */\n  getOptimalAgent(taskId: string): string | null {\n    const task = this.tasks.get(taskId);\n    if (!task) return null;\n\n    let bestAgent: string | null = null;\n    let bestScore = 0;\n\n    for (const [agentId, capabilities] of this.agentCapabilities) {\n      const score = this.calculateAgentTaskScore(task, capabilities);\n      if (score > bestScore) {\n        bestScore = score;\n        bestAgent = agentId;\n      }\n    }\n\n    return bestAgent;\n  }\n\n  /**\n   * Calculate how well agent capabilities match task\n   */\n  private calculateAgentTaskScore(task: HiveTask, capabilities: Set<string>): number {\n    let score = 0;\n\n    // Type-specific scoring\n    switch (task.type) {\n      case 'research':\n        if (capabilities.has('research')) score += 5;\n        if (capabilities.has('analysis')) score += 3;\n        if (capabilities.has('exploration')) score += 2;\n        break;\n      case 'design':\n        if (capabilities.has('architecture')) score += 5;\n        if (capabilities.has('design')) score += 4;\n        if (capabilities.has('planning')) score += 3;\n        break;\n      case 'implementation':\n        if (capabilities.has('coding')) score += 5;\n        if (capabilities.has('implementation')) score += 4;\n        if (capabilities.has('building')) score += 3;\n        break;\n      case 'testing':\n        if (capabilities.has('testing')) score += 5;\n        if (capabilities.has('validation')) score += 4;\n        if (capabilities.has('quality')) score += 3;\n        break;\n      case 'documentation':\n        if (capabilities.has('documentation')) score += 5;\n        if (capabilities.has('writing')) score += 3;\n        break;\n    }\n\n    // General capabilities bonus\n    if (capabilities.has('analysis')) score += 1;\n    if (capabilities.has('optimization')) score += 1;\n\n    return score;\n  }\n\n  /**\n   * Update task status\n   */\n  updateTaskStatus(taskId: string, status: HiveTask['status'], result?: any) {\n    const task = this.tasks.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} not found`);\n\n    task.status = status;\n    if (result) task.result = result;\n    if (status === 'completed' && task.metrics) {\n      task.metrics.endTime = Date.now();\n    }\n\n    this.emit('task:updated', task);\n\n    // Check if we can start dependent tasks\n    if (status === 'completed') {\n      this.checkDependentTasks(taskId);\n    }\n  }\n\n  /**\n   * Check and update dependent tasks\n   */\n  private checkDependentTasks(completedTaskId: string) {\n    for (const task of this.tasks.values()) {\n      if (task.status === 'pending' && task.dependencies.includes(completedTaskId)) {\n        // Check if all dependencies are completed\n        const allDepsCompleted = task.dependencies.every((depId) => {\n          const depTask = this.tasks.get(depId);\n          return depTask && depTask.status === 'completed';\n        });\n\n        if (allDepsCompleted) {\n          this.emit('task:ready', task);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate swarm performance metrics\n   */\n  getPerformanceMetrics() {\n    const tasks = Array.from(this.tasks.values());\n    const completed = tasks.filter((t) => t.status === 'completed');\n    const failed = tasks.filter((t) => t.status === 'failed');\n\n    const avgExecutionTime =\n      completed.length > 0\n        ? completed.reduce(\n            (sum, t) => sum + (t.metrics?.endTime || 0) - (t.metrics?.startTime || 0),\n            0,\n          ) / completed.length\n        : 0;\n\n    const decisions = Array.from(this.decisions.values());\n    const approvedDecisions = decisions.filter((d) => d.result === 'approved');\n\n    return {\n      totalTasks: tasks.length,\n      completedTasks: completed.length,\n      failedTasks: failed.length,\n      pendingTasks: tasks.filter((t) => t.status === 'pending').length,\n      executingTasks: tasks.filter((t) => t.status === 'executing').length,\n      avgExecutionTime,\n      totalDecisions: decisions.length,\n      approvedDecisions: approvedDecisions.length,\n      consensusRate: decisions.length > 0 ? approvedDecisions.length / decisions.length : 0,\n      topology: this.topology,\n    };\n  }\n\n  /**\n   * Get task dependency graph\n   */\n  getTaskGraph() {\n    const nodes = Array.from(this.tasks.values()).map((task) => ({\n      id: task.id,\n      type: task.type,\n      status: task.status,\n      assignedTo: task.assignedTo,\n    }));\n\n    const edges = [];\n    for (const task of this.tasks.values()) {\n      for (const dep of task.dependencies) {\n        edges.push({ from: dep, to: task.id });\n      }\n    }\n\n    return { nodes, edges };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
