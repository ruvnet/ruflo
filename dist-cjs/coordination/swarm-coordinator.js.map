{
  "version": 3,
  "sources": ["../../src/coordination/swarm-coordinator.ts"],
  "sourcesContent": ["import { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { EventBus } from '../core/event-bus.js';\nimport { generateId } from '../utils/helpers.js';\nimport { SwarmMonitor } from './swarm-monitor.js';\nimport type { AdvancedTaskScheduler } from './advanced-scheduler.js';\nimport { MemoryManager } from '../memory/manager.js';\n\nexport interface SwarmAgent {\n  id: string;\n  name: string;\n  type: 'researcher' | 'coder' | 'analyst' | 'coordinator' | 'reviewer';\n  status: 'idle' | 'busy' | 'failed' | 'completed';\n  capabilities: string[];\n  currentTask?: SwarmTask;\n  processId?: number;\n  terminalId?: string;\n  metrics: {\n    tasksCompleted: number;\n    tasksFailed: number;\n    totalDuration: number;\n    lastActivity: Date;\n  };\n}\n\nexport interface SwarmTask {\n  id: string;\n  type: string;\n  description: string;\n  priority: number;\n  dependencies: string[];\n  assignedTo?: string;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  result?: any;\n  error?: string;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  retryCount: number;\n  maxRetries: number;\n  timeout?: number;\n}\n\nexport interface SwarmObjective {\n  id: string;\n  description: string;\n  strategy: 'auto' | 'research' | 'development' | 'analysis';\n  tasks: SwarmTask[];\n  status: 'planning' | 'executing' | 'completed' | 'failed';\n  createdAt: Date;\n  completedAt?: Date;\n}\n\nexport interface SwarmConfig {\n  maxAgents: number;\n  maxConcurrentTasks: number;\n  taskTimeout: number;\n  enableMonitoring: boolean;\n  enableWorkStealing: boolean;\n  enableCircuitBreaker: boolean;\n  memoryNamespace: string;\n  coordinationStrategy: 'centralized' | 'distributed' | 'hybrid';\n  backgroundTaskInterval: number;\n  healthCheckInterval: number;\n  maxRetries: number;\n  backoffMultiplier: number;\n}\n\nexport class SwarmCoordinator extends EventEmitter {\n  private logger: Logger;\n  private config: SwarmConfig;\n  private agents: Map<string, SwarmAgent>;\n  private objectives: Map<string, SwarmObjective>;\n  private tasks: Map<string, SwarmTask>;\n  private monitor?: SwarmMonitor;\n  private scheduler?: AdvancedTaskScheduler;\n  private memoryManager: MemoryManager;\n  private backgroundWorkers: Map<string, NodeJS.Timeout>;\n  private isRunning: boolean = false;\n  private workStealer?: any;\n  private circuitBreaker?: any;\n\n  constructor(config: Partial<SwarmConfig> = {}) {\n    super();\n    this.logger = new Logger('SwarmCoordinator');\n    this.config = {\n      maxAgents: 10,\n      maxConcurrentTasks: 5,\n      taskTimeout: 300000, // 5 minutes\n      enableMonitoring: true,\n      enableWorkStealing: true,\n      enableCircuitBreaker: true,\n      memoryNamespace: 'swarm',\n      coordinationStrategy: 'hybrid',\n      backgroundTaskInterval: 5000, // 5 seconds\n      healthCheckInterval: 10000, // 10 seconds\n      maxRetries: 3,\n      backoffMultiplier: 2,\n      ...config,\n    };\n\n    this.agents = new Map();\n    this.objectives = new Map();\n    this.tasks = new Map();\n    this.backgroundWorkers = new Map();\n\n    // Initialize memory manager\n    const eventBus = EventBus.getInstance();\n    this.memoryManager = new MemoryManager(\n      {\n        backend: 'sqlite',\n        namespace: this.config.memoryNamespace,\n        cacheSizeMB: 50,\n        syncOnExit: true,\n        maxEntries: 10000,\n        ttlMinutes: 60,\n      },\n      eventBus,\n      this.logger,\n    );\n\n    if (this.config.enableMonitoring) {\n      this.monitor = new SwarmMonitor({\n        updateInterval: 1000,\n        enableAlerts: true,\n        enableHistory: true,\n      });\n    }\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    // Monitor events\n    if (this.monitor) {\n      this.monitor.on('alert', (alert: any) => {\n        this.handleMonitorAlert(alert);\n      });\n    }\n\n    // Add custom event handlers for swarm coordination\n    this.on('task:completed', (data: any) => {\n      this.handleTaskCompleted(data.taskId, data.result);\n    });\n\n    this.on('task:failed', (data: any) => {\n      this.handleTaskFailed(data.taskId, data.error);\n    });\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      this.logger.warn('Swarm coordinator already running');\n      return;\n    }\n\n    this.logger.info('Starting swarm coordinator...');\n    this.isRunning = true;\n\n    // Start subsystems\n    await this.memoryManager.initialize();\n\n    if (this.monitor) {\n      await this.monitor.start();\n    }\n\n    // Start background workers\n    this.startBackgroundWorkers();\n\n    this.emit('coordinator:started');\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      return;\n    }\n\n    this.logger.info('Stopping swarm coordinator...');\n    this.isRunning = false;\n\n    // Stop background workers\n    this.stopBackgroundWorkers();\n\n    // Stop subsystems\n    await this.scheduler.shutdown();\n\n    if (this.monitor) {\n      this.monitor.stop();\n    }\n\n    this.emit('coordinator:stopped');\n  }\n\n  private startBackgroundWorkers(): void {\n    // Task processor worker\n    const taskProcessor = setInterval(() => {\n      this.processBackgroundTasks();\n    }, this.config.backgroundTaskInterval);\n    this.backgroundWorkers.set('taskProcessor', taskProcessor);\n\n    // Health check worker\n    const healthChecker = setInterval(() => {\n      this.performHealthChecks();\n    }, this.config.healthCheckInterval);\n    this.backgroundWorkers.set('healthChecker', healthChecker);\n\n    // Work stealing worker\n    if (this.workStealer) {\n      const workStealerWorker = setInterval(() => {\n        this.performWorkStealing();\n      }, this.config.backgroundTaskInterval);\n      this.backgroundWorkers.set('workStealer', workStealerWorker);\n    }\n\n    // Memory sync worker\n    const memorySync = setInterval(() => {\n      this.syncMemoryState();\n    }, this.config.backgroundTaskInterval * 2);\n    this.backgroundWorkers.set('memorySync', memorySync);\n  }\n\n  private stopBackgroundWorkers(): void {\n    for (const [name, worker] of this.backgroundWorkers) {\n      clearInterval(worker);\n      this.logger.debug(`Stopped background worker: ${name}`);\n    }\n    this.backgroundWorkers.clear();\n  }\n\n  async createObjective(\n    description: string,\n    strategy: SwarmObjective['strategy'] = 'auto',\n  ): Promise<string> {\n    const objectiveId = generateId('objective');\n    const objective: SwarmObjective = {\n      id: objectiveId,\n      description,\n      strategy,\n      tasks: [],\n      status: 'planning',\n      createdAt: new Date(),\n    };\n\n    this.objectives.set(objectiveId, objective);\n    this.logger.info(`Created objective: ${objectiveId} - ${description}`);\n\n    // Decompose objective into tasks\n    const tasks = await this.decomposeObjective(objective);\n    objective.tasks = tasks;\n\n    // Store in memory\n    await this.memoryManager.store({\n      id: `objective:${objectiveId}`,\n      agentId: 'swarm-coordinator',\n      type: 'objective',\n      content: JSON.stringify(objective),\n      namespace: this.config.memoryNamespace,\n      timestamp: new Date(),\n      metadata: {\n        type: 'objective',\n        strategy,\n        taskCount: tasks.length,\n      },\n    });\n\n    this.emit('objective:created', objective);\n    return objectiveId;\n  }\n\n  private async decomposeObjective(objective: SwarmObjective): Promise<SwarmTask[]> {\n    const tasks: SwarmTask[] = [];\n\n    switch (objective.strategy) {\n      case 'research':\n        tasks.push(\n          this.createTask('research', 'Gather information and research materials', 1),\n          this.createTask('analysis', 'Analyze research findings', 2, ['research']),\n          this.createTask('synthesis', 'Synthesize insights and create report', 3, ['analysis']),\n        );\n        break;\n\n      case 'development':\n        tasks.push(\n          this.createTask('planning', 'Plan architecture and design', 1),\n          this.createTask('implementation', 'Implement core functionality', 2, ['planning']),\n          this.createTask('testing', 'Test and validate implementation', 3, ['implementation']),\n          this.createTask('documentation', 'Create documentation', 3, ['implementation']),\n          this.createTask('review', 'Peer review and refinement', 4, ['testing', 'documentation']),\n        );\n        break;\n\n      case 'analysis':\n        tasks.push(\n          this.createTask('data-collection', 'Collect and prepare data', 1),\n          this.createTask('analysis', 'Perform detailed analysis', 2, ['data-collection']),\n          this.createTask('visualization', 'Create visualizations', 3, ['analysis']),\n          this.createTask('reporting', 'Generate final report', 4, ['analysis', 'visualization']),\n        );\n        break;\n\n      default: // auto\n        // Use AI to decompose based on objective description\n        tasks.push(\n          this.createTask('exploration', 'Explore and understand requirements', 1),\n          this.createTask('planning', 'Create execution plan', 2, ['exploration']),\n          this.createTask('execution', 'Execute main tasks', 3, ['planning']),\n          this.createTask('validation', 'Validate and test results', 4, ['execution']),\n          this.createTask('completion', 'Finalize and document', 5, ['validation']),\n        );\n    }\n\n    // Register tasks\n    tasks.forEach((task) => {\n      this.tasks.set(task.id, task);\n    });\n\n    return tasks;\n  }\n\n  private createTask(\n    type: string,\n    description: string,\n    priority: number,\n    dependencies: string[] = [],\n  ): SwarmTask {\n    return {\n      id: generateId('task'),\n      type,\n      description,\n      priority,\n      dependencies,\n      status: 'pending',\n      createdAt: new Date(),\n      retryCount: 0,\n      maxRetries: this.config.maxRetries,\n      timeout: this.config.taskTimeout,\n    };\n  }\n\n  async registerAgent(\n    name: string,\n    type: SwarmAgent['type'],\n    capabilities: string[] = [],\n  ): Promise<string> {\n    const agentId = generateId('agent');\n    const agent: SwarmAgent = {\n      id: agentId,\n      name,\n      type,\n      status: 'idle',\n      capabilities,\n      metrics: {\n        tasksCompleted: 0,\n        tasksFailed: 0,\n        totalDuration: 0,\n        lastActivity: new Date(),\n      },\n    };\n\n    this.agents.set(agentId, agent);\n\n    if (this.monitor) {\n      this.monitor.registerAgent(agentId, name);\n    }\n\n    // Register with work stealer if enabled\n    if (this.workStealer) {\n      this.workStealer.registerWorker(agentId, 1);\n    }\n\n    this.logger.info(`Registered agent: ${name} (${agentId}) - Type: ${type}`);\n    this.emit('agent:registered', agent);\n\n    return agentId;\n  }\n\n  async assignTask(taskId: string, agentId: string): Promise<void> {\n    const task = this.tasks.get(taskId);\n    const agent = this.agents.get(agentId);\n\n    if (!task || !agent) {\n      throw new Error('Task or agent not found');\n    }\n\n    if (agent.status !== 'idle') {\n      throw new Error('Agent is not available');\n    }\n\n    // Check circuit breaker\n    if (this.circuitBreaker && !this.circuitBreaker.canExecute(agentId)) {\n      throw new Error('Agent circuit breaker is open');\n    }\n\n    task.assignedTo = agentId;\n    task.status = 'running';\n    task.startedAt = new Date();\n\n    agent.status = 'busy';\n    agent.currentTask = task;\n\n    if (this.monitor) {\n      this.monitor.taskStarted(agentId, taskId, task.description);\n    }\n\n    this.logger.info(`Assigned task ${taskId} to agent ${agentId}`);\n    this.emit('task:assigned', { task, agent });\n\n    // Execute task in background\n    this.executeTask(task, agent);\n  }\n\n  private async executeTask(task: SwarmTask, agent: SwarmAgent): Promise<void> {\n    try {\n      // Simulate task execution\n      // In real implementation, this would spawn actual Claude instances\n      const result = await this.simulateTaskExecution(task, agent);\n\n      await this.handleTaskCompleted(task.id, result);\n    } catch (error) {\n      await this.handleTaskFailed(task.id, error);\n    }\n  }\n\n  private async simulateTaskExecution(task: SwarmTask, agent: SwarmAgent): Promise<any> {\n    // This is where we would actually spawn Claude processes\n    // For now, simulate with timeout\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Task timeout'));\n      }, task.timeout || this.config.taskTimeout);\n\n      // Simulate work\n      setTimeout(\n        () => {\n          clearTimeout(timeout);\n          resolve({\n            taskId: task.id,\n            agentId: agent.id,\n            result: `Completed ${task.type} task`,\n            timestamp: new Date(),\n          });\n        },\n        Math.random() * 5000 + 2000,\n      );\n    });\n  }\n\n  private async handleTaskCompleted(taskId: string, result: any): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) return;\n\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo) : null;\n\n    task.status = 'completed';\n    task.completedAt = new Date();\n    task.result = result;\n\n    if (agent) {\n      agent.status = 'idle';\n      agent.currentTask = undefined;\n      agent.metrics.tasksCompleted++;\n      agent.metrics.totalDuration += task.completedAt.getTime() - (task.startedAt?.getTime() || 0);\n      agent.metrics.lastActivity = new Date();\n\n      if (this.monitor) {\n        this.monitor.taskCompleted(agent.id, taskId);\n      }\n\n      if (this.circuitBreaker) {\n        this.circuitBreaker.recordSuccess(agent.id);\n      }\n    }\n\n    // Store result in memory\n    await this.memoryManager.store({\n      id: `task:${taskId}:result`,\n      agentId: agent?.id || 'unknown',\n      type: 'task-result',\n      content: JSON.stringify(result),\n      namespace: this.config.memoryNamespace,\n      timestamp: new Date(),\n      metadata: {\n        type: 'task-result',\n        taskType: task.type,\n        agentId: agent?.id,\n      },\n    });\n\n    this.logger.info(`Task ${taskId} completed successfully`);\n    this.emit('task:completed', { task, result });\n\n    // Check if objective is complete\n    this.checkObjectiveCompletion(task);\n  }\n\n  private async handleTaskFailed(taskId: string, error: any): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) return;\n\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo) : null;\n\n    task.error = (error instanceof Error ? error.message : String(error)) || String(error);\n    task.retryCount++;\n\n    if (agent) {\n      agent.status = 'idle';\n      agent.currentTask = undefined;\n      agent.metrics.tasksFailed++;\n      agent.metrics.lastActivity = new Date();\n\n      if (this.monitor) {\n        this.monitor.taskFailed(agent.id, taskId, task.error);\n      }\n\n      if (this.circuitBreaker) {\n        this.circuitBreaker.recordFailure(agent.id);\n      }\n    }\n\n    // Retry logic\n    if (task.retryCount < task.maxRetries) {\n      task.status = 'pending';\n      task.assignedTo = undefined;\n      this.logger.warn(`Task ${taskId} failed, will retry (${task.retryCount}/${task.maxRetries})`);\n      this.emit('task:retry', { task, error });\n    } else {\n      task.status = 'failed';\n      task.completedAt = new Date();\n      this.logger.error(`Task ${taskId} failed after ${task.retryCount} retries`);\n      this.emit('task:failed', { task, error });\n    }\n  }\n\n  private checkObjectiveCompletion(completedTask: SwarmTask): void {\n    for (const [objectiveId, objective] of this.objectives) {\n      if (objective.status !== 'executing') continue;\n\n      const allTasksComplete = objective.tasks.every((task) => {\n        const t = this.tasks.get(task.id);\n        return t && (t.status === 'completed' || t.status === 'failed');\n      });\n\n      if (allTasksComplete) {\n        objective.status = 'completed';\n        objective.completedAt = new Date();\n        this.logger.info(`Objective ${objectiveId} completed`);\n        this.emit('objective:completed', objective);\n      }\n    }\n  }\n\n  private async processBackgroundTasks(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      // Process pending tasks\n      const pendingTasks = Array.from(this.tasks.values()).filter(\n        (t) => t.status === 'pending' && this.areDependenciesMet(t),\n      );\n\n      // Get available agents\n      const availableAgents = Array.from(this.agents.values()).filter((a) => a.status === 'idle');\n\n      // Assign tasks to agents\n      for (const task of pendingTasks) {\n        if (availableAgents.length === 0) break;\n\n        const agent = this.selectBestAgent(task, availableAgents);\n        if (agent) {\n          try {\n            await this.assignTask(task.id, agent.id);\n            availableAgents.splice(availableAgents.indexOf(agent), 1);\n          } catch (error) {\n            this.logger.error(`Failed to assign task ${task.id}:`, error);\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error processing background tasks:', error);\n    }\n  }\n\n  private areDependenciesMet(task: SwarmTask): boolean {\n    return task.dependencies.every((depId) => {\n      const dep = this.tasks.get(depId);\n      return dep && dep.status === 'completed';\n    });\n  }\n\n  private selectBestAgent(task: SwarmTask, availableAgents: SwarmAgent[]): SwarmAgent | null {\n    // Simple selection based on task type and agent capabilities\n    const compatibleAgents = availableAgents.filter((agent) => {\n      // Match task type to agent type\n      if (task.type.includes('research') && agent.type === 'researcher') return true;\n      if (task.type.includes('implement') && agent.type === 'coder') return true;\n      if (task.type.includes('analysis') && agent.type === 'analyst') return true;\n      if (task.type.includes('review') && agent.type === 'reviewer') return true;\n      return agent.type === 'coordinator'; // Coordinator can do any task\n    });\n\n    if (compatibleAgents.length === 0) {\n      return availableAgents[0]; // Fallback to any available agent\n    }\n\n    // Select agent with best performance metrics\n    return compatibleAgents.reduce((best, agent) => {\n      const bestRatio = best.metrics.tasksCompleted / (best.metrics.tasksFailed + 1);\n      const agentRatio = agent.metrics.tasksCompleted / (agent.metrics.tasksFailed + 1);\n      return agentRatio > bestRatio ? agent : best;\n    });\n  }\n\n  private async performHealthChecks(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      const now = new Date();\n\n      for (const [agentId, agent] of this.agents) {\n        // Check for stalled agents\n        if (agent.status === 'busy' && agent.currentTask) {\n          const taskDuration = now.getTime() - (agent.currentTask.startedAt?.getTime() || 0);\n          if (taskDuration > this.config.taskTimeout) {\n            this.logger.warn(`Agent ${agentId} appears stalled on task ${agent.currentTask.id}`);\n            await this.handleTaskFailed(agent.currentTask.id, new Error('Task timeout'));\n          }\n        }\n\n        // Check agent health\n        const inactivityTime = now.getTime() - agent.metrics.lastActivity.getTime();\n        if (inactivityTime > this.config.healthCheckInterval * 3) {\n          this.logger.warn(\n            `Agent ${agentId} has been inactive for ${Math.round(inactivityTime / 1000)}s`,\n          );\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error performing health checks:', error);\n    }\n  }\n\n  private async performWorkStealing(): Promise<void> {\n    if (!this.isRunning || !this.workStealer) return;\n\n    try {\n      // Get agent workloads\n      const workloads = new Map<string, number>();\n      for (const [agentId, agent] of this.agents) {\n        workloads.set(agentId, agent.status === 'busy' ? 1 : 0);\n      }\n\n      // Update work stealer\n      this.workStealer.updateLoads(workloads);\n\n      // Check for work stealing opportunities\n      const stealingSuggestions = this.workStealer.suggestWorkStealing();\n\n      for (const suggestion of stealingSuggestions) {\n        this.logger.debug(`Work stealing suggestion: ${suggestion.from} -> ${suggestion.to}`);\n        // In a real implementation, we would reassign tasks here\n      }\n    } catch (error) {\n      this.logger.error('Error performing work stealing:', error);\n    }\n  }\n\n  private async syncMemoryState(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      // Sync current state to memory\n      const state = {\n        objectives: Array.from(this.objectives.values()),\n        tasks: Array.from(this.tasks.values()),\n        agents: Array.from(this.agents.values()).map((a) => ({\n          ...a,\n          currentTask: undefined, // Don't store transient state\n        })),\n        timestamp: new Date(),\n      };\n\n      await this.memoryManager.store({\n        id: 'swarm:state',\n        agentId: 'swarm-coordinator',\n        type: 'swarm-state',\n        content: JSON.stringify(state),\n        namespace: this.config.memoryNamespace,\n        timestamp: new Date(),\n        metadata: {\n          type: 'swarm-state',\n          objectiveCount: state.objectives.length,\n          taskCount: state.tasks.length,\n          agentCount: state.agents.length,\n        },\n      });\n    } catch (error) {\n      this.logger.error('Error syncing memory state:', error);\n    }\n  }\n\n  private handleMonitorAlert(alert: any): void {\n    this.logger.warn(`Monitor alert: ${alert.message}`);\n    this.emit('monitor:alert', alert);\n  }\n\n  private handleAgentMessage(message: Message): void {\n    this.logger.debug(`Agent message: ${message.type} from ${message.from}`);\n    this.emit('agent:message', message);\n  }\n\n  // Public API methods\n  async executeObjective(objectiveId: string): Promise<void> {\n    const objective = this.objectives.get(objectiveId);\n    if (!objective) {\n      throw new Error('Objective not found');\n    }\n\n    objective.status = 'executing';\n    this.logger.info(`Executing objective: ${objectiveId}`);\n    this.emit('objective:started', objective);\n\n    // Tasks will be processed by background workers\n  }\n\n  getObjectiveStatus(objectiveId: string): SwarmObjective | undefined {\n    return this.objectives.get(objectiveId);\n  }\n\n  getAgentStatus(agentId: string): SwarmAgent | undefined {\n    return this.agents.get(agentId);\n  }\n\n  getSwarmStatus(): {\n    objectives: number;\n    tasks: { total: number; pending: number; running: number; completed: number; failed: number };\n    agents: { total: number; idle: number; busy: number; failed: number };\n    uptime: number;\n  } {\n    const tasks = Array.from(this.tasks.values());\n    const agents = Array.from(this.agents.values());\n\n    return {\n      objectives: this.objectives.size,\n      tasks: {\n        total: tasks.length,\n        pending: tasks.filter((t) => t.status === 'pending').length,\n        running: tasks.filter((t) => t.status === 'running').length,\n        completed: tasks.filter((t) => t.status === 'completed').length,\n        failed: tasks.filter((t) => t.status === 'failed').length,\n      },\n      agents: {\n        total: agents.length,\n        idle: agents.filter((a) => a.status === 'idle').length,\n        busy: agents.filter((a) => a.status === 'busy').length,\n        failed: agents.filter((a) => a.status === 'failed').length,\n      },\n      uptime: this.monitor ? this.monitor.getSummary().uptime : 0,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
