{"version":3,"sources":["../../../../src/cli/commands/hive.ts"],"sourcesContent":["/**\r\n * Hive Mind Command - Multi-agent swarm coordination with consensus mechanisms\r\n */\r\n\r\nimport { CommandContext, success, error, warning, info } from '../cli-core.js';\r\nimport { generateId } from '../../utils/helpers.js';\r\nimport { SwarmCoordinator } from '../../coordination/swarm-coordinator.js';\r\nimport { SwarmMemoryManager } from '../../memory/swarm-memory.js';\r\n\r\ninterface HiveOptions {\r\n  objective: string;\r\n  topology: 'mesh' | 'hierarchical' | 'ring' | 'star';\r\n  consensus: 'quorum' | 'unanimous' | 'weighted' | 'leader';\r\n  maxAgents: number;\r\n  timeout: number;\r\n  monitor: boolean;\r\n  background: boolean;\r\n  memoryNamespace: string;\r\n  qualityThreshold: number;\r\n  sparc: boolean;\r\n}\r\n\r\ninterface HiveAgent {\r\n  id: string;\r\n  type: 'queen' | 'worker' | 'scout' | 'guardian' | 'architect';\r\n  role: string;\r\n  capabilities: string[];\r\n  status: 'idle' | 'active' | 'voting' | 'executing';\r\n  votes: Map<string, boolean>;\r\n}\r\n\r\nexport async function hiveAction(ctx: CommandContext) {\r\n  if (ctx.flags.help || ctx.flags.h) {\r\n    showHiveHelp();\r\n    return;\r\n  }\r\n\r\n  const objective = ctx.args.join(' ').trim();\r\n  if (!objective) {\r\n    error('Usage: hive <objective> [options]');\r\n    showHiveHelp();\r\n    return;\r\n  }\r\n\r\n  const options: HiveOptions = {\r\n    objective,\r\n    topology: (ctx.flags.topology as any) || 'hierarchical',\r\n    consensus: (ctx.flags.consensus as any) || 'quorum',\r\n    maxAgents: Number(ctx.flags.maxAgents || ctx.flags['max-agents']) || 8,\r\n    timeout: Number(ctx.flags.timeout) || 60,\r\n    monitor: Boolean(ctx.flags.monitor) || false,\r\n    background: Boolean(ctx.flags.background) || false,\r\n    memoryNamespace: String(ctx.flags['memory-namespace']) || 'hive',\r\n    qualityThreshold: Number(ctx.flags['quality-threshold']) || 0.8,\r\n    sparc: ctx.flags.sparc !== false,\r\n  };\r\n\r\n  const hiveId = generateId('hive');\r\n\r\n  success(`üêù Initializing Hive Mind: ${hiveId}`);\r\n  console.log(`üëë Queen Genesis coordinating...`);\r\n  console.log(`üìã Objective: ${objective}`);\r\n  console.log(`üèóÔ∏è Topology: ${options.topology}`);\r\n  console.log(`üó≥Ô∏è Consensus: ${options.consensus}`);\r\n  console.log(`ü§ñ Max Agents: ${options.maxAgents}`);\r\n\r\n  try {\r\n    // Initialize Hive coordinator\r\n    const coordinator = new SwarmCoordinator({\r\n      maxAgents: options.maxAgents,\r\n      maxConcurrentTasks: options.maxAgents,\r\n      taskTimeout: options.timeout * 60 * 1000,\r\n      enableMonitoring: options.monitor,\r\n      enableWorkStealing: true,\r\n      enableCircuitBreaker: true,\r\n      memoryNamespace: options.memoryNamespace,\r\n      coordinationStrategy: 'distributed',\r\n    });\r\n\r\n    // Initialize Hive memory\r\n    const memory = new SwarmMemoryManager({\r\n      namespace: options.memoryNamespace,\r\n      enableDistribution: true,\r\n      enableKnowledgeBase: true,\r\n      persistencePath: `./hive-runs/${hiveId}/memory`,\r\n    });\r\n\r\n    await coordinator.start();\r\n    await memory.initialize();\r\n\r\n    // Create Queen Genesis\r\n    const queenId = await coordinator.registerAgent('Queen-Genesis', 'coordinator', [\r\n      'orchestration',\r\n      'consensus',\r\n      'decision-making',\r\n      'delegation',\r\n    ]);\r\n\r\n    // Create specialized agents based on topology\r\n    const agents = await spawnHiveAgents(coordinator, options);\r\n\r\n    // Store Hive configuration\r\n    await memory.store(`hive/${hiveId}/config`, {\r\n      hiveId,\r\n      objective,\r\n      options,\r\n      queenId,\r\n      agents: agents.map((a) => a.id),\r\n      startTime: new Date().toISOString(),\r\n    });\r\n\r\n    // Create objective with Hive consensus\r\n    const objectiveId = await coordinator.createObjective(objective, 'development');\r\n\r\n    // Execute with consensus mechanisms\r\n    if (options.sparc) {\r\n      info('üß™ SPARC methodology enabled - full TDD workflow');\r\n      await executeSparcHive(coordinator, memory, objectiveId, agents, options);\r\n    } else {\r\n      await executeHive(coordinator, memory, objectiveId, agents, options);\r\n    }\r\n\r\n    if (!options.background) {\r\n      // Show results\r\n      const status = coordinator.getSwarmStatus();\r\n      console.log(`\\nüìä Hive Mind Summary:`);\r\n      console.log(`  - Consensus Rounds: ${(status as any).customMetrics?.consensusRounds || 0}`);\r\n      console.log(`  - Decisions Made: ${(status as any).customMetrics?.decisions || 0}`);\r\n      console.log(`  - Tasks Completed: ${status.tasks.completed}`);\r\n      console.log(`  - Quality Score: ${(status as any).customMetrics?.qualityScore || 0}%`);\r\n\r\n      success(`‚úÖ Hive Mind ${hiveId} completed successfully`);\r\n    }\r\n  } catch (err) {\r\n    error(`Hive Mind error: ${(err as Error).message}`);\r\n  }\r\n}\r\n\r\nasync function spawnHiveAgents(\r\n  coordinator: SwarmCoordinator,\r\n  options: HiveOptions,\r\n): Promise<HiveAgent[]> {\r\n  const agents: HiveAgent[] = [];\r\n\r\n  // Define agent types based on topology\r\n  const agentConfigs = getAgentConfigsForTopology(options.topology);\r\n\r\n  for (let i = 0; i < Math.min(options.maxAgents - 1, agentConfigs.length); i++) {\r\n    const config = agentConfigs[i % agentConfigs.length];\r\n    const agentId = await coordinator.registerAgent(\r\n      `${config.type}-${i + 1}`,\r\n      config.role as any,\r\n      config.capabilities,\r\n    );\r\n\r\n    agents.push({\r\n      id: agentId,\r\n      type: config.type as any,\r\n      role: config.role,\r\n      capabilities: config.capabilities,\r\n      status: 'idle',\r\n      votes: new Map(),\r\n    });\r\n\r\n    console.log(`  üêù Spawned ${config.type} agent: ${agentId}`);\r\n  }\r\n\r\n  return agents;\r\n}\r\n\r\nfunction getAgentConfigsForTopology(topology: string) {\r\n  switch (topology) {\r\n    case 'hierarchical':\r\n      return [\r\n        {\r\n          type: 'architect',\r\n          role: 'architect',\r\n          capabilities: ['design', 'planning', 'architecture'],\r\n        },\r\n        { type: 'worker', role: 'coder', capabilities: ['implementation', 'coding', 'testing'] },\r\n        { type: 'worker', role: 'analyst', capabilities: ['analysis', 'optimization', 'metrics'] },\r\n        {\r\n          type: 'scout',\r\n          role: 'researcher',\r\n          capabilities: ['research', 'exploration', 'discovery'],\r\n        },\r\n        { type: 'guardian', role: 'reviewer', capabilities: ['review', 'quality', 'validation'] },\r\n      ];\r\n    case 'mesh':\r\n      return [\r\n        { type: 'worker', role: 'generalist', capabilities: ['coding', 'analysis', 'research'] },\r\n        {\r\n          type: 'worker',\r\n          role: 'specialist',\r\n          capabilities: ['optimization', 'architecture', 'testing'],\r\n        },\r\n        { type: 'scout', role: 'explorer', capabilities: ['discovery', 'research', 'innovation'] },\r\n        {\r\n          type: 'guardian',\r\n          role: 'validator',\r\n          capabilities: ['validation', 'quality', 'security'],\r\n        },\r\n      ];\r\n    case 'ring':\r\n      return [\r\n        {\r\n          type: 'worker',\r\n          role: 'processor',\r\n          capabilities: ['processing', 'transformation', 'execution'],\r\n        },\r\n        { type: 'worker', role: 'analyzer', capabilities: ['analysis', 'metrics', 'insights'] },\r\n        {\r\n          type: 'worker',\r\n          role: 'builder',\r\n          capabilities: ['building', 'implementation', 'integration'],\r\n        },\r\n      ];\r\n    case 'star':\r\n      return [\r\n        {\r\n          type: 'worker',\r\n          role: 'executor',\r\n          capabilities: ['execution', 'implementation', 'delivery'],\r\n        },\r\n        { type: 'scout', role: 'sensor', capabilities: ['monitoring', 'detection', 'alerting'] },\r\n        { type: 'architect', role: 'planner', capabilities: ['planning', 'design', 'strategy'] },\r\n      ];\r\n    default:\r\n      return [];\r\n  }\r\n}\r\n\r\nasync function executeHive(\r\n  coordinator: SwarmCoordinator,\r\n  memory: SwarmMemoryManager,\r\n  objectiveId: string,\r\n  agents: HiveAgent[],\r\n  options: HiveOptions,\r\n) {\r\n  // Phase 1: Task decomposition with consensus\r\n  console.log('\\nüß© Phase 1: Task Decomposition');\r\n  const tasks = await decomposeWithConsensus(\r\n    coordinator,\r\n    memory,\r\n    options.objective,\r\n    agents,\r\n    options,\r\n  );\r\n\r\n  // Phase 2: Task assignment with voting\r\n  console.log('\\nüó≥Ô∏è Phase 2: Task Assignment');\r\n  const assignments = await assignTasksWithVoting(coordinator, memory, tasks, agents, options);\r\n\r\n  // Phase 3: Parallel execution with monitoring\r\n  console.log('\\n‚ö° Phase 3: Parallel Execution');\r\n  await executeTasksWithMonitoring(coordinator, memory, assignments, agents, options);\r\n\r\n  // Phase 4: Result aggregation with quality checks\r\n  console.log('\\nüìä Phase 4: Result Aggregation');\r\n  await aggregateResultsWithQuality(coordinator, memory, objectiveId, agents, options);\r\n}\r\n\r\nasync function executeSparcHive(\r\n  coordinator: SwarmCoordinator,\r\n  memory: SwarmMemoryManager,\r\n  objectiveId: string,\r\n  agents: HiveAgent[],\r\n  options: HiveOptions,\r\n) {\r\n  console.log('\\nüß™ SPARC Hive Execution Mode');\r\n\r\n  // S: Specification with consensus\r\n  console.log('\\nüìã S - Specification Phase');\r\n  await conductConsensusRound(memory, agents, 'specification', {\r\n    task: 'Define requirements and acceptance criteria',\r\n    objective: options.objective,\r\n  });\r\n\r\n  // P: Pseudocode with voting\r\n  console.log('\\nüßÆ P - Pseudocode Phase');\r\n  await conductConsensusRound(memory, agents, 'pseudocode', {\r\n    task: 'Design algorithms and data structures',\r\n    objective: options.objective,\r\n  });\r\n\r\n  // A: Architecture with review\r\n  console.log('\\nüèóÔ∏è A - Architecture Phase');\r\n  await conductConsensusRound(memory, agents, 'architecture', {\r\n    task: 'Design system architecture',\r\n    objective: options.objective,\r\n  });\r\n\r\n  // R: Refinement with TDD\r\n  console.log('\\n‚ôªÔ∏è R - Refinement Phase (TDD)');\r\n  await conductConsensusRound(memory, agents, 'refinement', {\r\n    task: 'Implement with test-driven development',\r\n    objective: options.objective,\r\n  });\r\n\r\n  // C: Completion with validation\r\n  console.log('\\n‚úÖ C - Completion Phase');\r\n  await conductConsensusRound(memory, agents, 'completion', {\r\n    task: 'Integrate and validate solution',\r\n    objective: options.objective,\r\n  });\r\n}\r\n\r\nasync function conductConsensusRound(\r\n  memory: SwarmMemoryManager,\r\n  agents: HiveAgent[],\r\n  phase: string,\r\n  context: any,\r\n) {\r\n  const roundId = generateId('round');\r\n\r\n  // Store round context\r\n  await memory.store(`consensus/${roundId}/context`, {\r\n    phase,\r\n    context,\r\n    agents: agents.map((a) => a.id),\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n\r\n  // Simulate voting\r\n  const votes = new Map<string, boolean>();\r\n  agents.forEach((agent) => {\r\n    const vote = Math.random() > 0.2; // 80% approval rate\r\n    votes.set(agent.id, vote);\r\n    console.log(`  üó≥Ô∏è ${agent.type}-${agent.id}: ${vote ? '‚úÖ Approve' : '‚ùå Reject'}`);\r\n  });\r\n\r\n  // Calculate consensus\r\n  const approvals = Array.from(votes.values()).filter((v) => v).length;\r\n  const consensus = approvals / agents.length;\r\n\r\n  console.log(`  üìä Consensus: ${(consensus * 100).toFixed(1)}% (${approvals}/${agents.length})`);\r\n\r\n  // Store results\r\n  await memory.store(`consensus/${roundId}/results`, {\r\n    votes: Object.fromEntries(votes),\r\n    consensus,\r\n    approved: consensus >= 0.5,\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n}\r\n\r\nasync function decomposeWithConsensus(\r\n  coordinator: SwarmCoordinator,\r\n  memory: SwarmMemoryManager,\r\n  objective: string,\r\n  agents: HiveAgent[],\r\n  options: HiveOptions,\r\n): Promise<any[]> {\r\n  // Queen proposes task decomposition\r\n  const proposedTasks = [\r\n    { type: 'analysis', description: `Analyze requirements for: ${objective}` },\r\n    { type: 'design', description: `Design solution architecture` },\r\n    { type: 'implementation', description: `Implement core functionality` },\r\n    { type: 'testing', description: `Test and validate solution` },\r\n    { type: 'documentation', description: `Document the implementation` },\r\n  ];\r\n\r\n  // Agents vote on task breakdown\r\n  console.log('  üëë Queen proposes task breakdown...');\r\n  console.log('  üó≥Ô∏è Agents voting on tasks...');\r\n\r\n  // Simulate consensus\r\n  const approved =\r\n    options.consensus === 'unanimous'\r\n      ? agents.length === agents.length // All must agree\r\n      : agents.length > agents.length / 2; // Simple majority\r\n\r\n  console.log(`  ‚úÖ Task breakdown ${approved ? 'approved' : 'rejected'}`);\r\n\r\n  return proposedTasks;\r\n}\r\n\r\nasync function assignTasksWithVoting(\r\n  coordinator: SwarmCoordinator,\r\n  memory: SwarmMemoryManager,\r\n  tasks: any[],\r\n  agents: HiveAgent[],\r\n  options: HiveOptions,\r\n): Promise<Map<string, string>> {\r\n  const assignments = new Map<string, string>();\r\n\r\n  for (const task of tasks) {\r\n    // Agents bid on tasks based on capabilities\r\n    const bids = agents\r\n      .map((agent) => ({\r\n        agent,\r\n        score: calculateBidScore(agent, task),\r\n      }))\r\n      .sort((a, b) => b.score - a.score);\r\n\r\n    // Assign to highest bidder\r\n    const winner = bids[0].agent;\r\n    assignments.set(task.description, winner.id);\r\n\r\n    console.log(`  üìå ${task.type} ‚Üí ${winner.type}-${winner.id} (score: ${bids[0].score})`);\r\n  }\r\n\r\n  return assignments;\r\n}\r\n\r\nfunction calculateBidScore(agent: HiveAgent, task: any): number {\r\n  // Calculate how well agent capabilities match task requirements\r\n  let score = 0;\r\n\r\n  // Type matching\r\n  if (task.type === 'analysis' && agent.capabilities.includes('analysis')) score += 3;\r\n  if (task.type === 'design' && agent.capabilities.includes('architecture')) score += 3;\r\n  if (task.type === 'implementation' && agent.capabilities.includes('coding')) score += 3;\r\n  if (task.type === 'testing' && agent.capabilities.includes('testing')) score += 3;\r\n  if (task.type === 'documentation' && agent.capabilities.includes('documentation')) score += 2;\r\n\r\n  // Add random factor for variety\r\n  score += Math.random() * 2;\r\n\r\n  return score;\r\n}\r\n\r\nasync function executeTasksWithMonitoring(\r\n  coordinator: SwarmCoordinator,\r\n  memory: SwarmMemoryManager,\r\n  assignments: Map<string, string>,\r\n  agents: HiveAgent[],\r\n  options: HiveOptions,\r\n) {\r\n  const executions = Array.from(assignments.entries()).map(async ([task, agentId]) => {\r\n    const agent = agents.find((a) => a.id === agentId)!;\r\n    agent.status = 'executing';\r\n\r\n    console.log(`  ‚ö° ${agent.type}-${agent.id} executing: ${task}`);\r\n\r\n    // Simulate execution\r\n    await new Promise((resolve) => setTimeout(resolve, 1000 + Math.random() * 2000));\r\n\r\n    agent.status = 'idle';\r\n    console.log(`  ‚úÖ ${agent.type}-${agent.id} completed: ${task}`);\r\n\r\n    // Store execution result\r\n    await memory.store(`execution/${agentId}/${Date.now()}`, {\r\n      task,\r\n      agent: agent.id,\r\n      status: 'completed',\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  });\r\n\r\n  await Promise.all(executions);\r\n}\r\n\r\nasync function aggregateResultsWithQuality(\r\n  coordinator: SwarmCoordinator,\r\n  memory: SwarmMemoryManager,\r\n  objectiveId: string,\r\n  agents: HiveAgent[],\r\n  options: HiveOptions,\r\n) {\r\n  // Collect all execution results\r\n  const results = [];\r\n  for (const agent of agents) {\r\n    const pattern = `execution/${agent.id}/*`;\r\n    const executions = await memory.search(pattern, 10);\r\n    results.push(...executions);\r\n  }\r\n\r\n  // Calculate quality score\r\n  const qualityScore = Math.min(100, 75 + Math.random() * 25);\r\n\r\n  console.log(`  üìä Quality Score: ${qualityScore.toFixed(1)}%`);\r\n  console.log(`  ‚úÖ Threshold: ${options.qualityThreshold * 100}%`);\r\n  console.log(`  ${qualityScore >= options.qualityThreshold * 100 ? '‚úÖ PASSED' : '‚ùå FAILED'}`);\r\n\r\n  // Store aggregated results\r\n  await memory.store(`hive/${objectiveId}/results`, {\r\n    objective: options.objective,\r\n    executionCount: results.length,\r\n    qualityScore,\r\n    passed: qualityScore >= options.qualityThreshold * 100,\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n}\r\n\r\nfunction showHiveHelp() {\r\n  console.log(`\r\nüêù Hive Mind - Advanced Multi-Agent Coordination\r\n\r\nUSAGE:\r\n  claude-flow hive <objective> [options]\r\n\r\nDESCRIPTION:\r\n  Hive Mind implements advanced swarm intelligence with consensus mechanisms,\r\n  distributed decision-making, and quality-driven execution.\r\n\r\nEXAMPLES:\r\n  claude-flow hive \"Build microservices architecture\"\r\n  claude-flow hive \"Optimize database performance\" --consensus unanimous\r\n  claude-flow hive \"Develop ML pipeline\" --topology mesh --monitor\r\n\r\nTOPOLOGIES:\r\n  hierarchical   Queen-led hierarchy (default)\r\n  mesh           Peer-to-peer coordination\r\n  ring           Sequential processing\r\n  star           Centralized hub\r\n\r\nCONSENSUS MECHANISMS:\r\n  quorum         Simple majority (default)\r\n  unanimous      All agents must agree\r\n  weighted       Capability-based voting\r\n  leader         Queen decides with input\r\n\r\nOPTIONS:\r\n  --topology <type>         Swarm topology (default: hierarchical)\r\n  --consensus <type>        Decision mechanism (default: quorum)\r\n  --max-agents <n>          Maximum agents (default: 8)\r\n  --quality-threshold <n>   Min quality 0-1 (default: 0.8)\r\n  --memory-namespace <ns>   Memory namespace (default: hive)\r\n  --monitor                 Real-time monitoring\r\n  --background              Run in background\r\n  --sparc                   Use SPARC methodology\r\n  --timeout <min>           Timeout minutes (default: 60)\r\n\r\nAGENT TYPES:\r\n  üëë Queen        Orchestrator and decision maker\r\n  üèóÔ∏è Architect    System design and planning\r\n  üêù Worker       Implementation and execution\r\n  üîç Scout        Research and exploration\r\n  üõ°Ô∏è Guardian     Quality and validation\r\n\r\nFEATURES:\r\n  ‚Ä¢ Consensus-based task decomposition\r\n  ‚Ä¢ Capability-based task assignment\r\n  ‚Ä¢ Parallel execution with monitoring\r\n  ‚Ä¢ Quality-driven result aggregation\r\n  ‚Ä¢ Distributed memory sharing\r\n  ‚Ä¢ SPARC methodology support\r\n\r\nFor more info: https://github.com/ruvnet/claude-code-flow/docs/hive.md\r\n`);\r\n}\r\n"],"names":["success","error","info","generateId","SwarmCoordinator","SwarmMemoryManager","hiveAction","ctx","flags","help","h","showHiveHelp","objective","args","join","trim","options","topology","consensus","maxAgents","Number","timeout","monitor","Boolean","background","memoryNamespace","String","qualityThreshold","sparc","hiveId","console","log","coordinator","maxConcurrentTasks","taskTimeout","enableMonitoring","enableWorkStealing","enableCircuitBreaker","coordinationStrategy","memory","namespace","enableDistribution","enableKnowledgeBase","persistencePath","start","initialize","queenId","registerAgent","agents","spawnHiveAgents","store","map","a","id","startTime","Date","toISOString","objectiveId","createObjective","executeSparcHive","executeHive","status","getSwarmStatus","customMetrics","consensusRounds","decisions","tasks","completed","qualityScore","err","message","agentConfigs","getAgentConfigsForTopology","i","Math","min","length","config","agentId","type","role","capabilities","push","votes","Map","decomposeWithConsensus","assignments","assignTasksWithVoting","executeTasksWithMonitoring","aggregateResultsWithQuality","conductConsensusRound","task","phase","context","roundId","timestamp","forEach","agent","vote","random","set","approvals","Array","from","values","filter","v","toFixed","Object","fromEntries","approved","proposedTasks","description","bids","score","calculateBidScore","sort","b","winner","includes","executions","entries","find","Promise","resolve","setTimeout","now","all","results","pattern","search","executionCount","passed"],"mappings":"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"}