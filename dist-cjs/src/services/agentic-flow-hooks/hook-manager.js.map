{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/hook-manager.ts"],"sourcesContent":["/**\r\n * Agentic Flow Hook Manager\r\n * \r\n * Central manager for all agentic-flow hooks, providing registration,\r\n * execution, and lifecycle management.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { Logger } from '../../core/logger.js';\r\nimport { HookMatcher } from '../../hooks/hook-matchers.js';\r\nimport type {\r\n  AgenticHookContext,\r\n  AgenticHookType,\r\n  HookFilter,\r\n  HookHandler,\r\n  HookHandlerResult,\r\n  HookOptions,\r\n  HookPayload,\r\n  HookPipeline,\r\n  HookRegistration,\r\n  HookRegistry,\r\n  PipelineMetrics,\r\n  PipelineStage,\r\n  SideEffect,\r\n} from './types.js';\r\n\r\nconst logger = new Logger({\r\n  level: 'info',\r\n  format: 'text',\r\n  destination: 'console'\r\n}, { prefix: 'AgenticHookManager' });\r\n\r\nexport class AgenticHookManager extends EventEmitter implements HookRegistry {\r\n  private hooks: Map<AgenticHookType, HookRegistration[]> = new Map();\r\n  private pipelines: Map<string, HookPipeline> = new Map();\r\n  private metrics: Map<string, any> = new Map();\r\n  private activeExecutions: Set<string> = new Set();\r\n  private hookMatcher: HookMatcher;\r\n\r\n  constructor() {\r\n    super();\r\n    this.initializeMetrics();\r\n    this.hookMatcher = new HookMatcher({\r\n      cacheEnabled: true,\r\n      cacheTTL: 60000,\r\n      matchStrategy: 'all',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Register a new hook\r\n   */\r\n  register(registration: HookRegistration): void {\r\n    const { type, id } = registration;\r\n    \r\n    // Validate registration\r\n    this.validateRegistration(registration);\r\n    \r\n    // Get or create hook list for type\r\n    if (!this.hooks.has(type)) {\r\n      this.hooks.set(type, []);\r\n    }\r\n    \r\n    const hookList = this.hooks.get(type)!;\r\n    \r\n    // Check for duplicate ID\r\n    if (hookList.some(h => h.id === id)) {\r\n      throw new Error(`Hook with ID '${id}' already registered for type '${type}'`);\r\n    }\r\n    \r\n    // Insert hook sorted by priority (higher priority first)\r\n    const insertIndex = hookList.findIndex(h => h.priority < registration.priority);\r\n    if (insertIndex === -1) {\r\n      hookList.push(registration);\r\n    } else {\r\n      hookList.splice(insertIndex, 0, registration);\r\n    }\r\n    \r\n    logger.info(`Registered hook '${id}' for type '${type}' with priority ${registration.priority}`);\r\n    this.emit('hook:registered', { type, registration });\r\n    \r\n    // Update metrics\r\n    this.updateMetric('hooks.registered', 1);\r\n  }\r\n\r\n  /**\r\n   * Unregister a hook\r\n   */\r\n  unregister(id: string): void {\r\n    let found = false;\r\n    \r\n    for (const [type, hookList] of this.hooks.entries()) {\r\n      const index = hookList.findIndex(h => h.id === id);\r\n      if (index !== -1) {\r\n        hookList.splice(index, 1);\r\n        found = true;\r\n        \r\n        logger.info(`Unregistered hook '${id}' from type '${type}'`);\r\n        this.emit('hook:unregistered', { type, id });\r\n        \r\n        // Clean up empty lists\r\n        if (hookList.length === 0) {\r\n          this.hooks.delete(type);\r\n        }\r\n        \r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (!found) {\r\n      throw new Error(`Hook with ID '${id}' not found`);\r\n    }\r\n    \r\n    this.updateMetric('hooks.unregistered', 1);\r\n  }\r\n\r\n  /**\r\n   * Get hooks by type with optional filtering\r\n   */\r\n  getHooks(type: AgenticHookType, filter?: HookFilter): HookRegistration[] {\r\n    const hookList = this.hooks.get(type) || [];\r\n    \r\n    if (!filter) {\r\n      return [...hookList];\r\n    }\r\n    \r\n    return hookList.filter(hook => this.matchesFilter(hook, filter));\r\n  }\r\n\r\n  /**\r\n   * Execute hooks for a given type\r\n   */\r\n  async executeHooks(\r\n    type: AgenticHookType,\r\n    payload: HookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult[]> {\r\n    const executionId = this.generateExecutionId();\r\n    this.activeExecutions.add(executionId);\r\n\r\n    const startTime = Date.now();\r\n    const results: HookHandlerResult[] = [];\r\n\r\n    try {\r\n      // Get all hooks for this type\r\n      const allHooks = this.hooks.get(type) || [];\r\n\r\n      // Use hook matcher to filter applicable hooks (2-3x performance improvement)\r\n      const matchedHooks: HookRegistration[] = [];\r\n      for (const hook of allHooks) {\r\n        const matchResult = await this.hookMatcher.match(hook, context, payload);\r\n        if (matchResult.matched) {\r\n          matchedHooks.push(hook);\r\n\r\n          // Track matcher performance\r\n          this.updateMetric('hooks.matcher.executionTime', matchResult.executionTime);\r\n          if (matchResult.cacheHit) {\r\n            this.updateMetric('hooks.matcher.cacheHits', 1);\r\n          }\r\n        }\r\n      }\r\n\r\n      logger.debug(`Executing ${matchedHooks.length}/${allHooks.length} matched hooks for type '${type}'`);\r\n      this.emit('hooks:executing', {\r\n        type,\r\n        total: allHooks.length,\r\n        matched: matchedHooks.length,\r\n        executionId\r\n      });\r\n\r\n      // Execute matched hooks in order\r\n      let modifiedPayload = payload;\r\n      for (const hook of matchedHooks) {\r\n        try {\r\n          const result = await this.executeHook(hook, modifiedPayload, context);\r\n          results.push(result);\r\n\r\n          // Handle side effects\r\n          if (result.sideEffects) {\r\n            await this.processSideEffects(result.sideEffects, context);\r\n          }\r\n\r\n          // Update payload if modified\r\n          if (result.modified && result.payload) {\r\n            modifiedPayload = result.payload;\r\n          }\r\n\r\n          // Check if we should continue\r\n          if (!result.continue) {\r\n            logger.debug(`Hook '${hook.id}' halted execution chain`);\r\n            break;\r\n          }\r\n        } catch (error) {\r\n          await this.handleHookError(hook, error as Error, context);\r\n\r\n          // Determine if we should continue after error\r\n          if (hook.options?.errorHandler) {\r\n            hook.options.errorHandler(error as Error);\r\n          } else {\r\n            throw error; // Re-throw if no error handler\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Update metrics\r\n      const duration = Date.now() - startTime;\r\n      this.updateMetric('hooks.executions', 1);\r\n      this.updateMetric('hooks.totalDuration', duration);\r\n      this.updateMetric(`hooks.${type}.executions`, 1);\r\n      this.updateMetric(`hooks.${type}.duration`, duration);\r\n      \r\n      this.emit('hooks:executed', { \r\n        type, \r\n        results, \r\n        duration, \r\n        executionId \r\n      });\r\n      \r\n      return results;\r\n    } finally {\r\n      this.activeExecutions.delete(executionId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new hook pipeline\r\n   */\r\n  createPipeline(config: Partial<HookPipeline>): HookPipeline {\r\n    const pipeline: HookPipeline = {\r\n      id: config.id || this.generatePipelineId(),\r\n      name: config.name || 'Unnamed Pipeline',\r\n      stages: config.stages || [],\r\n      errorStrategy: config.errorStrategy || 'fail-fast',\r\n      metrics: {\r\n        executions: 0,\r\n        avgDuration: 0,\r\n        errorRate: 0,\r\n        throughput: 0,\r\n      },\r\n    };\r\n    \r\n    this.pipelines.set(pipeline.id, pipeline);\r\n    logger.info(`Created pipeline '${pipeline.name}' with ID '${pipeline.id}'`);\r\n    \r\n    return pipeline;\r\n  }\r\n\r\n  /**\r\n   * Execute a pipeline\r\n   */\r\n  async executePipeline(\r\n    pipelineId: string,\r\n    initialPayload: HookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult[]> {\r\n    const pipeline = this.pipelines.get(pipelineId);\r\n    if (!pipeline) {\r\n      throw new Error(`Pipeline '${pipelineId}' not found`);\r\n    }\r\n    \r\n    const startTime = Date.now();\r\n    const results: HookHandlerResult[] = [];\r\n    let currentPayload = initialPayload;\r\n    \r\n    try {\r\n      for (const stage of pipeline.stages) {\r\n        // Check stage condition\r\n        if (stage.condition && !stage.condition(context)) {\r\n          logger.debug(`Skipping stage '${stage.name}' due to condition`);\r\n          continue;\r\n        }\r\n        \r\n        // Execute stage hooks\r\n        const stageResults = await this.executeStage(\r\n          stage, \r\n          currentPayload, \r\n          context\r\n        );\r\n        \r\n        // Apply stage transform if provided\r\n        if (stage.transform) {\r\n          for (let i = 0; i < stageResults.length; i++) {\r\n            stageResults[i] = stage.transform(stageResults[i]);\r\n          }\r\n        }\r\n        \r\n        results.push(...stageResults);\r\n        \r\n        // Update payload for next stage\r\n        const lastModified = stageResults\r\n          .reverse()\r\n          .find(r => r.modified && r.payload);\r\n        if (lastModified) {\r\n          currentPayload = lastModified.payload;\r\n        }\r\n      }\r\n      \r\n      // Update pipeline metrics\r\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, false);\r\n      \r\n      return results;\r\n    } catch (error) {\r\n      // Update error metrics\r\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, true);\r\n      \r\n      // Handle error based on strategy\r\n      if (pipeline.errorStrategy === 'rollback') {\r\n        await this.rollbackPipeline(pipeline, results, context);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current metrics\r\n   */\r\n  getMetrics(): Record<string, any> {\r\n    const metrics: Record<string, any> = {};\r\n\r\n    for (const [key, value] of this.metrics.entries()) {\r\n      metrics[key] = value;\r\n    }\r\n\r\n    // Add computed metrics\r\n    metrics['hooks.count'] = this.getTotalHookCount();\r\n    metrics['hooks.types'] = Array.from(this.hooks.keys());\r\n    metrics['pipelines.count'] = this.pipelines.size;\r\n    metrics['executions.active'] = this.activeExecutions.size;\r\n\r\n    // Add matcher metrics\r\n    const matcherStats = this.hookMatcher.getCacheStats();\r\n    metrics['hooks.matcher.cacheSize'] = matcherStats.size;\r\n    metrics['hooks.matcher.cacheHitRate'] = matcherStats.hitRate;\r\n\r\n    return metrics;\r\n  }\r\n\r\n  /**\r\n   * Clear hook matcher cache\r\n   */\r\n  clearMatcherCache(): void {\r\n    this.hookMatcher.clearCache();\r\n    logger.info('Hook matcher cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Prune matcher cache\r\n   */\r\n  pruneMatcherCache(): number {\r\n    const pruned = this.hookMatcher.pruneCache();\r\n    logger.info(`Pruned ${pruned} expired matcher cache entries`);\r\n    return pruned;\r\n  }\r\n\r\n  // ===== Private Methods =====\r\n\r\n  private validateRegistration(registration: HookRegistration): void {\r\n    if (!registration.id) {\r\n      throw new Error('Hook registration must have an ID');\r\n    }\r\n    \r\n    if (!registration.type) {\r\n      throw new Error('Hook registration must have a type');\r\n    }\r\n    \r\n    if (typeof registration.handler !== 'function') {\r\n      throw new Error('Hook registration must have a handler function');\r\n    }\r\n    \r\n    if (registration.priority < 0) {\r\n      throw new Error('Hook priority must be non-negative');\r\n    }\r\n  }\r\n\r\n  private matchesFilter(hook: HookRegistration, filter: HookFilter): boolean {\r\n    if (!hook.filter) {\r\n      return true; // No filter means hook applies to all\r\n    }\r\n    \r\n    // Check providers\r\n    if (filter.providers && hook.filter.providers) {\r\n      const hasProvider = filter.providers.some(p => \r\n        hook.filter!.providers!.includes(p)\r\n      );\r\n      if (!hasProvider) return false;\r\n    }\r\n    \r\n    // Check models\r\n    if (filter.models && hook.filter.models) {\r\n      const hasModel = filter.models.some(m => \r\n        hook.filter!.models!.includes(m)\r\n      );\r\n      if (!hasModel) return false;\r\n    }\r\n    \r\n    // Check patterns\r\n    if (filter.patterns && hook.filter.patterns) {\r\n      // Complex pattern matching logic here\r\n      // For now, simplified version\r\n      return true;\r\n    }\r\n    \r\n    // Check conditions\r\n    if (filter.conditions && hook.filter.conditions) {\r\n      // Evaluate conditions\r\n      // Simplified for now\r\n      return true;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  private createFilterFromPayload(payload: HookPayload): HookFilter | undefined {\r\n    const filter: HookFilter = {};\r\n    \r\n    // Extract filter criteria from payload\r\n    if ('provider' in payload) {\r\n      filter.providers = [payload.provider];\r\n    }\r\n    \r\n    if ('model' in payload) {\r\n      filter.models = [payload.model];\r\n    }\r\n    \r\n    if ('operation' in payload) {\r\n      filter.operations = [payload.operation];\r\n    }\r\n    \r\n    if ('namespace' in payload) {\r\n      filter.namespaces = [payload.namespace];\r\n    }\r\n    \r\n    return Object.keys(filter).length > 0 ? filter : undefined;\r\n  }\r\n\r\n  private async executeHook(\r\n    hook: HookRegistration,\r\n    payload: HookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      // Check cache if enabled\r\n      if (hook.options?.cache?.enabled) {\r\n        const cacheKey = hook.options.cache.key(payload);\r\n        const cached = this.getCachedResult(hook.id, cacheKey);\r\n        if (cached) {\r\n          this.updateMetric('hooks.cacheHits', 1);\r\n          return cached;\r\n        }\r\n      }\r\n      \r\n      // Execute with timeout if specified\r\n      let resultPromise = hook.handler(payload, context);\r\n      \r\n      if (hook.options?.timeout) {\r\n        resultPromise = this.withTimeout(\r\n          resultPromise, \r\n          hook.options.timeout,\r\n          `Hook '${hook.id}' timed out`\r\n        );\r\n      }\r\n      \r\n      const result = await resultPromise;\r\n      \r\n      // Cache result if enabled\r\n      if (hook.options?.cache?.enabled && result) {\r\n        const cacheKey = hook.options.cache.key(payload);\r\n        this.cacheResult(hook.id, cacheKey, result, hook.options.cache.ttl);\r\n      }\r\n      \r\n      // Update hook-specific metrics\r\n      const duration = Date.now() - startTime;\r\n      this.updateMetric(`hooks.${hook.id}.executions`, 1);\r\n      this.updateMetric(`hooks.${hook.id}.duration`, duration);\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      // Handle retries if configured\r\n      if (hook.options?.retries && hook.options.retries > 0) {\r\n        logger.warn(`Hook '${hook.id}' failed, retrying...`);\r\n        return this.retryHook(hook, payload, context, hook.options.retries);\r\n      }\r\n      \r\n      // Use fallback if provided\r\n      if (hook.options?.fallback) {\r\n        logger.warn(`Hook '${hook.id}' failed, using fallback`);\r\n        return hook.options.fallback(payload, context);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async retryHook(\r\n    hook: HookRegistration,\r\n    payload: HookPayload,\r\n    context: AgenticHookContext,\r\n    retriesLeft: number\r\n  ): Promise<HookHandlerResult> {\r\n    for (let i = 0; i < retriesLeft; i++) {\r\n      try {\r\n        await this.delay(Math.pow(2, i) * 1000); // Exponential backoff\r\n        return await hook.handler(payload, context);\r\n      } catch (error) {\r\n        if (i === retriesLeft - 1) {\r\n          throw error; // Last retry failed\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Should not reach here\r\n    throw new Error('Retry logic error');\r\n  }\r\n\r\n  private async processSideEffects(\r\n    sideEffects: SideEffect[],\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    for (const effect of sideEffects) {\r\n      try {\r\n        await this.processSideEffect(effect, context);\r\n      } catch (error) {\r\n        logger.error(`Failed to process side effect: ${effect.type}`, error);\r\n        // Continue processing other side effects\r\n      }\r\n    }\r\n  }\r\n\r\n  private async processSideEffect(\r\n    effect: SideEffect,\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    switch (effect.type) {\r\n      case 'memory':\r\n        await this.processMemorySideEffect(effect, context);\r\n        break;\r\n      \r\n      case 'neural':\r\n        await this.processNeuralSideEffect(effect, context);\r\n        break;\r\n      \r\n      case 'metric':\r\n        this.processMetricSideEffect(effect);\r\n        break;\r\n      \r\n      case 'notification':\r\n        this.processNotificationSideEffect(effect);\r\n        break;\r\n      \r\n      case 'log':\r\n        this.processLogSideEffect(effect);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async processMemorySideEffect(\r\n    effect: SideEffect,\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    // Implement memory side effect processing\r\n    // This would integrate with the memory service\r\n    logger.debug(`Processing memory side effect: ${effect.action}`, effect.data);\r\n  }\r\n\r\n  private async processNeuralSideEffect(\r\n    effect: SideEffect,\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    // Implement neural side effect processing\r\n    // This would integrate with the neural service\r\n    logger.debug(`Processing neural side effect: ${effect.action}`, effect.data);\r\n  }\r\n\r\n  private processMetricSideEffect(effect: SideEffect): void {\r\n    if (effect.action === 'update') {\r\n      this.updateMetric(effect.data.name, effect.data.value);\r\n    } else if (effect.action === 'increment') {\r\n      this.updateMetric(effect.data.name, 1);\r\n    }\r\n  }\r\n\r\n  private processNotificationSideEffect(effect: SideEffect): void {\r\n    this.emit('notification', effect.data);\r\n  }\r\n\r\n  private processLogSideEffect(effect: SideEffect): void {\r\n    const { level = 'info', message, data } = effect.data;\r\n    logger[level as keyof Logger](message, data);\r\n  }\r\n\r\n  private async handleHookError(\r\n    hook: HookRegistration,\r\n    error: Error,\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    logger.error(`Hook '${hook.id}' error:`, error);\r\n    \r\n    this.updateMetric('hooks.errors', 1);\r\n    this.updateMetric(`hooks.${hook.id}.errors`, 1);\r\n    \r\n    this.emit('hook:error', {\r\n      hookId: hook.id,\r\n      type: hook.type,\r\n      error,\r\n      context,\r\n    });\r\n  }\r\n\r\n  private async executeStage(\r\n    stage: PipelineStage,\r\n    payload: HookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult[]> {\r\n    if (stage.parallel) {\r\n      // Execute hooks in parallel\r\n      const promises = stage.hooks.map(hook => \r\n        this.executeHook(hook, payload, context)\r\n      );\r\n      return Promise.all(promises);\r\n    } else {\r\n      // Execute hooks sequentially\r\n      const results: HookHandlerResult[] = [];\r\n      let currentPayload = payload;\r\n      \r\n      for (const hook of stage.hooks) {\r\n        const result = await this.executeHook(hook, currentPayload, context);\r\n        results.push(result);\r\n        \r\n        if (result.modified && result.payload) {\r\n          currentPayload = result.payload;\r\n        }\r\n        \r\n        if (!result.continue) {\r\n          break;\r\n        }\r\n      }\r\n      \r\n      return results;\r\n    }\r\n  }\r\n\r\n  private updatePipelineMetrics(\r\n    pipeline: HookPipeline,\r\n    duration: number,\r\n    hasError: boolean\r\n  ): void {\r\n    const metrics = pipeline.metrics;\r\n    \r\n    metrics.executions++;\r\n    metrics.avgDuration = \r\n      (metrics.avgDuration * (metrics.executions - 1) + duration) / \r\n      metrics.executions;\r\n    \r\n    if (hasError) {\r\n      metrics.errorRate = \r\n        (metrics.errorRate * (metrics.executions - 1) + 1) / \r\n        metrics.executions;\r\n    } else {\r\n      metrics.errorRate = \r\n        (metrics.errorRate * (metrics.executions - 1)) / \r\n        metrics.executions;\r\n    }\r\n    \r\n    // Calculate throughput (executions per minute)\r\n    const timeWindow = 60000; // 1 minute\r\n    metrics.throughput = (metrics.executions / duration) * timeWindow;\r\n  }\r\n\r\n  private async rollbackPipeline(\r\n    pipeline: HookPipeline,\r\n    results: HookHandlerResult[],\r\n    context: AgenticHookContext\r\n  ): Promise<void> {\r\n    logger.warn(`Rolling back pipeline '${pipeline.name}'`);\r\n    // Implement rollback logic based on side effects in results\r\n    // This is a placeholder for actual rollback implementation\r\n  }\r\n\r\n  private getTotalHookCount(): number {\r\n    let count = 0;\r\n    for (const hookList of this.hooks.values()) {\r\n      count += hookList.length;\r\n    }\r\n    return count;\r\n  }\r\n\r\n  private initializeMetrics(): void {\r\n    this.metrics.set('hooks.registered', 0);\r\n    this.metrics.set('hooks.unregistered', 0);\r\n    this.metrics.set('hooks.executions', 0);\r\n    this.metrics.set('hooks.errors', 0);\r\n    this.metrics.set('hooks.cacheHits', 0);\r\n    this.metrics.set('hooks.totalDuration', 0);\r\n  }\r\n\r\n  private updateMetric(key: string, value: number): void {\r\n    const current = this.metrics.get(key) || 0;\r\n    this.metrics.set(key, current + value);\r\n  }\r\n\r\n  private generateExecutionId(): string {\r\n    return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  private generatePipelineId(): string {\r\n    return `pipe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  private getCachedResult(\r\n    hookId: string, \r\n    cacheKey: string\r\n  ): HookHandlerResult | null {\r\n    // Implement cache retrieval\r\n    // This is a placeholder\r\n    return null;\r\n  }\r\n\r\n  private cacheResult(\r\n    hookId: string,\r\n    cacheKey: string,\r\n    result: HookHandlerResult,\r\n    ttl: number\r\n  ): void {\r\n    // Implement cache storage\r\n    // This is a placeholder\r\n  }\r\n\r\n  private async withTimeout<T>(\r\n    promise: Promise<T>,\r\n    timeout: number,\r\n    message: string\r\n  ): Promise<T> {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<T>((_, reject) => \r\n        setTimeout(() => reject(new Error(message)), timeout)\r\n      ),\r\n    ]);\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const agenticHookManager = new AgenticHookManager();"],"names":["EventEmitter","Logger","HookMatcher","logger","level","format","destination","prefix","AgenticHookManager","hooks","Map","pipelines","metrics","activeExecutions","Set","hookMatcher","initializeMetrics","cacheEnabled","cacheTTL","matchStrategy","register","registration","type","id","validateRegistration","has","set","hookList","get","some","h","Error","insertIndex","findIndex","priority","push","splice","info","emit","updateMetric","unregister","found","entries","index","length","delete","getHooks","filter","hook","matchesFilter","executeHooks","payload","context","executionId","generateExecutionId","add","startTime","Date","now","results","allHooks","matchedHooks","matchResult","match","matched","executionTime","cacheHit","debug","total","modifiedPayload","result","executeHook","sideEffects","processSideEffects","modified","continue","error","handleHookError","options","errorHandler","duration","createPipeline","config","pipeline","generatePipelineId","name","stages","errorStrategy","executions","avgDuration","errorRate","throughput","executePipeline","pipelineId","initialPayload","currentPayload","stage","condition","stageResults","executeStage","transform","i","lastModified","reverse","find","r","updatePipelineMetrics","rollbackPipeline","getMetrics","key","value","getTotalHookCount","Array","from","keys","size","matcherStats","getCacheStats","hitRate","clearMatcherCache","clearCache","pruneMatcherCache","pruned","pruneCache","handler","providers","hasProvider","p","includes","models","hasModel","m","patterns","conditions","createFilterFromPayload","provider","model","operations","operation","namespaces","namespace","Object","undefined","cache","enabled","cacheKey","cached","getCachedResult","resultPromise","timeout","withTimeout","cacheResult","ttl","retries","warn","retryHook","fallback","retriesLeft","delay","Math","pow","effect","processSideEffect","processMemorySideEffect","processNeuralSideEffect","processMetricSideEffect","processNotificationSideEffect","processLogSideEffect","action","data","message","hookId","parallel","promises","map","Promise","all","hasError","timeWindow","count","values","current","random","toString","substr","promise","race","_","reject","setTimeout","ms","resolve","agenticHookManager"],"mappings":"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"}