{
  "version": 3,
  "sources": ["../../src/resources/resource-manager.ts"],
  "sourcesContent": ["/**\n * Comprehensive resource management system for swarm operations\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { AgentId, TaskId } from '../swarm/types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface ResourceManagerConfig {\n  enableResourcePooling: boolean;\n  enableResourceMonitoring: boolean;\n  enableAutoScaling: boolean;\n  enableQoS: boolean;\n  monitoringInterval: number;\n  cleanupInterval: number;\n  defaultLimits: ResourceLimits;\n  reservationTimeout: number;\n  allocationStrategy: 'first-fit' | 'best-fit' | 'worst-fit' | 'balanced';\n  priorityWeights: PriorityWeights;\n  enablePredictiveAllocation: boolean;\n  enableResourceSharing: boolean;\n  debugMode: boolean;\n}\n\nexport interface ResourceLimits {\n  cpu: number; // CPU cores\n  memory: number; // Bytes\n  disk: number; // Bytes\n  network: number; // Bytes per second\n  gpu?: number; // GPU units\n  custom: Record<string, number>;\n}\n\nexport interface PriorityWeights {\n  critical: number;\n  high: number;\n  normal: number;\n  low: number;\n  background: number;\n}\n\nexport interface Resource {\n  id: string;\n  type: ResourceType;\n  name: string;\n  description: string;\n  capacity: ResourceLimits;\n  allocated: ResourceLimits;\n  available: ResourceLimits;\n  status: ResourceStatus;\n  metadata: ResourceMetadata;\n  reservations: ResourceReservation[];\n  allocations: ResourceAllocation[];\n  sharable: boolean;\n  persistent: boolean;\n  cost: number;\n  location?: string;\n  tags: string[];\n}\n\nexport interface ResourcePool {\n  id: string;\n  name: string;\n  type: ResourceType;\n  resources: string[]; // Resource IDs\n  strategy: PoolStrategy;\n  loadBalancing: LoadBalancingStrategy;\n  scaling: ScalingConfig;\n  qos: QoSConfig;\n  statistics: PoolStatistics;\n  filters: ResourceFilter[];\n}\n\nexport interface ResourceReservation {\n  id: string;\n  resourceId: string;\n  agentId: AgentId;\n  taskId?: TaskId;\n  requirements: ResourceRequirements;\n  status: ReservationStatus;\n  priority: ResourcePriority;\n  createdAt: Date;\n  expiresAt?: Date;\n  activatedAt?: Date;\n  releasedAt?: Date;\n  metadata: Record<string, any>;\n}\n\nexport interface ResourceAllocation {\n  id: string;\n  reservationId: string;\n  resourceId: string;\n  agentId: AgentId;\n  taskId?: TaskId;\n  allocated: ResourceLimits;\n  actualUsage: ResourceUsage;\n  efficiency: number;\n  startTime: Date;\n  endTime?: Date;\n  status: AllocationStatus;\n  qosViolations: QoSViolation[];\n}\n\nexport interface ResourceRequirements {\n  cpu?: ResourceSpec;\n  memory?: ResourceSpec;\n  disk?: ResourceSpec;\n  network?: ResourceSpec;\n  gpu?: ResourceSpec;\n  custom?: Record<string, ResourceSpec>;\n  constraints?: ResourceConstraints;\n  preferences?: ResourcePreferences;\n}\n\nexport interface ResourceSpec {\n  min: number;\n  max?: number;\n  preferred?: number;\n  unit: string;\n  shared?: boolean;\n  exclusive?: boolean;\n}\n\nexport interface ResourceConstraints {\n  location?: string[];\n  excludeLocation?: string[];\n  nodeAffinity?: NodeAffinity[];\n  antiAffinity?: AntiAffinity[];\n  timeWindow?: TimeWindow;\n  dependencies?: string[];\n  maxCost?: number;\n}\n\nexport interface ResourcePreferences {\n  location?: string;\n  performanceClass?: 'high' | 'medium' | 'low';\n  costOptimized?: boolean;\n  energyEfficient?: boolean;\n  highAvailability?: boolean;\n}\n\nexport interface ResourceUsage {\n  cpu: number;\n  memory: number;\n  disk: number;\n  network: number;\n  gpu?: number;\n  custom: Record<string, number>;\n  timestamp: Date;\n  duration: number;\n}\n\nexport interface ResourceMetadata {\n  provider: string;\n  region?: string;\n  zone?: string;\n  instance?: string;\n  capabilities: string[];\n  performance: PerformanceMetrics;\n  reliability: ReliabilityMetrics;\n  cost: CostMetrics;\n  lastUpdated: Date;\n}\n\nexport interface PerformanceMetrics {\n  cpuScore: number;\n  memoryBandwidth: number;\n  diskIOPS: number;\n  networkBandwidth: number;\n  gpuScore?: number;\n  benchmarkResults: Record<string, number>;\n}\n\nexport interface ReliabilityMetrics {\n  uptime: number;\n  meanTimeBetweenFailures: number;\n  errorRate: number;\n  lastFailure?: Date;\n  failureHistory: FailureRecord[];\n}\n\nexport interface CostMetrics {\n  hourlyRate: number;\n  dataTransferCost: number;\n  storageCost: number;\n  spotPricing?: boolean;\n  billing: BillingModel;\n}\n\nexport interface FailureRecord {\n  timestamp: Date;\n  type: string;\n  duration: number;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  resolved: boolean;\n}\n\nexport interface QoSConfig {\n  guarantees: QoSGuarantee[];\n  objectives: QoSObjective[];\n  violations: QoSViolationPolicy;\n}\n\nexport interface QoSGuarantee {\n  metric: string;\n  threshold: number;\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n  priority: ResourcePriority;\n  penalty?: number;\n}\n\nexport interface QoSObjective {\n  metric: string;\n  target: number;\n  weight: number;\n  tolerance: number;\n}\n\nexport interface QoSViolation {\n  timestamp: Date;\n  metric: string;\n  expected: number;\n  actual: number;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  duration: number;\n  resolved: boolean;\n}\n\nexport interface QoSViolationPolicy {\n  autoRemediation: boolean;\n  escalationThreshold: number;\n  penaltyFunction: string;\n  notificationEnabled: boolean;\n}\n\nexport interface ScalingConfig {\n  enabled: boolean;\n  minResources: number;\n  maxResources: number;\n  scaleUpThreshold: number;\n  scaleDownThreshold: number;\n  cooldownPeriod: number;\n  metrics: ScalingMetric[];\n}\n\nexport interface ScalingMetric {\n  name: string;\n  weight: number;\n  threshold: number;\n  aggregation: 'avg' | 'max' | 'min' | 'sum';\n}\n\nexport interface PoolStatistics {\n  totalResources: number;\n  availableResources: number;\n  utilizationRate: number;\n  allocationSuccessRate: number;\n  averageWaitTime: number;\n  throughput: number;\n  efficiency: number;\n  costPerHour: number;\n  qosScore: number;\n}\n\nexport interface NodeAffinity {\n  key: string;\n  operator: 'in' | 'notin' | 'exists' | 'notexists';\n  values?: string[];\n}\n\nexport interface AntiAffinity {\n  type: 'agent' | 'task' | 'resource';\n  scope: 'node' | 'zone' | 'region';\n  weight: number;\n}\n\nexport interface TimeWindow {\n  start: Date;\n  end: Date;\n  timezone?: string;\n}\n\nexport interface ResourceFilter {\n  id: string;\n  name: string;\n  enabled: boolean;\n  conditions: FilterCondition[];\n  action: 'include' | 'exclude' | 'prioritize' | 'deprioritize';\n}\n\nexport interface FilterCondition {\n  field: string;\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches';\n  value: any;\n}\n\nexport type ResourceType = 'compute' | 'storage' | 'network' | 'memory' | 'gpu' | 'custom';\nexport type ResourceStatus =\n  | 'available'\n  | 'allocated'\n  | 'reserved'\n  | 'maintenance'\n  | 'failed'\n  | 'offline';\nexport type ResourcePriority = 'critical' | 'high' | 'normal' | 'low' | 'background';\nexport type ReservationStatus =\n  | 'pending'\n  | 'confirmed'\n  | 'active'\n  | 'expired'\n  | 'cancelled'\n  | 'failed';\nexport type AllocationStatus = 'active' | 'completed' | 'failed' | 'terminated' | 'suspended';\nexport type PoolStrategy = 'round-robin' | 'least-loaded' | 'performance-based' | 'cost-optimized';\nexport type LoadBalancingStrategy =\n  | 'round-robin'\n  | 'weighted'\n  | 'least-connections'\n  | 'resource-based';\nexport type BillingModel = 'hourly' | 'per-usage' | 'reserved' | 'spot' | 'hybrid';\n\n/**\n * Comprehensive resource management with allocation, monitoring, and optimization\n */\nexport class ResourceManager extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: ResourceManagerConfig;\n\n  // Resource tracking\n  private resources = new Map<string, Resource>();\n  private pools = new Map<string, ResourcePool>();\n  private reservations = new Map<string, ResourceReservation>();\n  private allocations = new Map<string, ResourceAllocation>();\n\n  // Monitoring and optimization\n  private usageHistory = new Map<string, ResourceUsage[]>();\n  private predictions = new Map<string, ResourcePrediction>();\n  private optimizer: ResourceOptimizer;\n\n  // Scheduling and cleanup\n  private monitoringInterval?: NodeJS.Timeout;\n  private cleanupInterval?: NodeJS.Timeout;\n  private scalingInterval?: NodeJS.Timeout;\n\n  // Performance tracking\n  private metrics: ResourceManagerMetrics;\n\n  constructor(config: Partial<ResourceManagerConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      enableResourcePooling: true,\n      enableResourceMonitoring: true,\n      enableAutoScaling: true,\n      enableQoS: true,\n      monitoringInterval: 30000,\n      cleanupInterval: 300000,\n      defaultLimits: {\n        cpu: 4.0,\n        memory: 8 * 1024 * 1024 * 1024, // 8GB\n        disk: 100 * 1024 * 1024 * 1024, // 100GB\n        network: 1024 * 1024 * 1024, // 1Gbps\n        custom: {},\n      },\n      reservationTimeout: 300000, // 5 minutes\n      allocationStrategy: 'best-fit',\n      priorityWeights: {\n        critical: 1.0,\n        high: 0.8,\n        normal: 0.6,\n        low: 0.4,\n        background: 0.2,\n      },\n      enablePredictiveAllocation: true,\n      enableResourceSharing: true,\n      debugMode: false,\n      ...config,\n    };\n\n    this.optimizer = new ResourceOptimizer(this.config, this.logger);\n    this.metrics = new ResourceManagerMetrics();\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('agent:resource-request', (data) => {\n      this.handleResourceRequest(data);\n    });\n\n    this.eventBus.on('agent:resource-release', (data) => {\n      this.handleResourceRelease(data);\n    });\n\n    this.eventBus.on('resource:usage-update', (data) => {\n      this.updateResourceUsage(data.resourceId, data.usage);\n    });\n\n    this.eventBus.on('resource:failure', (data) => {\n      this.handleResourceFailure(data);\n    });\n\n    this.eventBus.on('scaling:trigger', (data) => {\n      this.handleScalingTrigger(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing resource manager', {\n      pooling: this.config.enableResourcePooling,\n      monitoring: this.config.enableResourceMonitoring,\n      autoScaling: this.config.enableAutoScaling,\n    });\n\n    // Initialize optimizer\n    await this.optimizer.initialize();\n\n    // Create default resource pools\n    await this.createDefaultPools();\n\n    // Start monitoring\n    if (this.config.enableResourceMonitoring) {\n      this.startMonitoring();\n    }\n\n    // Start cleanup\n    this.startCleanup();\n\n    // Start auto-scaling\n    if (this.config.enableAutoScaling) {\n      this.startAutoScaling();\n    }\n\n    this.emit('resource-manager:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down resource manager');\n\n    // Stop intervals\n    if (this.monitoringInterval) clearInterval(this.monitoringInterval);\n    if (this.cleanupInterval) clearInterval(this.cleanupInterval);\n    if (this.scalingInterval) clearInterval(this.scalingInterval);\n\n    // Release all active allocations\n    await this.releaseAllAllocations();\n\n    // Shutdown optimizer\n    await this.optimizer.shutdown();\n\n    this.emit('resource-manager:shutdown');\n  }\n\n  // === RESOURCE MANAGEMENT ===\n\n  async registerResource(\n    type: ResourceType,\n    name: string,\n    capacity: ResourceLimits,\n    metadata: Partial<ResourceMetadata> = {},\n  ): Promise<string> {\n    const resourceId = generateId('resource');\n\n    const resource: Resource = {\n      id: resourceId,\n      type,\n      name,\n      description: `${type} resource: ${name}`,\n      capacity,\n      allocated: this.createEmptyLimits(),\n      available: { ...capacity },\n      status: 'available',\n      metadata: {\n        provider: 'local',\n        capabilities: [],\n        performance: this.createDefaultPerformanceMetrics(),\n        reliability: this.createDefaultReliabilityMetrics(),\n        cost: this.createDefaultCostMetrics(),\n        lastUpdated: new Date(),\n        ...metadata,\n      },\n      reservations: [],\n      allocations: [],\n      sharable: this.config.enableResourceSharing,\n      persistent: true,\n      cost: 1.0,\n      tags: [],\n    };\n\n    this.resources.set(resourceId, resource);\n\n    this.logger.info('Resource registered', {\n      resourceId,\n      type,\n      name,\n      capacity,\n    });\n\n    this.emit('resource:registered', { resource });\n\n    return resourceId;\n  }\n\n  async unregisterResource(resourceId: string): Promise<void> {\n    const resource = this.resources.get(resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${resourceId} not found`);\n    }\n\n    // Check for active allocations\n    if (resource.allocations.length > 0) {\n      throw new Error(`Cannot unregister resource ${resourceId}: has active allocations`);\n    }\n\n    // Cancel pending reservations\n    for (const reservation of resource.reservations) {\n      await this.cancelReservation(reservation.id, 'resource_unregistered');\n    }\n\n    this.resources.delete(resourceId);\n\n    this.logger.info('Resource unregistered', { resourceId });\n    this.emit('resource:unregistered', { resourceId });\n  }\n\n  // === RESOURCE ALLOCATION ===\n\n  async requestResources(\n    agentId: AgentId,\n    requirements: ResourceRequirements,\n    options: {\n      taskId?: TaskId;\n      priority?: ResourcePriority;\n      timeout?: number;\n      preemptible?: boolean;\n    } = {},\n  ): Promise<string> {\n    const reservationId = generateId('reservation');\n    const now = new Date();\n\n    const reservation: ResourceReservation = {\n      id: reservationId,\n      resourceId: '', // Will be set when resource is found\n      agentId,\n      taskId: options.taskId,\n      requirements,\n      status: 'pending',\n      priority: options.priority || 'normal',\n      createdAt: now,\n      expiresAt: options.timeout\n        ? new Date(now.getTime() + options.timeout)\n        : new Date(now.getTime() + this.config.reservationTimeout),\n      metadata: {\n        preemptible: options.preemptible || false,\n      },\n    };\n\n    this.reservations.set(reservationId, reservation);\n\n    try {\n      // Find suitable resource\n      const resource = await this.findSuitableResource(requirements, reservation.priority);\n\n      if (!resource) {\n        reservation.status = 'failed';\n        throw new Error('No suitable resource available');\n      }\n\n      // Reserve resource\n      reservation.resourceId = resource.id;\n      resource.reservations.push(reservation);\n\n      // Update availability\n      this.updateResourceAvailability(resource);\n\n      reservation.status = 'confirmed';\n\n      this.logger.info('Resource reservation created', {\n        reservationId,\n        resourceId: resource.id,\n        agentId: agentId.id,\n        requirements,\n      });\n\n      this.emit('reservation:created', { reservation });\n\n      // Auto-activate if possible\n      if (this.canActivateReservation(reservation)) {\n        await this.activateReservation(reservationId);\n      }\n\n      return reservationId;\n    } catch (error) {\n      reservation.status = 'failed';\n      this.logger.error('Resource reservation failed', {\n        reservationId,\n        agentId: agentId.id,\n        error,\n      });\n      throw error;\n    }\n  }\n\n  async activateReservation(reservationId: string): Promise<string> {\n    const reservation = this.reservations.get(reservationId);\n    if (!reservation) {\n      throw new Error(`Reservation ${reservationId} not found`);\n    }\n\n    if (reservation.status !== 'confirmed') {\n      throw new Error(`Reservation ${reservationId} is not confirmed`);\n    }\n\n    const resource = this.resources.get(reservation.resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${reservation.resourceId} not found`);\n    }\n\n    // Create allocation\n    const allocationId = generateId('allocation');\n\n    const allocation: ResourceAllocation = {\n      id: allocationId,\n      reservationId,\n      resourceId: resource.id,\n      agentId: reservation.agentId,\n      taskId: reservation.taskId,\n      allocated: this.calculateAllocation(reservation.requirements, resource),\n      actualUsage: this.createEmptyUsage(),\n      efficiency: 1.0,\n      startTime: new Date(),\n      status: 'active',\n      qosViolations: [],\n    };\n\n    this.allocations.set(allocationId, allocation);\n    resource.allocations.push(allocation);\n\n    // Update resource allocated amounts\n    this.addToResourceLimits(resource.allocated, allocation.allocated);\n    this.updateResourceAvailability(resource);\n\n    // Update reservation status\n    reservation.status = 'active';\n    reservation.activatedAt = new Date();\n\n    this.logger.info('Resource allocation activated', {\n      allocationId,\n      reservationId,\n      resourceId: resource.id,\n      agentId: reservation.agentId.id,\n      allocated: allocation.allocated,\n    });\n\n    this.emit('allocation:activated', { allocation });\n\n    return allocationId;\n  }\n\n  async releaseResources(allocationId: string, reason: string = 'completed'): Promise<void> {\n    const allocation = this.allocations.get(allocationId);\n    if (!allocation) {\n      throw new Error(`Allocation ${allocationId} not found`);\n    }\n\n    const resource = this.resources.get(allocation.resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${allocation.resourceId} not found`);\n    }\n\n    // Update allocation status\n    allocation.status = 'completed';\n    allocation.endTime = new Date();\n\n    // Calculate final efficiency\n    allocation.efficiency = this.calculateEfficiency(allocation);\n\n    // Remove from resource allocated amounts\n    this.subtractFromResourceLimits(resource.allocated, allocation.allocated);\n\n    // Remove allocation from resource\n    resource.allocations = resource.allocations.filter((a) => a.id !== allocationId);\n\n    // Update resource availability\n    this.updateResourceAvailability(resource);\n\n    // Update reservation if exists\n    const reservation = this.reservations.get(allocation.reservationId);\n    if (reservation) {\n      reservation.releasedAt = new Date();\n    }\n\n    this.logger.info('Resource allocation released', {\n      allocationId,\n      resourceId: resource.id,\n      agentId: allocation.agentId.id,\n      reason,\n      efficiency: allocation.efficiency,\n    });\n\n    this.emit('allocation:released', { allocation, reason });\n\n    // Update metrics\n    this.metrics.recordAllocationReleased(allocation);\n  }\n\n  async cancelReservation(reservationId: string, reason: string = 'cancelled'): Promise<void> {\n    const reservation = this.reservations.get(reservationId);\n    if (!reservation) {\n      throw new Error(`Reservation ${reservationId} not found`);\n    }\n\n    // If reservation is active, release the allocation first\n    if (reservation.status === 'active') {\n      const allocation = Array.from(this.allocations.values()).find(\n        (a) => a.reservationId === reservationId,\n      );\n\n      if (allocation) {\n        await this.releaseResources(allocation.id, reason);\n      }\n    }\n\n    // Update reservation status\n    reservation.status = 'cancelled';\n\n    // Remove from resource if it was reserved\n    if (reservation.resourceId) {\n      const resource = this.resources.get(reservation.resourceId);\n      if (resource) {\n        resource.reservations = resource.reservations.filter((r) => r.id !== reservationId);\n        this.updateResourceAvailability(resource);\n      }\n    }\n\n    this.logger.info('Resource reservation cancelled', {\n      reservationId,\n      reason,\n    });\n\n    this.emit('reservation:cancelled', { reservation, reason });\n  }\n\n  // === RESOURCE POOLS ===\n\n  async createResourcePool(\n    name: string,\n    type: ResourceType,\n    resourceIds: string[],\n    strategy: PoolStrategy = 'least-loaded',\n  ): Promise<string> {\n    const poolId = generateId('pool');\n\n    // Validate resources exist and are of correct type\n    for (const resourceId of resourceIds) {\n      const resource = this.resources.get(resourceId);\n      if (!resource) {\n        throw new Error(`Resource ${resourceId} not found`);\n      }\n      if (resource.type !== type) {\n        throw new Error(\n          `Resource ${resourceId} type mismatch: expected ${type}, got ${resource.type}`,\n        );\n      }\n    }\n\n    const pool: ResourcePool = {\n      id: poolId,\n      name,\n      type,\n      resources: [...resourceIds],\n      strategy,\n      loadBalancing: 'least-connections',\n      scaling: {\n        enabled: this.config.enableAutoScaling,\n        minResources: Math.max(1, resourceIds.length),\n        maxResources: resourceIds.length * 3,\n        scaleUpThreshold: 0.8,\n        scaleDownThreshold: 0.3,\n        cooldownPeriod: 300000,\n        metrics: [\n          { name: 'utilization', weight: 1.0, threshold: 0.8, aggregation: 'avg' },\n          { name: 'queue_depth', weight: 0.5, threshold: 10, aggregation: 'max' },\n        ],\n      },\n      qos: {\n        guarantees: [],\n        objectives: [],\n        violations: {\n          autoRemediation: true,\n          escalationThreshold: 3,\n          penaltyFunction: 'linear',\n          notificationEnabled: true,\n        },\n      },\n      statistics: this.createPoolStatistics(),\n      filters: [],\n    };\n\n    this.pools.set(poolId, pool);\n\n    this.logger.info('Resource pool created', {\n      poolId,\n      name,\n      type,\n      resourceCount: resourceIds.length,\n    });\n\n    this.emit('pool:created', { pool });\n\n    return poolId;\n  }\n\n  async addResourceToPool(poolId: string, resourceId: string): Promise<void> {\n    const pool = this.pools.get(poolId);\n    if (!pool) {\n      throw new Error(`Pool ${poolId} not found`);\n    }\n\n    const resource = this.resources.get(resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${resourceId} not found`);\n    }\n\n    if (resource.type !== pool.type) {\n      throw new Error(\n        `Resource type mismatch: pool expects ${pool.type}, resource is ${resource.type}`,\n      );\n    }\n\n    if (!pool.resources.includes(resourceId)) {\n      pool.resources.push(resourceId);\n      this.updatePoolStatistics(pool);\n    }\n\n    this.logger.info('Resource added to pool', { poolId, resourceId });\n    this.emit('pool:resource-added', { poolId, resourceId });\n  }\n\n  async removeResourceFromPool(poolId: string, resourceId: string): Promise<void> {\n    const pool = this.pools.get(poolId);\n    if (!pool) {\n      throw new Error(`Pool ${poolId} not found`);\n    }\n\n    if (pool.resources.length <= pool.scaling.minResources) {\n      throw new Error(`Cannot remove resource: pool would go below minimum size`);\n    }\n\n    pool.resources = pool.resources.filter((id) => id !== resourceId);\n    this.updatePoolStatistics(pool);\n\n    this.logger.info('Resource removed from pool', { poolId, resourceId });\n    this.emit('pool:resource-removed', { poolId, resourceId });\n  }\n\n  // === RESOURCE DISCOVERY AND ALLOCATION ===\n\n  private async findSuitableResource(\n    requirements: ResourceRequirements,\n    priority: ResourcePriority,\n  ): Promise<Resource | null> {\n    const candidates: Array<{ resource: Resource; score: number }> = [];\n\n    for (const resource of this.resources.values()) {\n      if (resource.status !== 'available') continue;\n\n      const score = this.calculateResourceScore(resource, requirements, priority);\n      if (score > 0) {\n        candidates.push({ resource, score });\n      }\n    }\n\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    // Sort by score (highest first)\n    candidates.sort((a, b) => b.score - a.score);\n\n    // Apply allocation strategy\n    return this.selectResourceByStrategy(candidates, requirements);\n  }\n\n  private calculateResourceScore(\n    resource: Resource,\n    requirements: ResourceRequirements,\n    priority: ResourcePriority,\n  ): number {\n    let score = 0;\n\n    // Check if resource can satisfy requirements\n    if (!this.canSatisfyRequirements(resource, requirements)) {\n      return 0;\n    }\n\n    // Base score from resource utilization (prefer less utilized)\n    const utilization = this.calculateResourceUtilization(resource);\n    score += (1 - utilization) * 100;\n\n    // Performance score\n    score += resource.metadata.performance.cpuScore * 10;\n\n    // Reliability score\n    score += resource.metadata.reliability.uptime * 50;\n\n    // Cost efficiency (lower cost is better)\n    score += (1 / resource.cost) * 20;\n\n    // Priority adjustment\n    const priorityWeight = this.config.priorityWeights[priority] || 1.0;\n    score *= priorityWeight;\n\n    return score;\n  }\n\n  private canSatisfyRequirements(resource: Resource, requirements: ResourceRequirements): boolean {\n    // Check CPU\n    if (requirements.cpu && requirements.cpu.min > resource.available.cpu) {\n      return false;\n    }\n\n    // Check memory\n    if (requirements.memory && requirements.memory.min > resource.available.memory) {\n      return false;\n    }\n\n    // Check disk\n    if (requirements.disk && requirements.disk.min > resource.available.disk) {\n      return false;\n    }\n\n    // Check network\n    if (requirements.network && requirements.network.min > resource.available.network) {\n      return false;\n    }\n\n    // Check custom resources\n    if (requirements.custom) {\n      for (const [name, spec] of Object.entries(requirements.custom)) {\n        const available = resource.available.custom[name] || 0;\n        if (spec.min > available) {\n          return false;\n        }\n      }\n    }\n\n    // Check constraints\n    if (requirements.constraints) {\n      if (!this.checkConstraints(resource, requirements.constraints)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private checkConstraints(resource: Resource, constraints: ResourceConstraints): boolean {\n    // Location constraints\n    if (constraints.location && constraints.location.length > 0) {\n      if (!constraints.location.includes(resource.location || '')) {\n        return false;\n      }\n    }\n\n    if (constraints.excludeLocation && constraints.excludeLocation.length > 0) {\n      if (constraints.excludeLocation.includes(resource.location || '')) {\n        return false;\n      }\n    }\n\n    // Cost constraints\n    if (constraints.maxCost && resource.cost > constraints.maxCost) {\n      return false;\n    }\n\n    // Time window constraints\n    if (constraints.timeWindow) {\n      const now = new Date();\n      if (now < constraints.timeWindow.start || now > constraints.timeWindow.end) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private selectResourceByStrategy(\n    candidates: Array<{ resource: Resource; score: number }>,\n    requirements: ResourceRequirements,\n  ): Resource {\n    switch (this.config.allocationStrategy) {\n      case 'first-fit':\n        return candidates[0].resource;\n\n      case 'best-fit':\n        // Find resource with smallest waste\n        return candidates.reduce((best, current) => {\n          const bestWaste = this.calculateWaste(best.resource, requirements);\n          const currentWaste = this.calculateWaste(current.resource, requirements);\n          return currentWaste < bestWaste ? current : best;\n        }).resource;\n\n      case 'worst-fit':\n        // Find resource with largest waste (for fragmentation avoidance)\n        return candidates.reduce((worst, current) => {\n          const worstWaste = this.calculateWaste(worst.resource, requirements);\n          const currentWaste = this.calculateWaste(current.resource, requirements);\n          return currentWaste > worstWaste ? current : worst;\n        }).resource;\n\n      case 'balanced':\n      default:\n        // Use highest score (balanced approach)\n        return candidates[0].resource;\n    }\n  }\n\n  private calculateWaste(resource: Resource, requirements: ResourceRequirements): number {\n    let waste = 0;\n\n    if (requirements.cpu) {\n      waste += Math.max(0, resource.available.cpu - requirements.cpu.min);\n    }\n\n    if (requirements.memory) {\n      waste += Math.max(0, resource.available.memory - requirements.memory.min);\n    }\n\n    return waste;\n  }\n\n  private calculateAllocation(\n    requirements: ResourceRequirements,\n    resource: Resource,\n  ): ResourceLimits {\n    const allocation: ResourceLimits = {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      custom: {},\n    };\n\n    if (requirements.cpu) {\n      allocation.cpu = Math.min(\n        requirements.cpu.preferred || requirements.cpu.min,\n        resource.available.cpu,\n      );\n    }\n\n    if (requirements.memory) {\n      allocation.memory = Math.min(\n        requirements.memory.preferred || requirements.memory.min,\n        resource.available.memory,\n      );\n    }\n\n    if (requirements.disk) {\n      allocation.disk = Math.min(\n        requirements.disk.preferred || requirements.disk.min,\n        resource.available.disk,\n      );\n    }\n\n    if (requirements.network) {\n      allocation.network = Math.min(\n        requirements.network.preferred || requirements.network.min,\n        resource.available.network,\n      );\n    }\n\n    if (requirements.custom) {\n      for (const [name, spec] of Object.entries(requirements.custom)) {\n        const available = resource.available.custom[name] || 0;\n        allocation.custom[name] = Math.min(spec.preferred || spec.min, available);\n      }\n    }\n\n    return allocation;\n  }\n\n  // === MONITORING AND OPTIMIZATION ===\n\n  private startMonitoring(): void {\n    this.monitoringInterval = setInterval(() => {\n      this.performMonitoring();\n    }, this.config.monitoringInterval);\n\n    this.logger.info('Started resource monitoring', {\n      interval: this.config.monitoringInterval,\n    });\n  }\n\n  private startCleanup(): void {\n    this.cleanupInterval = setInterval(() => {\n      this.performCleanup();\n    }, this.config.cleanupInterval);\n\n    this.logger.info('Started resource cleanup', {\n      interval: this.config.cleanupInterval,\n    });\n  }\n\n  private startAutoScaling(): void {\n    this.scalingInterval = setInterval(() => {\n      this.evaluateScaling();\n    }, 60000); // Every minute\n\n    this.logger.info('Started auto-scaling');\n  }\n\n  private async performMonitoring(): Promise<void> {\n    try {\n      // Update resource statistics\n      for (const resource of this.resources.values()) {\n        await this.updateResourceStatistics(resource);\n      }\n\n      // Update pool statistics\n      for (const pool of this.pools.values()) {\n        this.updatePoolStatistics(pool);\n      }\n\n      // Check QoS violations\n      if (this.config.enableQoS) {\n        await this.checkQoSViolations();\n      }\n\n      // Predictive analysis\n      if (this.config.enablePredictiveAllocation) {\n        await this.updatePredictions();\n      }\n\n      // Emit monitoring update\n      this.emit('monitoring:updated', {\n        resources: this.resources.size,\n        pools: this.pools.size,\n        allocations: this.allocations.size,\n      });\n    } catch (error) {\n      this.logger.error('Monitoring failed', error);\n    }\n  }\n\n  private async performCleanup(): Promise<void> {\n    const now = new Date();\n\n    // Clean up expired reservations\n    const expiredReservations = Array.from(this.reservations.values()).filter(\n      (r) => r.expiresAt && r.expiresAt < now && r.status === 'pending',\n    );\n\n    for (const reservation of expiredReservations) {\n      await this.cancelReservation(reservation.id, 'expired');\n    }\n\n    // Clean up old usage history\n    const cutoff = new Date(now.getTime() - 86400000); // 24 hours\n    for (const [resourceId, history] of this.usageHistory) {\n      this.usageHistory.set(\n        resourceId,\n        history.filter((usage) => usage.timestamp > cutoff),\n      );\n    }\n\n    this.logger.debug('Cleanup completed', {\n      expiredReservations: expiredReservations.length,\n    });\n  }\n\n  private async evaluateScaling(): Promise<void> {\n    for (const pool of this.pools.values()) {\n      if (!pool.scaling.enabled) continue;\n\n      const metrics = this.calculatePoolMetrics(pool);\n      const shouldScale = this.shouldScale(pool, metrics);\n\n      if (shouldScale.action === 'scale-up') {\n        await this.scalePoolUp(pool);\n      } else if (shouldScale.action === 'scale-down') {\n        await this.scalePoolDown(pool);\n      }\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private canActivateReservation(reservation: ResourceReservation): boolean {\n    const resource = this.resources.get(reservation.resourceId);\n    if (!resource) return false;\n\n    return this.canSatisfyRequirements(resource, reservation.requirements);\n  }\n\n  private calculateResourceUtilization(resource: Resource): number {\n    let totalCapacity = 0;\n    let totalAllocated = 0;\n\n    // CPU utilization\n    totalCapacity += resource.capacity.cpu;\n    totalAllocated += resource.allocated.cpu;\n\n    // Memory utilization\n    totalCapacity += resource.capacity.memory / (1024 * 1024); // Convert to MB for comparison\n    totalAllocated += resource.allocated.memory / (1024 * 1024);\n\n    return totalCapacity > 0 ? totalAllocated / totalCapacity : 0;\n  }\n\n  private calculateEfficiency(allocation: ResourceAllocation): number {\n    if (!allocation.endTime) return 0;\n\n    const duration = allocation.endTime.getTime() - allocation.startTime.getTime();\n    if (duration <= 0) return 0;\n\n    // Calculate efficiency based on actual usage vs allocated\n    let efficiencySum = 0;\n    let factors = 0;\n\n    if (allocation.allocated.cpu > 0) {\n      efficiencySum += allocation.actualUsage.cpu / allocation.allocated.cpu;\n      factors++;\n    }\n\n    if (allocation.allocated.memory > 0) {\n      efficiencySum += allocation.actualUsage.memory / allocation.allocated.memory;\n      factors++;\n    }\n\n    return factors > 0 ? efficiencySum / factors : 1.0;\n  }\n\n  private updateResourceAvailability(resource: Resource): void {\n    resource.available = {\n      cpu: Math.max(0, resource.capacity.cpu - resource.allocated.cpu),\n      memory: Math.max(0, resource.capacity.memory - resource.allocated.memory),\n      disk: Math.max(0, resource.capacity.disk - resource.allocated.disk),\n      network: Math.max(0, resource.capacity.network - resource.allocated.network),\n      custom: {},\n    };\n\n    // Update custom resources\n    for (const [name, capacity] of Object.entries(resource.capacity.custom)) {\n      const allocated = resource.allocated.custom[name] || 0;\n      resource.available.custom[name] = Math.max(0, capacity - allocated);\n    }\n  }\n\n  private addToResourceLimits(target: ResourceLimits, source: ResourceLimits): void {\n    target.cpu += source.cpu;\n    target.memory += source.memory;\n    target.disk += source.disk;\n    target.network += source.network;\n\n    for (const [name, value] of Object.entries(source.custom)) {\n      target.custom[name] = (target.custom[name] || 0) + value;\n    }\n  }\n\n  private subtractFromResourceLimits(target: ResourceLimits, source: ResourceLimits): void {\n    target.cpu = Math.max(0, target.cpu - source.cpu);\n    target.memory = Math.max(0, target.memory - source.memory);\n    target.disk = Math.max(0, target.disk - source.disk);\n    target.network = Math.max(0, target.network - source.network);\n\n    for (const [name, value] of Object.entries(source.custom)) {\n      target.custom[name] = Math.max(0, (target.custom[name] || 0) - value);\n    }\n  }\n\n  private createEmptyLimits(): ResourceLimits {\n    return {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      custom: {},\n    };\n  }\n\n  private createEmptyUsage(): ResourceUsage {\n    return {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      custom: {},\n      timestamp: new Date(),\n      duration: 0,\n    };\n  }\n\n  private createDefaultPerformanceMetrics(): PerformanceMetrics {\n    return {\n      cpuScore: 1.0,\n      memoryBandwidth: 1000000000, // 1GB/s\n      diskIOPS: 1000,\n      networkBandwidth: 1000000000, // 1Gbps\n      benchmarkResults: {},\n    };\n  }\n\n  private createDefaultReliabilityMetrics(): ReliabilityMetrics {\n    return {\n      uptime: 0.99,\n      meanTimeBetweenFailures: 8760, // 1 year in hours\n      errorRate: 0.01,\n      failureHistory: [],\n    };\n  }\n\n  private createDefaultCostMetrics(): CostMetrics {\n    return {\n      hourlyRate: 1.0,\n      dataTransferCost: 0.1,\n      storageCost: 0.1,\n      billing: 'hourly',\n    };\n  }\n\n  private createPoolStatistics(): PoolStatistics {\n    return {\n      totalResources: 0,\n      availableResources: 0,\n      utilizationRate: 0,\n      allocationSuccessRate: 100,\n      averageWaitTime: 0,\n      throughput: 0,\n      efficiency: 1.0,\n      costPerHour: 0,\n      qosScore: 100,\n    };\n  }\n\n  private async createDefaultPools(): Promise<void> {\n    // Create default compute pool if we have compute resources\n    const computeResources = Array.from(this.resources.values())\n      .filter((r) => r.type === 'compute')\n      .map((r) => r.id);\n\n    if (computeResources.length > 0) {\n      await this.createResourcePool('default-compute', 'compute', computeResources);\n    }\n  }\n\n  private updateResourceUsage(resourceId: string, usage: ResourceUsage): void {\n    const resource = this.resources.get(resourceId);\n    if (!resource) return;\n\n    // Store usage history\n    const history = this.usageHistory.get(resourceId) || [];\n    history.push(usage);\n\n    // Keep only last 1000 entries\n    if (history.length > 1000) {\n      history.shift();\n    }\n\n    this.usageHistory.set(resourceId, history);\n\n    // Update active allocations with actual usage\n    for (const allocation of resource.allocations) {\n      if (allocation.status === 'active') {\n        allocation.actualUsage = usage;\n        allocation.efficiency = this.calculateEfficiency(allocation);\n      }\n    }\n  }\n\n  private async updateResourceStatistics(resource: Resource): Promise<void> {\n    // Update utilization\n    const utilization = this.calculateResourceUtilization(resource);\n\n    // Update performance metrics based on usage history\n    const history = this.usageHistory.get(resource.id) || [];\n    if (history.length > 0) {\n      const recent = history.slice(-10); // Last 10 measurements\n      const avgCpu = recent.reduce((sum, h) => sum + h.cpu, 0) / recent.length;\n\n      // Update performance score based on load\n      resource.metadata.performance.cpuScore = Math.max(0.1, 1.0 - avgCpu / 100);\n    }\n\n    resource.metadata.lastUpdated = new Date();\n  }\n\n  private updatePoolStatistics(pool: ResourcePool): void {\n    const resources = pool.resources\n      .map((id) => this.resources.get(id))\n      .filter(Boolean) as Resource[];\n\n    pool.statistics.totalResources = resources.length;\n    pool.statistics.availableResources = resources.filter((r) => r.status === 'available').length;\n\n    if (resources.length > 0) {\n      const totalUtilization = resources.reduce(\n        (sum, r) => sum + this.calculateResourceUtilization(r),\n        0,\n      );\n      pool.statistics.utilizationRate = totalUtilization / resources.length;\n\n      const totalCost = resources.reduce((sum, r) => sum + r.cost, 0);\n      pool.statistics.costPerHour = totalCost;\n    }\n  }\n\n  private async checkQoSViolations(): Promise<void> {\n    // Check QoS for all active allocations\n    for (const allocation of this.allocations.values()) {\n      if (allocation.status !== 'active') continue;\n\n      const resource = this.resources.get(allocation.resourceId);\n      if (!resource) continue;\n\n      // Find applicable pools\n      const pools = Array.from(this.pools.values()).filter((p) =>\n        p.resources.includes(resource.id),\n      );\n\n      for (const pool of pools) {\n        await this.checkPoolQoS(pool, allocation);\n      }\n    }\n  }\n\n  private async checkPoolQoS(pool: ResourcePool, allocation: ResourceAllocation): Promise<void> {\n    for (const guarantee of pool.qos.guarantees) {\n      const value = this.getMetricValue(allocation, guarantee.metric);\n      const violated = this.evaluateQoSCondition(value, guarantee.operator, guarantee.threshold);\n\n      if (violated) {\n        const violation: QoSViolation = {\n          timestamp: new Date(),\n          metric: guarantee.metric,\n          expected: guarantee.threshold,\n          actual: value,\n          severity: this.calculateViolationSeverity(guarantee, value),\n          duration: 0, // Will be calculated over time\n          resolved: false,\n        };\n\n        allocation.qosViolations.push(violation);\n\n        this.logger.warn('QoS violation detected', {\n          allocationId: allocation.id,\n          metric: guarantee.metric,\n          expected: guarantee.threshold,\n          actual: value,\n        });\n\n        this.emit('qos:violation', { allocation, violation });\n\n        // Auto-remediation if enabled\n        if (pool.qos.violations.autoRemediation) {\n          await this.remediateQoSViolation(allocation, violation);\n        }\n      }\n    }\n  }\n\n  private async updatePredictions(): Promise<void> {\n    for (const resource of this.resources.values()) {\n      const history = this.usageHistory.get(resource.id) || [];\n      if (history.length < 10) continue; // Need minimum history\n\n      const prediction = await this.optimizer.predictUsage(resource, history);\n      this.predictions.set(resource.id, prediction);\n    }\n  }\n\n  private calculatePoolMetrics(pool: ResourcePool): Record<string, number> {\n    const resources = pool.resources\n      .map((id) => this.resources.get(id))\n      .filter(Boolean) as Resource[];\n    const metrics: Record<string, number> = {};\n\n    if (resources.length === 0) return metrics;\n\n    // Calculate utilization\n    const totalUtilization = resources.reduce(\n      (sum, r) => sum + this.calculateResourceUtilization(r),\n      0,\n    );\n    metrics.utilization = totalUtilization / resources.length;\n\n    // Calculate queue depth (simplified)\n    const totalReservations = resources.reduce((sum, r) => sum + r.reservations.length, 0);\n    metrics.queue_depth = totalReservations;\n\n    return metrics;\n  }\n\n  private shouldScale(\n    pool: ResourcePool,\n    metrics: Record<string, number>,\n  ): { action: 'scale-up' | 'scale-down' | 'none'; reason: string } {\n    const scaling = pool.scaling;\n\n    // Check scale-up conditions\n    for (const metric of scaling.metrics) {\n      const value = metrics[metric.name] || 0;\n\n      if (metric.aggregation === 'avg' && value > metric.threshold) {\n        if (pool.resources.length < scaling.maxResources) {\n          return { action: 'scale-up', reason: `${metric.name} threshold exceeded` };\n        }\n      }\n    }\n\n    // Check scale-down conditions\n    for (const metric of scaling.metrics) {\n      const value = metrics[metric.name] || 0;\n\n      if (metric.aggregation === 'avg' && value < scaling.scaleDownThreshold) {\n        if (pool.resources.length > scaling.minResources) {\n          return { action: 'scale-down', reason: `${metric.name} below threshold` };\n        }\n      }\n    }\n\n    return { action: 'none', reason: 'No scaling needed' };\n  }\n\n  private async scalePoolUp(pool: ResourcePool): Promise<void> {\n    this.logger.info('Scaling pool up', { poolId: pool.id });\n    // Implementation would add new resources to the pool\n    this.emit('pool:scaled-up', { pool });\n  }\n\n  private async scalePoolDown(pool: ResourcePool): Promise<void> {\n    this.logger.info('Scaling pool down', { poolId: pool.id });\n    // Implementation would remove underutilized resources from the pool\n    this.emit('pool:scaled-down', { pool });\n  }\n\n  private getMetricValue(allocation: ResourceAllocation, metric: string): number {\n    switch (metric) {\n      case 'cpu':\n        return allocation.actualUsage.cpu;\n      case 'memory':\n        return allocation.actualUsage.memory;\n      case 'efficiency':\n        return allocation.efficiency;\n      default:\n        return 0;\n    }\n  }\n\n  private evaluateQoSCondition(value: number, operator: string, threshold: number): boolean {\n    switch (operator) {\n      case 'gt':\n        return value > threshold;\n      case 'lt':\n        return value < threshold;\n      case 'eq':\n        return value === threshold;\n      case 'gte':\n        return value >= threshold;\n      case 'lte':\n        return value <= threshold;\n      default:\n        return false;\n    }\n  }\n\n  private calculateViolationSeverity(\n    guarantee: QoSGuarantee,\n    actualValue: number,\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    const deviation = Math.abs(actualValue - guarantee.threshold) / guarantee.threshold;\n\n    if (deviation > 0.5) return 'critical';\n    if (deviation > 0.3) return 'high';\n    if (deviation > 0.1) return 'medium';\n    return 'low';\n  }\n\n  private async remediateQoSViolation(\n    allocation: ResourceAllocation,\n    violation: QoSViolation,\n  ): Promise<void> {\n    this.logger.info('Attempting QoS violation remediation', {\n      allocationId: allocation.id,\n      metric: violation.metric,\n      severity: violation.severity,\n    });\n\n    // Simple remediation strategies\n    switch (violation.metric) {\n      case 'cpu':\n        // Could migrate to a less loaded resource\n        break;\n      case 'memory':\n        // Could increase memory allocation if available\n        break;\n      case 'efficiency':\n        // Could provide optimization recommendations\n        break;\n    }\n\n    this.emit('qos:remediation-attempted', { allocation, violation });\n  }\n\n  private async releaseAllAllocations(): Promise<void> {\n    const activeAllocations = Array.from(this.allocations.values()).filter(\n      (a) => a.status === 'active',\n    );\n\n    for (const allocation of activeAllocations) {\n      await this.releaseResources(allocation.id, 'system_shutdown');\n    }\n  }\n\n  private handleResourceRequest(data: any): void {\n    // Handle resource requests from agents\n    this.emit('resource:request-received', data);\n  }\n\n  private handleResourceRelease(data: any): void {\n    // Handle resource releases from agents\n    this.emit('resource:release-received', data);\n  }\n\n  private handleResourceFailure(data: any): void {\n    const resource = this.resources.get(data.resourceId);\n    if (resource) {\n      resource.status = 'failed';\n\n      // Record failure\n      resource.metadata.reliability.failureHistory.push({\n        timestamp: new Date(),\n        type: data.type || 'unknown',\n        duration: data.duration || 0,\n        impact: data.impact || 'medium',\n        resolved: false,\n      });\n\n      this.logger.error('Resource failure detected', {\n        resourceId: data.resourceId,\n        type: data.type,\n      });\n\n      this.emit('resource:failed', { resource, failure: data });\n    }\n  }\n\n  private handleScalingTrigger(data: any): void {\n    // Handle scaling triggers from monitoring system\n    this.emit('scaling:triggered', data);\n  }\n\n  // === PUBLIC API ===\n\n  getResource(resourceId: string): Resource | undefined {\n    return this.resources.get(resourceId);\n  }\n\n  getAllResources(): Resource[] {\n    return Array.from(this.resources.values());\n  }\n\n  getResourcesByType(type: ResourceType): Resource[] {\n    return Array.from(this.resources.values()).filter((r) => r.type === type);\n  }\n\n  getPool(poolId: string): ResourcePool | undefined {\n    return this.pools.get(poolId);\n  }\n\n  getAllPools(): ResourcePool[] {\n    return Array.from(this.pools.values());\n  }\n\n  getReservation(reservationId: string): ResourceReservation | undefined {\n    return this.reservations.get(reservationId);\n  }\n\n  getAllReservations(): ResourceReservation[] {\n    return Array.from(this.reservations.values());\n  }\n\n  getAllocation(allocationId: string): ResourceAllocation | undefined {\n    return this.allocations.get(allocationId);\n  }\n\n  getAllAllocations(): ResourceAllocation[] {\n    return Array.from(this.allocations.values());\n  }\n\n  getResourceUsageHistory(resourceId: string): ResourceUsage[] {\n    return this.usageHistory.get(resourceId) || [];\n  }\n\n  getResourcePrediction(resourceId: string): ResourcePrediction | undefined {\n    return this.predictions.get(resourceId);\n  }\n\n  getManagerStatistics(): {\n    resources: number;\n    pools: number;\n    reservations: number;\n    allocations: number;\n    utilization: number;\n    efficiency: number;\n  } {\n    const resources = Array.from(this.resources.values());\n    const allocations = Array.from(this.allocations.values());\n\n    const totalCapacity = resources.reduce((sum, r) => sum + r.capacity.cpu, 0);\n    const totalAllocated = resources.reduce((sum, r) => sum + r.allocated.cpu, 0);\n\n    const activeAllocations = allocations.filter((a) => a.status === 'active');\n    const avgEfficiency =\n      activeAllocations.length > 0\n        ? activeAllocations.reduce((sum, a) => sum + a.efficiency, 0) / activeAllocations.length\n        : 1.0;\n\n    return {\n      resources: this.resources.size,\n      pools: this.pools.size,\n      reservations: this.reservations.size,\n      allocations: this.allocations.size,\n      utilization: totalCapacity > 0 ? totalAllocated / totalCapacity : 0,\n      efficiency: avgEfficiency,\n    };\n  }\n}\n\n// === HELPER CLASSES ===\n\ninterface ResourcePrediction {\n  resourceId: string;\n  predictions: Array<{\n    timestamp: Date;\n    predictedUsage: ResourceUsage;\n    confidence: number;\n  }>;\n  trends: {\n    cpu: 'increasing' | 'decreasing' | 'stable';\n    memory: 'increasing' | 'decreasing' | 'stable';\n    disk: 'increasing' | 'decreasing' | 'stable';\n  };\n  recommendations: string[];\n}\n\nclass ResourceOptimizer {\n  constructor(\n    private config: ResourceManagerConfig,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.debug('Resource optimizer initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.debug('Resource optimizer shutdown');\n  }\n\n  async predictUsage(resource: Resource, history: ResourceUsage[]): Promise<ResourcePrediction> {\n    // Simple linear trend analysis\n    const predictions: Array<{\n      timestamp: Date;\n      predictedUsage: ResourceUsage;\n      confidence: number;\n    }> = [];\n\n    // Calculate trends\n    const cpuTrend = this.calculateTrend(history.map((h) => h.cpu));\n    const memoryTrend = this.calculateTrend(history.map((h) => h.memory));\n    const diskTrend = this.calculateTrend(history.map((h) => h.disk));\n\n    // Generate predictions for next 24 hours\n    for (let i = 1; i <= 24; i++) {\n      const futureTime = new Date(Date.now() + i * 3600000); // i hours from now\n\n      predictions.push({\n        timestamp: futureTime,\n        predictedUsage: {\n          cpu: Math.max(0, Math.min(100, this.extrapolateTrend(cpuTrend, i))),\n          memory: Math.max(0, this.extrapolateTrend(memoryTrend, i)),\n          disk: Math.max(0, this.extrapolateTrend(diskTrend, i)),\n          network: 0, // Simplified\n          custom: {},\n          timestamp: futureTime,\n          duration: 3600000, // 1 hour\n        },\n        confidence: Math.max(0.1, 1.0 - i * 0.05), // Decreasing confidence over time\n      });\n    }\n\n    return {\n      resourceId: resource.id,\n      predictions,\n      trends: {\n        cpu: this.categorizeTrend(cpuTrend),\n        memory: this.categorizeTrend(memoryTrend),\n        disk: this.categorizeTrend(diskTrend),\n      },\n      recommendations: this.generateRecommendations(resource, history),\n    };\n  }\n\n  private calculateTrend(values: number[]): { slope: number; intercept: number; r2: number } {\n    if (values.length < 2) {\n      return { slope: 0, intercept: values[0] || 0, r2: 0 };\n    }\n\n    const n = values.length;\n    const sumX = values.reduce((sum, _, i) => sum + i, 0);\n    const sumY = values.reduce((sum, val) => sum + val, 0);\n    const sumXY = values.reduce((sum, val, i) => sum + i * val, 0);\n    const sumXX = values.reduce((sum, _, i) => sum + i * i, 0);\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n\n    // Calculate R\u00B2\n    const meanY = sumY / n;\n    const ssTotal = values.reduce((sum, val) => sum + Math.pow(val - meanY, 2), 0);\n    const ssRes = values.reduce((sum, val, i) => {\n      const predicted = slope * i + intercept;\n      return sum + Math.pow(val - predicted, 2);\n    }, 0);\n\n    const r2 = 1 - ssRes / ssTotal;\n\n    return { slope, intercept, r2 };\n  }\n\n  private extrapolateTrend(trend: { slope: number; intercept: number }, steps: number): number {\n    return trend.slope * steps + trend.intercept;\n  }\n\n  private categorizeTrend(trend: { slope: number }): 'increasing' | 'decreasing' | 'stable' {\n    const threshold = 0.1;\n    if (trend.slope > threshold) return 'increasing';\n    if (trend.slope < -threshold) return 'decreasing';\n    return 'stable';\n  }\n\n  private generateRecommendations(resource: Resource, history: ResourceUsage[]): string[] {\n    const recommendations: string[] = [];\n\n    if (history.length === 0) {\n      return recommendations;\n    }\n\n    const recent = history.slice(-10);\n    const avgCpu = recent.reduce((sum, h) => sum + h.cpu, 0) / recent.length;\n    const avgMemory = recent.reduce((sum, h) => sum + h.memory, 0) / recent.length;\n\n    // CPU recommendations\n    if (avgCpu > 80) {\n      recommendations.push('High CPU usage detected. Consider scaling up or optimizing workloads.');\n    } else if (avgCpu < 20) {\n      recommendations.push('Low CPU usage. Consider scaling down to reduce costs.');\n    }\n\n    // Memory recommendations\n    const memoryUtilization = avgMemory / resource.capacity.memory;\n    if (memoryUtilization > 0.9) {\n      recommendations.push('High memory usage. Consider increasing memory allocation.');\n    } else if (memoryUtilization < 0.3) {\n      recommendations.push('Low memory usage. Consider reducing memory allocation.');\n    }\n\n    return recommendations;\n  }\n}\n\nclass ResourceManagerMetrics {\n  private allocationsCreated = 0;\n  private allocationsReleased = 0;\n  private reservationsFailed = 0;\n  private qosViolations = 0;\n\n  recordAllocationCreated(): void {\n    this.allocationsCreated++;\n  }\n\n  recordAllocationReleased(allocation: ResourceAllocation): void {\n    this.allocationsReleased++;\n  }\n\n  recordReservationFailed(): void {\n    this.reservationsFailed++;\n  }\n\n  recordQoSViolation(): void {\n    this.qosViolations++;\n  }\n\n  getMetrics(): any {\n    return {\n      allocationsCreated: this.allocationsCreated,\n      allocationsReleased: this.allocationsReleased,\n      reservationsFailed: this.reservationsFailed,\n      qosViolations: this.qosViolations,\n      successRate:\n        this.allocationsCreated > 0\n          ? ((this.allocationsCreated - this.reservationsFailed) / this.allocationsCreated) * 100\n          : 100,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
