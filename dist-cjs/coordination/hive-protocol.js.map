{
  "version": 3,
  "sources": ["../../src/coordination/hive-protocol.ts"],
  "sourcesContent": ["/**\n * Hive Mind Communication Protocol\n * Defines how agents communicate, vote, and share knowledge\n */\n\nimport { EventEmitter } from 'events';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface HiveMessage {\n  id: string;\n  from: string;\n  to: string | 'broadcast';\n  type: HiveMessageType;\n  payload: any;\n  timestamp: number;\n  priority: 'urgent' | 'high' | 'normal' | 'low';\n  requiresResponse?: boolean;\n  inReplyTo?: string;\n}\n\nexport type HiveMessageType =\n  | 'task_proposal'\n  | 'vote_request'\n  | 'vote_response'\n  | 'status_update'\n  | 'knowledge_share'\n  | 'help_request'\n  | 'consensus_check'\n  | 'quality_report'\n  | 'coordination_sync';\n\nexport interface HiveChannel {\n  id: string;\n  name: string;\n  type: 'broadcast' | 'consensus' | 'coordination' | 'knowledge';\n  members: Set<string>;\n  messages: HiveMessage[];\n}\n\nexport class HiveCommunicationProtocol extends EventEmitter {\n  private channels: Map<string, HiveChannel> = new Map();\n  private messageQueue: Map<string, HiveMessage[]> = new Map();\n  private knowledgeBase: Map<string, any> = new Map();\n  private consensusThreshold: number;\n\n  constructor(options: { consensusThreshold?: number } = {}) {\n    super();\n    this.consensusThreshold = options.consensusThreshold || 0.6;\n    this.initializeChannels();\n  }\n\n  /**\n   * Initialize default communication channels\n   */\n  private initializeChannels() {\n    // Broadcast channel for all agents\n    this.createChannel('broadcast', 'broadcast', 'General announcements and updates');\n\n    // Consensus channel for voting\n    this.createChannel('consensus', 'consensus', 'Voting and decision making');\n\n    // Coordination channel for task management\n    this.createChannel('coordination', 'coordination', 'Task assignment and progress');\n\n    // Knowledge channel for sharing insights\n    this.createChannel('knowledge', 'knowledge', 'Knowledge sharing and learning');\n  }\n\n  /**\n   * Create a new communication channel\n   */\n  createChannel(name: string, type: HiveChannel['type'], description: string): HiveChannel {\n    const channel: HiveChannel = {\n      id: generateId('channel'),\n      name,\n      type,\n      members: new Set(),\n      messages: [],\n    };\n\n    this.channels.set(channel.id, channel);\n    this.emit('channel:created', { channel, description });\n\n    return channel;\n  }\n\n  /**\n   * Join an agent to a channel\n   */\n  joinChannel(channelId: string, agentId: string) {\n    const channel = this.channels.get(channelId);\n    if (!channel) throw new Error(`Channel ${channelId} not found`);\n\n    channel.members.add(agentId);\n    this.emit('channel:joined', { channelId, agentId });\n  }\n\n  /**\n   * Send a message through the protocol\n   */\n  sendMessage(message: Omit<HiveMessage, 'id' | 'timestamp'>): HiveMessage {\n    const fullMessage: HiveMessage = {\n      ...message,\n      id: generateId('msg'),\n      timestamp: Date.now(),\n    };\n\n    // Route message based on type\n    this.routeMessage(fullMessage);\n\n    // Store in appropriate channel\n    const channelType = this.getChannelTypeForMessage(fullMessage.type);\n    const channel = Array.from(this.channels.values()).find((c) => c.type === channelType);\n    if (channel) {\n      channel.messages.push(fullMessage);\n    }\n\n    // Queue for recipient(s)\n    if (fullMessage.to === 'broadcast') {\n      // Queue for all agents\n      for (const channel of this.channels.values()) {\n        for (const member of channel.members) {\n          this.queueMessage(member, fullMessage);\n        }\n      }\n    } else {\n      // Queue for specific recipient\n      this.queueMessage(fullMessage.to, fullMessage);\n    }\n\n    this.emit('message:sent', fullMessage);\n\n    return fullMessage;\n  }\n\n  /**\n   * Route message based on type\n   */\n  private routeMessage(message: HiveMessage) {\n    switch (message.type) {\n      case 'vote_request':\n        this.handleVoteRequest(message);\n        break;\n      case 'knowledge_share':\n        this.handleKnowledgeShare(message);\n        break;\n      case 'consensus_check':\n        this.handleConsensusCheck(message);\n        break;\n      case 'quality_report':\n        this.handleQualityReport(message);\n        break;\n    }\n  }\n\n  /**\n   * Get channel type for message type\n   */\n  private getChannelTypeForMessage(messageType: HiveMessageType): HiveChannel['type'] {\n    switch (messageType) {\n      case 'vote_request':\n      case 'vote_response':\n      case 'consensus_check':\n        return 'consensus';\n      case 'task_proposal':\n      case 'status_update':\n      case 'coordination_sync':\n        return 'coordination';\n      case 'knowledge_share':\n        return 'knowledge';\n      default:\n        return 'broadcast';\n    }\n  }\n\n  /**\n   * Queue message for agent\n   */\n  private queueMessage(agentId: string, message: HiveMessage) {\n    if (!this.messageQueue.has(agentId)) {\n      this.messageQueue.set(agentId, []);\n    }\n    this.messageQueue.get(agentId)!.push(message);\n  }\n\n  /**\n   * Retrieve messages for agent\n   */\n  getMessages(agentId: string): HiveMessage[] {\n    const messages = this.messageQueue.get(agentId) || [];\n    this.messageQueue.set(agentId, []); // Clear after retrieval\n    return messages;\n  }\n\n  /**\n   * Handle vote request\n   */\n  private handleVoteRequest(message: HiveMessage) {\n    const { proposal, deadline } = message.payload;\n\n    this.emit('vote:requested', {\n      messageId: message.id,\n      proposal,\n      deadline,\n      from: message.from,\n    });\n\n    // Set timeout for vote collection\n    if (deadline) {\n      setTimeout(() => {\n        this.collectVotes(message.id);\n      }, deadline - Date.now());\n    }\n  }\n\n  /**\n   * Submit a vote response\n   */\n  submitVote(requestId: string, agentId: string, vote: boolean, confidence: number = 1.0) {\n    const voteMessage = this.sendMessage({\n      from: agentId,\n      to: 'consensus',\n      type: 'vote_response',\n      payload: {\n        requestId,\n        vote,\n        confidence,\n        reasoning: this.generateVoteReasoning(vote, confidence),\n      },\n      priority: 'high',\n    });\n\n    this.emit('vote:submitted', {\n      requestId,\n      agentId,\n      vote,\n      confidence,\n    });\n\n    return voteMessage;\n  }\n\n  /**\n   * Generate reasoning for vote\n   */\n  private generateVoteReasoning(vote: boolean, confidence: number): string {\n    if (vote && confidence > 0.8) {\n      return 'Strong alignment with objectives and capabilities';\n    } else if (vote && confidence > 0.5) {\n      return 'Moderate alignment, some concerns but manageable';\n    } else if (!vote && confidence > 0.8) {\n      return 'Significant concerns or misalignment detected';\n    } else {\n      return 'Insufficient information or capability mismatch';\n    }\n  }\n\n  /**\n   * Collect and evaluate votes\n   */\n  private collectVotes(requestId: string) {\n    const votes = new Map<string, { vote: boolean; confidence: number }>();\n\n    // Collect all vote responses for this request\n    for (const channel of this.channels.values()) {\n      for (const message of channel.messages) {\n        if (message.type === 'vote_response' && message.payload.requestId === requestId) {\n          votes.set(message.from, {\n            vote: message.payload.vote,\n            confidence: message.payload.confidence,\n          });\n        }\n      }\n    }\n\n    // Calculate consensus\n    const consensus = this.calculateConsensus(votes);\n\n    this.emit('consensus:reached', {\n      requestId,\n      consensus,\n      votes: Array.from(votes.entries()),\n    });\n  }\n\n  /**\n   * Calculate consensus from votes\n   */\n  private calculateConsensus(votes: Map<string, { vote: boolean; confidence: number }>): {\n    approved: boolean;\n    confidence: number;\n  } {\n    if (votes.size === 0) {\n      return { approved: false, confidence: 0 };\n    }\n\n    let totalWeight = 0;\n    let approvalWeight = 0;\n\n    for (const [_, { vote, confidence }] of votes) {\n      totalWeight += confidence;\n      if (vote) {\n        approvalWeight += confidence;\n      }\n    }\n\n    const approvalRate = approvalWeight / totalWeight;\n    const approved = approvalRate >= this.consensusThreshold;\n\n    return { approved, confidence: approvalRate };\n  }\n\n  /**\n   * Handle knowledge sharing\n   */\n  private handleKnowledgeShare(message: HiveMessage) {\n    const { key, value, metadata } = message.payload;\n\n    // Store in knowledge base\n    this.knowledgeBase.set(key, {\n      value,\n      metadata,\n      contributor: message.from,\n      timestamp: message.timestamp,\n    });\n\n    this.emit('knowledge:shared', {\n      key,\n      contributor: message.from,\n      timestamp: message.timestamp,\n    });\n  }\n\n  /**\n   * Query knowledge base\n   */\n  queryKnowledge(pattern: string): any[] {\n    const results = [];\n\n    for (const [key, data] of this.knowledgeBase) {\n      if (key.includes(pattern)) {\n        results.push({ key, ...data });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Handle consensus check\n   */\n  private handleConsensusCheck(message: HiveMessage) {\n    const { topic, options } = message.payload;\n\n    // Initiate voting round\n    const voteRequest = this.sendMessage({\n      from: 'consensus-system',\n      to: 'broadcast',\n      type: 'vote_request',\n      payload: {\n        topic,\n        options,\n        deadline: Date.now() + 30000, // 30 second deadline\n      },\n      priority: 'urgent',\n      requiresResponse: true,\n    });\n\n    this.emit('consensus:initiated', {\n      topic,\n      options,\n      requestId: voteRequest.id,\n    });\n  }\n\n  /**\n   * Handle quality report\n   */\n  private handleQualityReport(message: HiveMessage) {\n    const { taskId, metrics, issues } = message.payload;\n\n    // Store quality metrics\n    this.knowledgeBase.set(`quality/${taskId}`, {\n      metrics,\n      issues,\n      reporter: message.from,\n      timestamp: message.timestamp,\n    });\n\n    // Check if quality threshold breached\n    if (metrics.score < 0.7) {\n      this.emit('quality:alert', {\n        taskId,\n        score: metrics.score,\n        issues,\n        reporter: message.from,\n      });\n    }\n  }\n\n  /**\n   * Get communication statistics\n   */\n  getStatistics() {\n    const stats = {\n      totalMessages: 0,\n      messagesByType: new Map<HiveMessageType, number>(),\n      messagesByPriority: new Map<string, number>(),\n      activeChannels: this.channels.size,\n      knowledgeEntries: this.knowledgeBase.size,\n      avgResponseTime: 0,\n    };\n\n    // Aggregate message statistics\n    for (const channel of this.channels.values()) {\n      stats.totalMessages += channel.messages.length;\n\n      for (const message of channel.messages) {\n        const typeCount = stats.messagesByType.get(message.type) || 0;\n        stats.messagesByType.set(message.type, typeCount + 1);\n\n        const priorityCount = stats.messagesByPriority.get(message.priority) || 0;\n        stats.messagesByPriority.set(message.priority, priorityCount + 1);\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Export communication log\n   */\n  exportLog(): any {\n    const log = {\n      channels: Array.from(this.channels.values()).map((channel) => ({\n        id: channel.id,\n        name: channel.name,\n        type: channel.type,\n        memberCount: channel.members.size,\n        messageCount: channel.messages.length,\n      })),\n      messages: [],\n      knowledge: Array.from(this.knowledgeBase.entries()).map(([key, value]) => ({\n        key,\n        ...value,\n      })),\n    };\n\n    // Collect all messages\n    for (const channel of this.channels.values()) {\n      log.messages.push(...channel.messages);\n    }\n\n    // Sort by timestamp\n    log.messages.sort((a, b) => a.timestamp - b.timestamp);\n\n    return log;\n  }\n}\n"],
  "mappings": "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",
  "names": ["channel"]
}
