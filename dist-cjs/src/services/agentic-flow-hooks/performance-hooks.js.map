{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/performance-hooks.ts"],"sourcesContent":["/**\r\n * Performance optimization hooks for agentic-flow\r\n * \r\n * Tracks metrics, identifies bottlenecks, and provides\r\n * optimization suggestions based on provider performance.\r\n */\r\n\r\nimport { agenticHookManager } from './hook-manager.js';\r\nimport type {\r\n  AgenticHookContext,\r\n  HookHandlerResult,\r\n  PerformanceHookPayload,\r\n  PerformanceMetric,\r\n  BottleneckAnalysis,\r\n  OptimizationSuggestion,\r\n  SideEffect,\r\n} from './types.js';\r\n\r\n// ===== Performance Metric Hook =====\r\n\r\nexport const performanceMetricHook = {\r\n  id: 'agentic-performance-metric',\r\n  type: 'performance-metric' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: PerformanceHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { metric, value, unit, threshold } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Store metric\r\n    const metricData: PerformanceMetric = {\r\n      name: metric,\r\n      value,\r\n      unit,\r\n      timestamp: Date.now(),\r\n      tags: extractTags(payload.context),\r\n    };\r\n    \r\n    context.performance.metrics.set(metric, metricData);\r\n    \r\n    // Check threshold violations\r\n    if (threshold !== undefined) {\r\n      const violated = checkThreshold(value, threshold, payload.context);\r\n      \r\n      if (violated) {\r\n        sideEffects.push({\r\n          type: 'notification',\r\n          action: 'emit',\r\n          data: {\r\n            event: 'performance:threshold:violated',\r\n            data: {\r\n              metric,\r\n              value,\r\n              threshold,\r\n              unit,\r\n            },\r\n          },\r\n        });\r\n        \r\n        // Generate optimization suggestion\r\n        const suggestion = await generateOptimizationSuggestion(\r\n          metric,\r\n          value,\r\n          threshold,\r\n          context\r\n        );\r\n        \r\n        if (suggestion) {\r\n          context.performance.optimizations.push(suggestion);\r\n          sideEffects.push({\r\n            type: 'log',\r\n            action: 'write',\r\n            data: {\r\n              level: 'info',\r\n              message: 'Optimization suggestion generated',\r\n              data: suggestion,\r\n            },\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Update rolling averages\r\n    await updateRollingAverages(metric, value, context);\r\n    \r\n    // Detect anomalies\r\n    const anomaly = await detectAnomaly(metric, value, context);\r\n    if (anomaly) {\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'performance:anomaly:detected',\r\n          data: { metric, value, anomaly },\r\n        },\r\n      });\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Performance Bottleneck Hook =====\r\n\r\nexport const performanceBottleneckHook = {\r\n  id: 'agentic-performance-bottleneck',\r\n  type: 'performance-bottleneck' as const,\r\n  priority: 90,\r\n  handler: async (\r\n    payload: PerformanceHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { bottleneck } = payload;\r\n    \r\n    if (!bottleneck) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Analyze bottleneck severity\r\n    const analysis: BottleneckAnalysis = {\r\n      component: bottleneck.location,\r\n      severity: mapSeverity(bottleneck.severity),\r\n      impact: bottleneck.severity / 10, // Normalize to 0-1\r\n      suggestions: bottleneck.suggestions,\r\n    };\r\n    \r\n    context.performance.bottlenecks.push(analysis);\r\n    \r\n    // Store for historical analysis\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `bottleneck:${analysis.component}:${Date.now()}`,\r\n        value: analysis,\r\n        ttl: 86400, // 24 hours\r\n      },\r\n    });\r\n    \r\n    // Check for recurring bottlenecks\r\n    const recurrence = await checkBottleneckRecurrence(\r\n      analysis.component,\r\n      context\r\n    );\r\n    \r\n    if (recurrence.count > 3) {\r\n      // Recurring bottleneck - escalate\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'performance:bottleneck:recurring',\r\n          data: {\r\n            component: analysis.component,\r\n            occurrences: recurrence.count,\r\n            timespan: recurrence.timespan,\r\n          },\r\n        },\r\n      });\r\n      \r\n      // Generate advanced optimization\r\n      const optimization = await generateAdvancedOptimization(\r\n        analysis,\r\n        recurrence,\r\n        context\r\n      );\r\n      \r\n      if (optimization) {\r\n        context.performance.optimizations.push(optimization);\r\n      }\r\n    }\r\n    \r\n    // Correlate with other metrics\r\n    const correlations = await findMetricCorrelations(\r\n      analysis.component,\r\n      context\r\n    );\r\n    \r\n    if (correlations.length > 0) {\r\n      sideEffects.push({\r\n        type: 'log',\r\n        action: 'write',\r\n        data: {\r\n          level: 'info',\r\n          message: 'Bottleneck correlations found',\r\n          data: { bottleneck: analysis, correlations },\r\n        },\r\n      });\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Performance Optimization Hook =====\r\n\r\nexport const performanceOptimizationHook = {\r\n  id: 'agentic-performance-optimization',\r\n  type: 'performance-optimization' as const,\r\n  priority: 80,\r\n  handler: async (\r\n    payload: PerformanceHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { optimization } = payload;\r\n    \r\n    if (!optimization) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Validate optimization\r\n    const validation = await validateOptimization(optimization, context);\r\n    if (!validation.valid) {\r\n      sideEffects.push({\r\n        type: 'log',\r\n        action: 'write',\r\n        data: {\r\n          level: 'warning',\r\n          message: 'Optimization validation failed',\r\n          data: { optimization, validation },\r\n        },\r\n      });\r\n      return { continue: true, sideEffects };\r\n    }\r\n    \r\n    // Simulate optimization impact\r\n    const simulation = await simulateOptimization(optimization, context);\r\n    \r\n    if (simulation.expectedImprovement < 0.1) {\r\n      // Low impact - skip\r\n      return { continue: true };\r\n    }\r\n    \r\n    // Store optimization recommendation\r\n    const recommendation = {\r\n      optimization,\r\n      simulation,\r\n      timestamp: Date.now(),\r\n      autoApply: optimization.applied && simulation.risk === 'low',\r\n    };\r\n    \r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `optimization:${optimization.type}:${Date.now()}`,\r\n        value: recommendation,\r\n        ttl: 604800, // 7 days\r\n      },\r\n    });\r\n    \r\n    // Auto-apply low-risk optimizations\r\n    if (recommendation.autoApply) {\r\n      await applyOptimization(optimization, context);\r\n      \r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'performance:optimization:applied',\r\n          data: { optimization, automatic: true },\r\n        },\r\n      });\r\n    } else {\r\n      // Queue for manual review\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'performance:optimization:suggested',\r\n          data: { optimization, simulation },\r\n        },\r\n      });\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Performance Threshold Hook =====\r\n\r\nexport const performanceThresholdHook = {\r\n  id: 'agentic-performance-threshold',\r\n  type: 'performance-threshold' as const,\r\n  priority: 95,\r\n  handler: async (\r\n    payload: PerformanceHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { metric, value, threshold } = payload;\r\n    \r\n    if (threshold === undefined) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Dynamic threshold adjustment\r\n    const historicalData = await getMetricHistory(metric, context);\r\n    const adjustedThreshold = calculateDynamicThreshold(\r\n      threshold,\r\n      historicalData\r\n    );\r\n    \r\n    if (adjustedThreshold !== threshold) {\r\n      sideEffects.push({\r\n        type: 'log',\r\n        action: 'write',\r\n        data: {\r\n          level: 'info',\r\n          message: 'Threshold dynamically adjusted',\r\n          data: {\r\n            metric,\r\n            original: threshold,\r\n            adjusted: adjustedThreshold,\r\n          },\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Predict threshold violations\r\n    const prediction = await predictThresholdViolation(\r\n      metric,\r\n      value,\r\n      adjustedThreshold,\r\n      historicalData\r\n    );\r\n    \r\n    if (prediction.willViolate && prediction.confidence > 0.7) {\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'performance:threshold:predicted',\r\n          data: {\r\n            metric,\r\n            currentValue: value,\r\n            threshold: adjustedThreshold,\r\n            predictedTime: prediction.timeToViolation,\r\n            confidence: prediction.confidence,\r\n          },\r\n        },\r\n      });\r\n      \r\n      // Proactive optimization\r\n      const proactiveOpt = await generateProactiveOptimization(\r\n        metric,\r\n        prediction,\r\n        context\r\n      );\r\n      \r\n      if (proactiveOpt) {\r\n        context.performance.optimizations.push(proactiveOpt);\r\n      }\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Helper Functions =====\r\n\r\nfunction extractTags(context: Record<string, any>): string[] {\r\n  const tags: string[] = [];\r\n  \r\n  if (context.provider) tags.push(`provider:${context.provider}`);\r\n  if (context.model) tags.push(`model:${context.model}`);\r\n  if (context.operation) tags.push(`op:${context.operation}`);\r\n  if (context.component) tags.push(`component:${context.component}`);\r\n  \r\n  return tags;\r\n}\r\n\r\nfunction checkThreshold(\r\n  value: number,\r\n  threshold: number,\r\n  context: Record<string, any>\r\n): boolean {\r\n  // Check if threshold is violated based on context\r\n  const operator = context.thresholdOperator || 'gt';\r\n  \r\n  switch (operator) {\r\n    case 'gt': return value > threshold;\r\n    case 'gte': return value >= threshold;\r\n    case 'lt': return value < threshold;\r\n    case 'lte': return value <= threshold;\r\n    case 'eq': return value === threshold;\r\n    case 'ne': return value !== threshold;\r\n    default: return value > threshold;\r\n  }\r\n}\r\n\r\nasync function generateOptimizationSuggestion(\r\n  metric: string,\r\n  value: number,\r\n  threshold: number,\r\n  context: AgenticHookContext\r\n): Promise<OptimizationSuggestion | null> {\r\n  // Generate optimization based on metric type\r\n  const metricType = getMetricType(metric);\r\n  \r\n  switch (metricType) {\r\n    case 'latency':\r\n      if (value > threshold * 2) {\r\n        return {\r\n          type: 'cache',\r\n          target: metric,\r\n          expectedImprovement: 50,\r\n          implementation: 'Enable response caching for frequently accessed data',\r\n          risk: 'low',\r\n        };\r\n      } else if (value > threshold * 1.5) {\r\n        return {\r\n          type: 'parallel',\r\n          target: metric,\r\n          expectedImprovement: 30,\r\n          implementation: 'Parallelize independent operations',\r\n          risk: 'medium',\r\n        };\r\n      }\r\n      break;\r\n      \r\n    case 'throughput':\r\n      if (value < threshold * 0.5) {\r\n        return {\r\n          type: 'batch',\r\n          target: metric,\r\n          expectedImprovement: 40,\r\n          implementation: 'Batch similar requests together',\r\n          risk: 'low',\r\n        };\r\n      }\r\n      break;\r\n      \r\n    case 'memory':\r\n      if (value > threshold * 0.9) {\r\n        return {\r\n          type: 'resource',\r\n          target: metric,\r\n          expectedImprovement: 20,\r\n          implementation: 'Implement memory pooling and recycling',\r\n          risk: 'medium',\r\n        };\r\n      }\r\n      break;\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nasync function updateRollingAverages(\r\n  metric: string,\r\n  value: number,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  const avgKey = `avg:${metric}`;\r\n  const history = await context.memory.cache.get(avgKey) || [];\r\n  \r\n  history.push({ value, timestamp: Date.now() });\r\n  \r\n  // Keep last 1000 values\r\n  if (history.length > 1000) {\r\n    history.shift();\r\n  }\r\n  \r\n  await context.memory.cache.set(avgKey, history);\r\n}\r\n\r\nasync function detectAnomaly(\r\n  metric: string,\r\n  value: number,\r\n  context: AgenticHookContext\r\n): Promise<any | null> {\r\n  const avgKey = `avg:${metric}`;\r\n  const history = await context.memory.cache.get(avgKey) || [];\r\n  \r\n  if (history.length < 100) {\r\n    return null; // Not enough data\r\n  }\r\n  \r\n  // Calculate statistics\r\n  const values = history.map((h: any) => h.value);\r\n  const mean = values.reduce((a: number, b: number) => a + b, 0) / values.length;\r\n  const variance = values.reduce((a: number, b: number) => \r\n    a + Math.pow(b - mean, 2), 0\r\n  ) / values.length;\r\n  const stdDev = Math.sqrt(variance);\r\n  \r\n  // Check if value is anomalous (> 3 standard deviations)\r\n  const zScore = Math.abs((value - mean) / stdDev);\r\n  \r\n  if (zScore > 3) {\r\n    return {\r\n      type: 'statistical',\r\n      zScore,\r\n      mean,\r\n      stdDev,\r\n      severity: zScore > 5 ? 'high' : 'medium',\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction mapSeverity(severity: number): BottleneckAnalysis['severity'] {\r\n  if (severity >= 8) return 'critical';\r\n  if (severity >= 6) return 'high';\r\n  if (severity >= 4) return 'medium';\r\n  return 'low';\r\n}\r\n\r\nasync function checkBottleneckRecurrence(\r\n  component: string,\r\n  context: AgenticHookContext\r\n): Promise<{ count: number; timespan: number }> {\r\n  const historyKey = `bottleneck:history:${component}`;\r\n  const history = await context.memory.cache.get(historyKey) || [];\r\n  \r\n  const now = Date.now();\r\n  const dayAgo = now - 86400000;\r\n  \r\n  // Count occurrences in last 24 hours\r\n  const recentOccurrences = history.filter((h: any) => \r\n    h.timestamp > dayAgo\r\n  );\r\n  \r\n  return {\r\n    count: recentOccurrences.length,\r\n    timespan: 86400000, // 24 hours in ms\r\n  };\r\n}\r\n\r\nasync function generateAdvancedOptimization(\r\n  bottleneck: BottleneckAnalysis,\r\n  recurrence: { count: number; timespan: number },\r\n  context: AgenticHookContext\r\n): Promise<OptimizationSuggestion | null> {\r\n  // Generate advanced optimization for recurring bottlenecks\r\n  if (bottleneck.severity === 'critical' && recurrence.count > 5) {\r\n    return {\r\n      type: 'algorithm',\r\n      target: bottleneck.component,\r\n      expectedImprovement: 60,\r\n      implementation: `Redesign ${bottleneck.component} algorithm for better scalability`,\r\n      risk: 'high',\r\n    };\r\n  }\r\n  \r\n  if (bottleneck.severity === 'high' && recurrence.count > 3) {\r\n    return {\r\n      type: 'cache',\r\n      target: bottleneck.component,\r\n      expectedImprovement: 40,\r\n      implementation: `Implement distributed caching for ${bottleneck.component}`,\r\n      risk: 'medium',\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nasync function findMetricCorrelations(\r\n  component: string,\r\n  context: AgenticHookContext\r\n): Promise<Array<{ metric: string; correlation: number }>> {\r\n  const correlations: Array<{ metric: string; correlation: number }> = [];\r\n  \r\n  // Check correlations with other metrics\r\n  for (const [metric, data] of context.performance.metrics) {\r\n    if (data.tags.includes(`component:${component}`)) {\r\n      // Simple correlation check\r\n      correlations.push({\r\n        metric: data.name,\r\n        correlation: 0.7, // Placeholder\r\n      });\r\n    }\r\n  }\r\n  \r\n  return correlations;\r\n}\r\n\r\nasync function validateOptimization(\r\n  optimization: any,\r\n  context: AgenticHookContext\r\n): Promise<{ valid: boolean; reason?: string }> {\r\n  // Validate optimization is safe to apply\r\n  if (!optimization.type || !optimization.details) {\r\n    return {\r\n      valid: false,\r\n      reason: 'Missing required optimization fields',\r\n    };\r\n  }\r\n  \r\n  // Check risk level\r\n  if (optimization.details === 'high' && !context.metadata.allowHighRisk) {\r\n    return {\r\n      valid: false,\r\n      reason: 'High-risk optimizations not allowed',\r\n    };\r\n  }\r\n  \r\n  return { valid: true };\r\n}\r\n\r\nasync function simulateOptimization(\r\n  optimization: any,\r\n  context: AgenticHookContext\r\n): Promise<any> {\r\n  // Simulate optimization impact\r\n  const baseline = await getBaselineMetrics(optimization.type, context);\r\n  \r\n  const simulation = {\r\n    expectedImprovement: optimization.improvement || 0.2,\r\n    risk: calculateRisk(optimization),\r\n    affectedMetrics: identifyAffectedMetrics(optimization),\r\n    rollbackPlan: generateRollbackPlan(optimization),\r\n  };\r\n  \r\n  return simulation;\r\n}\r\n\r\nasync function applyOptimization(\r\n  optimization: any,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Apply optimization\r\n  // Placeholder implementation\r\n  const timestamp = Date.now();\r\n  \r\n  // Store optimization application\r\n  await context.memory.cache.set(\r\n    `applied:${optimization.type}:${timestamp}`,\r\n    {\r\n      optimization,\r\n      appliedAt: timestamp,\r\n      appliedBy: 'automatic',\r\n    }\r\n  );\r\n}\r\n\r\nasync function getMetricHistory(\r\n  metric: string,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  const historyKey = `history:${metric}`;\r\n  return await context.memory.cache.get(historyKey) || [];\r\n}\r\n\r\nfunction calculateDynamicThreshold(\r\n  baseThreshold: number,\r\n  historicalData: any[]\r\n): number {\r\n  if (historicalData.length < 50) {\r\n    return baseThreshold; // Not enough data\r\n  }\r\n  \r\n  // Calculate percentile-based threshold\r\n  const values = historicalData\r\n    .map(d => d.value)\r\n    .sort((a, b) => a - b);\r\n  \r\n  const p95 = values[Math.floor(values.length * 0.95)];\r\n  \r\n  // Adjust threshold based on historical performance\r\n  return Math.max(baseThreshold, p95 * 1.1);\r\n}\r\n\r\nasync function predictThresholdViolation(\r\n  metric: string,\r\n  currentValue: number,\r\n  threshold: number,\r\n  historicalData: any[]\r\n): Promise<any> {\r\n  if (historicalData.length < 10) {\r\n    return {\r\n      willViolate: false,\r\n      confidence: 0,\r\n    };\r\n  }\r\n  \r\n  // Simple linear trend prediction\r\n  const recentValues = historicalData.slice(-10).map(d => d.value);\r\n  const trend = calculateTrend(recentValues);\r\n  \r\n  if (trend > 0 && currentValue > threshold * 0.8) {\r\n    const timeToViolation = (threshold - currentValue) / trend;\r\n    \r\n    return {\r\n      willViolate: true,\r\n      timeToViolation,\r\n      confidence: Math.min(trend * 10, 0.9),\r\n    };\r\n  }\r\n  \r\n  return {\r\n    willViolate: false,\r\n    confidence: 0,\r\n  };\r\n}\r\n\r\nasync function generateProactiveOptimization(\r\n  metric: string,\r\n  prediction: any,\r\n  context: AgenticHookContext\r\n): Promise<OptimizationSuggestion | null> {\r\n  // Generate proactive optimization to prevent violation\r\n  const metricType = getMetricType(metric);\r\n  \r\n  if (metricType === 'latency' && prediction.timeToViolation < 300000) {\r\n    return {\r\n      type: 'cache',\r\n      target: metric,\r\n      expectedImprovement: 30,\r\n      implementation: 'Preemptively cache high-latency operations',\r\n      risk: 'low',\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction getMetricType(metric: string): string {\r\n  if (metric.includes('latency')) return 'latency';\r\n  if (metric.includes('throughput')) return 'throughput';\r\n  if (metric.includes('memory')) return 'memory';\r\n  if (metric.includes('cpu')) return 'cpu';\r\n  return 'unknown';\r\n}\r\n\r\nasync function getBaselineMetrics(\r\n  type: string,\r\n  context: AgenticHookContext\r\n): Promise<any> {\r\n  // Get baseline metrics for comparison\r\n  // Placeholder implementation\r\n  return {};\r\n}\r\n\r\nfunction calculateRisk(optimization: any): string {\r\n  // Calculate optimization risk level\r\n  if (optimization.type === 'algorithm') return 'high';\r\n  if (optimization.type === 'architecture') return 'high';\r\n  if (optimization.type === 'cache') return 'low';\r\n  if (optimization.type === 'batch') return 'low';\r\n  return 'medium';\r\n}\r\n\r\nfunction identifyAffectedMetrics(optimization: any): string[] {\r\n  // Identify metrics affected by optimization\r\n  const affected: string[] = [];\r\n  \r\n  switch (optimization.type) {\r\n    case 'cache':\r\n      affected.push('latency', 'memory_usage');\r\n      break;\r\n    case 'parallel':\r\n      affected.push('latency', 'cpu_usage', 'throughput');\r\n      break;\r\n    case 'batch':\r\n      affected.push('throughput', 'latency');\r\n      break;\r\n    case 'algorithm':\r\n      affected.push('latency', 'cpu_usage', 'memory_usage');\r\n      break;\r\n  }\r\n  \r\n  return affected;\r\n}\r\n\r\nfunction generateRollbackPlan(optimization: any): any {\r\n  // Generate rollback plan\r\n  return {\r\n    steps: [\r\n      'Capture current metrics',\r\n      'Apply optimization',\r\n      'Monitor for 5 minutes',\r\n      'Rollback if metrics degrade',\r\n    ],\r\n    triggers: {\r\n      errorRate: 0.05,\r\n      latencyIncrease: 1.5,\r\n    },\r\n  };\r\n}\r\n\r\nfunction calculateTrend(values: number[]): number {\r\n  if (values.length < 2) return 0;\r\n  \r\n  // Simple linear regression\r\n  const n = values.length;\r\n  const sumX = values.reduce((a, _, i) => a + i, 0);\r\n  const sumY = values.reduce((a, b) => a + b, 0);\r\n  const sumXY = values.reduce((a, b, i) => a + i * b, 0);\r\n  const sumX2 = values.reduce((a, _, i) => a + i * i, 0);\r\n  \r\n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\r\n  \r\n  return slope;\r\n}\r\n\r\n// ===== Register Hooks =====\r\n\r\nexport function registerPerformanceHooks(): void {\r\n  agenticHookManager.register(performanceMetricHook);\r\n  agenticHookManager.register(performanceBottleneckHook);\r\n  agenticHookManager.register(performanceOptimizationHook);\r\n  agenticHookManager.register(performanceThresholdHook);\r\n}"],"names":["agenticHookManager","performanceMetricHook","id","type","priority","handler","payload","context","metric","value","unit","threshold","sideEffects","metricData","name","timestamp","Date","now","tags","extractTags","performance","metrics","set","undefined","violated","checkThreshold","push","action","data","event","suggestion","generateOptimizationSuggestion","optimizations","level","message","updateRollingAverages","anomaly","detectAnomaly","continue","performanceBottleneckHook","bottleneck","analysis","component","location","severity","mapSeverity","impact","suggestions","bottlenecks","key","ttl","recurrence","checkBottleneckRecurrence","count","occurrences","timespan","optimization","generateAdvancedOptimization","correlations","findMetricCorrelations","length","performanceOptimizationHook","validation","validateOptimization","valid","simulation","simulateOptimization","expectedImprovement","recommendation","autoApply","applied","risk","applyOptimization","automatic","performanceThresholdHook","historicalData","getMetricHistory","adjustedThreshold","calculateDynamicThreshold","original","adjusted","prediction","predictThresholdViolation","willViolate","confidence","currentValue","predictedTime","timeToViolation","proactiveOpt","generateProactiveOptimization","provider","model","operation","operator","thresholdOperator","metricType","getMetricType","target","implementation","avgKey","history","memory","cache","get","shift","values","map","h","mean","reduce","a","b","variance","Math","pow","stdDev","sqrt","zScore","abs","historyKey","dayAgo","recentOccurrences","filter","includes","correlation","details","reason","metadata","allowHighRisk","baseline","getBaselineMetrics","improvement","calculateRisk","affectedMetrics","identifyAffectedMetrics","rollbackPlan","generateRollbackPlan","appliedAt","appliedBy","baseThreshold","d","sort","p95","floor","max","recentValues","slice","trend","calculateTrend","min","affected","steps","triggers","errorRate","latencyIncrease","n","sumX","_","i","sumY","sumXY","sumX2","slope","registerPerformanceHooks","register"],"mappings":"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"}