{"version":3,"sources":["../../../../src/swarm/optimizations/circular-buffer.ts"],"sourcesContent":["/**\r\n * Circular Buffer Implementation\r\n * Fixed-size buffer that overwrites oldest entries when full\r\n */\r\n\r\nexport class CircularBuffer<T> {\r\n  private buffer: (T | undefined)[];\r\n  private writeIndex = 0;\r\n  private size = 0;\r\n  private totalItemsWritten = 0;\r\n\r\n  constructor(private capacity: number) {\r\n    if (capacity <= 0) {\r\n      throw new Error('Capacity must be greater than 0');\r\n    }\r\n    this.buffer = new Array(capacity);\r\n  }\r\n\r\n  push(item: T): void {\r\n    this.buffer[this.writeIndex] = item;\r\n    this.writeIndex = (this.writeIndex + 1) % this.capacity;\r\n    this.size = Math.min(this.size + 1, this.capacity);\r\n    this.totalItemsWritten++;\r\n  }\r\n\r\n  pushMany(items: T[]): void {\r\n    for (const item of items) {\r\n      this.push(item);\r\n    }\r\n  }\r\n\r\n  get(index: number): T | undefined {\r\n    if (index < 0 || index >= this.size) {\r\n      return undefined;\r\n    }\r\n\r\n    // Calculate actual buffer index based on current state\r\n    const actualIndex =\r\n      this.size < this.capacity ? index : (this.writeIndex + index) % this.capacity;\r\n\r\n    return this.buffer[actualIndex];\r\n  }\r\n\r\n  getRecent(count: number): T[] {\r\n    const result: T[] = [];\r\n    const itemsToReturn = Math.min(count, this.size);\r\n\r\n    // Calculate starting position for most recent items\r\n    const start =\r\n      this.size < this.capacity\r\n        ? Math.max(0, this.size - itemsToReturn)\r\n        : (this.writeIndex - itemsToReturn + this.capacity) % this.capacity;\r\n\r\n    for (let i = 0; i < itemsToReturn; i++) {\r\n      const index = (start + i) % this.capacity;\r\n      const item = this.buffer[index];\r\n      if (item !== undefined) {\r\n        result.push(item);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  getAll(): T[] {\r\n    const result: T[] = [];\r\n\r\n    if (this.size < this.capacity) {\r\n      // Buffer not full yet, return items in order\r\n      for (let i = 0; i < this.size; i++) {\r\n        const item = this.buffer[i];\r\n        if (item !== undefined) {\r\n          result.push(item);\r\n        }\r\n      }\r\n    } else {\r\n      // Buffer is full, start from oldest item\r\n      for (let i = 0; i < this.capacity; i++) {\r\n        const index = (this.writeIndex + i) % this.capacity;\r\n        const item = this.buffer[index];\r\n        if (item !== undefined) {\r\n          result.push(item);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  find(predicate: (item: T) => boolean): T | undefined {\r\n    const all = this.getAll();\r\n    return all.find(predicate);\r\n  }\r\n\r\n  filter(predicate: (item: T) => boolean): T[] {\r\n    const all = this.getAll();\r\n    return all.filter(predicate);\r\n  }\r\n\r\n  clear(): void {\r\n    this.buffer = new Array(this.capacity);\r\n    this.writeIndex = 0;\r\n    this.size = 0;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.size === 0;\r\n  }\r\n\r\n  isFull(): boolean {\r\n    return this.size === this.capacity;\r\n  }\r\n\r\n  getSize(): number {\r\n    return this.size;\r\n  }\r\n\r\n  getCapacity(): number {\r\n    return this.capacity;\r\n  }\r\n\r\n  getTotalItemsWritten(): number {\r\n    return this.totalItemsWritten;\r\n  }\r\n\r\n  getOverwrittenCount(): number {\r\n    return Math.max(0, this.totalItemsWritten - this.capacity);\r\n  }\r\n\r\n  /**\r\n   * Get estimated memory usage of the buffer\r\n   */\r\n  getMemoryUsage(): number {\r\n    if (this.size === 0) return 0;\r\n\r\n    // Sample first item to estimate size\r\n    const sample = this.buffer[0];\r\n    if (sample === undefined) return 0;\r\n\r\n    try {\r\n      // Rough estimation based on JSON serialization\r\n      const sampleSize = JSON.stringify(sample).length * 2; // 2 bytes per character\r\n      return sampleSize * this.size;\r\n    } catch {\r\n      // If serialization fails, return a default estimate\r\n      return this.size * 1024; // 1KB per item default\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a snapshot of the current buffer state\r\n   */\r\n  snapshot(): {\r\n    items: T[];\r\n    capacity: number;\r\n    size: number;\r\n    totalItemsWritten: number;\r\n    overwrittenCount: number;\r\n    memoryUsage: number;\r\n  } {\r\n    return {\r\n      items: this.getAll(),\r\n      capacity: this.capacity,\r\n      size: this.size,\r\n      totalItemsWritten: this.totalItemsWritten,\r\n      overwrittenCount: this.getOverwrittenCount(),\r\n      memoryUsage: this.getMemoryUsage(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Resize the buffer (creates a new buffer with the new capacity)\r\n   */\r\n  resize(newCapacity: number): void {\r\n    if (newCapacity <= 0) {\r\n      throw new Error('New capacity must be greater than 0');\r\n    }\r\n\r\n    const items = this.getAll();\r\n    this.capacity = newCapacity;\r\n    this.buffer = new Array(newCapacity);\r\n    this.writeIndex = 0;\r\n    this.size = 0;\r\n\r\n    // Re-add items (newest items will be kept if newCapacity < items.length)\r\n    const itemsToKeep = items.slice(-newCapacity);\r\n    this.pushMany(itemsToKeep);\r\n  }\r\n}\r\n"],"names":["CircularBuffer","buffer","writeIndex","size","totalItemsWritten","capacity","Error","Array","push","item","Math","min","pushMany","items","get","index","undefined","actualIndex","getRecent","count","result","itemsToReturn","start","max","i","getAll","find","predicate","all","filter","clear","isEmpty","isFull","getSize","getCapacity","getTotalItemsWritten","getOverwrittenCount","getMemoryUsage","sample","sampleSize","JSON","stringify","length","snapshot","overwrittenCount","memoryUsage","resize","newCapacity","itemsToKeep","slice"],"mappings":"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"}