{"version":3,"sources":["../../../../src/swarm/strategies/research.ts"],"sourcesContent":["/**\r\n * Optimized Research Strategy Implementation\r\n * Provides intelligent research capabilities with parallel processing,\r\n * semantic clustering, caching, and progressive refinement\r\n */\r\n\r\nimport { BaseStrategy } from './base.js';\r\nimport type { DecompositionResult, StrategyMetrics } from './base.js';\r\nimport { Logger } from '../../core/logger.js';\r\nimport { generateId } from '../../utils/helpers.js';\r\nimport {\r\n  SwarmObjective,\r\n  TaskDefinition,\r\n  TaskId,\r\n  TaskType,\r\n  TaskPriority,\r\n  SwarmConfig,\r\n  SWARM_CONSTANTS,\r\n} from '../types.js';\r\n\r\n// Research-specific interfaces\r\ninterface ResearchQuery {\r\n  id: string;\r\n  query: string;\r\n  keywords: string[];\r\n  domains: string[];\r\n  priority: number;\r\n  timestamp: Date;\r\n  sources?: string[];\r\n  filters?: ResearchFilters;\r\n}\r\n\r\ninterface ResearchFilters {\r\n  dateRange?: { start: Date; end: Date };\r\n  sourceTypes?: ('academic' | 'news' | 'blog' | 'documentation' | 'forum')[];\r\n  languages?: string[];\r\n  credibilityThreshold?: number;\r\n  maxResults?: number;\r\n}\r\n\r\ninterface ResearchResult {\r\n  id: string;\r\n  queryId: string;\r\n  url: string;\r\n  title: string;\r\n  content: string;\r\n  summary: string;\r\n  credibilityScore: number;\r\n  relevanceScore: number;\r\n  sourceType: string;\r\n  publishedDate?: Date;\r\n  extractedAt: Date;\r\n  metadata: Record<string, any>;\r\n  semanticVector?: number[];\r\n}\r\n\r\ninterface ResearchCluster {\r\n  id: string;\r\n  topic: string;\r\n  results: ResearchResult[];\r\n  centroid: number[];\r\n  coherenceScore: number;\r\n  keywords: string[];\r\n  summary: string;\r\n}\r\n\r\ninterface CacheEntry {\r\n  key: string;\r\n  data: any;\r\n  timestamp: Date;\r\n  ttl: number;\r\n  accessCount: number;\r\n  lastAccessed: Date;\r\n}\r\n\r\ninterface ConnectionPool {\r\n  active: number;\r\n  idle: number;\r\n  max: number;\r\n  timeout: number;\r\n  connections: Map<string, any>;\r\n}\r\n\r\ninterface RateLimiter {\r\n  requests: number;\r\n  windowStart: Date;\r\n  windowSize: number;\r\n  maxRequests: number;\r\n  backoffMultiplier: number;\r\n}\r\n\r\nexport class ResearchStrategy extends BaseStrategy {\r\n  private logger: Logger;\r\n  private researchCache: Map<string, CacheEntry> = new Map();\r\n  private connectionPool: ConnectionPool;\r\n  private rateLimiters: Map<string, RateLimiter> = new Map();\r\n  private semanticModel: any; // Placeholder for semantic analysis\r\n  private researchQueries: Map<string, ResearchQuery> = new Map();\r\n  private researchResults: Map<string, ResearchResult> = new Map();\r\n  private researchClusters: Map<string, ResearchCluster> = new Map();\r\n\r\n  // Research-specific metrics extending base metrics\r\n  private researchMetrics = {\r\n    queriesExecuted: 0,\r\n    resultsCollected: 0,\r\n    cacheHits: 0,\r\n    cacheMisses: 0,\r\n    averageResponseTime: 0,\r\n    credibilityScores: [] as number[],\r\n    clusteringAccuracy: 0,\r\n    parallelEfficiency: 0,\r\n  };\r\n\r\n  constructor(config: Partial<SwarmConfig> = {}) {\r\n    const defaultConfig: SwarmConfig = {\r\n      name: 'research-strategy',\r\n      description: 'Research-focused strategy',\r\n      version: '1.0.0',\r\n      mode: 'mesh',\r\n      strategy: 'research',\r\n      coordinationStrategy: {\r\n        name: 'research-coordination',\r\n        description: 'Research-optimized coordination',\r\n        agentSelection: 'capability-based',\r\n        taskScheduling: 'priority',\r\n        loadBalancing: 'work-sharing',\r\n        faultTolerance: 'retry',\r\n        communication: 'direct',\r\n      },\r\n      maxAgents: 8,\r\n      maxTasks: 50,\r\n      maxDuration: 3600000,\r\n      resourceLimits: {},\r\n      qualityThreshold: 0.8,\r\n      reviewRequired: true,\r\n      testingRequired: false,\r\n      monitoring: {\r\n        metricsEnabled: true,\r\n        loggingEnabled: true,\r\n        tracingEnabled: false,\r\n        metricsInterval: 5000,\r\n        heartbeatInterval: 10000,\r\n        healthCheckInterval: 30000,\r\n        retentionPeriod: 86400000,\r\n        maxLogSize: 1048576,\r\n        maxMetricPoints: 1000,\r\n        alertingEnabled: false,\r\n        alertThresholds: {},\r\n        exportEnabled: false,\r\n        exportFormat: 'json',\r\n        exportDestination: 'file',\r\n      },\r\n      memory: {\r\n        namespace: 'research',\r\n        partitions: [],\r\n        permissions: {\r\n          read: 'swarm',\r\n          write: 'swarm',\r\n          delete: 'team',\r\n          share: 'swarm',\r\n        },\r\n        persistent: true,\r\n        backupEnabled: false,\r\n        distributed: false,\r\n        consistency: 'eventual',\r\n        cacheEnabled: true,\r\n        compressionEnabled: false,\r\n      },\r\n      security: {\r\n        authenticationRequired: false,\r\n        authorizationRequired: false,\r\n        encryptionEnabled: false,\r\n        defaultPermissions: ['read', 'write'],\r\n        adminRoles: ['admin'],\r\n        auditEnabled: false,\r\n        auditLevel: 'info',\r\n        inputValidation: true,\r\n        outputSanitization: true,\r\n      },\r\n      performance: {\r\n        maxConcurrency: 10,\r\n        defaultTimeout: 300000,\r\n        cacheEnabled: true,\r\n        cacheSize: 100,\r\n        cacheTtl: 3600000,\r\n        optimizationEnabled: true,\r\n        adaptiveScheduling: true,\r\n        predictiveLoading: false,\r\n        resourcePooling: true,\r\n        connectionPooling: true,\r\n        memoryPooling: false,\r\n      },\r\n    };\r\n\r\n    const mergedConfig = { ...defaultConfig, ...config };\r\n    super(mergedConfig);\r\n\r\n    this.logger = new Logger(\r\n      { level: 'info', format: 'text', destination: 'console' },\r\n      { component: 'ResearchStrategy' },\r\n    );\r\n\r\n    // Initialize connection pool\r\n    this.connectionPool = {\r\n      active: 0,\r\n      idle: 0,\r\n      max: config.performance?.maxConcurrency || 10,\r\n      timeout: 30000,\r\n      connections: new Map(),\r\n    };\r\n\r\n    this.logger.info('ResearchStrategy initialized with optimizations', {\r\n      maxConcurrency: this.connectionPool.max,\r\n      cacheEnabled: config.performance?.cacheEnabled !== false,\r\n    });\r\n  }\r\n\r\n  async decomposeObjective(objective: SwarmObjective): Promise<DecompositionResult> {\r\n    this.logger.info('Decomposing research objective', {\r\n      objectiveId: objective.id,\r\n      description: objective.description,\r\n    });\r\n\r\n    const tasks: TaskDefinition[] = [];\r\n    const dependencies = new Map<string, string[]>();\r\n\r\n    // Extract research parameters from objective\r\n    const researchParams = this.extractResearchParameters(objective.description);\r\n\r\n    // Create research query planning task\r\n    const queryPlanningTask = this.createResearchTask(\r\n      'query-planning',\r\n      'research',\r\n      'Research Query Planning',\r\n      `Analyze the research objective and create optimized search queries:\r\n\r\n${objective.description}\r\n\r\nCreate a comprehensive research plan that includes:\r\n1. Primary and secondary research questions\r\n2. Key search terms and synonyms\r\n3. Relevant domains and sources to explore\r\n4. Research methodology and approach\r\n5. Quality criteria for evaluating sources\r\n\r\nFocus on creating queries that will yield high-quality, credible results.`,\r\n      {\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: 5 * 60 * 1000, // 5 minutes\r\n        requiredCapabilities: ['research', 'analysis'],\r\n        researchParams,\r\n      },\r\n    );\r\n    tasks.push(queryPlanningTask);\r\n\r\n    // Create parallel web search tasks\r\n    const webSearchTask = this.createResearchTask(\r\n      'web-search',\r\n      'research',\r\n      'Parallel Web Search Execution',\r\n      `Execute parallel web searches based on the research plan:\r\n\r\n${objective.description}\r\n\r\nPerform comprehensive web searches using:\r\n1. Multiple search engines and sources\r\n2. Parallel query execution for efficiency\r\n3. Intelligent source ranking and filtering\r\n4. Real-time credibility assessment\r\n5. Deduplication of results\r\n\r\nCollect diverse, high-quality sources relevant to the research objective.`,\r\n      {\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: 10 * 60 * 1000, // 10 minutes\r\n        requiredCapabilities: ['web-search', 'research'],\r\n        dependencies: [queryPlanningTask.id.id],\r\n        researchParams,\r\n      },\r\n    );\r\n    tasks.push(webSearchTask);\r\n    dependencies.set(webSearchTask.id.id, [queryPlanningTask.id.id]);\r\n\r\n    // Create data extraction and processing task\r\n    const dataExtractionTask = this.createResearchTask(\r\n      'data-extraction',\r\n      'analysis',\r\n      'Parallel Data Extraction',\r\n      `Extract and process data from collected sources:\r\n\r\n${objective.description}\r\n\r\nProcess the collected sources by:\r\n1. Extracting key information and insights\r\n2. Performing semantic analysis and clustering\r\n3. Identifying patterns and relationships\r\n4. Assessing information quality and reliability\r\n5. Creating structured summaries\r\n\r\nUse parallel processing for efficient data extraction.`,\r\n      {\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: 8 * 60 * 1000, // 8 minutes\r\n        requiredCapabilities: ['analysis', 'research'],\r\n        dependencies: [webSearchTask.id.id],\r\n        researchParams,\r\n      },\r\n    );\r\n    tasks.push(dataExtractionTask);\r\n    dependencies.set(dataExtractionTask.id.id, [webSearchTask.id.id]);\r\n\r\n    // Create semantic clustering task\r\n    const clusteringTask = this.createResearchTask(\r\n      'semantic-clustering',\r\n      'analysis',\r\n      'Semantic Clustering and Analysis',\r\n      `Perform semantic clustering of research findings:\r\n\r\n${objective.description}\r\n\r\nAnalyze the extracted data by:\r\n1. Grouping related information using semantic similarity\r\n2. Identifying key themes and topics\r\n3. Creating coherent clusters of information\r\n4. Generating cluster summaries and insights\r\n5. Mapping relationships between clusters\r\n\r\nProvide a structured analysis of the research findings.`,\r\n      {\r\n        priority: 'medium' as TaskPriority,\r\n        estimatedDuration: 6 * 60 * 1000, // 6 minutes\r\n        requiredCapabilities: ['analysis', 'research'],\r\n        dependencies: [dataExtractionTask.id.id],\r\n        researchParams,\r\n      },\r\n    );\r\n    tasks.push(clusteringTask);\r\n    dependencies.set(clusteringTask.id.id, [dataExtractionTask.id.id]);\r\n\r\n    // Create synthesis and reporting task\r\n    const synthesisTask = this.createResearchTask(\r\n      'synthesis-reporting',\r\n      'documentation',\r\n      'Research Synthesis and Reporting',\r\n      `Synthesize research findings into comprehensive report:\r\n\r\n${objective.description}\r\n\r\nCreate a comprehensive research report that includes:\r\n1. Executive summary of key findings\r\n2. Detailed analysis of each research cluster\r\n3. Insights and recommendations\r\n4. Source credibility assessment\r\n5. Methodology and limitations\r\n6. References and citations\r\n\r\nEnsure the report is well-structured and actionable.`,\r\n      {\r\n        priority: 'medium' as TaskPriority,\r\n        estimatedDuration: 7 * 60 * 1000, // 7 minutes\r\n        requiredCapabilities: ['documentation', 'analysis'],\r\n        dependencies: [clusteringTask.id.id],\r\n        researchParams,\r\n      },\r\n    );\r\n    tasks.push(synthesisTask);\r\n    dependencies.set(synthesisTask.id.id, [clusteringTask.id.id]);\r\n\r\n    const totalDuration = tasks.reduce(\r\n      (sum, task) => sum + (task.constraints.timeoutAfter || 0),\r\n      0,\r\n    );\r\n\r\n    this.logger.info('Research objective decomposed', {\r\n      objectiveId: objective.id,\r\n      taskCount: tasks.length,\r\n      estimatedDuration: totalDuration,\r\n      parallelTasks: tasks.filter((t) => !dependencies.has(t.id.id)).length,\r\n    });\r\n\r\n    return {\r\n      tasks,\r\n      dependencies,\r\n      estimatedDuration: totalDuration,\r\n      recommendedStrategy: 'research',\r\n      complexity: this.estimateComplexity(objective.description),\r\n      batchGroups: this.createTaskBatches(tasks, dependencies),\r\n      timestamp: new Date(),\r\n      ttl: 3600000, // 1 hour\r\n      accessCount: 0,\r\n      lastAccessed: new Date(),\r\n      data: { objectiveId: objective.id, description: objective.description },\r\n      resourceRequirements: {\r\n        memory: SWARM_CONSTANTS.DEFAULT_MEMORY_LIMIT * 1.5,\r\n        cpu: SWARM_CONSTANTS.DEFAULT_CPU_LIMIT * 1.2,\r\n        network: 'high',\r\n        storage: 'medium',\r\n      },\r\n    };\r\n  }\r\n\r\n  // Research-specific optimizations for task execution\r\n  async optimizeTaskExecution(task: TaskDefinition, agent: any): Promise<any> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Apply research-specific optimizations based on task type\r\n      switch (task.type) {\r\n        case 'research':\r\n          return await this.executeOptimizedWebSearch(task, agent);\r\n        case 'analysis':\r\n          return await this.executeOptimizedDataExtraction(task, agent);\r\n        default:\r\n          return await this.executeGenericResearchTask(task, agent);\r\n      }\r\n    } finally {\r\n      const duration = Date.now() - startTime;\r\n      this.updateResearchMetrics(task.type, duration);\r\n    }\r\n  }\r\n\r\n  private async executeOptimizedWebSearch(task: TaskDefinition, agent: any): Promise<any> {\r\n    this.logger.info('Executing optimized web search', { taskId: task.id.id });\r\n\r\n    // Check cache first\r\n    const cacheKey = this.generateCacheKey('web-search', task.description);\r\n    const cached = this.getFromCache(cacheKey);\r\n    if (cached) {\r\n      this.researchMetrics.cacheHits++;\r\n      return cached;\r\n    }\r\n\r\n    // Execute parallel web searches with rate limiting\r\n    const queries = this.generateSearchQueries(task.description);\r\n    const searchPromises = queries.map((query) => this.executeRateLimitedSearch(query, agent));\r\n\r\n    const results = await Promise.allSettled(searchPromises);\r\n    const successfulResults = results\r\n      .filter((r) => r.status === 'fulfilled')\r\n      .map((r) => (r as PromiseFulfilledResult<any>).value)\r\n      .flat();\r\n\r\n    // Rank and filter results by credibility\r\n    const rankedResults = await this.rankResultsByCredibility(successfulResults);\r\n\r\n    // Cache results\r\n    this.setCache(cacheKey, rankedResults, 3600000); // 1 hour TTL\r\n    this.researchMetrics.cacheMisses++;\r\n\r\n    return {\r\n      results: rankedResults,\r\n      totalFound: successfulResults.length,\r\n      queriesExecuted: queries.length,\r\n      credibilityScores: rankedResults.map((r) => r.credibilityScore),\r\n    };\r\n  }\r\n\r\n  private async executeOptimizedDataExtraction(task: TaskDefinition, agent: any): Promise<any> {\r\n    this.logger.info('Executing optimized data extraction', { taskId: task.id.id });\r\n\r\n    // Get connection from pool\r\n    const connection = await this.getPooledConnection();\r\n\r\n    try {\r\n      // Parallel data extraction with deduplication\r\n      const extractionPromises = this.createParallelExtractionTasks(task, agent);\r\n      const extractedData = await Promise.all(extractionPromises);\r\n\r\n      // Deduplicate results\r\n      const deduplicatedData = this.deduplicateResults(extractedData.flat());\r\n\r\n      return {\r\n        extractedData: deduplicatedData,\r\n        totalExtracted: extractedData.flat().length,\r\n        uniqueResults: deduplicatedData.length,\r\n        deduplicationRate: 1 - deduplicatedData.length / extractedData.flat().length,\r\n      };\r\n    } finally {\r\n      this.releasePooledConnection(connection);\r\n    }\r\n  }\r\n\r\n  private async executeOptimizedClustering(task: TaskDefinition, agent: any): Promise<any> {\r\n    this.logger.info('Executing optimized semantic clustering', { taskId: task.id.id });\r\n\r\n    // Implement semantic clustering with caching\r\n    const data = task.input?.extractedData || [];\r\n    const cacheKey = this.generateCacheKey('clustering', JSON.stringify(data));\r\n\r\n    const cached = this.getFromCache(cacheKey);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    // Perform semantic clustering\r\n    const clusters = await this.performSemanticClustering(data);\r\n\r\n    // Cache clustering results\r\n    this.setCache(cacheKey, clusters, 7200000); // 2 hours TTL\r\n\r\n    return {\r\n      clusters,\r\n      clusterCount: clusters.length,\r\n      averageClusterSize: clusters.reduce((sum, c) => sum + c.results.length, 0) / clusters.length,\r\n      coherenceScore: clusters.reduce((sum, c) => sum + c.coherenceScore, 0) / clusters.length,\r\n    };\r\n  }\r\n\r\n  private async executeGenericResearchTask(task: TaskDefinition, agent: any): Promise<any> {\r\n    this.logger.info('Executing generic research task', { taskId: task.id.id });\r\n\r\n    // Apply general research optimizations\r\n    return {\r\n      status: 'completed',\r\n      optimizations: ['caching', 'rate-limiting', 'connection-pooling'],\r\n      executionTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  // Helper methods for research optimizations\r\n\r\n  private extractResearchParameters(description: string): any {\r\n    return {\r\n      domains: this.extractDomains(description),\r\n      keywords: this.extractKeywords(description),\r\n      timeframe: this.extractTimeframe(description),\r\n      sourceTypes: this.extractSourceTypes(description),\r\n    };\r\n  }\r\n\r\n  private extractDomains(description: string): string[] {\r\n    // Extract relevant domains from description\r\n    const domains = [];\r\n    if (description.includes('academic') || description.includes('research'))\r\n      domains.push('academic');\r\n    if (description.includes('news') || description.includes('current')) domains.push('news');\r\n    if (description.includes('technical') || description.includes('documentation'))\r\n      domains.push('technical');\r\n    return domains.length > 0 ? domains : ['general'];\r\n  }\r\n\r\n  private extractKeywords(description: string): string[] {\r\n    // Simple keyword extraction - in production, use NLP\r\n    return description\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter((word) => word.length > 3)\r\n      .slice(0, 10);\r\n  }\r\n\r\n  private extractTimeframe(description: string): any {\r\n    // Extract time-related constraints\r\n    const now = new Date();\r\n    return {\r\n      start: new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000), // 1 year ago\r\n      end: now,\r\n    };\r\n  }\r\n\r\n  private extractSourceTypes(description: string): string[] {\r\n    return ['academic', 'news', 'documentation', 'blog'];\r\n  }\r\n\r\n  private generateSearchQueries(description: string): ResearchQuery[] {\r\n    const baseQuery = description.substring(0, 100);\r\n    const keywords = this.extractKeywords(description);\r\n\r\n    return [\r\n      {\r\n        id: generateId('query'),\r\n        query: baseQuery,\r\n        keywords: keywords.slice(0, 5),\r\n        domains: ['general'],\r\n        priority: 1,\r\n        timestamp: new Date(),\r\n      },\r\n      {\r\n        id: generateId('query'),\r\n        query: `${baseQuery} research study`,\r\n        keywords: [...keywords.slice(0, 3), 'research', 'study'],\r\n        domains: ['academic'],\r\n        priority: 2,\r\n        timestamp: new Date(),\r\n      },\r\n      {\r\n        id: generateId('query'),\r\n        query: `${baseQuery} best practices`,\r\n        keywords: [...keywords.slice(0, 3), 'best', 'practices'],\r\n        domains: ['technical'],\r\n        priority: 2,\r\n        timestamp: new Date(),\r\n      },\r\n    ];\r\n  }\r\n\r\n  private async executeRateLimitedSearch(\r\n    query: ResearchQuery,\r\n    agent: any,\r\n  ): Promise<ResearchResult[]> {\r\n    const domain = query.domains[0] || 'general';\r\n\r\n    // Check rate limits\r\n    if (!this.checkRateLimit(domain)) {\r\n      await this.waitForRateLimit(domain);\r\n    }\r\n\r\n    // Simulate web search with retry logic\r\n    let attempts = 0;\r\n    const maxAttempts = 3;\r\n\r\n    while (attempts < maxAttempts) {\r\n      try {\r\n        // Simulate search execution\r\n        const results = await this.simulateWebSearch(query);\r\n        this.updateRateLimit(domain);\r\n        return results;\r\n      } catch (error) {\r\n        attempts++;\r\n        if (attempts >= maxAttempts) throw error;\r\n        await this.exponentialBackoff(attempts);\r\n      }\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  private async simulateWebSearch(query: ResearchQuery): Promise<ResearchResult[]> {\r\n    // Simulate web search results\r\n    const resultCount = Math.floor(Math.random() * 10) + 5;\r\n    const results: ResearchResult[] = [];\r\n\r\n    for (let i = 0; i < resultCount; i++) {\r\n      results.push({\r\n        id: generateId('result'),\r\n        queryId: query.id,\r\n        url: `https://example.com/result-${i}`,\r\n        title: `Research Result ${i} for ${query.query}`,\r\n        content: `Content for ${query.query} - result ${i}`,\r\n        summary: `Summary of result ${i}`,\r\n        credibilityScore: Math.random() * 0.4 + 0.6, // 0.6-1.0\r\n        relevanceScore: Math.random() * 0.3 + 0.7, // 0.7-1.0\r\n        sourceType: query.domains[0] || 'general',\r\n        extractedAt: new Date(),\r\n        metadata: { queryKeywords: query.keywords },\r\n      });\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  private async rankResultsByCredibility(results: ResearchResult[]): Promise<ResearchResult[]> {\r\n    // Sort by combined credibility and relevance score\r\n    return results.sort((a, b) => {\r\n      const scoreA = a.credibilityScore * 0.6 + a.relevanceScore * 0.4;\r\n      const scoreB = b.credibilityScore * 0.6 + b.relevanceScore * 0.4;\r\n      return scoreB - scoreA;\r\n    });\r\n  }\r\n\r\n  private createParallelExtractionTasks(task: TaskDefinition, agent: any): Promise<any>[] {\r\n    // Create parallel extraction tasks\r\n    const results = task.input?.results || [];\r\n    const batchSize = Math.ceil(results.length / this.connectionPool.max);\r\n    const batches = [];\r\n\r\n    for (let i = 0; i < results.length; i += batchSize) {\r\n      const batch = results.slice(i, i + batchSize);\r\n      batches.push(this.extractDataFromBatch(batch));\r\n    }\r\n\r\n    return batches;\r\n  }\r\n\r\n  private async extractDataFromBatch(batch: ResearchResult[]): Promise<any[]> {\r\n    // Simulate parallel data extraction\r\n    return batch.map((result) => ({\r\n      id: result.id,\r\n      extractedData: `Extracted data from ${result.title}`,\r\n      insights: [`Insight 1 from ${result.title}`, `Insight 2 from ${result.title}`],\r\n      metadata: result.metadata,\r\n    }));\r\n  }\r\n\r\n  private deduplicateResults(results: any[]): any[] {\r\n    const seen = new Set();\r\n    return results.filter((result) => {\r\n      const key = result.extractedData || result.id;\r\n      if (seen.has(key)) return false;\r\n      seen.add(key);\r\n      return true;\r\n    });\r\n  }\r\n\r\n  private async performSemanticClustering(data: any[]): Promise<ResearchCluster[]> {\r\n    // Simulate semantic clustering\r\n    const clusterCount = Math.min(Math.ceil(data.length / 5), 10);\r\n    const clusters: ResearchCluster[] = [];\r\n\r\n    for (let i = 0; i < clusterCount; i++) {\r\n      const clusterData = data.slice(i * 5, (i + 1) * 5);\r\n      clusters.push({\r\n        id: generateId('cluster'),\r\n        topic: `Research Topic ${i + 1}`,\r\n        results: clusterData,\r\n        centroid: Array(10)\r\n          .fill(0)\r\n          .map(() => Math.random()),\r\n        coherenceScore: Math.random() * 0.3 + 0.7,\r\n        keywords: [`keyword${i}1`, `keyword${i}2`],\r\n        summary: `Summary of cluster ${i + 1}`,\r\n      });\r\n    }\r\n\r\n    return clusters;\r\n  }\r\n\r\n  // Connection pooling methods\r\n  private async getPooledConnection(): Promise<any> {\r\n    if (this.connectionPool.active >= this.connectionPool.max) {\r\n      await this.waitForConnection();\r\n    }\r\n\r\n    this.connectionPool.active++;\r\n    return { id: generateId('connection'), timestamp: new Date() };\r\n  }\r\n\r\n  private releasePooledConnection(connection: any): void {\r\n    this.connectionPool.active--;\r\n    this.connectionPool.idle++;\r\n  }\r\n\r\n  private async waitForConnection(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      const checkConnection = () => {\r\n        if (this.connectionPool.active < this.connectionPool.max) {\r\n          resolve();\r\n        } else {\r\n          setTimeout(checkConnection, 100);\r\n        }\r\n      };\r\n      checkConnection();\r\n    });\r\n  }\r\n\r\n  // Rate limiting methods\r\n  private checkRateLimit(domain: string): boolean {\r\n    const limiter = this.rateLimiters.get(domain);\r\n    if (!limiter) {\r\n      this.rateLimiters.set(domain, {\r\n        requests: 0,\r\n        windowStart: new Date(),\r\n        windowSize: 60000, // 1 minute\r\n        maxRequests: 10,\r\n        backoffMultiplier: 1,\r\n      });\r\n      return true;\r\n    }\r\n\r\n    const now = new Date();\r\n    if (now.getTime() - limiter.windowStart.getTime() > limiter.windowSize) {\r\n      limiter.requests = 0;\r\n      limiter.windowStart = now;\r\n    }\r\n\r\n    return limiter.requests < limiter.maxRequests;\r\n  }\r\n\r\n  private updateRateLimit(domain: string): void {\r\n    const limiter = this.rateLimiters.get(domain);\r\n    if (limiter) {\r\n      limiter.requests++;\r\n    }\r\n  }\r\n\r\n  private async waitForRateLimit(domain: string): Promise<void> {\r\n    const limiter = this.rateLimiters.get(domain);\r\n    if (!limiter) return;\r\n\r\n    const waitTime = limiter.windowSize * limiter.backoffMultiplier;\r\n    await new Promise((resolve) => setTimeout(resolve, waitTime));\r\n  }\r\n\r\n  private async exponentialBackoff(attempt: number): Promise<void> {\r\n    const delay = Math.pow(2, attempt) * 1000;\r\n    await new Promise((resolve) => setTimeout(resolve, delay));\r\n  }\r\n\r\n  // Caching methods\r\n  private generateCacheKey(type: string, data: string): string {\r\n    return `${type}:${Buffer.from(data).toString('base64').substring(0, 32)}`;\r\n  }\r\n\r\n  private getFromCache(key: string): any | null {\r\n    const entry = this.researchCache.get(key);\r\n    if (!entry) return null;\r\n\r\n    const now = new Date();\r\n    if (now.getTime() - entry.timestamp.getTime() > entry.ttl) {\r\n      this.researchCache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    entry.accessCount++;\r\n    entry.lastAccessed = now;\r\n    return entry.data;\r\n  }\r\n\r\n  private setCache(key: string, data: any, ttl: number): void {\r\n    this.researchCache.set(key, {\r\n      key,\r\n      data,\r\n      timestamp: new Date(),\r\n      ttl,\r\n      accessCount: 0,\r\n      lastAccessed: new Date(),\r\n    });\r\n\r\n    // Cleanup old entries if cache is too large\r\n    if (this.researchCache.size > 1000) {\r\n      this.cleanupCache();\r\n    }\r\n  }\r\n\r\n  private cleanupCache(): void {\r\n    const entries = Array.from(this.researchCache.entries());\r\n    entries.sort((a, b) => a[1].lastAccessed.getTime() - b[1].lastAccessed.getTime());\r\n\r\n    // Remove oldest 20% of entries\r\n    const toRemove = Math.floor(entries.length * 0.2);\r\n    for (let i = 0; i < toRemove; i++) {\r\n      this.researchCache.delete(entries[i][0]);\r\n    }\r\n  }\r\n\r\n  private createResearchTask(\r\n    id: string,\r\n    type: TaskType,\r\n    name: string,\r\n    instructions: string,\r\n    options: any = {},\r\n  ): TaskDefinition {\r\n    const taskId: TaskId = {\r\n      id: generateId('task'),\r\n      swarmId: 'research-swarm',\r\n      sequence: 1,\r\n      priority: 1,\r\n    };\r\n\r\n    return {\r\n      id: taskId,\r\n      type,\r\n      name,\r\n      description: instructions,\r\n      instructions,\r\n      requirements: {\r\n        capabilities: options.requiredCapabilities || ['research'],\r\n        tools: ['WebFetchTool', 'WebSearch'],\r\n        permissions: ['read', 'write'],\r\n      },\r\n      constraints: {\r\n        dependencies: options.dependencies || [],\r\n        dependents: [],\r\n        conflicts: [],\r\n        maxRetries: 3,\r\n        timeoutAfter: options.estimatedDuration || 300000,\r\n      },\r\n      priority: options.priority || 'medium',\r\n      input: options.researchParams || {},\r\n      context: {},\r\n      examples: [],\r\n      status: 'created',\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      attempts: [],\r\n      statusHistory: [\r\n        {\r\n          timestamp: new Date(),\r\n          from: 'created',\r\n          to: 'created',\r\n          reason: 'Task created',\r\n          triggeredBy: 'system',\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  private updateResearchMetrics(taskType: string, duration: number): void {\r\n    this.researchMetrics.queriesExecuted++;\r\n    this.researchMetrics.averageResponseTime =\r\n      (this.researchMetrics.averageResponseTime + duration) / 2;\r\n  }\r\n\r\n  private createTaskBatches(tasks: TaskDefinition[], dependencies: Map<string, string[]>): any[] {\r\n    const batches: any[] = [];\r\n    const processed = new Set<string>();\r\n    let batchIndex = 0;\r\n\r\n    while (processed.size < tasks.length) {\r\n      const batchTasks = tasks.filter(\r\n        (task) =>\r\n          !processed.has(task.id.id) &&\r\n          task.constraints.dependencies.every((dep) => processed.has(dep.id)),\r\n      );\r\n\r\n      if (batchTasks.length === 0) break; // Prevent infinite loop\r\n\r\n      const batch = {\r\n        id: `research-batch-${batchIndex++}`,\r\n        tasks: batchTasks,\r\n        canRunInParallel: batchTasks.length > 1,\r\n        estimatedDuration: Math.max(...batchTasks.map((t) => t.constraints.timeoutAfter || 0)),\r\n        requiredResources: {\r\n          agents: batchTasks.length,\r\n          memory: batchTasks.length * 512, // MB\r\n          cpu: batchTasks.length * 0.5, // CPU cores\r\n        },\r\n      };\r\n\r\n      batches.push(batch);\r\n      batchTasks.forEach((task) => processed.add(task.id.id));\r\n    }\r\n\r\n    return batches;\r\n  }\r\n\r\n  // Public API for metrics\r\n  override getMetrics() {\r\n    const credibilityScoresRecord: Record<string, number> = {};\r\n    this.researchMetrics.credibilityScores.forEach((score, index) => {\r\n      credibilityScoresRecord[`result_${index}`] = score;\r\n    });\r\n\r\n    return {\r\n      ...this.metrics,\r\n      queriesExecuted: this.researchMetrics.queriesExecuted,\r\n      averageResponseTime: this.researchMetrics.averageResponseTime,\r\n      cacheHits: this.researchMetrics.cacheHits,\r\n      cacheMisses: this.researchMetrics.cacheMisses,\r\n      credibilityScores: credibilityScoresRecord,\r\n      cacheHitRate:\r\n        this.researchMetrics.cacheHits /\r\n        (this.researchMetrics.cacheHits + this.researchMetrics.cacheMisses || 1),\r\n      averageCredibilityScore:\r\n        this.researchMetrics.credibilityScores.length > 0\r\n          ? this.researchMetrics.credibilityScores.reduce((a, b) => a + b, 0) /\r\n            this.researchMetrics.credibilityScores.length\r\n          : 0,\r\n      connectionPoolUtilization: this.connectionPool.active / this.connectionPool.max,\r\n      cacheSize: this.researchCache.size,\r\n    };\r\n  }\r\n\r\n  // Progressive refinement methods\r\n  async refineResearchScope(\r\n    objective: SwarmObjective,\r\n    intermediateResults: any[],\r\n  ): Promise<SwarmObjective> {\r\n    this.logger.info('Refining research scope based on intermediate results', {\r\n      objectiveId: objective.id,\r\n      resultsCount: intermediateResults.length,\r\n    });\r\n\r\n    // Analyze intermediate results to refine scope\r\n    const refinedObjective = { ...objective };\r\n\r\n    // Update requirements based on findings\r\n    if (intermediateResults.length > 0) {\r\n      const avgCredibility =\r\n        intermediateResults.map((r) => r.credibilityScore || 0.5).reduce((a, b) => a + b, 0) /\r\n        intermediateResults.length;\r\n\r\n      if (avgCredibility < 0.7) {\r\n        refinedObjective.requirements.qualityThreshold = Math.max(\r\n          refinedObjective.requirements.qualityThreshold,\r\n          0.8,\r\n        );\r\n      }\r\n    }\r\n\r\n    return refinedObjective;\r\n  }\r\n\r\n  // Implementation of abstract methods from BaseStrategy\r\n  async selectAgentForTask(task: TaskDefinition, availableAgents: any[]): Promise<string | null> {\r\n    if (availableAgents.length === 0) return null;\r\n\r\n    // Research-specific agent selection logic\r\n    let bestAgent = null;\r\n    let bestScore = 0;\r\n\r\n    for (const agent of availableAgents) {\r\n      let score = 0;\r\n\r\n      // Check for research capabilities\r\n      if (agent.capabilities?.research) score += 0.4;\r\n      if (agent.capabilities?.webSearch) score += 0.3;\r\n      if (agent.capabilities?.analysis) score += 0.2;\r\n\r\n      // Check for specific research task types\r\n      if (task.type === 'research' && agent.type === 'researcher') score += 0.3;\r\n      if (task.type === 'analysis' && agent.type === 'analyst') score += 0.3;\r\n      if (task.type === 'research' && agent.capabilities?.webSearch) score += 0.4;\r\n\r\n      // Consider current workload\r\n      score *= 1 - (agent.workload || 0);\r\n\r\n      if (score > bestScore) {\r\n        bestScore = score;\r\n        bestAgent = agent;\r\n      }\r\n    }\r\n\r\n    return bestAgent?.id?.id || null;\r\n  }\r\n\r\n  async optimizeTaskSchedule(tasks: TaskDefinition[], agents: any[]): Promise<any[]> {\r\n    const allocations: any[] = [];\r\n\r\n    // Group tasks by type for optimal allocation\r\n    const researchTasks = tasks.filter((t) => t.type === 'research');\r\n    const analysisTasks = tasks.filter((t) => t.type === 'analysis');\r\n    const otherTasks = tasks.filter((t) => !['research', 'analysis'].includes(t.type as string));\r\n\r\n    for (const agent of agents) {\r\n      const allocation = {\r\n        agentId: agent.id?.id || agent.id,\r\n        tasks: [] as string[],\r\n        estimatedWorkload: 0,\r\n        capabilities: this.getAgentCapabilitiesList(agent),\r\n      };\r\n\r\n      // Allocate tasks based on agent capabilities\r\n      if (agent.type === 'researcher' && researchTasks.length > 0) {\r\n        const task = researchTasks.shift();\r\n        if (task) {\r\n          allocation.tasks.push(task.id.id);\r\n          allocation.estimatedWorkload += 0.3;\r\n        }\r\n      }\r\n\r\n      if (agent.type === 'analyst' && analysisTasks.length > 0) {\r\n        const task = analysisTasks.shift();\r\n        if (task) {\r\n          allocation.tasks.push(task.id.id);\r\n          allocation.estimatedWorkload += 0.3;\r\n        }\r\n      }\r\n\r\n      // Web search tasks are handled as research tasks\r\n\r\n      // Allocate remaining tasks\r\n      if (allocation.tasks.length === 0 && otherTasks.length > 0) {\r\n        const task = otherTasks.shift();\r\n        if (task) {\r\n          allocation.tasks.push(task.id.id);\r\n          allocation.estimatedWorkload += 0.2;\r\n        }\r\n      }\r\n\r\n      if (allocation.tasks.length > 0) {\r\n        allocations.push(allocation);\r\n      }\r\n    }\r\n\r\n    return allocations;\r\n  }\r\n\r\n  private getAgentCapabilitiesList(agent: any): string[] {\r\n    const caps: string[] = [];\r\n    if (agent.capabilities) {\r\n      if (agent.capabilities.research) caps.push('research');\r\n      if (agent.capabilities.webSearch) caps.push('web-search');\r\n      if (agent.capabilities.analysis) caps.push('analysis');\r\n      if (agent.capabilities.codeGeneration) caps.push('code-generation');\r\n      if (agent.capabilities.documentation) caps.push('documentation');\r\n    }\r\n    return caps;\r\n  }\r\n}\r\n"],"names":["BaseStrategy","Logger","generateId","SWARM_CONSTANTS","ResearchStrategy","logger","researchCache","Map","connectionPool","rateLimiters","semanticModel","researchQueries","researchResults","researchClusters","researchMetrics","queriesExecuted","resultsCollected","cacheHits","cacheMisses","averageResponseTime","credibilityScores","clusteringAccuracy","parallelEfficiency","config","defaultConfig","name","description","version","mode","strategy","coordinationStrategy","agentSelection","taskScheduling","loadBalancing","faultTolerance","communication","maxAgents","maxTasks","maxDuration","resourceLimits","qualityThreshold","reviewRequired","testingRequired","monitoring","metricsEnabled","loggingEnabled","tracingEnabled","metricsInterval","heartbeatInterval","healthCheckInterval","retentionPeriod","maxLogSize","maxMetricPoints","alertingEnabled","alertThresholds","exportEnabled","exportFormat","exportDestination","memory","namespace","partitions","permissions","read","write","delete","share","persistent","backupEnabled","distributed","consistency","cacheEnabled","compressionEnabled","security","authenticationRequired","authorizationRequired","encryptionEnabled","defaultPermissions","adminRoles","auditEnabled","auditLevel","inputValidation","outputSanitization","performance","maxConcurrency","defaultTimeout","cacheSize","cacheTtl","optimizationEnabled","adaptiveScheduling","predictiveLoading","resourcePooling","connectionPooling","memoryPooling","mergedConfig","level","format","destination","component","active","idle","max","timeout","connections","info","decomposeObjective","objective","objectiveId","id","tasks","dependencies","researchParams","extractResearchParameters","queryPlanningTask","createResearchTask","priority","estimatedDuration","requiredCapabilities","push","webSearchTask","set","dataExtractionTask","clusteringTask","synthesisTask","totalDuration","reduce","sum","task","constraints","timeoutAfter","taskCount","length","parallelTasks","filter","t","has","recommendedStrategy","complexity","estimateComplexity","batchGroups","createTaskBatches","timestamp","Date","ttl","accessCount","lastAccessed","data","resourceRequirements","DEFAULT_MEMORY_LIMIT","cpu","DEFAULT_CPU_LIMIT","network","storage","optimizeTaskExecution","agent","startTime","now","type","executeOptimizedWebSearch","executeOptimizedDataExtraction","executeGenericResearchTask","duration","updateResearchMetrics","taskId","cacheKey","generateCacheKey","cached","getFromCache","queries","generateSearchQueries","searchPromises","map","query","executeRateLimitedSearch","results","Promise","allSettled","successfulResults","r","status","value","flat","rankedResults","rankResultsByCredibility","setCache","totalFound","credibilityScore","connection","getPooledConnection","extractionPromises","createParallelExtractionTasks","extractedData","all","deduplicatedData","deduplicateResults","totalExtracted","uniqueResults","deduplicationRate","releasePooledConnection","executeOptimizedClustering","input","JSON","stringify","clusters","performSemanticClustering","clusterCount","averageClusterSize","c","coherenceScore","optimizations","executionTime","domains","extractDomains","keywords","extractKeywords","timeframe","extractTimeframe","sourceTypes","extractSourceTypes","includes","toLowerCase","split","word","slice","start","getTime","end","baseQuery","substring","domain","checkRateLimit","waitForRateLimit","attempts","maxAttempts","simulateWebSearch","updateRateLimit","error","exponentialBackoff","resultCount","Math","floor","random","i","queryId","url","title","content","summary","relevanceScore","sourceType","extractedAt","metadata","queryKeywords","sort","a","b","scoreA","scoreB","batchSize","ceil","batches","batch","extractDataFromBatch","result","insights","seen","Set","key","add","min","clusterData","topic","centroid","Array","fill","waitForConnection","resolve","checkConnection","setTimeout","limiter","get","requests","windowStart","windowSize","maxRequests","backoffMultiplier","waitTime","attempt","delay","pow","Buffer","from","toString","entry","size","cleanupCache","entries","toRemove","instructions","options","swarmId","sequence","requirements","capabilities","tools","dependents","conflicts","maxRetries","context","examples","createdAt","updatedAt","statusHistory","to","reason","triggeredBy","taskType","processed","batchIndex","batchTasks","every","dep","canRunInParallel","requiredResources","agents","forEach","getMetrics","credibilityScoresRecord","score","index","metrics","cacheHitRate","averageCredibilityScore","connectionPoolUtilization","refineResearchScope","intermediateResults","resultsCount","refinedObjective","avgCredibility","selectAgentForTask","availableAgents","bestAgent","bestScore","research","webSearch","analysis","workload","optimizeTaskSchedule","allocations","researchTasks","analysisTasks","otherTasks","allocation","agentId","estimatedWorkload","getAgentCapabilitiesList","shift","caps","codeGeneration","documentation"],"mappings":"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"}