{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/types.ts"],"sourcesContent":["/**\r\n * Agentic Flow Hook System Type Definitions\r\n * \r\n * This module defines the comprehensive hook system for integrating\r\n * agentic-flow with Claude Flow's existing infrastructure.\r\n */\r\n\r\nimport type { HookType, HookResult } from '../../cli/commands/hook-types.js';\r\n\r\n// ===== Core Hook Types =====\r\n\r\nexport interface AgenticHookContext {\r\n  sessionId: string;\r\n  timestamp: number;\r\n  correlationId: string;\r\n  metadata: Record<string, any>;\r\n  memory: MemoryContext;\r\n  neural: NeuralContext;\r\n  performance: PerformanceContext;\r\n}\r\n\r\nexport interface MemoryContext {\r\n  namespace: string;\r\n  provider: string;\r\n  ttl?: number;\r\n  cache: Map<string, any>;\r\n}\r\n\r\nexport interface NeuralContext {\r\n  modelId: string;\r\n  patterns: PatternStore;\r\n  training: TrainingState;\r\n}\r\n\r\nexport interface PerformanceContext {\r\n  metrics: Map<string, PerformanceMetric>;\r\n  bottlenecks: BottleneckAnalysis[];\r\n  optimizations: OptimizationSuggestion[];\r\n}\r\n\r\n// ===== LLM Hook Types =====\r\n\r\nexport type LLMHookType = \r\n  | 'pre-llm-call'\r\n  | 'post-llm-call'\r\n  | 'llm-error'\r\n  | 'llm-retry'\r\n  | 'llm-fallback'\r\n  | 'llm-cache-hit'\r\n  | 'llm-cache-miss';\r\n\r\nexport interface LLMHookPayload {\r\n  provider: string;\r\n  model: string;\r\n  operation: 'completion' | 'embedding' | 'function-call' | 'vision';\r\n  request: LLMRequest;\r\n  response?: LLMResponse;\r\n  error?: Error;\r\n  metrics?: LLMMetrics;\r\n}\r\n\r\nexport interface LLMRequest {\r\n  messages?: Array<{\r\n    role: 'system' | 'user' | 'assistant' | 'function';\r\n    content: string;\r\n    name?: string;\r\n  }>;\r\n  prompt?: string;\r\n  temperature?: number;\r\n  maxTokens?: number;\r\n  topP?: number;\r\n  frequencyPenalty?: number;\r\n  presencePenalty?: number;\r\n  stopSequences?: string[];\r\n  functions?: Array<{\r\n    name: string;\r\n    description: string;\r\n    parameters: Record<string, any>;\r\n  }>;\r\n  tools?: Array<{\r\n    type: string;\r\n    function: Record<string, any>;\r\n  }>;\r\n}\r\n\r\nexport interface LLMResponse {\r\n  id: string;\r\n  choices: Array<{\r\n    message?: {\r\n      role: string;\r\n      content: string;\r\n      functionCall?: {\r\n        name: string;\r\n        arguments: string;\r\n      };\r\n    };\r\n    text?: string;\r\n    finishReason: string;\r\n    index: number;\r\n  }>;\r\n  usage: {\r\n    promptTokens: number;\r\n    completionTokens: number;\r\n    totalTokens: number;\r\n  };\r\n  model: string;\r\n  created: number;\r\n}\r\n\r\nexport interface LLMMetrics {\r\n  latency: number;\r\n  tokensPerSecond: number;\r\n  costEstimate: number;\r\n  cacheHit: boolean;\r\n  retryCount: number;\r\n  providerHealth: number; // 0-1 health score\r\n}\r\n\r\n// ===== Memory Hook Types =====\r\n\r\nexport type MemoryHookType =\r\n  | 'pre-memory-store'\r\n  | 'post-memory-store'\r\n  | 'pre-memory-retrieve'\r\n  | 'post-memory-retrieve'\r\n  | 'memory-sync'\r\n  | 'memory-persist'\r\n  | 'memory-expire';\r\n\r\nexport interface MemoryHookPayload {\r\n  operation: 'store' | 'retrieve' | 'sync' | 'persist' | 'expire';\r\n  namespace: string;\r\n  key?: string;\r\n  value?: any;\r\n  ttl?: number;\r\n  provider: string;\r\n  crossProvider?: boolean;\r\n  syncTargets?: string[];\r\n}\r\n\r\n// ===== Neural Hook Types =====\r\n\r\nexport type NeuralHookType =\r\n  | 'pre-neural-train'\r\n  | 'post-neural-train'\r\n  | 'neural-pattern-detected'\r\n  | 'neural-prediction'\r\n  | 'neural-adaptation';\r\n\r\nexport interface NeuralHookPayload {\r\n  operation: 'train' | 'predict' | 'adapt' | 'analyze';\r\n  modelId: string;\r\n  patterns?: Pattern[];\r\n  trainingData?: TrainingData;\r\n  prediction?: Prediction;\r\n  accuracy?: number;\r\n  adaptations?: Adaptation[];\r\n}\r\n\r\nexport interface Pattern {\r\n  id: string;\r\n  type: 'success' | 'failure' | 'optimization' | 'behavior';\r\n  confidence: number;\r\n  occurrences: number;\r\n  context: Record<string, any>;\r\n}\r\n\r\nexport interface TrainingData {\r\n  inputs: any[];\r\n  outputs: any[];\r\n  labels?: string[];\r\n  weights?: number[];\r\n  batchSize: number;\r\n  epochs: number;\r\n}\r\n\r\nexport interface Prediction {\r\n  input: any;\r\n  output: any;\r\n  confidence: number;\r\n  alternatives: Array<{\r\n    output: any;\r\n    confidence: number;\r\n  }>;\r\n}\r\n\r\nexport interface Adaptation {\r\n  type: 'parameter' | 'architecture' | 'strategy';\r\n  target: string;\r\n  oldValue: any;\r\n  newValue: any;\r\n  reason: string;\r\n  impact: number; // -1 to 1\r\n}\r\n\r\n// ===== Performance Hook Types =====\r\n\r\nexport type PerformanceHookType =\r\n  | 'performance-metric'\r\n  | 'performance-bottleneck'\r\n  | 'performance-optimization'\r\n  | 'performance-threshold';\r\n\r\nexport interface PerformanceHookPayload {\r\n  metric: string;\r\n  value: number;\r\n  unit: string;\r\n  threshold?: number;\r\n  bottleneck?: BottleneckInfo;\r\n  optimization?: OptimizationInfo;\r\n  context: Record<string, any>;\r\n}\r\n\r\nexport interface PerformanceMetric {\r\n  name: string;\r\n  value: number;\r\n  unit: string;\r\n  timestamp: number;\r\n  tags: string[];\r\n}\r\n\r\nexport interface BottleneckAnalysis {\r\n  component: string;\r\n  severity: 'low' | 'medium' | 'high' | 'critical';\r\n  impact: number; // 0-1\r\n  suggestions: string[];\r\n}\r\n\r\nexport interface OptimizationSuggestion {\r\n  type: 'cache' | 'parallel' | 'batch' | 'algorithm' | 'resource';\r\n  target: string;\r\n  expectedImprovement: number; // percentage\r\n  implementation: string;\r\n  risk: 'low' | 'medium' | 'high';\r\n}\r\n\r\nexport interface BottleneckInfo {\r\n  location: string;\r\n  type: string;\r\n  severity: number;\r\n  suggestions: string[];\r\n}\r\n\r\nexport interface OptimizationInfo {\r\n  applied: boolean;\r\n  type: string;\r\n  improvement: number;\r\n  details: string;\r\n}\r\n\r\n// ===== Workflow Hook Types =====\r\n\r\nexport type WorkflowHookType =\r\n  | 'workflow-start'\r\n  | 'workflow-step'\r\n  | 'workflow-decision'\r\n  | 'workflow-complete'\r\n  | 'workflow-error';\r\n\r\nexport interface WorkflowHookPayload {\r\n  workflowId: string;\r\n  step?: string;\r\n  decision?: WorkflowDecision;\r\n  state: Record<string, any>;\r\n  metrics?: WorkflowMetrics;\r\n  error?: Error;\r\n}\r\n\r\nexport interface WorkflowDecision {\r\n  point: string;\r\n  options: string[];\r\n  selected: string;\r\n  confidence: number;\r\n  reasoning: string;\r\n  learnings: Learning[];\r\n}\r\n\r\nexport interface Learning {\r\n  type: 'success' | 'failure' | 'optimization';\r\n  context: string;\r\n  value: any;\r\n  applicability: number; // 0-1\r\n}\r\n\r\nexport interface WorkflowMetrics {\r\n  duration: number;\r\n  steps: number;\r\n  decisions: number;\r\n  errorRate: number;\r\n  successRate: number;\r\n  improvementRate: number;\r\n}\r\n\r\n// ===== Hook Registration & Management =====\r\n\r\nexport interface HookRegistration {\r\n  id: string;\r\n  type: AgenticHookType;\r\n  handler: HookHandler;\r\n  priority: number;\r\n  filter?: HookFilter;\r\n  options?: HookOptions;\r\n}\r\n\r\nexport type AgenticHookType = \r\n  | LLMHookType \r\n  | MemoryHookType \r\n  | NeuralHookType \r\n  | PerformanceHookType \r\n  | WorkflowHookType\r\n  | HookType; // Include existing Claude Flow hooks\r\n\r\nexport type HookHandler = (\r\n  payload: HookPayload,\r\n  context: AgenticHookContext\r\n) => Promise<HookHandlerResult>;\r\n\r\nexport type HookPayload = \r\n  | LLMHookPayload\r\n  | MemoryHookPayload\r\n  | NeuralHookPayload\r\n  | PerformanceHookPayload\r\n  | WorkflowHookPayload;\r\n\r\nexport interface HookHandlerResult {\r\n  continue: boolean;\r\n  modified?: boolean;\r\n  payload?: any;\r\n  metadata?: Record<string, any>;\r\n  sideEffects?: SideEffect[];\r\n}\r\n\r\nexport interface SideEffect {\r\n  type: 'memory' | 'neural' | 'metric' | 'notification' | 'log';\r\n  action: string;\r\n  data: any;\r\n}\r\n\r\nexport interface HookFilter {\r\n  providers?: string[];\r\n  models?: string[];\r\n  operations?: string[];\r\n  namespaces?: string[];\r\n  patterns?: RegExp[];\r\n  conditions?: Array<{\r\n    field: string;\r\n    operator: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte' | 'in' | 'nin' | 'regex';\r\n    value: any;\r\n  }>;\r\n}\r\n\r\nexport interface HookOptions {\r\n  async?: boolean;\r\n  timeout?: number;\r\n  retries?: number;\r\n  fallback?: HookHandler;\r\n  errorHandler?: (error: Error) => void;\r\n  cache?: {\r\n    enabled: boolean;\r\n    ttl: number;\r\n    key: (payload: HookPayload) => string;\r\n  };\r\n}\r\n\r\n// ===== Hook Pipeline =====\r\n\r\nexport interface HookPipeline {\r\n  id: string;\r\n  name: string;\r\n  stages: PipelineStage[];\r\n  errorStrategy: 'fail-fast' | 'continue' | 'rollback';\r\n  metrics: PipelineMetrics;\r\n}\r\n\r\nexport interface PipelineStage {\r\n  name: string;\r\n  hooks: HookRegistration[];\r\n  parallel: boolean;\r\n  condition?: (context: AgenticHookContext) => boolean;\r\n  transform?: (result: HookHandlerResult) => HookHandlerResult;\r\n}\r\n\r\nexport interface PipelineMetrics {\r\n  executions: number;\r\n  avgDuration: number;\r\n  errorRate: number;\r\n  throughput: number;\r\n}\r\n\r\n// ===== Provider Integration =====\r\n\r\nexport interface ProviderHookConfig {\r\n  provider: string;\r\n  hooks: {\r\n    preCall?: HookRegistration[];\r\n    postCall?: HookRegistration[];\r\n    error?: HookRegistration[];\r\n    cache?: HookRegistration[];\r\n  };\r\n  memory: {\r\n    enabled: boolean;\r\n    namespace: string;\r\n    persistence: 'session' | 'persistent';\r\n  };\r\n  neural: {\r\n    enabled: boolean;\r\n    modelId: string;\r\n    training: 'online' | 'batch' | 'hybrid';\r\n  };\r\n  performance: {\r\n    tracking: boolean;\r\n    optimization: boolean;\r\n    thresholds: Record<string, number>;\r\n  };\r\n}\r\n\r\n// ===== Self-Improvement Types =====\r\n\r\nexport interface SelfImprovementConfig {\r\n  enabled: boolean;\r\n  strategies: ImprovementStrategy[];\r\n  evaluation: EvaluationConfig;\r\n  adaptation: AdaptationConfig;\r\n}\r\n\r\nexport interface ImprovementStrategy {\r\n  name: string;\r\n  type: 'reinforcement' | 'evolutionary' | 'gradient' | 'heuristic';\r\n  target: 'latency' | 'accuracy' | 'cost' | 'reliability';\r\n  parameters: Record<string, any>;\r\n}\r\n\r\nexport interface EvaluationConfig {\r\n  metrics: string[];\r\n  window: number; // evaluation window in seconds\r\n  minSamples: number;\r\n  confidenceThreshold: number;\r\n}\r\n\r\nexport interface AdaptationConfig {\r\n  automatic: boolean;\r\n  requiresApproval: boolean;\r\n  maxChangeMagnitude: number;\r\n  rollbackThreshold: number;\r\n}\r\n\r\n// ===== Hook Context Helpers =====\r\n\r\nexport interface HookContextBuilder {\r\n  withSession(sessionId: string): HookContextBuilder;\r\n  withMemory(namespace: string, provider: string): HookContextBuilder;\r\n  withNeural(modelId: string): HookContextBuilder;\r\n  withPerformance(metrics: PerformanceMetric[]): HookContextBuilder;\r\n  withMetadata(metadata: Record<string, any>): HookContextBuilder;\r\n  build(): AgenticHookContext;\r\n}\r\n\r\n// ===== Hook Registry Interface =====\r\n\r\nexport interface HookRegistry {\r\n  register(registration: HookRegistration): void;\r\n  unregister(id: string): void;\r\n  getHooks(type: AgenticHookType, filter?: HookFilter): HookRegistration[];\r\n  executeHooks(\r\n    type: AgenticHookType,\r\n    payload: HookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult[]>;\r\n  createPipeline(config: Partial<HookPipeline>): HookPipeline;\r\n  getMetrics(): Record<string, any>;\r\n}\r\n\r\n// ===== Pattern Store =====\r\n\r\nexport interface PatternStore {\r\n  add(pattern: Pattern): void;\r\n  get(id: string): Pattern | undefined;\r\n  findSimilar(pattern: Partial<Pattern>, threshold: number): Pattern[];\r\n  getByType(type: Pattern['type']): Pattern[];\r\n  prune(maxAge: number): void;\r\n  export(): Pattern[];\r\n  import(patterns: Pattern[]): void;\r\n}\r\n\r\n// ===== Training State =====\r\n\r\nexport interface TrainingState {\r\n  epoch: number;\r\n  loss: number;\r\n  accuracy: number;\r\n  validationLoss?: number;\r\n  validationAccuracy?: number;\r\n  learningRate: number;\r\n  optimizer: string;\r\n  checkpoints: Checkpoint[];\r\n}\r\n\r\nexport interface Checkpoint {\r\n  epoch: number;\r\n  timestamp: number;\r\n  metrics: Record<string, number>;\r\n  path: string;\r\n}"],"names":[],"mappings":"AAifA,WAKC"}