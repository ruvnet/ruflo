{"version":3,"sources":["../../../src/terminal/pool.ts"],"sourcesContent":["/**\r\n * Terminal pool management\r\n */\r\n\r\nimport type { Terminal, ITerminalAdapter } from './adapters/base.js';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { TerminalError } from '../utils/errors.js';\r\nimport { delay } from '../utils/helpers.js';\r\n\r\ninterface PooledTerminal {\r\n  terminal: Terminal;\r\n  useCount: number;\r\n  lastUsed: Date;\r\n  inUse: boolean;\r\n}\r\n\r\n/**\r\n * Terminal pool for efficient resource management\r\n */\r\nexport class TerminalPool {\r\n  private terminals = new Map<string, PooledTerminal>();\r\n  private availableQueue: string[] = [];\r\n  private initializationPromise?: Promise<void>;\r\n\r\n  constructor(\r\n    private maxSize: number,\r\n    private recycleAfter: number,\r\n    private adapter: ITerminalAdapter,\r\n    private logger: ILogger,\r\n  ) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.initializationPromise) {\r\n      return this.initializationPromise;\r\n    }\r\n\r\n    this.initializationPromise = this.doInitialize();\r\n    return this.initializationPromise;\r\n  }\r\n\r\n  private async doInitialize(): Promise<void> {\r\n    this.logger.info('Initializing terminal pool', {\r\n      maxSize: this.maxSize,\r\n      recycleAfter: this.recycleAfter,\r\n    });\r\n\r\n    // Pre-create some terminals\r\n    const preCreateCount = Math.min(2, this.maxSize);\r\n    const promises: Promise<void>[] = [];\r\n\r\n    for (let i = 0; i < preCreateCount; i++) {\r\n      promises.push(this.createPooledTerminal());\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    this.logger.info('Terminal pool initialized', {\r\n      created: preCreateCount,\r\n    });\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down terminal pool');\r\n\r\n    // Destroy all terminals\r\n    const terminals = Array.from(this.terminals.values());\r\n    await Promise.all(terminals.map(({ terminal }) => this.adapter.destroyTerminal(terminal)));\r\n\r\n    this.terminals.clear();\r\n    this.availableQueue = [];\r\n  }\r\n\r\n  async acquire(): Promise<Terminal> {\r\n    // Try to get an available terminal\r\n    while (this.availableQueue.length > 0) {\r\n      const terminalId = this.availableQueue.shift()!;\r\n      const pooled = this.terminals.get(terminalId);\r\n\r\n      if (pooled && pooled.terminal.isAlive()) {\r\n        pooled.inUse = true;\r\n        pooled.lastUsed = new Date();\r\n\r\n        this.logger.debug('Terminal acquired from pool', {\r\n          terminalId,\r\n          useCount: pooled.useCount,\r\n        });\r\n\r\n        return pooled.terminal;\r\n      }\r\n\r\n      // Terminal is dead, remove it\r\n      if (pooled) {\r\n        this.terminals.delete(terminalId);\r\n      }\r\n    }\r\n\r\n    // No available terminals, create new one if under limit\r\n    if (this.terminals.size < this.maxSize) {\r\n      await this.createPooledTerminal();\r\n      return this.acquire(); // Recursive call to get the newly created terminal\r\n    }\r\n\r\n    // Pool is full, wait for a terminal to become available\r\n    this.logger.info('Terminal pool full, waiting for available terminal');\r\n\r\n    const startTime = Date.now();\r\n    const timeout = 30000; // 30 seconds\r\n\r\n    while (Date.now() - startTime < timeout) {\r\n      await delay(100);\r\n\r\n      // Check if any terminal became available\r\n      const available = Array.from(this.terminals.values()).find(\r\n        (pooled) => !pooled.inUse && pooled.terminal.isAlive(),\r\n      );\r\n\r\n      if (available) {\r\n        available.inUse = true;\r\n        available.lastUsed = new Date();\r\n        return available.terminal;\r\n      }\r\n    }\r\n\r\n    throw new TerminalError('No terminal available in pool (timeout)');\r\n  }\r\n\r\n  async release(terminal: Terminal): Promise<void> {\r\n    const pooled = this.terminals.get(terminal.id);\r\n    if (!pooled) {\r\n      this.logger.warn('Attempted to release unknown terminal', {\r\n        terminalId: terminal.id,\r\n      });\r\n      return;\r\n    }\r\n\r\n    pooled.useCount++;\r\n    pooled.inUse = false;\r\n\r\n    // Check if terminal should be recycled\r\n    if (pooled.useCount >= this.recycleAfter || !terminal.isAlive()) {\r\n      this.logger.info('Recycling terminal', {\r\n        terminalId: terminal.id,\r\n        useCount: pooled.useCount,\r\n      });\r\n\r\n      // Destroy old terminal\r\n      this.terminals.delete(terminal.id);\r\n      await this.adapter.destroyTerminal(terminal);\r\n\r\n      // Create replacement if under limit\r\n      if (this.terminals.size < this.maxSize) {\r\n        await this.createPooledTerminal();\r\n      }\r\n    } else {\r\n      // Return to available queue\r\n      this.availableQueue.push(terminal.id);\r\n\r\n      this.logger.debug('Terminal returned to pool', {\r\n        terminalId: terminal.id,\r\n        useCount: pooled.useCount,\r\n      });\r\n    }\r\n  }\r\n\r\n  async getHealthStatus(): Promise<{\r\n    healthy: boolean;\r\n    size: number;\r\n    available: number;\r\n    recycled: number;\r\n  }> {\r\n    const aliveTerminals = Array.from(this.terminals.values()).filter((pooled) =>\r\n      pooled.terminal.isAlive(),\r\n    );\r\n\r\n    const available = aliveTerminals.filter((pooled) => !pooled.inUse).length;\r\n    const recycled = Array.from(this.terminals.values()).filter(\r\n      (pooled) => pooled.useCount >= this.recycleAfter,\r\n    ).length;\r\n\r\n    return {\r\n      healthy: aliveTerminals.length > 0,\r\n      size: this.terminals.size,\r\n      available,\r\n      recycled,\r\n    };\r\n  }\r\n\r\n  async performMaintenance(): Promise<void> {\r\n    this.logger.debug('Performing terminal pool maintenance');\r\n\r\n    // Remove dead terminals\r\n    const deadTerminals: string[] = [];\r\n    for (const [id, pooled] of this.terminals.entries()) {\r\n      if (!pooled.terminal.isAlive()) {\r\n        deadTerminals.push(id);\r\n      }\r\n    }\r\n\r\n    // Clean up dead terminals\r\n    for (const id of deadTerminals) {\r\n      this.logger.warn('Removing dead terminal from pool', { terminalId: id });\r\n      this.terminals.delete(id);\r\n      const index = this.availableQueue.indexOf(id);\r\n      if (index !== -1) {\r\n        this.availableQueue.splice(index, 1);\r\n      }\r\n    }\r\n\r\n    // Ensure minimum pool size\r\n    const currentSize = this.terminals.size;\r\n    const minSize = Math.min(2, this.maxSize);\r\n\r\n    if (currentSize < minSize) {\r\n      const toCreate = minSize - currentSize;\r\n      this.logger.info('Replenishing terminal pool', {\r\n        currentSize,\r\n        minSize,\r\n        creating: toCreate,\r\n      });\r\n\r\n      const promises: Promise<void>[] = [];\r\n      for (let i = 0; i < toCreate; i++) {\r\n        promises.push(this.createPooledTerminal());\r\n      }\r\n\r\n      await Promise.all(promises);\r\n    }\r\n\r\n    // Check for stale terminals that should be recycled\r\n    const now = Date.now();\r\n    const staleTimeout = 300000; // 5 minutes\r\n\r\n    for (const [id, pooled] of this.terminals.entries()) {\r\n      if (!pooled.inUse && pooled.terminal.isAlive()) {\r\n        const idleTime = now - pooled.lastUsed.getTime();\r\n        if (idleTime > staleTimeout) {\r\n          this.logger.info('Recycling stale terminal', {\r\n            terminalId: id,\r\n            idleTime,\r\n          });\r\n\r\n          // Mark for recycling\r\n          pooled.useCount = this.recycleAfter;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async createPooledTerminal(): Promise<void> {\r\n    try {\r\n      const terminal = await this.adapter.createTerminal();\r\n\r\n      const pooled: PooledTerminal = {\r\n        terminal,\r\n        useCount: 0,\r\n        lastUsed: new Date(),\r\n        inUse: false,\r\n      };\r\n\r\n      this.terminals.set(terminal.id, pooled);\r\n      this.availableQueue.push(terminal.id);\r\n\r\n      this.logger.debug('Created pooled terminal', { terminalId: terminal.id });\r\n    } catch (error) {\r\n      this.logger.error('Failed to create pooled terminal', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"names":["TerminalError","delay","TerminalPool","terminals","Map","availableQueue","initializationPromise","maxSize","recycleAfter","adapter","logger","initialize","doInitialize","info","preCreateCount","Math","min","promises","i","push","createPooledTerminal","Promise","all","created","shutdown","Array","from","values","map","terminal","destroyTerminal","clear","acquire","length","terminalId","shift","pooled","get","isAlive","inUse","lastUsed","Date","debug","useCount","delete","size","startTime","now","timeout","available","find","release","id","warn","getHealthStatus","aliveTerminals","filter","recycled","healthy","performMaintenance","deadTerminals","entries","index","indexOf","splice","currentSize","minSize","toCreate","creating","staleTimeout","idleTime","getTime","createTerminal","set","error"],"mappings":"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"}