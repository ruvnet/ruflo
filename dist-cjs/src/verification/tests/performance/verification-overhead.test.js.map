{"version":3,"sources":["../../../../../src/verification/tests/performance/verification-overhead.test.ts"],"sourcesContent":["/**\r\n * Performance Benchmark Tests for Verification Overhead\r\n * \r\n * Tests the performance impact of the verification system including:\r\n * - Truth scoring calculation performance\r\n * - Memory usage during verification\r\n * - Throughput under load\r\n * - Latency impact on agent communication\r\n */\r\n\r\nimport { jest } from '@jest/globals';\r\nimport { performance } from 'perf_hooks';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport * as os from 'os';\r\n\r\n// Import verification components\r\nimport TruthScoreCalculator from '../../../../.claude/helpers/truth-score.js';\r\n\r\ninterface PerformanceMetrics {\r\n  operations: number;\r\n  totalTime: number;\r\n  averageTime: number;\r\n  throughput: number;\r\n  memoryUsage: {\r\n    initial: number;\r\n    peak: number;\r\n    final: number;\r\n    delta: number;\r\n  };\r\n  p50: number;\r\n  p95: number;\r\n  p99: number;\r\n}\r\n\r\ninterface BenchmarkResult {\r\n  testName: string;\r\n  metrics: PerformanceMetrics;\r\n  passed: boolean;\r\n  thresholds: BenchmarkThresholds;\r\n}\r\n\r\ninterface BenchmarkThresholds {\r\n  maxAverageTime: number;\r\n  minThroughput: number;\r\n  maxMemoryDelta: number;\r\n  maxP99Latency: number;\r\n}\r\n\r\ndescribe('Verification System Performance Benchmarks', () => {\r\n  let tempDir: string;\r\n  let calculator: any;\r\n  let performanceResults: BenchmarkResult[] = [];\r\n\r\n  beforeAll(async () => {\r\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'verification-perf-'));\r\n    \r\n    // Setup truth score calculator\r\n    calculator = new TruthScoreCalculator();\r\n    calculator.configPath = path.join(tempDir, 'verification.json');\r\n    calculator.memoryPath = path.join(tempDir, 'truth-scores');\r\n    await calculator.init();\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await fs.rm(tempDir, { recursive: true, force: true });\r\n    \r\n    // Generate performance report\r\n    await generatePerformanceReport(performanceResults);\r\n  });\r\n\r\n  describe('Truth Score Calculation Performance', () => {\r\n    test('should calculate truth scores efficiently at scale', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 5, // 5ms per calculation\r\n        minThroughput: 200, // 200 calculations per second\r\n        maxMemoryDelta: 50 * 1024 * 1024, // 50MB max memory increase\r\n        maxP99Latency: 20 // 20ms p99 latency\r\n      };\r\n\r\n      const operations = 1000;\r\n      const evidenceVariants = generateEvidenceVariants(10);\r\n      const durations: number[] = [];\r\n      \r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      let peakMemory = initialMemory;\r\n\r\n      const startTime = performance.now();\r\n\r\n      for (let i = 0; i < operations; i++) {\r\n        const evidence = evidenceVariants[i % evidenceVariants.length];\r\n        \r\n        const operationStart = performance.now();\r\n        const score = calculator.calculateScore(evidence);\r\n        const operationEnd = performance.now();\r\n        \r\n        durations.push(operationEnd - operationStart);\r\n        \r\n        // Track memory usage\r\n        const currentMemory = process.memoryUsage().heapUsed;\r\n        peakMemory = Math.max(peakMemory, currentMemory);\r\n        \r\n        // Verify score is valid\r\n        expect(score).toBeGreaterThanOrEqual(0);\r\n        expect(score).toBeLessThanOrEqual(1);\r\n      }\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n      \r\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: peakMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Truth Score Calculation Performance',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      // Assert performance requirements\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\r\n      expect(metrics.p99).toBeLessThanOrEqual(thresholds.maxP99Latency);\r\n    });\r\n\r\n    test('should handle concurrent truth score calculations efficiently', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 8, // 8ms per calculation (slightly higher for concurrency)\r\n        minThroughput: 150, // 150 calculations per second\r\n        maxMemoryDelta: 100 * 1024 * 1024, // 100MB max memory increase\r\n        maxP99Latency: 30 // 30ms p99 latency\r\n      };\r\n\r\n      const concurrency = 10;\r\n      const operationsPerWorker = 100;\r\n      const totalOperations = concurrency * operationsPerWorker;\r\n\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      const startTime = performance.now();\r\n\r\n      // Create concurrent workers\r\n      const workerPromises = Array.from({ length: concurrency }, async (_, workerIndex) => {\r\n        const workerDurations: number[] = [];\r\n        const evidenceVariants = generateEvidenceVariants(5);\r\n\r\n        for (let i = 0; i < operationsPerWorker; i++) {\r\n          const evidence = evidenceVariants[i % evidenceVariants.length];\r\n          \r\n          const operationStart = performance.now();\r\n          const score = calculator.calculateScore(evidence);\r\n          const operationEnd = performance.now();\r\n          \r\n          workerDurations.push(operationEnd - operationStart);\r\n          \r\n          expect(score).toBeGreaterThanOrEqual(0);\r\n          expect(score).toBeLessThanOrEqual(1);\r\n\r\n          // Add small delay to simulate realistic workload\r\n          if (i % 10 === 0) {\r\n            await new Promise(resolve => setTimeout(resolve, 1));\r\n          }\r\n        }\r\n\r\n        return workerDurations;\r\n      });\r\n\r\n      const allDurations = (await Promise.all(workerPromises)).flat();\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n\r\n      const metrics = calculatePerformanceMetrics(totalOperations, allDurations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: finalMemory, // Simplified for concurrent case\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Concurrent Truth Score Calculation',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\r\n    }, 30000);\r\n  });\r\n\r\n  describe('Memory Usage Optimization', () => {\r\n    test('should maintain stable memory usage during extended operations', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 10, // 10ms per operation\r\n        minThroughput: 100, // 100 operations per second\r\n        maxMemoryDelta: 20 * 1024 * 1024, // 20MB max memory increase\r\n        maxP99Latency: 50 // 50ms p99 latency\r\n      };\r\n\r\n      const operations = 2000;\r\n      const evidenceVariants = generateEvidenceVariants(20);\r\n      const durations: number[] = [];\r\n      const memorySnapshots: number[] = [];\r\n\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      memorySnapshots.push(initialMemory);\r\n\r\n      const startTime = performance.now();\r\n\r\n      for (let i = 0; i < operations; i++) {\r\n        const evidence = evidenceVariants[i % evidenceVariants.length];\r\n        \r\n        const operationStart = performance.now();\r\n        \r\n        // Perform multiple operations to test memory accumulation\r\n        const score1 = calculator.calculateScore(evidence);\r\n        const comparison = calculator.compareClaimToReality(\r\n          { tests_pass: true, no_lint_errors: true },\r\n          { tests_pass: score1 > 0.8, lint_errors: score1 > 0.9 ? 0 : 2 }\r\n        );\r\n        \r\n        const operationEnd = performance.now();\r\n        durations.push(operationEnd - operationStart);\r\n\r\n        // Take memory snapshots every 100 operations\r\n        if (i % 100 === 0) {\r\n          const currentMemory = process.memoryUsage().heapUsed;\r\n          memorySnapshots.push(currentMemory);\r\n\r\n          // Force garbage collection every 500 operations to test cleanup\r\n          if (i % 500 === 0 && global.gc) {\r\n            global.gc();\r\n          }\r\n        }\r\n      }\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n      const peakMemory = Math.max(...memorySnapshots);\r\n\r\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: peakMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      // Check for memory leaks by analyzing memory growth trend\r\n      const memoryGrowthRate = (finalMemory - initialMemory) / operations;\r\n      expect(memoryGrowthRate).toBeLessThan(1000); // Less than 1KB per operation\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Extended Memory Usage Stability',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds) && memoryGrowthRate < 1000,\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\r\n    }, 45000);\r\n\r\n    test('should efficiently handle large evidence datasets', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 15, // 15ms per operation (larger datasets)\r\n        minThroughput: 70, // 70 operations per second\r\n        maxMemoryDelta: 150 * 1024 * 1024, // 150MB max memory increase\r\n        maxP99Latency: 100 // 100ms p99 latency\r\n      };\r\n\r\n      const operations = 500;\r\n      const durations: number[] = [];\r\n\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      const startTime = performance.now();\r\n\r\n      for (let i = 0; i < operations; i++) {\r\n        // Create large evidence objects\r\n        const largeEvidence = generateLargeEvidence(i);\r\n        \r\n        const operationStart = performance.now();\r\n        const score = calculator.calculateScore(largeEvidence);\r\n        const operationEnd = performance.now();\r\n        \r\n        durations.push(operationEnd - operationStart);\r\n        \r\n        expect(score).toBeGreaterThanOrEqual(0);\r\n        expect(score).toBeLessThanOrEqual(1);\r\n\r\n        // Cleanup large objects to prevent memory accumulation\r\n        if (i % 50 === 0 && global.gc) {\r\n          global.gc();\r\n        }\r\n      }\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n\r\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: finalMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Large Evidence Dataset Handling',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n    }, 30000);\r\n  });\r\n\r\n  describe('Truth Score Storage Performance', () => {\r\n    test('should store truth scores efficiently at high volume', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 20, // 20ms per storage operation\r\n        minThroughput: 50, // 50 storage operations per second\r\n        maxMemoryDelta: 100 * 1024 * 1024, // 100MB max memory increase\r\n        maxP99Latency: 100 // 100ms p99 latency\r\n      };\r\n\r\n      const operations = 200; // Reduced for storage operations\r\n      const durations: number[] = [];\r\n\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      const startTime = performance.now();\r\n\r\n      for (let i = 0; i < operations; i++) {\r\n        const agentId = `agent-${i % 10}`;\r\n        const taskId = `task-${i}`;\r\n        const score = Math.random();\r\n        const evidence = generateEvidenceVariants(1)[0];\r\n\r\n        const operationStart = performance.now();\r\n        await calculator.storeTruthScore(agentId, taskId, score, evidence);\r\n        const operationEnd = performance.now();\r\n        \r\n        durations.push(operationEnd - operationStart);\r\n      }\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n\r\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: finalMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'High Volume Truth Score Storage',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n\r\n      // Verify all files were created\r\n      const files = await fs.readdir(calculator.memoryPath);\r\n      expect(files.length).toBe(operations);\r\n    }, 30000);\r\n\r\n    test('should retrieve agent history efficiently', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 50, // 50ms per history retrieval\r\n        minThroughput: 20, // 20 retrievals per second\r\n        maxMemoryDelta: 50 * 1024 * 1024, // 50MB max memory increase\r\n        maxP99Latency: 200 // 200ms p99 latency\r\n      };\r\n\r\n      // First, create test data\r\n      const agents = Array.from({ length: 10 }, (_, i) => `perf-agent-${i}`);\r\n      for (const agentId of agents) {\r\n        for (let i = 0; i < 50; i++) {\r\n          await calculator.storeTruthScore(\r\n            agentId,\r\n            `history-task-${i}`,\r\n            Math.random(),\r\n            { test: `data-${i}` }\r\n          );\r\n        }\r\n      }\r\n\r\n      const operations = 100;\r\n      const durations: number[] = [];\r\n\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      const startTime = performance.now();\r\n\r\n      for (let i = 0; i < operations; i++) {\r\n        const agentId = agents[i % agents.length];\r\n        const limit = Math.floor(Math.random() * 20) + 5; // 5-24 entries\r\n\r\n        const operationStart = performance.now();\r\n        const history = await calculator.getAgentHistory(agentId, limit);\r\n        const operationEnd = performance.now();\r\n        \r\n        durations.push(operationEnd - operationStart);\r\n        \r\n        expect(history.length).toBeLessThanOrEqual(limit);\r\n        expect(history.length).toBeGreaterThan(0);\r\n      }\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n\r\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: finalMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Agent History Retrieval Performance',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n    }, 45000);\r\n  });\r\n\r\n  describe('Report Generation Performance', () => {\r\n    test('should generate reports efficiently with large datasets', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 1000, // 1 second per report generation\r\n        minThroughput: 1, // 1 report per second\r\n        maxMemoryDelta: 200 * 1024 * 1024, // 200MB max memory increase\r\n        maxP99Latency: 3000 // 3 second p99 latency\r\n      };\r\n\r\n      // Create large dataset for report generation\r\n      const agents = Array.from({ length: 50 }, (_, i) => `report-agent-${i}`);\r\n      for (const agentId of agents) {\r\n        for (let i = 0; i < 100; i++) {\r\n          await calculator.storeTruthScore(\r\n            agentId,\r\n            `report-task-${i}`,\r\n            Math.random(),\r\n            { complexity: Math.random(), quality: Math.random() }\r\n          );\r\n        }\r\n      }\r\n\r\n      const operations = 10; // Fewer operations for expensive report generation\r\n      const durations: number[] = [];\r\n\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      const startTime = performance.now();\r\n\r\n      for (let i = 0; i < operations; i++) {\r\n        const format = i % 2 === 0 ? 'json' : 'markdown';\r\n\r\n        const operationStart = performance.now();\r\n        const report = await calculator.generateReport(format);\r\n        const operationEnd = performance.now();\r\n        \r\n        durations.push(operationEnd - operationStart);\r\n        \r\n        if (format === 'json') {\r\n          expect(typeof report).toBe('object');\r\n          expect(report.total_verifications).toBeGreaterThan(0);\r\n          expect(Object.keys(report.agents).length).toBe(agents.length);\r\n        } else {\r\n          expect(typeof report).toBe('string');\r\n          expect(report).toContain('# Truth Score Report');\r\n          expect(report).toContain('Agent Performance');\r\n        }\r\n\r\n        // Force garbage collection between operations\r\n        if (global.gc) {\r\n          global.gc();\r\n        }\r\n      }\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n\r\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: finalMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Large Dataset Report Generation',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n    }, 60000);\r\n  });\r\n\r\n  describe('System Load Testing', () => {\r\n    test('should maintain performance under sustained load', async () => {\r\n      const thresholds: BenchmarkThresholds = {\r\n        maxAverageTime: 25, // 25ms average under load\r\n        minThroughput: 40, // 40 operations per second\r\n        maxMemoryDelta: 300 * 1024 * 1024, // 300MB max memory increase\r\n        maxP99Latency: 150 // 150ms p99 latency\r\n      };\r\n\r\n      const loadDuration = 15000; // 15 seconds of sustained load\r\n      const batchSize = 10;\r\n      const batchInterval = 100; // 100ms between batches\r\n\r\n      const durations: number[] = [];\r\n      const initialMemory = process.memoryUsage().heapUsed;\r\n      const startTime = performance.now();\r\n      \r\n      let operationCount = 0;\r\n      const evidenceVariants = generateEvidenceVariants(5);\r\n\r\n      const loadTestPromise = new Promise<void>((resolve) => {\r\n        const interval = setInterval(async () => {\r\n          if (performance.now() - startTime >= loadDuration) {\r\n            clearInterval(interval);\r\n            resolve();\r\n            return;\r\n          }\r\n\r\n          // Process batch of operations\r\n          const batchPromises = Array.from({ length: batchSize }, async (_, i) => {\r\n            const evidence = evidenceVariants[(operationCount + i) % evidenceVariants.length];\r\n            \r\n            const operationStart = performance.now();\r\n            \r\n            // Mixed operations to simulate realistic load\r\n            if (i % 3 === 0) {\r\n              const score = calculator.calculateScore(evidence);\r\n              expect(score).toBeGreaterThanOrEqual(0);\r\n            } else if (i % 3 === 1) {\r\n              const comparison = calculator.compareClaimToReality(\r\n                { tests_pass: true },\r\n                { tests_pass: Math.random() > 0.5 }\r\n              );\r\n              expect(comparison.truth_score).toBeGreaterThanOrEqual(0);\r\n            } else {\r\n              await calculator.storeTruthScore(\r\n                `load-agent-${operationCount + i}`,\r\n                `load-task-${operationCount + i}`,\r\n                Math.random(),\r\n                evidence\r\n              );\r\n            }\r\n            \r\n            const operationEnd = performance.now();\r\n            durations.push(operationEnd - operationStart);\r\n          });\r\n\r\n          await Promise.all(batchPromises);\r\n          operationCount += batchSize;\r\n        }, batchInterval);\r\n      });\r\n\r\n      await loadTestPromise;\r\n\r\n      const endTime = performance.now();\r\n      const finalMemory = process.memoryUsage().heapUsed;\r\n\r\n      const metrics = calculatePerformanceMetrics(operationCount, durations, startTime, endTime, {\r\n        initial: initialMemory,\r\n        peak: finalMemory,\r\n        final: finalMemory\r\n      });\r\n\r\n      const result: BenchmarkResult = {\r\n        testName: 'Sustained Load Performance',\r\n        metrics,\r\n        passed: validateBenchmark(metrics, thresholds),\r\n        thresholds\r\n      };\r\n\r\n      performanceResults.push(result);\r\n\r\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\r\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\r\n      expect(operationCount).toBeGreaterThan(100); // Should process significant number of operations\r\n    }, 20000);\r\n  });\r\n\r\n  // Helper functions\r\n  function generateEvidenceVariants(count: number): any[] {\r\n    return Array.from({ length: count }, (_, i) => ({\r\n      test_results: {\r\n        passed: Math.floor(Math.random() * 20),\r\n        total: 20\r\n      },\r\n      lint_results: {\r\n        errors: Math.floor(Math.random() * 5)\r\n      },\r\n      type_results: {\r\n        errors: Math.floor(Math.random() * 3)\r\n      },\r\n      build_results: {\r\n        success: Math.random() > 0.2\r\n      },\r\n      performance_metrics: {\r\n        response_time: Math.random() * 500 + 50,\r\n        memory_usage: Math.random() * 100 + 50\r\n      },\r\n      complexity_score: Math.random(),\r\n      variant_id: i\r\n    }));\r\n  }\r\n\r\n  function generateLargeEvidence(index: number): any {\r\n    return {\r\n      test_results: {\r\n        passed: Math.floor(Math.random() * 100),\r\n        total: 100,\r\n        detailed_results: Array.from({ length: 100 }, (_, i) => ({\r\n          test_name: `test_${i}`,\r\n          status: Math.random() > 0.1 ? 'passed' : 'failed',\r\n          duration: Math.random() * 1000,\r\n          memory_usage: Math.random() * 50\r\n        }))\r\n      },\r\n      lint_results: {\r\n        errors: Math.floor(Math.random() * 10),\r\n        warnings: Math.floor(Math.random() * 20),\r\n        file_reports: Array.from({ length: 50 }, (_, i) => ({\r\n          file: `file_${i}.js`,\r\n          issues: Math.floor(Math.random() * 5)\r\n        }))\r\n      },\r\n      build_results: {\r\n        success: Math.random() > 0.1,\r\n        build_log: 'x'.repeat(10000), // 10KB of build log data\r\n        dependencies: Array.from({ length: 200 }, (_, i) => `package_${i}`)\r\n      },\r\n      performance_data: {\r\n        metrics: Array.from({ length: 1000 }, () => Math.random() * 100),\r\n        timestamps: Array.from({ length: 1000 }, (_, i) => Date.now() + i * 1000)\r\n      },\r\n      index\r\n    };\r\n  }\r\n\r\n  function calculatePerformanceMetrics(\r\n    operations: number,\r\n    durations: number[],\r\n    startTime: number,\r\n    endTime: number,\r\n    memory: { initial: number; peak: number; final: number }\r\n  ): PerformanceMetrics {\r\n    const totalTime = endTime - startTime;\r\n    const averageTime = durations.reduce((a, b) => a + b, 0) / durations.length;\r\n    const throughput = (operations / totalTime) * 1000; // Operations per second\r\n\r\n    const sortedDurations = durations.sort((a, b) => a - b);\r\n    const p50 = sortedDurations[Math.floor(sortedDurations.length * 0.5)];\r\n    const p95 = sortedDurations[Math.floor(sortedDurations.length * 0.95)];\r\n    const p99 = sortedDurations[Math.floor(sortedDurations.length * 0.99)];\r\n\r\n    return {\r\n      operations,\r\n      totalTime,\r\n      averageTime,\r\n      throughput,\r\n      memoryUsage: {\r\n        initial: memory.initial,\r\n        peak: memory.peak,\r\n        final: memory.final,\r\n        delta: memory.final - memory.initial\r\n      },\r\n      p50,\r\n      p95,\r\n      p99\r\n    };\r\n  }\r\n\r\n  function validateBenchmark(metrics: PerformanceMetrics, thresholds: BenchmarkThresholds): boolean {\r\n    return (\r\n      metrics.averageTime <= thresholds.maxAverageTime &&\r\n      metrics.throughput >= thresholds.minThroughput &&\r\n      metrics.memoryUsage.delta <= thresholds.maxMemoryDelta &&\r\n      metrics.p99 <= thresholds.maxP99Latency\r\n    );\r\n  }\r\n\r\n  async function generatePerformanceReport(results: BenchmarkResult[]) {\r\n    const reportPath = path.join(tempDir, 'performance-report.json');\r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      summary: {\r\n        totalTests: results.length,\r\n        passedTests: results.filter(r => r.passed).length,\r\n        failedTests: results.filter(r => !r.passed).length\r\n      },\r\n      results: results.map(r => ({\r\n        testName: r.testName,\r\n        passed: r.passed,\r\n        metrics: {\r\n          averageTime: `${r.metrics.averageTime.toFixed(2)}ms`,\r\n          throughput: `${r.metrics.throughput.toFixed(2)} ops/sec`,\r\n          memoryDelta: `${(r.metrics.memoryUsage.delta / 1024 / 1024).toFixed(2)}MB`,\r\n          p99Latency: `${r.metrics.p99.toFixed(2)}ms`\r\n        },\r\n        thresholds: {\r\n          maxAverageTime: `${r.thresholds.maxAverageTime}ms`,\r\n          minThroughput: `${r.thresholds.minThroughput} ops/sec`,\r\n          maxMemoryDelta: `${(r.thresholds.maxMemoryDelta / 1024 / 1024).toFixed(0)}MB`,\r\n          maxP99Latency: `${r.thresholds.maxP99Latency}ms`\r\n        }\r\n      }))\r\n    };\r\n\r\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\r\n    console.log(`Performance report generated: ${reportPath}`);\r\n  }\r\n});"],"names":["performance","fs","path","os","TruthScoreCalculator","describe","tempDir","calculator","performanceResults","beforeAll","mkdtemp","join","tmpdir","configPath","memoryPath","init","afterAll","rm","recursive","force","generatePerformanceReport","test","thresholds","maxAverageTime","minThroughput","maxMemoryDelta","maxP99Latency","operations","evidenceVariants","generateEvidenceVariants","durations","initialMemory","process","memoryUsage","heapUsed","peakMemory","startTime","now","i","evidence","length","operationStart","score","calculateScore","operationEnd","push","currentMemory","Math","max","expect","toBeGreaterThanOrEqual","toBeLessThanOrEqual","endTime","finalMemory","metrics","calculatePerformanceMetrics","initial","peak","final","result","testName","passed","validateBenchmark","averageTime","throughput","delta","p99","concurrency","operationsPerWorker","totalOperations","workerPromises","Array","from","_","workerIndex","workerDurations","Promise","resolve","setTimeout","allDurations","all","flat","memorySnapshots","score1","comparison","compareClaimToReality","tests_pass","no_lint_errors","lint_errors","global","gc","memoryGrowthRate","toBeLessThan","largeEvidence","generateLargeEvidence","agentId","taskId","random","storeTruthScore","files","readdir","toBe","agents","limit","floor","history","getAgentHistory","toBeGreaterThan","complexity","quality","format","report","generateReport","total_verifications","Object","keys","toContain","loadDuration","batchSize","batchInterval","operationCount","loadTestPromise","interval","setInterval","clearInterval","batchPromises","truth_score","count","test_results","total","lint_results","errors","type_results","build_results","success","performance_metrics","response_time","memory_usage","complexity_score","variant_id","index","detailed_results","test_name","status","duration","warnings","file_reports","file","issues","build_log","repeat","dependencies","performance_data","timestamps","Date","memory","totalTime","reduce","a","b","sortedDurations","sort","p50","p95","results","reportPath","timestamp","toISOString","summary","totalTests","passedTests","filter","r","failedTests","map","toFixed","memoryDelta","p99Latency","writeFile","JSON","stringify","console","log"],"mappings":"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"}