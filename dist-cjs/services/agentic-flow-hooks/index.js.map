{
  "version": 3,
  "sources": ["../../../src/services/agentic-flow-hooks/index.ts"],
  "sourcesContent": ["/**\n * Agentic Flow Hook System\n * \n * Main entry point for the hook system integration with agentic-flow.\n * Provides initialization, registration, and management of all hook types.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport { registerLLMHooks } from './llm-hooks.js';\nimport { registerMemoryHooks } from './memory-hooks.js';\nimport { registerNeuralHooks } from './neural-hooks.js';\nimport { registerPerformanceHooks } from './performance-hooks.js';\nimport { registerWorkflowHooks } from './workflow-hooks.js';\nimport { Logger } from '../../core/logger.js';\n\nexport * from './types.js';\nexport { agenticHookManager } from './hook-manager.js';\nexport * from './llm-hooks.js';\nexport * from './memory-hooks.js';\nexport * from './neural-hooks.js';\nexport * from './performance-hooks.js';\nexport * from './workflow-hooks.js';\n\nconst logger = new Logger({\n  level: 'info',\n  format: 'text',\n  destination: 'console'\n}, { prefix: 'AgenticFlowHooks' });\n\n/**\n * Initialize the agentic-flow hook system\n */\nexport async function initializeAgenticFlowHooks(): Promise<void> {\n  logger.info('Initializing agentic-flow hook system...');\n  \n  try {\n    // Register all hook types\n    registerLLMHooks();\n    logger.debug('LLM hooks registered');\n    \n    registerMemoryHooks();\n    logger.debug('Memory hooks registered');\n    \n    registerNeuralHooks();\n    logger.debug('Neural hooks registered');\n    \n    registerPerformanceHooks();\n    logger.debug('Performance hooks registered');\n    \n    registerWorkflowHooks();\n    logger.debug('Workflow hooks registered');\n    \n    // Set up default pipelines\n    await setupDefaultPipelines();\n    \n    // Initialize metrics collection\n    startMetricsCollection();\n    \n    logger.info('Agentic-flow hook system initialized successfully');\n  } catch (error) {\n    logger.error('Failed to initialize agentic-flow hooks:', error);\n    throw error;\n  }\n}\n\n/**\n * Set up default hook pipelines\n */\nasync function setupDefaultPipelines(): Promise<void> {\n  // LLM Call Pipeline\n  agenticHookManager.createPipeline({\n    id: 'llm-call-pipeline',\n    name: 'LLM Call Pipeline',\n    stages: [\n      {\n        name: 'pre-call',\n        hooks: agenticHookManager.getHooks('pre-llm-call'),\n        parallel: false,\n      },\n      {\n        name: 'call-execution',\n        hooks: [], // Actual LLM call happens here\n        parallel: false,\n      },\n      {\n        name: 'post-call',\n        hooks: agenticHookManager.getHooks('post-llm-call'),\n        parallel: true,\n      },\n    ],\n    errorStrategy: 'continue',\n  });\n  \n  // Memory Operation Pipeline\n  agenticHookManager.createPipeline({\n    id: 'memory-operation-pipeline',\n    name: 'Memory Operation Pipeline',\n    stages: [\n      {\n        name: 'validation',\n        hooks: agenticHookManager.getHooks('pre-memory-store'),\n        parallel: false,\n      },\n      {\n        name: 'storage',\n        hooks: agenticHookManager.getHooks('post-memory-store'),\n        parallel: true,\n      },\n      {\n        name: 'sync',\n        hooks: agenticHookManager.getHooks('memory-sync'),\n        parallel: true,\n        condition: (ctx) => ctx.metadata.crossProvider === true,\n      },\n    ],\n    errorStrategy: 'rollback',\n  });\n  \n  // Workflow Execution Pipeline\n  agenticHookManager.createPipeline({\n    id: 'workflow-execution-pipeline',\n    name: 'Workflow Execution Pipeline',\n    stages: [\n      {\n        name: 'initialization',\n        hooks: agenticHookManager.getHooks('workflow-start'),\n        parallel: false,\n      },\n      {\n        name: 'execution',\n        hooks: [\n          ...agenticHookManager.getHooks('workflow-step'),\n          ...agenticHookManager.getHooks('workflow-decision'),\n        ],\n        parallel: false,\n      },\n      {\n        name: 'completion',\n        hooks: agenticHookManager.getHooks('workflow-complete'),\n        parallel: true,\n      },\n    ],\n    errorStrategy: 'fail-fast',\n  });\n}\n\n/**\n * Start background metrics collection\n */\nfunction startMetricsCollection(): void {\n  // Collect metrics every 30 seconds\n  setInterval(() => {\n    const metrics = agenticHookManager.getMetrics();\n    \n    // Log high-level metrics\n    logger.debug('Hook system metrics:', {\n      totalHooks: metrics['hooks.count'],\n      totalExecutions: metrics['hooks.executions'],\n      errorRate: metrics['hooks.errors'] / metrics['hooks.executions'] || 0,\n      cacheHitRate: metrics['hooks.cacheHits'] / metrics['hooks.executions'] || 0,\n    });\n    \n    // Emit metrics event\n    agenticHookManager.emit('metrics:collected', metrics);\n  }, 30000);\n}\n\n/**\n * Shutdown the hook system gracefully\n */\nexport async function shutdownAgenticFlowHooks(): Promise<void> {\n  logger.info('Shutting down agentic-flow hook system...');\n  \n  try {\n    // Wait for active executions to complete\n    const maxWaitTime = 10000; // 10 seconds\n    const startTime = Date.now();\n    \n    while (agenticHookManager.getMetrics()['executions.active'] > 0) {\n      if (Date.now() - startTime > maxWaitTime) {\n        logger.warn('Timeout waiting for active executions to complete');\n        break;\n      }\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    // Remove all listeners\n    agenticHookManager.removeAllListeners();\n    \n    logger.info('Agentic-flow hook system shut down successfully');\n  } catch (error) {\n    logger.error('Error during hook system shutdown:', error);\n    throw error;\n  }\n}\n\n/**\n * Get hook system status\n */\nexport function getHookSystemStatus(): {\n  initialized: boolean;\n  metrics: Record<string, any>;\n  pipelines: string[];\n  activeExecutions: number;\n} {\n  const metrics = agenticHookManager.getMetrics();\n  \n  return {\n    initialized: metrics['hooks.count'] > 0,\n    metrics,\n    pipelines: [\n      'llm-call-pipeline',\n      'memory-operation-pipeline',\n      'workflow-execution-pipeline',\n    ],\n    activeExecutions: metrics['executions.active'] || 0,\n  };\n}\n\n/**\n * Create a context builder for hook execution\n */\nexport function createHookContext(): HookContextBuilder {\n  class ContextBuilder implements HookContextBuilder {\n    private context: Partial<AgenticHookContext> = {\n      timestamp: Date.now(),\n      correlationId: this.generateCorrelationId(),\n      metadata: {},\n    };\n    \n    withSession(sessionId: string): HookContextBuilder {\n      this.context.sessionId = sessionId;\n      return this;\n    }\n    \n    withMemory(namespace: string, provider: string): HookContextBuilder {\n      this.context.memory = {\n        namespace,\n        provider,\n        cache: new Map(),\n      };\n      return this;\n    }\n    \n    withNeural(modelId: string): HookContextBuilder {\n      this.context.neural = {\n        modelId,\n        patterns: this.createPatternStore(),\n        training: {\n          epoch: 0,\n          loss: 0,\n          accuracy: 0,\n          learningRate: 0.001,\n          optimizer: 'adam',\n          checkpoints: [],\n        },\n      };\n      return this;\n    }\n    \n    withPerformance(metrics: PerformanceMetric[]): HookContextBuilder {\n      const metricsMap = new Map<string, PerformanceMetric>();\n      metrics.forEach(m => metricsMap.set(m.name, m));\n      \n      this.context.performance = {\n        metrics: metricsMap,\n        bottlenecks: [],\n        optimizations: [],\n      };\n      return this;\n    }\n    \n    withMetadata(metadata: Record<string, any>): HookContextBuilder {\n      this.context.metadata = { ...this.context.metadata, ...metadata };\n      return this;\n    }\n    \n    build(): AgenticHookContext {\n      if (!this.context.sessionId) {\n        this.context.sessionId = this.generateSessionId();\n      }\n      \n      if (!this.context.memory) {\n        this.context.memory = {\n          namespace: 'default',\n          provider: 'memory',\n          cache: new Map(),\n        };\n      }\n      \n      if (!this.context.neural) {\n        this.context.neural = {\n          modelId: 'default',\n          patterns: this.createPatternStore(),\n          training: {\n            epoch: 0,\n            loss: 0,\n            accuracy: 0,\n            learningRate: 0.001,\n            optimizer: 'adam',\n            checkpoints: [],\n          },\n        };\n      }\n      \n      if (!this.context.performance) {\n        this.context.performance = {\n          metrics: new Map(),\n          bottlenecks: [],\n          optimizations: [],\n        };\n      }\n      \n      return this.context as AgenticHookContext;\n    }\n    \n    private generateCorrelationId(): string {\n      return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    private generateSessionId(): string {\n      return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    private createPatternStore(): PatternStore {\n      const patterns = new Map<string, Pattern>();\n      \n      return {\n        add(pattern: Pattern): void {\n          patterns.set(pattern.id, pattern);\n        },\n        \n        get(id: string): Pattern | undefined {\n          return patterns.get(id);\n        },\n        \n        findSimilar(pattern: Partial<Pattern>, threshold: number): Pattern[] {\n          const results: Pattern[] = [];\n          \n          for (const p of patterns.values()) {\n            // Simple similarity check\n            if (p.type === pattern.type && p.confidence >= threshold) {\n              results.push(p);\n            }\n          }\n          \n          return results;\n        },\n        \n        getByType(type: Pattern['type']): Pattern[] {\n          return Array.from(patterns.values()).filter(p => p.type === type);\n        },\n        \n        prune(maxAge: number): void {\n          const cutoff = Date.now() - maxAge;\n          for (const [id, pattern] of patterns) {\n            if (pattern.context.timestamp < cutoff) {\n              patterns.delete(id);\n            }\n          }\n        },\n        \n        export(): Pattern[] {\n          return Array.from(patterns.values());\n        },\n        \n        import(newPatterns: Pattern[]): void {\n          for (const pattern of newPatterns) {\n            patterns.set(pattern.id, pattern);\n          }\n        },\n      };\n    }\n  }\n  \n  return new ContextBuilder();\n}\n\n// Import types for the context builder\nimport type {\n  AgenticHookContext,\n  HookContextBuilder,\n  PatternStore,\n  Pattern,\n  PerformanceMetric,\n} from './types.js';"],
  "mappings": "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",
  "names": ["import_hook_manager"]
}
