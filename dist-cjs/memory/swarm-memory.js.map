{
  "version": 3,
  "sources": ["../../src/memory/swarm-memory.ts"],
  "sourcesContent": ["import { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { MemoryManager } from './manager.js';\nimport { EventBus } from '../core/event-bus.js';\nimport { generateId } from '../utils/helpers.js';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nexport interface SwarmMemoryEntry {\n  id: string;\n  agentId: string;\n  type: 'knowledge' | 'result' | 'state' | 'communication' | 'error';\n  content: any;\n  timestamp: Date;\n  metadata: {\n    taskId?: string;\n    objectiveId?: string;\n    tags?: string[];\n    priority?: number;\n    shareLevel?: 'private' | 'team' | 'public';\n  };\n}\n\nexport interface SwarmMemoryQuery {\n  agentId?: string;\n  type?: SwarmMemoryEntry['type'];\n  taskId?: string;\n  objectiveId?: string;\n  tags?: string[];\n  since?: Date;\n  before?: Date;\n  limit?: number;\n  shareLevel?: SwarmMemoryEntry['metadata']['shareLevel'];\n}\n\nexport interface SwarmKnowledgeBase {\n  id: string;\n  name: string;\n  description: string;\n  entries: SwarmMemoryEntry[];\n  metadata: {\n    domain: string;\n    expertise: string[];\n    contributors: string[];\n    lastUpdated: Date;\n  };\n}\n\nexport interface SwarmMemoryConfig {\n  namespace: string;\n  enableDistribution: boolean;\n  enableReplication: boolean;\n  syncInterval: number;\n  maxEntries: number;\n  compressionThreshold: number;\n  enableKnowledgeBase: boolean;\n  enableCrossAgentSharing: boolean;\n  persistencePath: string;\n}\n\nexport class SwarmMemoryManager extends EventEmitter {\n  private logger: Logger;\n  private config: SwarmMemoryConfig;\n  private baseMemory: MemoryManager;\n  private entries: Map<string, SwarmMemoryEntry>;\n  private knowledgeBases: Map<string, SwarmKnowledgeBase>;\n  private agentMemories: Map<string, Set<string>>; // agentId -> set of entry IDs\n  private syncTimer?: NodeJS.Timeout;\n  private isInitialized: boolean = false;\n\n  constructor(config: Partial<SwarmMemoryConfig> = {}) {\n    super();\n    this.logger = new Logger('SwarmMemoryManager');\n    this.config = {\n      namespace: 'swarm',\n      enableDistribution: true,\n      enableReplication: true,\n      syncInterval: 10000, // 10 seconds\n      maxEntries: 10000,\n      compressionThreshold: 1000,\n      enableKnowledgeBase: true,\n      enableCrossAgentSharing: true,\n      persistencePath: './swarm-memory',\n      ...config,\n    };\n\n    this.entries = new Map();\n    this.knowledgeBases = new Map();\n    this.agentMemories = new Map();\n\n    const eventBus = EventBus.getInstance();\n    this.baseMemory = new MemoryManager(\n      {\n        backend: 'sqlite',\n        namespace: this.config.namespace,\n        cacheSizeMB: 50,\n        syncOnExit: true,\n        maxEntries: this.config.maxEntries,\n        ttlMinutes: 60,\n      },\n      eventBus,\n      this.logger,\n    );\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    this.logger.info('Initializing swarm memory manager...');\n\n    // Initialize base memory\n    await this.baseMemory.initialize();\n\n    // Create persistence directory\n    await fs.mkdir(this.config.persistencePath, { recursive: true });\n\n    // Load existing memory\n    await this.loadMemoryState();\n\n    // Start sync timer\n    if (this.config.syncInterval > 0) {\n      this.syncTimer = setInterval(() => {\n        this.syncMemoryState();\n      }, this.config.syncInterval);\n    }\n\n    this.isInitialized = true;\n    this.emit('memory:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n\n    this.logger.info('Shutting down swarm memory manager...');\n\n    // Stop sync timer\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = undefined;\n    }\n\n    // Save final state\n    await this.saveMemoryState();\n\n    this.isInitialized = false;\n    this.emit('memory:shutdown');\n  }\n\n  async remember(\n    agentId: string,\n    type: SwarmMemoryEntry['type'],\n    content: any,\n    metadata: Partial<SwarmMemoryEntry['metadata']> = {},\n  ): Promise<string> {\n    const entryId = generateId('mem');\n    const entry: SwarmMemoryEntry = {\n      id: entryId,\n      agentId,\n      type,\n      content,\n      timestamp: new Date(),\n      metadata: {\n        shareLevel: 'team',\n        priority: 1,\n        ...metadata,\n      },\n    };\n\n    this.entries.set(entryId, entry);\n\n    // Associate with agent\n    if (!this.agentMemories.has(agentId)) {\n      this.agentMemories.set(agentId, new Set());\n    }\n    this.agentMemories.get(agentId)!.add(entryId);\n\n    // Store in base memory for persistence\n    await this.baseMemory.remember({\n      namespace: this.config.namespace,\n      key: `entry:${entryId}`,\n      content: JSON.stringify(entry),\n      metadata: {\n        type: 'swarm-memory',\n        agentId,\n        entryType: type,\n        shareLevel: entry.metadata.shareLevel,\n      },\n    });\n\n    this.logger.debug(`Agent ${agentId} remembered: ${type} - ${entryId}`);\n    this.emit('memory:added', entry);\n\n    // Update knowledge base if applicable\n    if (type === 'knowledge' && this.config.enableKnowledgeBase) {\n      await this.updateKnowledgeBase(entry);\n    }\n\n    // Check for memory limits\n    await this.enforceMemoryLimits();\n\n    return entryId;\n  }\n\n  async recall(query: SwarmMemoryQuery): Promise<SwarmMemoryEntry[]> {\n    let results = Array.from(this.entries.values());\n\n    // Apply filters\n    if (query.agentId) {\n      results = results.filter((e) => e.agentId === query.agentId);\n    }\n\n    if (query.type) {\n      results = results.filter((e) => e.type === query.type);\n    }\n\n    if (query.taskId) {\n      results = results.filter((e) => e.metadata.taskId === query.taskId);\n    }\n\n    if (query.objectiveId) {\n      results = results.filter((e) => e.metadata.objectiveId === query.objectiveId);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter(\n        (e) => e.metadata.tags && query.tags!.some((tag) => e.metadata.tags!.includes(tag)),\n      );\n    }\n\n    if (query.since) {\n      results = results.filter((e) => e.timestamp >= query.since!);\n    }\n\n    if (query.before) {\n      results = results.filter((e) => e.timestamp <= query.before!);\n    }\n\n    if (query.shareLevel) {\n      results = results.filter((e) => e.metadata.shareLevel === query.shareLevel);\n    }\n\n    // Sort by timestamp (newest first)\n    results.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    // Apply limit\n    if (query.limit) {\n      results = results.slice(0, query.limit);\n    }\n\n    this.logger.debug(`Recalled ${results.length} memories for query`);\n    return results;\n  }\n\n  async shareMemory(entryId: string, targetAgentId: string): Promise<void> {\n    const entry = this.entries.get(entryId);\n    if (!entry) {\n      throw new Error('Memory entry not found');\n    }\n\n    if (!this.config.enableCrossAgentSharing) {\n      throw new Error('Cross-agent sharing is disabled');\n    }\n\n    // Check share level permissions\n    if (entry.metadata.shareLevel === 'private') {\n      throw new Error('Memory entry is private and cannot be shared');\n    }\n\n    // Create a shared copy for the target agent\n    const sharedEntry: SwarmMemoryEntry = {\n      ...entry,\n      id: generateId('mem'),\n      metadata: {\n        ...entry.metadata,\n        originalId: entryId,\n        sharedFrom: entry.agentId,\n        sharedTo: targetAgentId,\n        sharedAt: new Date(),\n      },\n    };\n\n    this.entries.set(sharedEntry.id, sharedEntry);\n\n    // Associate with target agent\n    if (!this.agentMemories.has(targetAgentId)) {\n      this.agentMemories.set(targetAgentId, new Set());\n    }\n    this.agentMemories.get(targetAgentId)!.add(sharedEntry.id);\n\n    this.logger.info(`Shared memory ${entryId} from ${entry.agentId} to ${targetAgentId}`);\n    this.emit('memory:shared', { original: entry, shared: sharedEntry });\n  }\n\n  async broadcastMemory(entryId: string, agentIds?: string[]): Promise<void> {\n    const entry = this.entries.get(entryId);\n    if (!entry) {\n      throw new Error('Memory entry not found');\n    }\n\n    if (entry.metadata.shareLevel === 'private') {\n      throw new Error('Cannot broadcast private memory');\n    }\n\n    const targets =\n      agentIds || Array.from(this.agentMemories.keys()).filter((id) => id !== entry.agentId);\n\n    for (const targetId of targets) {\n      try {\n        await this.shareMemory(entryId, targetId);\n      } catch (error) {\n        this.logger.warn(`Failed to share memory to ${targetId}:`, error);\n      }\n    }\n\n    this.logger.info(`Broadcasted memory ${entryId} to ${targets.length} agents`);\n  }\n\n  async createKnowledgeBase(\n    name: string,\n    description: string,\n    domain: string,\n    expertise: string[],\n  ): Promise<string> {\n    const kbId = generateId('kb');\n    const knowledgeBase: SwarmKnowledgeBase = {\n      id: kbId,\n      name,\n      description,\n      entries: [],\n      metadata: {\n        domain,\n        expertise,\n        contributors: [],\n        lastUpdated: new Date(),\n      },\n    };\n\n    this.knowledgeBases.set(kbId, knowledgeBase);\n\n    this.logger.info(`Created knowledge base: ${name} (${kbId})`);\n    this.emit('knowledgebase:created', knowledgeBase);\n\n    return kbId;\n  }\n\n  async updateKnowledgeBase(entry: SwarmMemoryEntry): Promise<void> {\n    if (!this.config.enableKnowledgeBase) return;\n\n    // Find relevant knowledge bases\n    const relevantKBs = Array.from(this.knowledgeBases.values()).filter((kb) => {\n      // Simple matching based on tags and content\n      const tags = entry.metadata.tags || [];\n      return tags.some((tag) =>\n        kb.metadata.expertise.some(\n          (exp) =>\n            exp.toLowerCase().includes(tag.toLowerCase()) ||\n            tag.toLowerCase().includes(exp.toLowerCase()),\n        ),\n      );\n    });\n\n    for (const kb of relevantKBs) {\n      // Add entry to knowledge base\n      kb.entries.push(entry);\n      kb.metadata.lastUpdated = new Date();\n\n      // Add contributor\n      if (!kb.metadata.contributors.includes(entry.agentId)) {\n        kb.metadata.contributors.push(entry.agentId);\n      }\n\n      this.logger.debug(`Updated knowledge base ${kb.id} with entry ${entry.id}`);\n    }\n  }\n\n  async searchKnowledge(\n    query: string,\n    domain?: string,\n    expertise?: string[],\n  ): Promise<SwarmMemoryEntry[]> {\n    const allEntries: SwarmMemoryEntry[] = [];\n\n    // Search in knowledge bases\n    for (const kb of this.knowledgeBases.values()) {\n      if (domain && kb.metadata.domain !== domain) continue;\n\n      if (expertise && !expertise.some((exp) => kb.metadata.expertise.includes(exp))) {\n        continue;\n      }\n\n      allEntries.push(...kb.entries);\n    }\n\n    // Simple text search (in real implementation, use better search)\n    const queryLower = query.toLowerCase();\n    const results = allEntries.filter((entry) => {\n      const contentStr = JSON.stringify(entry.content).toLowerCase();\n      return contentStr.includes(queryLower);\n    });\n\n    return results.slice(0, 50); // Limit results\n  }\n\n  async getAgentMemorySnapshot(agentId: string): Promise<{\n    totalEntries: number;\n    recentEntries: SwarmMemoryEntry[];\n    knowledgeContributions: number;\n    sharedEntries: number;\n  }> {\n    const agentEntryIds = this.agentMemories.get(agentId) || new Set();\n    const agentEntries = Array.from(agentEntryIds)\n      .map((id) => this.entries.get(id))\n      .filter(Boolean) as SwarmMemoryEntry[];\n\n    const recentEntries = agentEntries\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(0, 10);\n\n    const knowledgeContributions = agentEntries.filter((e) => e.type === 'knowledge').length;\n\n    const sharedEntries = agentEntries.filter(\n      (e) => e.metadata.shareLevel === 'public' || e.metadata.shareLevel === 'team',\n    ).length;\n\n    return {\n      totalEntries: agentEntries.length,\n      recentEntries,\n      knowledgeContributions,\n      sharedEntries,\n    };\n  }\n\n  private async loadMemoryState(): Promise<void> {\n    try {\n      // Load entries\n      const entriesFile = path.join(this.config.persistencePath, 'entries.json');\n      try {\n        const entriesData = await fs.readFile(entriesFile, 'utf-8');\n        const entriesArray = JSON.parse(entriesData);\n\n        for (const entry of entriesArray) {\n          this.entries.set(entry.id, {\n            ...entry,\n            timestamp: new Date(entry.timestamp),\n          });\n\n          // Rebuild agent memory associations\n          if (!this.agentMemories.has(entry.agentId)) {\n            this.agentMemories.set(entry.agentId, new Set());\n          }\n          this.agentMemories.get(entry.agentId)!.add(entry.id);\n        }\n\n        this.logger.info(`Loaded ${entriesArray.length} memory entries`);\n      } catch (error) {\n        this.logger.warn('No existing memory entries found');\n      }\n\n      // Load knowledge bases\n      const kbFile = path.join(this.config.persistencePath, 'knowledge-bases.json');\n      try {\n        const kbData = await fs.readFile(kbFile, 'utf-8');\n        const kbArray = JSON.parse(kbData);\n\n        for (const kb of kbArray) {\n          this.knowledgeBases.set(kb.id, {\n            ...kb,\n            metadata: {\n              ...kb.metadata,\n              lastUpdated: new Date(kb.metadata.lastUpdated),\n            },\n            entries: kb.entries.map((e: any) => ({\n              ...e,\n              timestamp: new Date(e.timestamp),\n            })),\n          });\n        }\n\n        this.logger.info(`Loaded ${kbArray.length} knowledge bases`);\n      } catch (error) {\n        this.logger.warn('No existing knowledge bases found');\n      }\n    } catch (error) {\n      this.logger.error('Error loading memory state:', error);\n    }\n  }\n\n  private async saveMemoryState(): Promise<void> {\n    try {\n      // Save entries\n      const entriesArray = Array.from(this.entries.values());\n      const entriesFile = path.join(this.config.persistencePath, 'entries.json');\n      await fs.writeFile(entriesFile, JSON.stringify(entriesArray, null, 2));\n\n      // Save knowledge bases\n      const kbArray = Array.from(this.knowledgeBases.values());\n      const kbFile = path.join(this.config.persistencePath, 'knowledge-bases.json');\n      await fs.writeFile(kbFile, JSON.stringify(kbArray, null, 2));\n\n      this.logger.debug('Saved memory state to disk');\n    } catch (error) {\n      this.logger.error('Error saving memory state:', error);\n    }\n  }\n\n  private async syncMemoryState(): Promise<void> {\n    try {\n      await this.saveMemoryState();\n      this.emit('memory:synced');\n    } catch (error) {\n      this.logger.error('Error syncing memory state:', error);\n    }\n  }\n\n  private async enforceMemoryLimits(): Promise<void> {\n    if (this.entries.size <= this.config.maxEntries) return;\n\n    this.logger.info('Enforcing memory limits...');\n\n    // Remove oldest entries that are not marked as important\n    const entries = Array.from(this.entries.values())\n      .filter((e) => (e.metadata.priority || 1) <= 1) // Only remove low priority\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    const toRemove = entries.slice(0, this.entries.size - this.config.maxEntries);\n\n    for (const entry of toRemove) {\n      this.entries.delete(entry.id);\n\n      // Remove from agent memory\n      const agentEntries = this.agentMemories.get(entry.agentId);\n      if (agentEntries) {\n        agentEntries.delete(entry.id);\n      }\n\n      this.logger.debug(`Removed old memory entry: ${entry.id}`);\n    }\n\n    this.emit('memory:cleaned', toRemove.length);\n  }\n\n  // Public API methods\n  getMemoryStats(): {\n    totalEntries: number;\n    entriesByType: Record<string, number>;\n    entriesByAgent: Record<string, number>;\n    knowledgeBases: number;\n    memoryUsage: number;\n  } {\n    const entries = Array.from(this.entries.values());\n    const entriesByType: Record<string, number> = {};\n    const entriesByAgent: Record<string, number> = {};\n\n    for (const entry of entries) {\n      entriesByType[entry.type] = (entriesByType[entry.type] || 0) + 1;\n      entriesByAgent[entry.agentId] = (entriesByAgent[entry.agentId] || 0) + 1;\n    }\n\n    // Rough memory usage calculation\n    const memoryUsage = JSON.stringify(entries).length;\n\n    return {\n      totalEntries: entries.length,\n      entriesByType,\n      entriesByAgent,\n      knowledgeBases: this.knowledgeBases.size,\n      memoryUsage,\n    };\n  }\n\n  async exportMemory(agentId?: string): Promise<any> {\n    const entries = agentId ? await this.recall({ agentId }) : Array.from(this.entries.values());\n\n    return {\n      entries,\n      knowledgeBases: agentId\n        ? Array.from(this.knowledgeBases.values()).filter((kb) =>\n            kb.metadata.contributors.includes(agentId),\n          )\n        : Array.from(this.knowledgeBases.values()),\n      exportedAt: new Date(),\n      stats: this.getMemoryStats(),\n    };\n  }\n\n  async clearMemory(agentId?: string): Promise<void> {\n    if (agentId) {\n      // Clear specific agent's memory\n      const entryIds = this.agentMemories.get(agentId) || new Set();\n      for (const entryId of entryIds) {\n        this.entries.delete(entryId);\n      }\n      this.agentMemories.delete(agentId);\n      this.logger.info(`Cleared memory for agent ${agentId}`);\n    } else {\n      // Clear all memory\n      this.entries.clear();\n      this.agentMemories.clear();\n      this.knowledgeBases.clear();\n      this.logger.info('Cleared all swarm memory');\n    }\n\n    this.emit('memory:cleared', { agentId });\n  }\n\n  // Compatibility methods for hive.ts\n  async store(key: string, value: any): Promise<void> {\n    // Extract namespace and actual key from the path\n    const parts = key.split('/');\n    const type = (parts[0] as SwarmMemoryEntry['type']) || 'state';\n    const agentId = parts[1] || 'system';\n\n    await this.remember(agentId, type, value, {\n      tags: [parts[0], parts[1]].filter(Boolean),\n      shareLevel: 'team',\n    });\n  }\n\n  async search(pattern: string, limit: number = 10): Promise<any[]> {\n    // Simple pattern matching on stored keys/content\n    const results: any[] = [];\n\n    for (const entry of this.entries.values()) {\n      const entryString = JSON.stringify(entry);\n      if (entryString.includes(pattern.replace('*', ''))) {\n        results.push(entry.content);\n        if (results.length >= limit) break;\n      }\n    }\n\n    return results;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
