{"version":3,"sources":["../../../src/communication/message-bus.ts"],"sourcesContent":["/**\r\n * Advanced messaging and communication layer for swarm coordination\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport type { IEventBus } from '../core/event-bus.js';\r\nimport type { SwarmEvent, EventType, AgentId, CommunicationStrategy } from '../swarm/types.js';\r\nimport { generateId } from '../utils/helpers.js';\r\n\r\nexport interface MessageBusConfig {\r\n  strategy: CommunicationStrategy;\r\n  enablePersistence: boolean;\r\n  enableReliability: boolean;\r\n  enableOrdering: boolean;\r\n  enableFiltering: boolean;\r\n  maxMessageSize: number;\r\n  maxQueueSize: number;\r\n  messageRetention: number;\r\n  acknowledgmentTimeout: number;\r\n  retryAttempts: number;\r\n  backoffMultiplier: number;\r\n  compressionEnabled: boolean;\r\n  encryptionEnabled: boolean;\r\n  metricsEnabled: boolean;\r\n  debugMode: boolean;\r\n}\r\n\r\nexport interface Message {\r\n  id: string;\r\n  type: string;\r\n  sender: AgentId;\r\n  receivers: AgentId[];\r\n  content: any;\r\n  metadata: MessageMetadata;\r\n  timestamp: Date;\r\n  expiresAt?: Date;\r\n  priority: MessagePriority;\r\n  reliability: ReliabilityLevel;\r\n}\r\n\r\nexport interface MessageMetadata {\r\n  correlationId?: string;\r\n  causationId?: string;\r\n  replyTo?: string;\r\n  ttl?: number;\r\n  compressed: boolean;\r\n  encrypted: boolean;\r\n  size: number;\r\n  contentType: string;\r\n  encoding: string;\r\n  checksum?: string;\r\n  route?: string[];\r\n  deadLetterReason?: string;\r\n  deadLetterTimestamp?: Date;\r\n}\r\n\r\nexport interface MessageChannel {\r\n  id: string;\r\n  name: string;\r\n  type: ChannelType;\r\n  participants: AgentId[];\r\n  config: ChannelConfig;\r\n  statistics: ChannelStatistics;\r\n  filters: MessageFilter[];\r\n  middleware: ChannelMiddleware[];\r\n}\r\n\r\nexport interface ChannelConfig {\r\n  persistent: boolean;\r\n  ordered: boolean;\r\n  reliable: boolean;\r\n  maxParticipants: number;\r\n  maxMessageSize: number;\r\n  maxQueueDepth: number;\r\n  retentionPeriod: number;\r\n  accessControl: AccessControlConfig;\r\n}\r\n\r\nexport interface AccessControlConfig {\r\n  readPermission: 'public' | 'participants' | 'restricted';\r\n  writePermission: 'public' | 'participants' | 'restricted';\r\n  adminPermission: 'creator' | 'administrators' | 'system';\r\n  allowedSenders: AgentId[];\r\n  allowedReceivers: AgentId[];\r\n  bannedAgents: AgentId[];\r\n}\r\n\r\nexport interface ChannelStatistics {\r\n  messagesTotal: number;\r\n  messagesDelivered: number;\r\n  messagesFailed: number;\r\n  bytesTransferred: number;\r\n  averageLatency: number;\r\n  throughput: number;\r\n  errorRate: number;\r\n  participantCount: number;\r\n  lastActivity: Date;\r\n}\r\n\r\nexport interface MessageFilter {\r\n  id: string;\r\n  name: string;\r\n  enabled: boolean;\r\n  conditions: FilterCondition[];\r\n  action: 'allow' | 'deny' | 'modify' | 'route';\r\n  priority: number;\r\n}\r\n\r\nexport interface FilterCondition {\r\n  field: string;\r\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches' | 'in';\r\n  value: any;\r\n  caseSensitive?: boolean;\r\n}\r\n\r\nexport interface ChannelMiddleware {\r\n  id: string;\r\n  name: string;\r\n  enabled: boolean;\r\n  order: number;\r\n  process: (message: Message, context: MiddlewareContext) => Promise<Message | null>;\r\n}\r\n\r\nexport interface MiddlewareContext {\r\n  channel: MessageChannel;\r\n  direction: 'inbound' | 'outbound';\r\n  agent: AgentId;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface MessageQueue {\r\n  id: string;\r\n  name: string;\r\n  type: QueueType;\r\n  messages: Message[];\r\n  config: QueueConfig;\r\n  subscribers: QueueSubscriber[];\r\n  statistics: QueueStatistics;\r\n}\r\n\r\nexport interface QueueConfig {\r\n  maxSize: number;\r\n  persistent: boolean;\r\n  ordered: boolean;\r\n  durability: 'memory' | 'disk' | 'distributed';\r\n  deliveryMode: 'at-most-once' | 'at-least-once' | 'exactly-once';\r\n  deadLetterQueue?: string;\r\n  retryPolicy: RetryPolicy;\r\n}\r\n\r\nexport interface QueueSubscriber {\r\n  id: string;\r\n  agent: AgentId;\r\n  filter?: MessageFilter;\r\n  ackMode: 'auto' | 'manual';\r\n  prefetchCount: number;\r\n  lastActivity: Date;\r\n}\r\n\r\nexport interface QueueStatistics {\r\n  depth: number;\r\n  enqueueRate: number;\r\n  dequeueRate: number;\r\n  throughput: number;\r\n  averageWaitTime: number;\r\n  subscriberCount: number;\r\n  deadLetterCount: number;\r\n}\r\n\r\nexport interface RetryPolicy {\r\n  maxAttempts: number;\r\n  initialDelay: number;\r\n  maxDelay: number;\r\n  backoffMultiplier: number;\r\n  jitter: boolean;\r\n}\r\n\r\nexport interface TopicSubscription {\r\n  id: string;\r\n  topic: string;\r\n  subscriber: AgentId;\r\n  filter?: MessageFilter;\r\n  ackRequired: boolean;\r\n  qos: QualityOfService;\r\n  createdAt: Date;\r\n  lastMessage?: Date;\r\n}\r\n\r\nexport interface RoutingRule {\r\n  id: string;\r\n  name: string;\r\n  enabled: boolean;\r\n  priority: number;\r\n  conditions: FilterCondition[];\r\n  actions: RoutingAction[];\r\n}\r\n\r\nexport interface RoutingAction {\r\n  type: 'forward' | 'duplicate' | 'transform' | 'aggregate' | 'delay';\r\n  target?: string;\r\n  config: Record<string, any>;\r\n}\r\n\r\nexport type MessagePriority = 'low' | 'normal' | 'high' | 'critical';\r\nexport type ReliabilityLevel = 'best-effort' | 'at-least-once' | 'exactly-once';\r\nexport type ChannelType = 'direct' | 'broadcast' | 'multicast' | 'topic' | 'queue';\r\nexport type QueueType = 'fifo' | 'lifo' | 'priority' | 'delay' | 'round-robin';\r\nexport type QualityOfService = 0 | 1 | 2; // MQTT-style QoS levels\r\n\r\n/**\r\n * Advanced message bus with support for multiple communication patterns\r\n */\r\nexport class MessageBus extends EventEmitter {\r\n  private logger: ILogger;\r\n  private eventBus: IEventBus;\r\n  private config: MessageBusConfig;\r\n\r\n  // Core messaging components\r\n  private channels = new Map<string, MessageChannel>();\r\n  private queues = new Map<string, MessageQueue>();\r\n  private subscriptions = new Map<string, TopicSubscription>();\r\n  private routingRules = new Map<string, RoutingRule>();\r\n\r\n  // Message tracking\r\n  private messageStore = new Map<string, Message>();\r\n  private deliveryReceipts = new Map<string, DeliveryReceipt>();\r\n  private acknowledgments = new Map<string, MessageAcknowledgment>();\r\n\r\n  // Routing and delivery\r\n  private router: MessageRouter;\r\n  private deliveryManager: DeliveryManager;\r\n  private retryManager: RetryManager;\r\n\r\n  // Performance monitoring\r\n  private metrics: MessageBusMetrics;\r\n  private metricsInterval?: NodeJS.Timeout;\r\n\r\n  constructor(config: Partial<MessageBusConfig>, logger: ILogger, eventBus: IEventBus) {\r\n    super();\r\n    this.logger = logger;\r\n    this.eventBus = eventBus;\r\n\r\n    this.config = {\r\n      strategy: 'event-driven',\r\n      enablePersistence: true,\r\n      enableReliability: true,\r\n      enableOrdering: false,\r\n      enableFiltering: true,\r\n      maxMessageSize: 1024 * 1024, // 1MB\r\n      maxQueueSize: 10000,\r\n      messageRetention: 86400000, // 24 hours\r\n      acknowledgmentTimeout: 30000,\r\n      retryAttempts: 3,\r\n      backoffMultiplier: 2,\r\n      compressionEnabled: false,\r\n      encryptionEnabled: false,\r\n      metricsEnabled: true,\r\n      debugMode: false,\r\n      ...config,\r\n    };\r\n\r\n    this.router = new MessageRouter(this.config, this.logger);\r\n    this.deliveryManager = new DeliveryManager(this.config, this.logger);\r\n    this.retryManager = new RetryManager(this.config, this.logger);\r\n    this.metrics = new MessageBusMetrics();\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.eventBus.on('agent:connected', (data) => {\r\n      if (hasAgentId(data)) {\r\n        this.handleAgentConnected(data.agentId);\r\n      }\r\n    });\r\n\r\n    this.eventBus.on('agent:disconnected', (data) => {\r\n      if (hasAgentId(data)) {\r\n        this.handleAgentDisconnected(data.agentId);\r\n      }\r\n    });\r\n\r\n    this.deliveryManager.on('delivery:success', (data) => {\r\n      this.handleDeliverySuccess(data);\r\n    });\r\n\r\n    this.deliveryManager.on('delivery:failure', (data) => {\r\n      this.handleDeliveryFailure(data);\r\n    });\r\n\r\n    this.retryManager.on('retry:exhausted', (data) => {\r\n      this.handleRetryExhausted(data);\r\n    });\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing message bus', {\r\n      strategy: this.config.strategy,\r\n      persistence: this.config.enablePersistence,\r\n      reliability: this.config.enableReliability,\r\n    });\r\n\r\n    // Initialize components\r\n    await this.router.initialize();\r\n    await this.deliveryManager.initialize();\r\n    await this.retryManager.initialize();\r\n\r\n    // Create default channels\r\n    await this.createDefaultChannels();\r\n\r\n    // Start metrics collection\r\n    if (this.config.metricsEnabled) {\r\n      this.startMetricsCollection();\r\n    }\r\n\r\n    this.emit('messagebus:initialized');\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down message bus');\r\n\r\n    // Stop metrics collection\r\n    if (this.metricsInterval) {\r\n      clearInterval(this.metricsInterval);\r\n    }\r\n\r\n    // Shutdown components\r\n    await this.retryManager.shutdown();\r\n    await this.deliveryManager.shutdown();\r\n    await this.router.shutdown();\r\n\r\n    // Persist any remaining messages if enabled\r\n    if (this.config.enablePersistence) {\r\n      await this.persistMessages();\r\n    }\r\n\r\n    this.emit('messagebus:shutdown');\r\n  }\r\n\r\n  // === MESSAGE OPERATIONS ===\r\n\r\n  async sendMessage(\r\n    type: string,\r\n    content: any,\r\n    sender: AgentId,\r\n    receivers: AgentId | AgentId[],\r\n    options: {\r\n      priority?: MessagePriority;\r\n      reliability?: ReliabilityLevel;\r\n      ttl?: number;\r\n      correlationId?: string;\r\n      replyTo?: string;\r\n      channel?: string;\r\n    } = {},\r\n  ): Promise<string> {\r\n    const messageId = generateId('msg');\r\n    const now = new Date();\r\n\r\n    const receiversArray = Array.isArray(receivers) ? receivers : [receivers];\r\n\r\n    const message: Message = {\r\n      id: messageId,\r\n      type,\r\n      sender,\r\n      receivers: receiversArray,\r\n      content: await this.processContent(content),\r\n      metadata: {\r\n        correlationId: options.correlationId,\r\n        replyTo: options.replyTo,\r\n        ttl: options.ttl,\r\n        compressed: this.config.compressionEnabled,\r\n        encrypted: this.config.encryptionEnabled,\r\n        size: this.calculateSize(content),\r\n        contentType: this.detectContentType(content),\r\n        encoding: 'utf-8',\r\n        route: [sender.id],\r\n      },\r\n      timestamp: now,\r\n      expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\r\n      priority: options.priority || 'normal',\r\n      reliability: options.reliability || 'best-effort',\r\n    };\r\n\r\n    // Validate message\r\n    this.validateMessage(message);\r\n\r\n    // Store message if persistence is enabled\r\n    if (this.config.enablePersistence) {\r\n      this.messageStore.set(messageId, message);\r\n    }\r\n\r\n    // Route and deliver message\r\n    await this.routeMessage(message, options.channel);\r\n\r\n    this.metrics.recordMessageSent(message);\r\n\r\n    this.logger.debug('Message sent', {\r\n      messageId,\r\n      type,\r\n      sender: sender.id,\r\n      receivers: receiversArray.map((r) => r.id),\r\n      size: message.metadata.size,\r\n    });\r\n\r\n    this.emit('message:sent', { message });\r\n\r\n    return messageId;\r\n  }\r\n\r\n  async broadcastMessage(\r\n    type: string,\r\n    content: any,\r\n    sender: AgentId,\r\n    options: {\r\n      channel?: string;\r\n      filter?: MessageFilter;\r\n      priority?: MessagePriority;\r\n      ttl?: number;\r\n    } = {},\r\n  ): Promise<string> {\r\n    const channel = options.channel\r\n      ? this.channels.get(options.channel)\r\n      : this.getDefaultBroadcastChannel();\r\n\r\n    if (!channel) {\r\n      throw new Error('No broadcast channel available');\r\n    }\r\n\r\n    // Get all participants as receivers\r\n    let receivers = channel.participants.filter((p) => p.id !== sender.id);\r\n\r\n    // Apply filter if provided\r\n    if (options.filter) {\r\n      receivers = await this.filterReceivers(receivers, options.filter, { type, content });\r\n    }\r\n\r\n    return this.sendMessage(type, content, sender, receivers, {\r\n      priority: options.priority,\r\n      ttl: options.ttl,\r\n      channel: channel.id,\r\n    });\r\n  }\r\n\r\n  async subscribeToTopic(\r\n    topic: string,\r\n    subscriber: AgentId,\r\n    options: {\r\n      filter?: MessageFilter;\r\n      qos?: QualityOfService;\r\n      ackRequired?: boolean;\r\n    } = {},\r\n  ): Promise<string> {\r\n    const subscriptionId = generateId('sub');\r\n\r\n    const subscription: TopicSubscription = {\r\n      id: subscriptionId,\r\n      topic,\r\n      subscriber,\r\n      filter: options.filter,\r\n      ackRequired: options.ackRequired || false,\r\n      qos: options.qos || 0,\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    this.subscriptions.set(subscriptionId, subscription);\r\n\r\n    this.logger.info('Topic subscription created', {\r\n      subscriptionId,\r\n      topic,\r\n      subscriber: subscriber.id,\r\n      qos: subscription.qos,\r\n    });\r\n\r\n    this.emit('subscription:created', { subscription });\r\n\r\n    return subscriptionId;\r\n  }\r\n\r\n  async unsubscribeFromTopic(subscriptionId: string): Promise<void> {\r\n    const subscription = this.subscriptions.get(subscriptionId);\r\n    if (!subscription) {\r\n      throw new Error(`Subscription ${subscriptionId} not found`);\r\n    }\r\n\r\n    this.subscriptions.delete(subscriptionId);\r\n\r\n    this.logger.info('Topic subscription removed', {\r\n      subscriptionId,\r\n      topic: subscription.topic,\r\n      subscriber: subscription.subscriber.id,\r\n    });\r\n\r\n    this.emit('subscription:removed', { subscription });\r\n  }\r\n\r\n  async acknowledgeMessage(messageId: string, agentId: AgentId): Promise<void> {\r\n    const message = this.messageStore.get(messageId);\r\n    if (!message) {\r\n      throw new Error(`Message ${messageId} not found`);\r\n    }\r\n\r\n    const ack: MessageAcknowledgment = {\r\n      messageId,\r\n      agentId,\r\n      timestamp: new Date(),\r\n      status: 'acknowledged',\r\n    };\r\n\r\n    this.acknowledgments.set(`${messageId}:${agentId.id}`, ack);\r\n\r\n    this.logger.debug('Message acknowledged', {\r\n      messageId,\r\n      agentId: agentId.id,\r\n    });\r\n\r\n    this.emit('message:acknowledged', { messageId, agentId });\r\n\r\n    // Check if all receivers have acknowledged\r\n    this.checkAllAcknowledgments(message);\r\n  }\r\n\r\n  // === CHANNEL MANAGEMENT ===\r\n\r\n  async createChannel(\r\n    name: string,\r\n    type: ChannelType,\r\n    config: Partial<ChannelConfig> = {},\r\n  ): Promise<string> {\r\n    const channelId = generateId('channel');\r\n\r\n    const channel: MessageChannel = {\r\n      id: channelId,\r\n      name,\r\n      type,\r\n      participants: [],\r\n      config: {\r\n        persistent: true,\r\n        ordered: false,\r\n        reliable: true,\r\n        maxParticipants: 1000,\r\n        maxMessageSize: this.config.maxMessageSize,\r\n        maxQueueDepth: this.config.maxQueueSize,\r\n        retentionPeriod: this.config.messageRetention,\r\n        accessControl: {\r\n          readPermission: 'participants',\r\n          writePermission: 'participants',\r\n          adminPermission: 'creator',\r\n          allowedSenders: [],\r\n          allowedReceivers: [],\r\n          bannedAgents: [],\r\n        },\r\n        ...config,\r\n      },\r\n      statistics: this.createChannelStatistics(),\r\n      filters: [],\r\n      middleware: [],\r\n    };\r\n\r\n    this.channels.set(channelId, channel);\r\n\r\n    this.logger.info('Channel created', {\r\n      channelId,\r\n      name,\r\n      type,\r\n      config: channel.config,\r\n    });\r\n\r\n    this.emit('channel:created', { channel });\r\n\r\n    return channelId;\r\n  }\r\n\r\n  async joinChannel(channelId: string, agentId: AgentId): Promise<void> {\r\n    const channel = this.channels.get(channelId);\r\n    if (!channel) {\r\n      throw new Error(`Channel ${channelId} not found`);\r\n    }\r\n\r\n    // Check access permissions\r\n    if (!this.canJoinChannel(channel, agentId)) {\r\n      throw new Error(`Agent ${agentId.id} not allowed to join channel ${channelId}`);\r\n    }\r\n\r\n    // Check capacity\r\n    if (channel.participants.length >= channel.config.maxParticipants) {\r\n      throw new Error(`Channel ${channelId} is at capacity`);\r\n    }\r\n\r\n    // Add participant if not already present\r\n    if (!channel.participants.some((p) => p.id === agentId.id)) {\r\n      channel.participants.push(agentId);\r\n      channel.statistics.participantCount = channel.participants.length;\r\n    }\r\n\r\n    this.logger.info('Agent joined channel', {\r\n      channelId,\r\n      agentId: agentId.id,\r\n      participantCount: channel.participants.length,\r\n    });\r\n\r\n    this.emit('channel:joined', { channelId, agentId });\r\n  }\r\n\r\n  async leaveChannel(channelId: string, agentId: AgentId): Promise<void> {\r\n    const channel = this.channels.get(channelId);\r\n    if (!channel) {\r\n      throw new Error(`Channel ${channelId} not found`);\r\n    }\r\n\r\n    // Remove participant\r\n    channel.participants = channel.participants.filter((p) => p.id !== agentId.id);\r\n    channel.statistics.participantCount = channel.participants.length;\r\n\r\n    this.logger.info('Agent left channel', {\r\n      channelId,\r\n      agentId: agentId.id,\r\n      participantCount: channel.participants.length,\r\n    });\r\n\r\n    this.emit('channel:left', { channelId, agentId });\r\n  }\r\n\r\n  // === QUEUE MANAGEMENT ===\r\n\r\n  async createQueue(\r\n    name: string,\r\n    type: QueueType,\r\n    config: Partial<QueueConfig> = {},\r\n  ): Promise<string> {\r\n    const queueId = generateId('queue');\r\n\r\n    const queue: MessageQueue = {\r\n      id: queueId,\r\n      name,\r\n      type,\r\n      messages: [],\r\n      config: {\r\n        maxSize: this.config.maxQueueSize,\r\n        persistent: this.config.enablePersistence,\r\n        ordered: this.config.enableOrdering,\r\n        durability: 'memory',\r\n        deliveryMode: 'at-least-once',\r\n        retryPolicy: {\r\n          maxAttempts: this.config.retryAttempts,\r\n          initialDelay: 1000,\r\n          maxDelay: 30000,\r\n          backoffMultiplier: this.config.backoffMultiplier,\r\n          jitter: true,\r\n        },\r\n        ...config,\r\n      },\r\n      subscribers: [],\r\n      statistics: this.createQueueStatistics(),\r\n    };\r\n\r\n    this.queues.set(queueId, queue);\r\n\r\n    this.logger.info('Queue created', {\r\n      queueId,\r\n      name,\r\n      type,\r\n      config: queue.config,\r\n    });\r\n\r\n    this.emit('queue:created', { queue });\r\n\r\n    return queueId;\r\n  }\r\n\r\n  async enqueueMessage(queueId: string, message: Message): Promise<void> {\r\n    const queue = this.queues.get(queueId);\r\n    if (!queue) {\r\n      throw new Error(`Queue ${queueId} not found`);\r\n    }\r\n\r\n    // Check queue capacity\r\n    if (queue.messages.length >= queue.config.maxSize) {\r\n      if (queue.config.deadLetterQueue) {\r\n        await this.sendToDeadLetterQueue(queue.config.deadLetterQueue, message, 'queue_full');\r\n        return;\r\n      } else {\r\n        throw new Error(`Queue ${queueId} is full`);\r\n      }\r\n    }\r\n\r\n    // Insert message based on queue type\r\n    this.insertMessageInQueue(queue, message);\r\n\r\n    queue.statistics.depth = queue.messages.length;\r\n    queue.statistics.enqueueRate++;\r\n\r\n    this.logger.debug('Message enqueued', {\r\n      queueId,\r\n      messageId: message.id,\r\n      queueDepth: queue.messages.length,\r\n    });\r\n\r\n    this.emit('message:enqueued', { queueId, message });\r\n\r\n    // Process queue for delivery\r\n    await this.processQueue(queue);\r\n  }\r\n\r\n  async dequeueMessage(queueId: string, subscriberId: string): Promise<Message | null> {\r\n    const queue = this.queues.get(queueId);\r\n    if (!queue) {\r\n      throw new Error(`Queue ${queueId} not found`);\r\n    }\r\n\r\n    const subscriber = queue.subscribers.find((s) => s.id === subscriberId);\r\n    if (!subscriber) {\r\n      throw new Error(`Subscriber ${subscriberId} not found in queue ${queueId}`);\r\n    }\r\n\r\n    // Find next eligible message\r\n    let message: Message | null = null;\r\n    let messageIndex = -1;\r\n\r\n    for (let i = 0; i < queue.messages.length; i++) {\r\n      const msg = queue.messages[i];\r\n\r\n      // Check if message matches subscriber filter\r\n      if (subscriber.filter && !this.matchesFilter(msg, subscriber.filter)) {\r\n        continue;\r\n      }\r\n\r\n      message = msg;\r\n      messageIndex = i;\r\n      break;\r\n    }\r\n\r\n    if (!message) {\r\n      return null;\r\n    }\r\n\r\n    // Remove message from queue (for at-least-once, remove after ack)\r\n    if (queue.config.deliveryMode === 'at-most-once') {\r\n      queue.messages.splice(messageIndex, 1);\r\n    }\r\n\r\n    queue.statistics.depth = queue.messages.length;\r\n    queue.statistics.dequeueRate++;\r\n    subscriber.lastActivity = new Date();\r\n\r\n    this.logger.debug('Message dequeued', {\r\n      queueId,\r\n      messageId: message.id,\r\n      subscriberId,\r\n      queueDepth: queue.messages.length,\r\n    });\r\n\r\n    this.emit('message:dequeued', { queueId, message, subscriberId });\r\n\r\n    return message;\r\n  }\r\n\r\n  // === ROUTING AND DELIVERY ===\r\n\r\n  private async routeMessage(message: Message, preferredChannel?: string): Promise<void> {\r\n    // Apply routing rules\r\n    const route = await this.router.calculateRoute(message, preferredChannel);\r\n\r\n    // Update message route\r\n    message.metadata.route = [...(message.metadata.route || []), ...route.hops];\r\n\r\n    // Deliver to targets\r\n    for (const target of route.targets) {\r\n      await this.deliverMessage(message, target);\r\n    }\r\n  }\r\n\r\n  private async deliverMessage(message: Message, target: DeliveryTarget): Promise<void> {\r\n    try {\r\n      await this.deliveryManager.deliver(message, target);\r\n      this.metrics.recordDeliverySuccess(message);\r\n    } catch (error) {\r\n      this.metrics.recordDeliveryFailure(message);\r\n\r\n      // Handle delivery failure based on reliability level\r\n      if (message.reliability !== 'best-effort') {\r\n        await this.retryManager.scheduleRetry(message, target, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // === UTILITY METHODS ===\r\n\r\n  private validateMessage(message: Message): void {\r\n    if (message.metadata.size > this.config.maxMessageSize) {\r\n      throw new Error(\r\n        `Message size ${message.metadata.size} exceeds limit ${this.config.maxMessageSize}`,\r\n      );\r\n    }\r\n\r\n    if (message.expiresAt && message.expiresAt <= new Date()) {\r\n      throw new Error('Message has already expired');\r\n    }\r\n\r\n    if (message.receivers.length === 0) {\r\n      throw new Error('Message must have at least one receiver');\r\n    }\r\n  }\r\n\r\n  private async processContent(content: any): Promise<any> {\r\n    let processed = content;\r\n\r\n    // Compress if enabled\r\n    if (this.config.compressionEnabled) {\r\n      processed = await this.compress(processed);\r\n    }\r\n\r\n    // Encrypt if enabled\r\n    if (this.config.encryptionEnabled) {\r\n      processed = await this.encrypt(processed);\r\n    }\r\n\r\n    return processed;\r\n  }\r\n\r\n  private calculateSize(content: any): number {\r\n    return JSON.stringify(content).length;\r\n  }\r\n\r\n  private detectContentType(content: any): string {\r\n    if (typeof content === 'string') return 'text/plain';\r\n    if (typeof content === 'object') return 'application/json';\r\n    if (Buffer.isBuffer(content)) return 'application/octet-stream';\r\n    return 'application/unknown';\r\n  }\r\n\r\n  private async filterReceivers(\r\n    receivers: AgentId[],\r\n    filter: MessageFilter,\r\n    context: any,\r\n  ): Promise<AgentId[]> {\r\n    // Placeholder for receiver filtering logic\r\n    return receivers;\r\n  }\r\n\r\n  private canJoinChannel(channel: MessageChannel, agentId: AgentId): boolean {\r\n    const acl = channel.config.accessControl;\r\n\r\n    // Check banned list\r\n    if (acl.bannedAgents.some((banned) => banned.id === agentId.id)) {\r\n      return false;\r\n    }\r\n\r\n    // Check allowed list (if specified)\r\n    if (acl.allowedSenders.length > 0) {\r\n      return acl.allowedSenders.some((allowed) => allowed.id === agentId.id);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private matchesFilter(message: Message, filter: MessageFilter): boolean {\r\n    return filter.conditions.every((condition) => {\r\n      const fieldValue = this.getFieldValue(message, condition.field);\r\n      return this.evaluateCondition(fieldValue, condition.operator, condition.value);\r\n    });\r\n  }\r\n\r\n  private getFieldValue(message: Message, field: string): any {\r\n    const parts = field.split('.');\r\n    let value: any = message;\r\n\r\n    for (const part of parts) {\r\n      value = value?.[part];\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  private evaluateCondition(fieldValue: any, operator: string, compareValue: any): boolean {\r\n    switch (operator) {\r\n      case 'eq':\r\n        return fieldValue === compareValue;\r\n      case 'ne':\r\n        return fieldValue !== compareValue;\r\n      case 'gt':\r\n        return fieldValue > compareValue;\r\n      case 'lt':\r\n        return fieldValue < compareValue;\r\n      case 'contains':\r\n        return String(fieldValue).includes(String(compareValue));\r\n      case 'matches':\r\n        return new RegExp(compareValue).test(String(fieldValue));\r\n      case 'in':\r\n        return Array.isArray(compareValue) && compareValue.includes(fieldValue);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private insertMessageInQueue(queue: MessageQueue, message: Message): void {\r\n    switch (queue.type) {\r\n      case 'fifo':\r\n        queue.messages.push(message);\r\n        break;\r\n      case 'lifo':\r\n        queue.messages.unshift(message);\r\n        break;\r\n      case 'priority':\r\n        this.insertByPriority(queue.messages, message);\r\n        break;\r\n      case 'delay':\r\n        this.insertByTimestamp(queue.messages, message);\r\n        break;\r\n      default:\r\n        queue.messages.push(message);\r\n    }\r\n  }\r\n\r\n  private insertByPriority(messages: Message[], message: Message): void {\r\n    const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };\r\n    const messagePriority = priorityOrder[message.priority];\r\n\r\n    let insertIndex = messages.length;\r\n    for (let i = 0; i < messages.length; i++) {\r\n      const currentPriority = priorityOrder[messages[i].priority];\r\n      if (messagePriority < currentPriority) {\r\n        insertIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    messages.splice(insertIndex, 0, message);\r\n  }\r\n\r\n  private insertByTimestamp(messages: Message[], message: Message): void {\r\n    const targetTime = message.expiresAt || message.timestamp;\r\n\r\n    let insertIndex = messages.length;\r\n    for (let i = 0; i < messages.length; i++) {\r\n      const currentTime = messages[i].expiresAt || messages[i].timestamp;\r\n      if (targetTime <= currentTime) {\r\n        insertIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    messages.splice(insertIndex, 0, message);\r\n  }\r\n\r\n  private async processQueue(queue: MessageQueue): Promise<void> {\r\n    // Process messages for subscribers\r\n    for (const subscriber of queue.subscribers) {\r\n      if (subscriber.prefetchCount > 0) {\r\n        // Deliver up to prefetch count\r\n        for (let i = 0; i < subscriber.prefetchCount; i++) {\r\n          const message = await this.dequeueMessage(queue.id, subscriber.id);\r\n          if (!message) break;\r\n\r\n          await this.deliverMessageToSubscriber(message, subscriber);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async deliverMessageToSubscriber(\r\n    message: Message,\r\n    subscriber: QueueSubscriber,\r\n  ): Promise<void> {\r\n    try {\r\n      // Deliver message to subscriber\r\n      this.emit('message:delivered', {\r\n        message,\r\n        subscriber: subscriber.agent,\r\n      });\r\n\r\n      // Handle acknowledgment if required\r\n      if (subscriber.ackMode === 'auto') {\r\n        await this.acknowledgeMessage(message.id, subscriber.agent);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to deliver message to subscriber', {\r\n        messageId: message.id,\r\n        subscriberId: subscriber.id,\r\n        error,\r\n      });\r\n    }\r\n  }\r\n\r\n  private checkAllAcknowledgments(message: Message): void {\r\n    const requiredAcks = message.receivers.length;\r\n    const receivedAcks = message.receivers.filter((receiver) =>\r\n      this.acknowledgments.has(`${message.id}:${receiver.id}`),\r\n    ).length;\r\n\r\n    if (receivedAcks === requiredAcks) {\r\n      this.emit('message:fully-acknowledged', { message });\r\n\r\n      // Clean up acknowledgments\r\n      message.receivers.forEach((receiver) => {\r\n        this.acknowledgments.delete(`${message.id}:${receiver.id}`);\r\n      });\r\n    }\r\n  }\r\n\r\n  private async createDefaultChannels(): Promise<void> {\r\n    // System broadcast channel\r\n    await this.createChannel('system-broadcast', 'broadcast', {\r\n      persistent: true,\r\n      reliable: true,\r\n      maxParticipants: 10000,\r\n    });\r\n\r\n    // Agent coordination channel\r\n    await this.createChannel('agent-coordination', 'multicast', {\r\n      persistent: true,\r\n      reliable: true,\r\n      ordered: true,\r\n    });\r\n\r\n    // Task distribution channel\r\n    await this.createChannel('task-distribution', 'topic', {\r\n      persistent: true,\r\n      reliable: false,\r\n    });\r\n  }\r\n\r\n  private getDefaultBroadcastChannel(): MessageChannel | undefined {\r\n    return Array.from(this.channels.values()).find((channel) => channel.type === 'broadcast');\r\n  }\r\n\r\n  private createChannelStatistics(): ChannelStatistics {\r\n    return {\r\n      messagesTotal: 0,\r\n      messagesDelivered: 0,\r\n      messagesFailed: 0,\r\n      bytesTransferred: 0,\r\n      averageLatency: 0,\r\n      throughput: 0,\r\n      errorRate: 0,\r\n      participantCount: 0,\r\n      lastActivity: new Date(),\r\n    };\r\n  }\r\n\r\n  private createQueueStatistics(): QueueStatistics {\r\n    return {\r\n      depth: 0,\r\n      enqueueRate: 0,\r\n      dequeueRate: 0,\r\n      throughput: 0,\r\n      averageWaitTime: 0,\r\n      subscriberCount: 0,\r\n      deadLetterCount: 0,\r\n    };\r\n  }\r\n\r\n  private startMetricsCollection(): void {\r\n    this.metricsInterval = setInterval(() => {\r\n      this.updateMetrics();\r\n    }, 10000); // Every 10 seconds\r\n  }\r\n\r\n  private updateMetrics(): void {\r\n    // Update channel statistics\r\n    for (const channel of this.channels.values()) {\r\n      // Calculate throughput, latency, etc.\r\n      this.updateChannelStatistics(channel);\r\n    }\r\n\r\n    // Update queue statistics\r\n    for (const queue of this.queues.values()) {\r\n      this.updateQueueStatistics(queue);\r\n    }\r\n\r\n    // Emit metrics event\r\n    this.emit('metrics:updated', { metrics: this.getMetrics() });\r\n  }\r\n\r\n  private updateChannelStatistics(channel: MessageChannel): void {\r\n    // Placeholder for channel statistics calculation\r\n    channel.statistics.lastActivity = new Date();\r\n  }\r\n\r\n  private updateQueueStatistics(queue: MessageQueue): void {\r\n    // Placeholder for queue statistics calculation\r\n    queue.statistics.depth = queue.messages.length;\r\n  }\r\n\r\n  private handleAgentConnected(agentId: AgentId): void {\r\n    this.logger.info('Agent connected to message bus', { agentId: agentId.id });\r\n    this.emit('agent:connected', { agentId });\r\n  }\r\n\r\n  private handleAgentDisconnected(agentId: AgentId): void {\r\n    this.logger.info('Agent disconnected from message bus', { agentId: agentId.id });\r\n\r\n    // Remove from all channels\r\n    for (const channel of this.channels.values()) {\r\n      channel.participants = channel.participants.filter((p) => p.id !== agentId.id);\r\n    }\r\n\r\n    // Remove subscriptions\r\n    for (const [subId, subscription] of this.subscriptions) {\r\n      if (subscription.subscriber.id === agentId.id) {\r\n        this.subscriptions.delete(subId);\r\n      }\r\n    }\r\n\r\n    this.emit('agent:disconnected', { agentId });\r\n  }\r\n\r\n  private handleDeliverySuccess(data: any): void {\r\n    this.metrics.recordDeliverySuccess(data.message);\r\n  }\r\n\r\n  private handleDeliveryFailure(data: any): void {\r\n    this.metrics.recordDeliveryFailure(data.message);\r\n  }\r\n\r\n  private handleRetryExhausted(data: any): void {\r\n    this.logger.error('Message delivery retry exhausted', {\r\n      messageId: data.message.id,\r\n      target: data.target,\r\n    });\r\n\r\n    // Send to dead letter queue if configured\r\n    this.sendToDeadLetterQueue('system-dlq', data.message, 'retry_exhausted');\r\n  }\r\n\r\n  private async sendToDeadLetterQueue(\r\n    queueId: string,\r\n    message: Message,\r\n    reason: string,\r\n  ): Promise<void> {\r\n    try {\r\n      message.metadata.deadLetterReason = reason;\r\n      message.metadata.deadLetterTimestamp = new Date();\r\n\r\n      await this.enqueueMessage(queueId, message);\r\n    } catch (error) {\r\n      this.logger.error('Failed to send message to dead letter queue', {\r\n        messageId: message.id,\r\n        queueId,\r\n        reason,\r\n        error,\r\n      });\r\n    }\r\n  }\r\n\r\n  private async compress(content: any): Promise<any> {\r\n    // Placeholder for compression\r\n    return content;\r\n  }\r\n\r\n  private async encrypt(content: any): Promise<any> {\r\n    // Placeholder for encryption\r\n    return content;\r\n  }\r\n\r\n  private async persistMessages(): Promise<void> {\r\n    // Placeholder for message persistence\r\n    this.logger.info('Persisting messages', { count: this.messageStore.size });\r\n  }\r\n\r\n  // === PUBLIC API ===\r\n\r\n  getChannel(channelId: string): MessageChannel | undefined {\r\n    return this.channels.get(channelId);\r\n  }\r\n\r\n  getAllChannels(): MessageChannel[] {\r\n    return Array.from(this.channels.values());\r\n  }\r\n\r\n  getQueue(queueId: string): MessageQueue | undefined {\r\n    return this.queues.get(queueId);\r\n  }\r\n\r\n  getAllQueues(): MessageQueue[] {\r\n    return Array.from(this.queues.values());\r\n  }\r\n\r\n  getSubscription(subscriptionId: string): TopicSubscription | undefined {\r\n    return this.subscriptions.get(subscriptionId);\r\n  }\r\n\r\n  getAllSubscriptions(): TopicSubscription[] {\r\n    return Array.from(this.subscriptions.values());\r\n  }\r\n\r\n  getMetrics(): any {\r\n    return {\r\n      channels: this.channels.size,\r\n      queues: this.queues.size,\r\n      subscriptions: this.subscriptions.size,\r\n      storedMessages: this.messageStore.size,\r\n      deliveryReceipts: this.deliveryReceipts.size,\r\n      acknowledgments: this.acknowledgments.size,\r\n      busMetrics: this.metrics.getMetrics(),\r\n    };\r\n  }\r\n\r\n  getMessage(messageId: string): Message | undefined {\r\n    return this.messageStore.get(messageId);\r\n  }\r\n\r\n  async addChannelFilter(channelId: string, filter: MessageFilter): Promise<void> {\r\n    const channel = this.channels.get(channelId);\r\n    if (!channel) {\r\n      throw new Error(`Channel ${channelId} not found`);\r\n    }\r\n\r\n    channel.filters.push(filter);\r\n    channel.filters.sort((a, b) => a.priority - b.priority);\r\n  }\r\n\r\n  async addChannelMiddleware(channelId: string, middleware: ChannelMiddleware): Promise<void> {\r\n    const channel = this.channels.get(channelId);\r\n    if (!channel) {\r\n      throw new Error(`Channel ${channelId} not found`);\r\n    }\r\n\r\n    channel.middleware.push(middleware);\r\n    channel.middleware.sort((a, b) => a.order - b.order);\r\n  }\r\n}\r\n\r\n// === HELPER CLASSES ===\r\n\r\ninterface DeliveryReceipt {\r\n  messageId: string;\r\n  target: string;\r\n  status: 'delivered' | 'failed' | 'pending';\r\n  timestamp: Date;\r\n  attempts: number;\r\n  error?: string;\r\n}\r\n\r\ninterface MessageAcknowledgment {\r\n  messageId: string;\r\n  agentId: AgentId;\r\n  timestamp: Date;\r\n  status: 'acknowledged' | 'rejected';\r\n}\r\n\r\ninterface DeliveryTarget {\r\n  type: 'agent' | 'channel' | 'queue' | 'topic';\r\n  id: string;\r\n  address?: string;\r\n}\r\n\r\ninterface RouteResult {\r\n  targets: DeliveryTarget[];\r\n  hops: string[];\r\n  cost: number;\r\n}\r\n\r\nclass MessageRouter {\r\n  constructor(\r\n    private config: MessageBusConfig,\r\n    private logger: ILogger,\r\n  ) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    this.logger.debug('Message router initialized');\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.debug('Message router shutdown');\r\n  }\r\n\r\n  async calculateRoute(message: Message, preferredChannel?: string): Promise<RouteResult> {\r\n    const targets: DeliveryTarget[] = [];\r\n    const hops: string[] = [];\r\n\r\n    // Simple routing - direct to receivers\r\n    for (const receiver of message.receivers) {\r\n      targets.push({\r\n        type: 'agent',\r\n        id: receiver.id,\r\n      });\r\n      hops.push(receiver.id);\r\n    }\r\n\r\n    return {\r\n      targets,\r\n      hops,\r\n      cost: targets.length,\r\n    };\r\n  }\r\n}\r\n\r\nclass DeliveryManager extends EventEmitter {\r\n  constructor(\r\n    private config: MessageBusConfig,\r\n    private logger: ILogger,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    this.logger.debug('Delivery manager initialized');\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.debug('Delivery manager shutdown');\r\n  }\r\n\r\n  async deliver(message: Message, target: DeliveryTarget): Promise<void> {\r\n    // Simulate delivery\r\n    this.logger.debug('Delivering message', {\r\n      messageId: message.id,\r\n      target: target.id,\r\n      type: target.type,\r\n    });\r\n\r\n    // Emit delivery success\r\n    this.emit('delivery:success', { message, target });\r\n  }\r\n}\r\n\r\nclass RetryManager extends EventEmitter {\r\n  private retryQueue: Array<{ message: Message; target: DeliveryTarget; attempts: number }> = [];\r\n  private retryInterval?: NodeJS.Timeout;\r\n\r\n  constructor(\r\n    private config: MessageBusConfig,\r\n    private logger: ILogger,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    this.startRetryProcessor();\r\n    this.logger.debug('Retry manager initialized');\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    if (this.retryInterval) {\r\n      clearInterval(this.retryInterval);\r\n    }\r\n    this.logger.debug('Retry manager shutdown');\r\n  }\r\n\r\n  async scheduleRetry(message: Message, target: DeliveryTarget, error: any): Promise<void> {\r\n    const existingEntry = this.retryQueue.find(\r\n      (entry) => entry.message.id === message.id && entry.target.id === target.id,\r\n    );\r\n\r\n    if (existingEntry) {\r\n      existingEntry.attempts++;\r\n    } else {\r\n      this.retryQueue.push({ message, target, attempts: 1 });\r\n    }\r\n\r\n    this.logger.debug('Retry scheduled', {\r\n      messageId: message.id,\r\n      target: target.id,\r\n      error: error instanceof Error ? error.message : String(error),\r\n    });\r\n  }\r\n\r\n  private startRetryProcessor(): void {\r\n    this.retryInterval = setInterval(() => {\r\n      this.processRetries();\r\n    }, 5000); // Process retries every 5 seconds\r\n  }\r\n\r\n  private async processRetries(): Promise<void> {\r\n    const now = Date.now();\r\n    const toRetry = this.retryQueue.filter((entry) => {\r\n      const delay = this.calculateDelay(entry.attempts);\r\n      return now >= entry.message.timestamp.getTime() + delay;\r\n    });\r\n\r\n    for (const entry of toRetry) {\r\n      if (entry.attempts >= this.config.retryAttempts) {\r\n        // Remove from retry queue and emit exhausted event\r\n        this.retryQueue = this.retryQueue.filter((r) => r !== entry);\r\n        this.emit('retry:exhausted', entry);\r\n      } else {\r\n        // Retry delivery\r\n        try {\r\n          // Simulate retry delivery\r\n          this.logger.debug('Retrying message delivery', {\r\n            messageId: entry.message.id,\r\n            attempt: entry.attempts,\r\n          });\r\n\r\n          // Remove from retry queue on success\r\n          this.retryQueue = this.retryQueue.filter((r) => r !== entry);\r\n        } catch (error) {\r\n          // Keep in retry queue for next attempt\r\n          this.logger.warn('Retry attempt failed', {\r\n            messageId: entry.message.id,\r\n            attempt: entry.attempts,\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private calculateDelay(attempts: number): number {\r\n    const baseDelay = 1000; // 1 second\r\n    return Math.min(\r\n      baseDelay * Math.pow(this.config.backoffMultiplier, attempts - 1),\r\n      30000, // Max 30 seconds\r\n    );\r\n  }\r\n}\r\n\r\nclass MessageBusMetrics {\r\n  private messagesSent = 0;\r\n  private messagesDelivered = 0;\r\n  private messagesFailed = 0;\r\n  private bytesTransferred = 0;\r\n  private deliveryLatencies: number[] = [];\r\n\r\n  recordMessageSent(message: Message): void {\r\n    this.messagesSent++;\r\n    this.bytesTransferred += message.metadata.size;\r\n  }\r\n\r\n  recordDeliverySuccess(message: Message): void {\r\n    this.messagesDelivered++;\r\n    const latency = Date.now() - message.timestamp.getTime();\r\n    this.deliveryLatencies.push(latency);\r\n\r\n    // Keep only last 1000 latencies\r\n    if (this.deliveryLatencies.length > 1000) {\r\n      this.deliveryLatencies.shift();\r\n    }\r\n  }\r\n\r\n  recordDeliveryFailure(message: Message): void {\r\n    this.messagesFailed++;\r\n  }\r\n\r\n  getMetrics(): any {\r\n    const avgLatency =\r\n      this.deliveryLatencies.length > 0\r\n        ? this.deliveryLatencies.reduce((sum, lat) => sum + lat, 0) / this.deliveryLatencies.length\r\n        : 0;\r\n\r\n    return {\r\n      messagesSent: this.messagesSent,\r\n      messagesDelivered: this.messagesDelivered,\r\n      messagesFailed: this.messagesFailed,\r\n      bytesTransferred: this.bytesTransferred,\r\n      averageLatency: avgLatency,\r\n      successRate: this.messagesSent > 0 ? (this.messagesDelivered / this.messagesSent) * 100 : 100,\r\n    };\r\n  }\r\n}\r\n"],"names":["EventEmitter","generateId","MessageBus","logger","eventBus","config","channels","Map","queues","subscriptions","routingRules","messageStore","deliveryReceipts","acknowledgments","router","deliveryManager","retryManager","metrics","metricsInterval","strategy","enablePersistence","enableReliability","enableOrdering","enableFiltering","maxMessageSize","maxQueueSize","messageRetention","acknowledgmentTimeout","retryAttempts","backoffMultiplier","compressionEnabled","encryptionEnabled","metricsEnabled","debugMode","MessageRouter","DeliveryManager","RetryManager","MessageBusMetrics","setupEventHandlers","on","data","hasAgentId","handleAgentConnected","agentId","handleAgentDisconnected","handleDeliverySuccess","handleDeliveryFailure","handleRetryExhausted","initialize","info","persistence","reliability","createDefaultChannels","startMetricsCollection","emit","shutdown","clearInterval","persistMessages","sendMessage","type","content","sender","receivers","options","messageId","now","Date","receiversArray","Array","isArray","message","id","processContent","metadata","correlationId","replyTo","ttl","compressed","encrypted","size","calculateSize","contentType","detectContentType","encoding","route","timestamp","expiresAt","getTime","undefined","priority","validateMessage","set","routeMessage","channel","recordMessageSent","debug","map","r","broadcastMessage","get","getDefaultBroadcastChannel","Error","participants","filter","p","filterReceivers","subscribeToTopic","topic","subscriber","subscriptionId","subscription","ackRequired","qos","createdAt","unsubscribeFromTopic","delete","acknowledgeMessage","ack","status","checkAllAcknowledgments","createChannel","name","channelId","persistent","ordered","reliable","maxParticipants","maxQueueDepth","retentionPeriod","accessControl","readPermission","writePermission","adminPermission","allowedSenders","allowedReceivers","bannedAgents","statistics","createChannelStatistics","filters","middleware","joinChannel","canJoinChannel","length","some","push","participantCount","leaveChannel","createQueue","queueId","queue","messages","maxSize","durability","deliveryMode","retryPolicy","maxAttempts","initialDelay","maxDelay","jitter","subscribers","createQueueStatistics","enqueueMessage","deadLetterQueue","sendToDeadLetterQueue","insertMessageInQueue","depth","enqueueRate","queueDepth","processQueue","dequeueMessage","subscriberId","find","s","messageIndex","i","msg","matchesFilter","splice","dequeueRate","lastActivity","preferredChannel","calculateRoute","hops","target","targets","deliverMessage","deliver","recordDeliverySuccess","error","recordDeliveryFailure","scheduleRetry","processed","compress","encrypt","JSON","stringify","Buffer","isBuffer","context","acl","banned","allowed","conditions","every","condition","fieldValue","getFieldValue","field","evaluateCondition","operator","value","parts","split","part","compareValue","String","includes","RegExp","test","unshift","insertByPriority","insertByTimestamp","priorityOrder","critical","high","normal","low","messagePriority","insertIndex","currentPriority","targetTime","currentTime","prefetchCount","deliverMessageToSubscriber","agent","ackMode","requiredAcks","receivedAcks","receiver","has","forEach","from","values","messagesTotal","messagesDelivered","messagesFailed","bytesTransferred","averageLatency","throughput","errorRate","averageWaitTime","subscriberCount","deadLetterCount","setInterval","updateMetrics","updateChannelStatistics","updateQueueStatistics","getMetrics","subId","reason","deadLetterReason","deadLetterTimestamp","count","getChannel","getAllChannels","getQueue","getAllQueues","getSubscription","getAllSubscriptions","storedMessages","busMetrics","getMessage","addChannelFilter","sort","a","b","addChannelMiddleware","order","cost","retryQueue","retryInterval","startRetryProcessor","existingEntry","entry","attempts","processRetries","toRetry","delay","calculateDelay","attempt","warn","baseDelay","Math","min","pow","messagesSent","deliveryLatencies","latency","shift","avgLatency","reduce","sum","lat","successRate"],"mappings":"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"}