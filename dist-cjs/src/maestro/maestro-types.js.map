{"version":3,"sources":["../../../src/maestro/maestro-types.ts"],"sourcesContent":["export interface MaestroSpec {\r\n  name: string;\r\n  description: string;\r\n  version: string;\r\n  goals: string[];\r\n  workflow: WorkflowPhase[];\r\n}\r\n\r\nexport interface WorkflowPhase {\r\n  step: string;\r\n  agent: string; // Name of the sub-agent\r\n  input?: string;\r\n  input_from?: string; // Reference to previous step's output\r\n  input_transform?: string;\r\n  output_format: string;\r\n  next_step_on_success?: string;\r\n  parallel_tasks?: Array<{ task: string; agent: string; input: string }>;\r\n  environment?: string;\r\n  on_failure?: string;\r\n}\r\n\r\nexport interface TaskItem {\r\n  id: string;\r\n  description: string;\r\n  status: 'pending' | 'in-progress' | 'completed' | 'failed';\r\n  assignedAgent?: string;\r\n  dependencies?: string[];\r\n  priority: number;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface AgentProfile {\r\n  id: string;\r\n  name: string;\r\n  type: string;\r\n  capabilities: string[];\r\n  maxConcurrentTasks: number;\r\n  priority: number;\r\n}\r\n\r\nexport interface SteeringContext {\r\n  domain: string;\r\n  guidelines: string;\r\n  constraints: string[];\r\n  examples?: string[];\r\n}\r\n\r\nexport type WorkflowPhase = \r\n  | 'Requirements Clarification'\r\n  | 'Research & Design'\r\n  | 'Implementation Planning'\r\n  | 'Task Execution'\r\n  | 'Completed';\r\n\r\nexport interface MaestroWorkflowState {\r\n  featureName: string;\r\n  currentPhase: WorkflowPhase;\r\n  currentTaskIndex: number;\r\n  status: 'idle' | 'running' | 'paused' | 'completed' | 'failed';\r\n  lastActivity: Date;\r\n  history: Array<{ phase: WorkflowPhase; status: 'completed' | 'failed' | 'in-progress' | 'approved'; timestamp: Date; output?: any; error?: string }>;\r\n  // Add more state as needed, e.g., for human-in-the-loop gates\r\n}\r\n\r\n// ===== KIRO ENHANCEMENT TYPES =====\r\n\r\nexport interface KiroEnhancedSpec extends MaestroSpec {\r\n  livingDocumentation: LivingDocumentationConfig;\r\n  agentHooks: AgentHookConfig[];\r\n  consensusRequirements: ConsensusRequirements;\r\n  patternLearning: PatternLearningConfig;\r\n  enhancedMetadata: SpecMetadata;\r\n}\r\n\r\nexport interface LivingDocumentationConfig {\r\n  enabled: boolean;\r\n  syncMode: 'bidirectional' | 'spec-to-code' | 'code-to-spec';\r\n  autoUpdateThreshold: number; // 0-1, how much change triggers auto-update\r\n  conflictResolution: 'manual' | 'spec-wins' | 'code-wins' | 'merge';\r\n  versionTracking: boolean;\r\n  changeDetectionGranularity: 'file' | 'function' | 'line';\r\n  realTimeSync: boolean;\r\n  watchPatterns: string[]; // File patterns to watch\r\n  excludePatterns: string[]; // File patterns to exclude\r\n}\r\n\r\nexport interface AgentHookConfig {\r\n  type: 'file-change' | 'code-quality' | 'documentation' | 'testing' | 'deployment';\r\n  trigger: HookTrigger;\r\n  actions: HookAction[];\r\n  conditions: HookCondition[];\r\n  priority: number;\r\n  enabled: boolean;\r\n  agentTypes: string[]; // Which agent types should handle this hook\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface HookTrigger {\r\n  event: 'file-modified' | 'file-created' | 'file-deleted' | 'git-commit' | 'test-failed' | 'build-failed';\r\n  patterns: string[]; // File patterns or other patterns\r\n  debounceMs: number; // Debounce multiple triggers\r\n  batchingEnabled: boolean;\r\n  conditions?: string[]; // Additional trigger conditions\r\n}\r\n\r\nexport interface HookAction {\r\n  type: 'spawn-agent' | 'update-spec' | 'run-tests' | 'generate-docs' | 'quality-check';\r\n  agentType: string;\r\n  parameters: Record<string, any>;\r\n  timeout: number;\r\n  retryCount: number;\r\n  background: boolean;\r\n}\r\n\r\nexport interface HookCondition {\r\n  type: 'file-size' | 'file-age' | 'git-status' | 'test-status' | 'custom';\r\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches';\r\n  value: any;\r\n  negate?: boolean;\r\n}\r\n\r\nexport interface ConsensusRequirements {\r\n  enabled: boolean;\r\n  algorithm: 'simple-majority' | 'weighted-vote' | 'byzantine-fault-tolerant' | 'raft';\r\n  minimumAgents: number;\r\n  quorumPercentage: number; // 0-1, what percentage needed for consensus\r\n  timeoutMs: number;\r\n  retryCount: number;\r\n  validatorAgentTypes: string[];\r\n  consensusScope: 'design-phase' | 'implementation-phase' | 'all-phases';\r\n  conflictResolution: 'revote' | 'escalate' | 'fallback-to-human';\r\n}\r\n\r\nexport interface PatternLearningConfig {\r\n  enabled: boolean;\r\n  learningMode: 'passive' | 'active' | 'hybrid';\r\n  dataCollection: {\r\n    specHistory: boolean;\r\n    designDecisions: boolean;\r\n    implementationOutcomes: boolean;\r\n    userFeedback: boolean;\r\n  };\r\n  modelType: 'rule-based' | 'ml-based' | 'hybrid';\r\n  adaptationThreshold: number; // How much data before adapting\r\n  confidenceThreshold: number; // Minimum confidence for suggestions\r\n}\r\n\r\nexport interface SpecMetadata {\r\n  createdAt: Date;\r\n  lastModified: Date;\r\n  version: string;\r\n  contributors: string[];\r\n  reviewers: string[];\r\n  approvalStatus: 'draft' | 'under-review' | 'approved' | 'deprecated';\r\n  tags: string[];\r\n  relatedSpecs: string[];\r\n  implementationStatus: {\r\n    phase: string;\r\n    progress: number; // 0-1\r\n    quality: number; // 0-1\r\n    testCoverage: number; // 0-1\r\n  };\r\n  metrics: {\r\n    cycleTime: number; // ms from spec to implementation\r\n    defectRate: number;\r\n    changeFrequency: number;\r\n    stakeholderSatisfaction: number; // 0-1\r\n  };\r\n}\r\n\r\n// ===== ENHANCED WORKFLOW TYPES =====\r\n\r\nexport interface EnhancedWorkflowPhase extends WorkflowPhase {\r\n  hooks: AgentHookConfig[];\r\n  consensusRequired: boolean;\r\n  livingDocSync: boolean;\r\n  patternLearningEnabled: boolean;\r\n  qualityGates: QualityGate[];\r\n  parallelExecution: boolean;\r\n  backgroundMonitoring: boolean;\r\n}\r\n\r\nexport interface QualityGate {\r\n  id: string;\r\n  name: string;\r\n  type: 'automated' | 'manual' | 'hybrid';\r\n  criteria: QualityCriteria[];\r\n  threshold: number; // 0-1\r\n  blocking: boolean; // Does failure block progression?\r\n  agentTypes: string[]; // Which agents can validate this gate\r\n}\r\n\r\nexport interface QualityCriteria {\r\n  metric: string;\r\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';\r\n  value: number;\r\n  weight: number; // 0-1, importance of this criteria\r\n  source: 'automated-test' | 'code-analysis' | 'human-review' | 'consensus';\r\n}\r\n\r\n// ===== LIVING DOCUMENTATION TYPES =====\r\n\r\nexport interface LivingDocumentationState {\r\n  specVersion: string;\r\n  codeVersion: string;\r\n  lastSyncTimestamp: Date;\r\n  syncStatus: 'in-sync' | 'diverged' | 'syncing' | 'conflict';\r\n  changesSinceLastSync: DocumentationChange[];\r\n  conflicts: SyncConflict[];\r\n  automatedSyncEnabled: boolean;\r\n}\r\n\r\nexport interface DocumentationChange {\r\n  id: string;\r\n  type: 'spec-change' | 'code-change';\r\n  file: string;\r\n  section?: string;\r\n  oldValue: string;\r\n  newValue: string;\r\n  timestamp: Date;\r\n  author: string;\r\n  confidence: number; // 0-1, how confident we are about this change\r\n}\r\n\r\nexport interface SyncConflict {\r\n  id: string;\r\n  type: 'content-conflict' | 'structural-conflict' | 'semantic-conflict';\r\n  specSection: string;\r\n  codeSection: string;\r\n  description: string;\r\n  resolutionStrategy: 'manual' | 'spec-wins' | 'code-wins' | 'merge';\r\n  priority: 'low' | 'medium' | 'high';\r\n  createdAt: Date;\r\n}\r\n\r\n// ===== CONSENSUS SYSTEM TYPES =====\r\n\r\nexport interface ConsensusSession {\r\n  id: string;\r\n  topic: string;\r\n  participants: ConsensusParticipant[];\r\n  status: 'pending' | 'active' | 'completed' | 'failed' | 'timeout';\r\n  startedAt: Date;\r\n  completedAt?: Date;\r\n  result?: ConsensusResult;\r\n  rounds: ConsensusRound[];\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface ConsensusParticipant {\r\n  agentId: string;\r\n  agentType: string;\r\n  weight: number; // Voting weight based on expertise\r\n  reliability: number; // 0-1, historical reliability\r\n  expertise: Record<string, number>; // Domain expertise scores\r\n  availability: boolean;\r\n}\r\n\r\nexport interface ConsensusRound {\r\n  round: number;\r\n  votes: ConsensusVote[];\r\n  result: 'consensus' | 'no-consensus' | 'timeout';\r\n  timestamp: Date;\r\n  convergenceMetric: number; // How close to consensus\r\n}\r\n\r\nexport interface ConsensusVote {\r\n  agentId: string;\r\n  option: string;\r\n  confidence: number; // 0-1\r\n  reasoning: string;\r\n  timestamp: Date;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface ConsensusResult {\r\n  decision: string;\r\n  confidence: number; // 0-1\r\n  unanimity: boolean;\r\n  participationRate: number; // 0-1\r\n  qualityScore: number; // 0-1\r\n  dissents: ConsensusDissent[];\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface ConsensusDissent {\r\n  agentId: string;\r\n  reason: string;\r\n  alternativeProposal?: string;\r\n  severity: 'low' | 'medium' | 'high';\r\n}\r\n\r\n// ===== AGENT HOOK SYSTEM TYPES =====\r\n\r\nexport interface AgentHookEvent {\r\n  id: string;\r\n  type: string;\r\n  source: string;\r\n  timestamp: Date;\r\n  data: Record<string, any>;\r\n  processed: boolean;\r\n  processingResults?: HookProcessingResult[];\r\n}\r\n\r\nexport interface HookProcessingResult {\r\n  hookId: string;\r\n  agentId: string;\r\n  status: 'success' | 'failed' | 'timeout';\r\n  result?: any;\r\n  error?: string;\r\n  processingTime: number; // ms\r\n  timestamp: Date;\r\n}\r\n\r\n// ===== PATTERN LEARNING TYPES =====\r\n\r\nexport interface PatternLearningData {\r\n  specificationPatterns: SpecPattern[];\r\n  designPatterns: DesignPattern[];\r\n  implementationPatterns: ImplementationPattern[];\r\n  outcomePatterns: OutcomePattern[];\r\n}\r\n\r\nexport interface SpecPattern {\r\n  id: string;\r\n  domain: string;\r\n  pattern: string;\r\n  frequency: number;\r\n  successRate: number;\r\n  contexts: string[];\r\n  examples: string[];\r\n}\r\n\r\nexport interface DesignPattern {\r\n  id: string;\r\n  architecture: string;\r\n  components: string[];\r\n  relationships: string[];\r\n  applicability: string[];\r\n  pros: string[];\r\n  cons: string[];\r\n  usage_frequency: number;\r\n}\r\n\r\nexport interface ImplementationPattern {\r\n  id: string;\r\n  language: string;\r\n  framework: string;\r\n  pattern_code: string;\r\n  complexity: 'low' | 'medium' | 'high';\r\n  maintainability: number; // 0-1\r\n  performance: number; // 0-1\r\n}\r\n\r\nexport interface OutcomePattern {\r\n  id: string;\r\n  inputs: Record<string, any>;\r\n  outputs: Record<string, any>;\r\n  quality: number; // 0-1\r\n  timeline: number; // actual time taken\r\n  stakeholder_satisfaction: number; // 0-1\r\n  lessons_learned: string[];\r\n}\r\n\r\n// ===== ENHANCED ORCHESTRATOR STATE =====\r\n\r\nexport interface KiroEnhancedWorkflowState extends MaestroWorkflowState {\r\n  livingDocState: LivingDocumentationState;\r\n  activeHooks: string[]; // Active hook IDs\r\n  consensusSessions: ConsensusSession[];\r\n  patternLearningData: PatternLearningData;\r\n  qualityMetrics: QualityMetrics;\r\n  backgroundAgents: string[]; // Background monitoring agents\r\n  enhancedMetadata: Record<string, any>;\r\n}\r\n\r\nexport interface QualityMetrics {\r\n  codeQuality: number; // 0-1\r\n  documentationQuality: number; // 0-1\r\n  testCoverage: number; // 0-1\r\n  specCompleteness: number; // 0-1\r\n  implementationFidelity: number; // 0-1, how well code matches spec\r\n  consensusReliability: number; // 0-1\r\n  cycletime: number; // ms\r\n  defectDensity: number; // defects per KLOC\r\n}\r\n"],"names":[],"mappings":"AAwXA,WASC"}