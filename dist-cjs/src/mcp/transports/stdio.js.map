{"version":3,"sources":["../../../../src/mcp/transports/stdio.ts"],"sourcesContent":["/**\r\n * Standard I/O transport for MCP\r\n */\r\n\r\nimport { createReadStream, createWriteStream } from 'node:fs';\r\nimport { stdin, stdout } from 'node:process';\r\nimport { createInterface, Interface } from 'node:readline';\r\nimport type { ITransport, RequestHandler, NotificationHandler } from './base.js';\r\nimport type { MCPRequest, MCPResponse, MCPNotification } from '../../utils/types.js';\r\nimport type { ILogger } from '../../core/logger.js';\r\nimport { MCPTransportError } from '../../utils/errors.js';\r\n\r\n/**\r\n * Stdio transport implementation\r\n */\r\nexport class StdioTransport implements ITransport {\r\n  private requestHandler?: RequestHandler;\r\n  private notificationHandler?: NotificationHandler;\r\n  private readline?: Interface;\r\n  private messageCount = 0;\r\n  private notificationCount = 0;\r\n  private running = false;\r\n\r\n  constructor(private logger: ILogger) {}\r\n\r\n  async start(): Promise<void> {\r\n    if (this.running) {\r\n      throw new MCPTransportError('Transport already running');\r\n    }\r\n\r\n    this.logger.info('Starting stdio transport');\r\n\r\n    try {\r\n      // Create readline interface for stdin\r\n      this.readline = createInterface({\r\n        input: stdin,\r\n        output: stdout,\r\n        terminal: false,\r\n      });\r\n\r\n      // Set up line handler\r\n      this.readline.on('line', (line: string) => {\r\n        this.processMessage(line.trim()).catch((error) => {\r\n          this.logger.error('Error processing message', { line, error });\r\n        });\r\n      });\r\n\r\n      this.readline.on('close', () => {\r\n        this.logger.info('Stdin closed');\r\n        this.running = false;\r\n      });\r\n\r\n      this.running = true;\r\n      this.logger.info('Stdio transport started');\r\n    } catch (error) {\r\n      throw new MCPTransportError('Failed to start stdio transport', { error });\r\n    }\r\n  }\r\n\r\n  async stop(): Promise<void> {\r\n    if (!this.running) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Stopping stdio transport');\r\n\r\n    this.running = false;\r\n\r\n    if (this.readline) {\r\n      this.readline.close();\r\n      this.readline = undefined;\r\n    }\r\n\r\n    this.logger.info('Stdio transport stopped');\r\n  }\r\n\r\n  onRequest(handler: RequestHandler): void {\r\n    this.requestHandler = handler;\r\n  }\r\n\r\n  onNotification(handler: NotificationHandler): void {\r\n    this.notificationHandler = handler;\r\n  }\r\n\r\n  async getHealthStatus(): Promise<{\r\n    healthy: boolean;\r\n    error?: string;\r\n    metrics?: Record<string, number>;\r\n  }> {\r\n    return {\r\n      healthy: this.running,\r\n      metrics: {\r\n        messagesReceived: this.messageCount,\r\n        notificationsSent: this.notificationCount,\r\n        stdinOpen: this.readline ? 1 : 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async processMessage(line: string): Promise<void> {\r\n    let message: any;\r\n\r\n    try {\r\n      message = JSON.parse(line);\r\n\r\n      if (!message.jsonrpc || message.jsonrpc !== '2.0') {\r\n        throw new Error('Invalid JSON-RPC version');\r\n      }\r\n\r\n      if (!message.method) {\r\n        throw new Error('Missing method');\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse message', { line, error });\r\n\r\n      // Send error response if we can extract an ID\r\n      let id = 'unknown';\r\n      try {\r\n        const parsed = JSON.parse(line);\r\n        if (parsed.id !== undefined) {\r\n          id = parsed.id;\r\n        }\r\n      } catch {\r\n        // Ignore parse error for ID extraction\r\n      }\r\n\r\n      await this.sendResponse({\r\n        jsonrpc: '2.0',\r\n        id,\r\n        error: {\r\n          code: -32700,\r\n          message: 'Parse error',\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.messageCount++;\r\n\r\n    // Check if this is a notification (no id field) or a request\r\n    if (message.id === undefined) {\r\n      // This is a notification\r\n      await this.handleNotification(message as MCPNotification);\r\n    } else {\r\n      // This is a request\r\n      await this.handleRequest(message as MCPRequest);\r\n    }\r\n  }\r\n\r\n  private async handleRequest(request: MCPRequest): Promise<void> {\r\n    if (!this.requestHandler) {\r\n      await this.sendResponse({\r\n        jsonrpc: '2.0',\r\n        id: request.id,\r\n        error: {\r\n          code: -32603,\r\n          message: 'No request handler registered',\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await this.requestHandler(request);\r\n      await this.sendResponse(response);\r\n    } catch (error) {\r\n      this.logger.error('Request handler error', { request, error });\r\n\r\n      await this.sendResponse({\r\n        jsonrpc: '2.0',\r\n        id: request.id,\r\n        error: {\r\n          code: -32603,\r\n          message: 'Internal error',\r\n          data: error instanceof Error ? error.message : String(error),\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  private async handleNotification(notification: MCPNotification): Promise<void> {\r\n    if (!this.notificationHandler) {\r\n      this.logger.warn('Received notification but no handler registered', {\r\n        method: notification.method,\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await this.notificationHandler(notification);\r\n    } catch (error) {\r\n      this.logger.error('Notification handler error', { notification, error });\r\n      // Notifications don't send error responses\r\n    }\r\n  }\r\n\r\n  private async sendResponse(response: MCPResponse): Promise<void> {\r\n    try {\r\n      const json = JSON.stringify(response);\r\n      stdout.write(json + '\\n');\r\n    } catch (error) {\r\n      this.logger.error('Failed to send response', { response, error });\r\n    }\r\n  }\r\n\r\n  async connect(): Promise<void> {\r\n    // For STDIO transport, connect is handled by start()\r\n    if (!this.running) {\r\n      await this.start();\r\n    }\r\n  }\r\n\r\n  async disconnect(): Promise<void> {\r\n    // For STDIO transport, disconnect is handled by stop()\r\n    await this.stop();\r\n  }\r\n\r\n  async sendRequest(request: MCPRequest): Promise<MCPResponse> {\r\n    // Send request to stdout\r\n    const json = JSON.stringify(request);\r\n    stdout.write(json + '\\n');\r\n\r\n    // In STDIO transport, responses are handled asynchronously\r\n    // This would need a proper request/response correlation mechanism\r\n    throw new Error('STDIO transport sendRequest requires request/response correlation');\r\n  }\r\n\r\n  async sendNotification(notification: MCPNotification): Promise<void> {\r\n    try {\r\n      const json = JSON.stringify(notification);\r\n      stdout.write(json + '\\n');\r\n      this.notificationCount++;\r\n    } catch (error) {\r\n      this.logger.error('Failed to send notification', { notification, error });\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"names":["stdin","stdout","createInterface","MCPTransportError","StdioTransport","requestHandler","notificationHandler","readline","messageCount","notificationCount","running","logger","start","info","input","output","terminal","on","line","processMessage","trim","catch","error","stop","close","undefined","onRequest","handler","onNotification","getHealthStatus","healthy","metrics","messagesReceived","notificationsSent","stdinOpen","message","JSON","parse","jsonrpc","Error","method","id","parsed","sendResponse","code","handleNotification","handleRequest","request","response","data","String","notification","warn","json","stringify","write","connect","disconnect","sendRequest","sendNotification"],"mappings":"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"}