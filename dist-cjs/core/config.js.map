{
  "version": 3,
  "sources": ["../../src/core/config.ts"],
  "sourcesContent": ["/**\n * Enterprise Configuration Management for Claude-Flow\n * Features: Security masking, change tracking, multi-format support, credential management\n */\n\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\nimport { createHash, randomBytes, createCipheriv, createDecipheriv } from 'crypto';\nimport type { Config } from '../utils/types.js';\nimport { deepMerge, safeParseJSON } from '../utils/helpers.js';\nimport { ConfigError, ValidationError } from '../utils/errors.js';\n\n// Format parsers\ninterface FormatParser {\n  parse(content: string): any;\n  stringify(obj: any): string;\n  extension: string;\n}\n\n// Configuration change record\ninterface ConfigChange {\n  timestamp: string;\n  path: string;\n  oldValue: any;\n  newValue: any;\n  user?: string;\n  reason?: string;\n  source: 'cli' | 'api' | 'file' | 'env';\n}\n\n// Security classification\ninterface SecurityClassification {\n  level: 'public' | 'internal' | 'confidential' | 'secret';\n  maskPattern?: string;\n  encrypted?: boolean;\n}\n\n// Validation rule\ninterface ValidationRule {\n  type: string;\n  required?: boolean;\n  min?: number;\n  max?: number;\n  values?: string[];\n  pattern?: RegExp;\n  validator?: (value: any, config: Config) => string | null;\n  dependencies?: string[];\n}\n\n/**\n * Security classifications for configuration paths\n */\nconst SECURITY_CLASSIFICATIONS: Record<string, SecurityClassification> = {\n  credentials: { level: 'secret', encrypted: true },\n  'credentials.apiKey': { level: 'secret', maskPattern: '****...****', encrypted: true },\n  'credentials.token': { level: 'secret', maskPattern: '****...****', encrypted: true },\n  'credentials.password': { level: 'secret', maskPattern: '********', encrypted: true },\n  'mcp.apiKey': { level: 'confidential', maskPattern: '****...****' },\n  'logging.destination': { level: 'internal' },\n  orchestrator: { level: 'internal' },\n  terminal: { level: 'public' },\n};\n\n/**\n * Sensitive configuration paths that should be masked in output\n */\nconst SENSITIVE_PATHS = ['credentials', 'apiKey', 'token', 'password', 'secret', 'key', 'auth'];\n\n/**\n * Format parsers for different configuration file types\n */\nconst FORMAT_PARSERS: Record<string, FormatParser> = {\n  json: {\n    parse: JSON.parse,\n    stringify: (obj) => JSON.stringify(obj, null, 2),\n    extension: '.json',\n  },\n  yaml: {\n    parse: (content) => {\n      // Simple YAML parser for basic key-value pairs\n      const lines = content.split('\\n');\n      const result: any = {};\n      let current = result;\n      const stack: any[] = [result];\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (!trimmed || trimmed.startsWith('#')) continue;\n\n        const indent = line.length - line.trimStart().length;\n        const colonIndex = trimmed.indexOf(':');\n\n        if (colonIndex === -1) continue;\n\n        const key = trimmed.substring(0, colonIndex).trim();\n        const value = trimmed.substring(colonIndex + 1).trim();\n\n        // Simple value parsing\n        let parsedValue: any = value;\n        if (value === 'true') parsedValue = true;\n        else if (value === 'false') parsedValue = false;\n        else if (!isNaN(Number(value)) && value !== '') parsedValue = Number(value);\n        else if (value.startsWith('\"') && value.endsWith('\"')) {\n          parsedValue = value.slice(1, -1);\n        }\n\n        current[key] = parsedValue;\n      }\n\n      return result;\n    },\n    stringify: (obj) => {\n      const stringify = (obj: any, indent = 0): string => {\n        const spaces = '  '.repeat(indent);\n        let result = '';\n\n        for (const [key, value] of Object.entries(obj)) {\n          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n            result += `${spaces}${key}:\\n${stringify(value, indent + 1)}`;\n          } else {\n            const formattedValue = typeof value === 'string' ? `\"${value}\"` : String(value);\n            result += `${spaces}${key}: ${formattedValue}\\n`;\n          }\n        }\n\n        return result;\n      };\n\n      return stringify(obj);\n    },\n    extension: '.yaml',\n  },\n  toml: {\n    parse: (content) => {\n      // Simple TOML parser for basic sections and key-value pairs\n      const lines = content.split('\\n');\n      const result: any = {};\n      let currentSection = result;\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (!trimmed || trimmed.startsWith('#')) continue;\n\n        // Section header\n        if (trimmed.startsWith('[') && trimmed.endsWith(']')) {\n          const sectionName = trimmed.slice(1, -1);\n          currentSection = result[sectionName] = {};\n          continue;\n        }\n\n        // Key-value pair\n        const equalsIndex = trimmed.indexOf('=');\n        if (equalsIndex === -1) continue;\n\n        const key = trimmed.substring(0, equalsIndex).trim();\n        const value = trimmed.substring(equalsIndex + 1).trim();\n\n        // Simple value parsing\n        let parsedValue: any = value;\n        if (value === 'true') parsedValue = true;\n        else if (value === 'false') parsedValue = false;\n        else if (!isNaN(Number(value)) && value !== '') parsedValue = Number(value);\n        else if (value.startsWith('\"') && value.endsWith('\"')) {\n          parsedValue = value.slice(1, -1);\n        }\n\n        currentSection[key] = parsedValue;\n      }\n\n      return result;\n    },\n    stringify: (obj) => {\n      let result = '';\n\n      for (const [section, values] of Object.entries(obj)) {\n        if (typeof values === 'object' && values !== null && !Array.isArray(values)) {\n          result += `[${section}]\\n`;\n          for (const [key, value] of Object.entries(values)) {\n            const formattedValue = typeof value === 'string' ? `\"${value}\"` : String(value);\n            result += `${key} = ${formattedValue}\\n`;\n          }\n          result += '\\n';\n        }\n      }\n\n      return result;\n    },\n    extension: '.toml',\n  },\n};\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Config = {\n  orchestrator: {\n    maxConcurrentAgents: 10,\n    taskQueueSize: 100,\n    healthCheckInterval: 30000, // 30 seconds\n    shutdownTimeout: 30000, // 30 seconds\n  },\n  terminal: {\n    type: 'auto',\n    poolSize: 5,\n    recycleAfter: 10, // recycle after 10 uses\n    healthCheckInterval: 60000, // 1 minute\n    commandTimeout: 300000, // 5 minutes\n  },\n  memory: {\n    backend: 'hybrid',\n    cacheSizeMB: 100,\n    syncInterval: 5000, // 5 seconds\n    conflictResolution: 'crdt',\n    retentionDays: 30,\n  },\n  coordination: {\n    maxRetries: 3,\n    retryDelay: 1000, // 1 second\n    deadlockDetection: true,\n    resourceTimeout: 60000, // 1 minute\n    messageTimeout: 30000, // 30 seconds\n  },\n  mcp: {\n    transport: 'stdio',\n    port: 3000,\n    tlsEnabled: false,\n  },\n  logging: {\n    level: 'info',\n    format: 'json',\n    destination: 'console',\n  },\n  credentials: {\n    // Encrypted credentials storage\n  },\n  security: {\n    encryptionEnabled: true,\n    auditLogging: true,\n    maskSensitiveValues: true,\n    allowEnvironmentOverrides: true,\n  },\n};\n\n/**\n * Configuration manager\n */\nexport class ConfigManager {\n  private static instance: ConfigManager;\n  private config: Config;\n  private configPath?: string;\n  private profiles: Map<string, Partial<Config>> = new Map();\n  private currentProfile?: string;\n  private userConfigDir: string;\n  private changeHistory: ConfigChange[] = [];\n  private encryptionKey?: Buffer;\n  private validationRules: Map<string, ValidationRule> = new Map();\n  private formatParsers = FORMAT_PARSERS;\n\n  private constructor() {\n    this.config = deepClone(DEFAULT_CONFIG);\n    this.userConfigDir = this.getUserConfigDir();\n    this.setupValidationRules();\n    // Encryption will be initialized via init() method\n  }\n\n  /**\n   * Gets the singleton instance\n   */\n  static getInstance(): ConfigManager {\n    if (!ConfigManager.instance) {\n      ConfigManager.instance = new ConfigManager();\n    }\n    return ConfigManager.instance;\n  }\n\n  /**\n   * Initialize async components\n   */\n  async init(): Promise<void> {\n    await this.initializeEncryption();\n  }\n\n  /**\n   * Initializes encryption for sensitive configuration values\n   */\n  private async initializeEncryption(): Promise<void> {\n    try {\n      const keyFile = join(this.userConfigDir, '.encryption-key');\n      // Check if key file exists (simplified for demo)\n      try {\n        await fs.access(keyFile);\n        // In a real implementation, this would be more secure\n        this.encryptionKey = randomBytes(32);\n      } catch {\n        this.encryptionKey = randomBytes(32);\n        // Store key securely (in production, use proper key management)\n      }\n    } catch (error) {\n      console.warn('Failed to initialize encryption:', (error as Error).message);\n    }\n  }\n\n  /**\n   * Sets up validation rules for configuration paths\n   */\n  private setupValidationRules(): void {\n    // Orchestrator validation rules\n    this.validationRules.set('orchestrator.maxConcurrentAgents', {\n      type: 'number',\n      required: true,\n      min: 1,\n      max: 100,\n      validator: (value, config) => {\n        if (value > config.terminal?.poolSize * 2) {\n          return 'maxConcurrentAgents should not exceed 2x terminal pool size';\n        }\n        return null;\n      },\n    });\n\n    this.validationRules.set('orchestrator.taskQueueSize', {\n      type: 'number',\n      required: true,\n      min: 1,\n      max: 10000,\n      dependencies: ['orchestrator.maxConcurrentAgents'],\n      validator: (value, config) => {\n        const maxAgents = config.orchestrator?.maxConcurrentAgents || 1;\n        if (value < maxAgents * 10) {\n          return 'taskQueueSize should be at least 10x maxConcurrentAgents';\n        }\n        return null;\n      },\n    });\n\n    // Terminal validation rules\n    this.validationRules.set('terminal.type', {\n      type: 'string',\n      required: true,\n      values: ['auto', 'vscode', 'native'],\n    });\n\n    this.validationRules.set('terminal.poolSize', {\n      type: 'number',\n      required: true,\n      min: 1,\n      max: 50,\n    });\n\n    // Memory validation rules\n    this.validationRules.set('memory.backend', {\n      type: 'string',\n      required: true,\n      values: ['sqlite', 'markdown', 'hybrid'],\n    });\n\n    this.validationRules.set('memory.cacheSizeMB', {\n      type: 'number',\n      required: true,\n      min: 1,\n      max: 10000,\n      validator: (value) => {\n        if (value > 1000) {\n          return 'Large cache sizes may impact system performance';\n        }\n        return null;\n      },\n    });\n\n    // Security validation rules\n    this.validationRules.set('security.encryptionEnabled', {\n      type: 'boolean',\n      required: true,\n    });\n\n    // Credentials validation\n    this.validationRules.set('credentials.apiKey', {\n      type: 'string',\n      pattern: /^[a-zA-Z0-9_-]+$/,\n      validator: (value) => {\n        if (value && value.length < 16) {\n          return 'API key should be at least 16 characters long';\n        }\n        return null;\n      },\n    });\n  }\n\n  /**\n   * Loads configuration from various sources\n   */\n  async load(configPath?: string): Promise<Config> {\n    if (configPath !== undefined) {\n      this.configPath = configPath;\n    }\n\n    // Start with defaults\n    let config = deepClone(DEFAULT_CONFIG);\n\n    // Load from file if specified\n    if (configPath) {\n      const fileConfig = await this.loadFromFile(configPath);\n      config = deepMergeConfig(config, fileConfig);\n    }\n\n    // Load from environment variables\n    const envConfig = this.loadFromEnv();\n    config = deepMergeConfig(config, envConfig);\n\n    // Validate the final configuration\n    this.validate(config);\n\n    this.config = config;\n    return config;\n  }\n\n  /**\n   * Gets the current configuration with optional security masking\n   */\n  get(maskSensitive = false): Config {\n    const config = deepClone(this.config);\n\n    if (maskSensitive && this.config.security?.maskSensitiveValues) {\n      return this.maskSensitiveValues(config);\n    }\n\n    return config;\n  }\n\n  /**\n   * Gets configuration with security masking applied\n   */\n  getSecure(): Config {\n    return this.get(true);\n  }\n\n  /**\n   * Gets all configuration values (alias for get method for backward compatibility)\n   */\n  async getAll(): Promise<Config> {\n    return this.get();\n  }\n\n  /**\n   * Updates configuration values with change tracking\n   */\n  update(\n    updates: Partial<Config>,\n    options: { user?: string; reason?: string; source?: 'cli' | 'api' | 'file' | 'env' } = {},\n  ): Config {\n    const oldConfig = deepClone(this.config);\n\n    // Track changes before applying\n    this.trackChanges(oldConfig, updates, options);\n\n    // Apply updates\n    this.config = deepMergeConfig(this.config, updates);\n\n    // Validate the updated configuration\n    this.validateWithDependencies(this.config);\n\n    return this.get();\n  }\n\n  /**\n   * Loads default configuration\n   */\n  loadDefault(): void {\n    this.config = deepClone(DEFAULT_CONFIG);\n  }\n\n  /**\n   * Saves configuration to file with format support\n   */\n  async save(path?: string, format?: string): Promise<void> {\n    const savePath = path || this.configPath;\n    if (!savePath) {\n      throw new ConfigError('No configuration file path specified');\n    }\n\n    const detectedFormat = format || this.detectFormat(savePath);\n    const parser = this.formatParsers[detectedFormat];\n\n    if (!parser) {\n      throw new ConfigError(`Unsupported format for saving: ${detectedFormat}`);\n    }\n\n    // Get configuration without sensitive values for saving\n    const configToSave = this.getConfigForSaving();\n    const content = parser.stringify(configToSave);\n\n    await fs.writeFile(savePath, content, 'utf8');\n\n    // Record the save operation\n    this.recordChange({\n      timestamp: new Date().toISOString(),\n      path: 'CONFIG_SAVED',\n      oldValue: null,\n      newValue: savePath,\n      source: 'file',\n    });\n  }\n\n  /**\n   * Gets configuration suitable for saving (excludes runtime-only values)\n   */\n  private getConfigForSaving(): Partial<Config> {\n    const config = deepClone(this.config);\n\n    // Remove encrypted credentials from the saved config\n    // They should be stored separately in a secure location\n    if (config.credentials) {\n      delete config.credentials;\n    }\n\n    return config;\n  }\n\n  /**\n   * Gets user configuration directory\n   */\n  private getUserConfigDir(): string {\n    const home = homedir();\n    return join(home, '.claude-flow');\n  }\n\n  /**\n   * Creates user config directory if it doesn't exist\n   */\n  private async ensureUserConfigDir(): Promise<void> {\n    try {\n      await fs.mkdir(this.userConfigDir, { recursive: true });\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code !== 'EEXIST') {\n        throw new ConfigError(`Failed to create config directory: ${(error as Error).message}`);\n      }\n    }\n  }\n\n  /**\n   * Loads all profiles from the profiles directory\n   */\n  async loadProfiles(): Promise<void> {\n    const profilesDir = join(this.userConfigDir, 'profiles');\n\n    try {\n      const entries = await fs.readdir(profilesDir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        if (entry.isFile() && entry.name.endsWith('.json')) {\n          const profileName = entry.name.replace('.json', '');\n          const profilePath = join(profilesDir, entry.name);\n\n          try {\n            const content = await fs.readFile(profilePath, 'utf8');\n            const profileConfig = safeParseJSON<Partial<Config>>(content);\n\n            if (profileConfig) {\n              this.profiles.set(profileName, profileConfig);\n            }\n          } catch (error) {\n            console.warn(`Failed to load profile ${profileName}: ${(error as Error).message}`);\n          }\n        }\n      }\n    } catch (error) {\n      // Profiles directory doesn't exist - this is okay\n    }\n  }\n\n  /**\n   * Applies a named profile\n   */\n  async applyProfile(profileName: string): Promise<void> {\n    await this.loadProfiles();\n\n    const profile = this.profiles.get(profileName);\n    if (!profile) {\n      throw new ConfigError(`Profile '${profileName}' not found`);\n    }\n\n    this.config = deepMergeConfig(this.config, profile);\n    this.currentProfile = profileName;\n    this.validate(this.config);\n  }\n\n  /**\n   * Saves current configuration as a profile\n   */\n  async saveProfile(profileName: string, config?: Partial<Config>): Promise<void> {\n    await this.ensureUserConfigDir();\n\n    const profilesDir = join(this.userConfigDir, 'profiles');\n    await fs.mkdir(profilesDir, { recursive: true });\n\n    const profileConfig = config || this.config;\n    const profilePath = join(profilesDir, `${profileName}.json`);\n\n    const content = JSON.stringify(profileConfig, null, 2);\n    await fs.writeFile(profilePath, content, 'utf8');\n\n    this.profiles.set(profileName, profileConfig);\n  }\n\n  /**\n   * Deletes a profile\n   */\n  async deleteProfile(profileName: string): Promise<void> {\n    const profilePath = join(this.userConfigDir, 'profiles', `${profileName}.json`);\n\n    try {\n      await fs.unlink(profilePath);\n      this.profiles.delete(profileName);\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        throw new ConfigError(`Profile '${profileName}' not found`);\n      }\n      throw new ConfigError(`Failed to delete profile: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Lists all available profiles\n   */\n  async listProfiles(): Promise<string[]> {\n    await this.loadProfiles();\n    return Array.from(this.profiles.keys());\n  }\n\n  /**\n   * Gets a specific profile configuration\n   */\n  async getProfile(profileName: string): Promise<Partial<Config> | undefined> {\n    await this.loadProfiles();\n    return this.profiles.get(profileName);\n  }\n\n  /**\n   * Gets the current active profile name\n   */\n  getCurrentProfile(): string | undefined {\n    return this.currentProfile;\n  }\n\n  /**\n   * Sets a configuration value by path with change tracking and validation\n   */\n  set(\n    path: string,\n    value: any,\n    options: { user?: string; reason?: string; source?: 'cli' | 'api' | 'file' | 'env' } = {},\n  ): void {\n    const oldValue = this.getValue(path);\n\n    // Record the change\n    this.recordChange({\n      timestamp: new Date().toISOString(),\n      path,\n      oldValue,\n      newValue: value,\n      user: options.user,\n      reason: options.reason,\n      source: options.source || 'cli',\n    });\n\n    // Encrypt sensitive values\n    if (this.isSensitivePath(path) && this.config.security?.encryptionEnabled) {\n      value = this.encryptValue(value);\n    }\n\n    const keys = path.split('.');\n    let current: any = this.config;\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n      if (!(key in current)) {\n        current[key] = {};\n      }\n      current = current[key];\n    }\n\n    current[keys[keys.length - 1]] = value;\n\n    // Validate the path-specific rule and dependencies\n    this.validatePath(path, value);\n    this.validateWithDependencies(this.config);\n  }\n\n  /**\n   * Gets a configuration value by path with decryption for sensitive values\n   */\n  getValue(path: string, decrypt = true): any {\n    const keys = path.split('.');\n    let current: any = this.config;\n\n    for (const key of keys) {\n      if (current && typeof current === 'object' && key in current) {\n        current = current[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    // Decrypt sensitive values if requested\n    if (decrypt && this.isSensitivePath(path) && this.isEncryptedValue(current)) {\n      try {\n        return this.decryptValue(current);\n      } catch (error) {\n        console.warn(`Failed to decrypt value at path ${path}:`, (error as Error).message);\n        return current;\n      }\n    }\n\n    return current;\n  }\n\n  /**\n   * Resets configuration to defaults\n   */\n  reset(): void {\n    this.config = deepClone(DEFAULT_CONFIG);\n    delete this.currentProfile;\n  }\n\n  /**\n   * Gets configuration schema for validation\n   */\n  getSchema(): any {\n    return {\n      orchestrator: {\n        maxConcurrentAgents: { type: 'number', min: 1, max: 100 },\n        taskQueueSize: { type: 'number', min: 1, max: 10000 },\n        healthCheckInterval: { type: 'number', min: 1000, max: 300000 },\n        shutdownTimeout: { type: 'number', min: 1000, max: 300000 },\n      },\n      terminal: {\n        type: { type: 'string', values: ['auto', 'vscode', 'native'] },\n        poolSize: { type: 'number', min: 1, max: 50 },\n        recycleAfter: { type: 'number', min: 1, max: 1000 },\n        healthCheckInterval: { type: 'number', min: 1000, max: 3600000 },\n        commandTimeout: { type: 'number', min: 1000, max: 3600000 },\n      },\n      memory: {\n        backend: { type: 'string', values: ['sqlite', 'markdown', 'hybrid'] },\n        cacheSizeMB: { type: 'number', min: 1, max: 10000 },\n        syncInterval: { type: 'number', min: 1000, max: 300000 },\n        conflictResolution: { type: 'string', values: ['crdt', 'timestamp', 'manual'] },\n        retentionDays: { type: 'number', min: 1, max: 3650 },\n      },\n      coordination: {\n        maxRetries: { type: 'number', min: 0, max: 100 },\n        retryDelay: { type: 'number', min: 100, max: 60000 },\n        deadlockDetection: { type: 'boolean' },\n        resourceTimeout: { type: 'number', min: 1000, max: 3600000 },\n        messageTimeout: { type: 'number', min: 1000, max: 300000 },\n      },\n      mcp: {\n        transport: { type: 'string', values: ['stdio', 'http', 'websocket'] },\n        port: { type: 'number', min: 1, max: 65535 },\n        tlsEnabled: { type: 'boolean' },\n      },\n      logging: {\n        level: { type: 'string', values: ['debug', 'info', 'warn', 'error'] },\n        format: { type: 'string', values: ['json', 'text'] },\n        destination: { type: 'string', values: ['console', 'file'] },\n      },\n    };\n  }\n\n  /**\n   * Validates a value against schema\n   */\n  private validateValue(value: any, schema: any, path: string): void {\n    if (schema.type === 'number') {\n      if (typeof value !== 'number' || isNaN(value)) {\n        throw new ValidationError(`${path}: must be a number`);\n      }\n      if (schema.min !== undefined && value < schema.min) {\n        throw new ValidationError(`${path}: must be at least ${schema.min}`);\n      }\n      if (schema.max !== undefined && value > schema.max) {\n        throw new ValidationError(`${path}: must be at most ${schema.max}`);\n      }\n    } else if (schema.type === 'string') {\n      if (typeof value !== 'string') {\n        throw new ValidationError(`${path}: must be a string`);\n      }\n      if (schema.values && !schema.values.includes(value)) {\n        throw new ValidationError(`${path}: must be one of [${schema.values.join(', ')}]`);\n      }\n    } else if (schema.type === 'boolean') {\n      if (typeof value !== 'boolean') {\n        throw new ValidationError(`${path}: must be a boolean`);\n      }\n    }\n  }\n\n  /**\n   * Gets configuration diff between current and default\n   */\n  getDiff(): any {\n    const defaultConfig = DEFAULT_CONFIG;\n    const diff: any = {};\n\n    const findDifferences = (current: any, defaults: any, path: string = '') => {\n      for (const key in current) {\n        const currentValue = current[key];\n        const defaultValue = defaults[key];\n        const fullPath = path ? `${path}.${key}` : key;\n\n        if (\n          typeof currentValue === 'object' &&\n          currentValue !== null &&\n          !Array.isArray(currentValue)\n        ) {\n          if (typeof defaultValue === 'object' && defaultValue !== null) {\n            const nestedDiff = {};\n            findDifferences(currentValue, defaultValue, fullPath);\n            if (Object.keys(nestedDiff).length > 0) {\n              if (!path) {\n                diff[key] = nestedDiff;\n              }\n            }\n          }\n        } else if (currentValue !== defaultValue) {\n          const pathParts = fullPath.split('.');\n          let target = diff;\n          for (let i = 0; i < pathParts.length - 1; i++) {\n            if (!target[pathParts[i]]) {\n              target[pathParts[i]] = {};\n            }\n            target = target[pathParts[i]];\n          }\n          target[pathParts[pathParts.length - 1]] = currentValue;\n        }\n      }\n    };\n\n    findDifferences(this.config, defaultConfig);\n    return diff;\n  }\n\n  /**\n   * Exports configuration with metadata\n   */\n  export(): any {\n    return {\n      version: '1.0.0',\n      exported: new Date().toISOString(),\n      profile: this.currentProfile,\n      config: this.config,\n      diff: this.getDiff(),\n    };\n  }\n\n  /**\n   * Imports configuration from export\n   */\n  import(data: any): void {\n    if (!data.config) {\n      throw new ConfigError('Invalid configuration export format');\n    }\n\n    this.validateWithDependencies(data.config);\n    this.config = data.config;\n    this.currentProfile = data.profile;\n\n    // Record the import operation\n    this.recordChange({\n      timestamp: new Date().toISOString(),\n      path: 'CONFIG_IMPORTED',\n      oldValue: null,\n      newValue: data.version || 'unknown',\n      source: 'file',\n    });\n  }\n\n  /**\n   * Loads configuration from file with format detection\n   */\n  private async loadFromFile(path: string): Promise<Partial<Config>> {\n    try {\n      const content = await fs.readFile(path, 'utf8');\n      const format = this.detectFormat(path, content);\n      const parser = this.formatParsers[format];\n\n      if (!parser) {\n        throw new ConfigError(`Unsupported configuration format: ${format}`);\n      }\n\n      const config = parser.parse(content) as Partial<Config>;\n\n      if (!config) {\n        throw new ConfigError(`Invalid ${format.toUpperCase()} in configuration file: ${path}`);\n      }\n\n      return config;\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        // File doesn't exist, use defaults\n        return {};\n      }\n      throw new ConfigError(\n        `Failed to load configuration from ${path}: ${(error as Error).message}`,\n      );\n    }\n  }\n\n  /**\n   * Detects configuration file format\n   */\n  private detectFormat(path: string, content?: string): string {\n    const ext = path.split('.').pop()?.toLowerCase();\n\n    if (ext === 'yaml' || ext === 'yml') return 'yaml';\n    if (ext === 'toml') return 'toml';\n    if (ext === 'json') return 'json';\n\n    // Try to detect from content\n    if (content) {\n      const trimmed = content.trim();\n      if (trimmed.startsWith('{') || trimmed.startsWith('[')) return 'json';\n      if (trimmed.includes('=') && trimmed.includes('[')) return 'toml';\n      if (trimmed.includes(':') && !trimmed.includes('=')) return 'yaml';\n    }\n\n    // Default to JSON\n    return 'json';\n  }\n\n  /**\n   * Loads configuration from environment variables\n   */\n  private loadFromEnv(): Partial<Config> {\n    const config: Partial<Config> = {};\n\n    // Orchestrator settings\n    const maxAgents = process.env.CLAUDE_FLOW_MAX_AGENTS;\n    if (maxAgents) {\n      if (!config.orchestrator) {\n        config.orchestrator = {} as any;\n      }\n      config.orchestrator = {\n        ...DEFAULT_CONFIG.orchestrator,\n        ...config.orchestrator,\n        maxConcurrentAgents: parseInt(maxAgents, 10),\n      };\n    }\n\n    // Terminal settings\n    const terminalType = process.env.CLAUDE_FLOW_TERMINAL_TYPE;\n    if (terminalType === 'vscode' || terminalType === 'native' || terminalType === 'auto') {\n      config.terminal = {\n        ...DEFAULT_CONFIG.terminal,\n        ...config.terminal,\n        type: terminalType,\n      };\n    }\n\n    // Memory settings\n    const memoryBackend = process.env.CLAUDE_FLOW_MEMORY_BACKEND;\n    if (memoryBackend === 'sqlite' || memoryBackend === 'markdown' || memoryBackend === 'hybrid') {\n      config.memory = {\n        ...DEFAULT_CONFIG.memory,\n        ...config.memory,\n        backend: memoryBackend,\n      };\n    }\n\n    // MCP settings\n    const mcpTransport = process.env.CLAUDE_FLOW_MCP_TRANSPORT;\n    if (mcpTransport === 'stdio' || mcpTransport === 'http' || mcpTransport === 'websocket') {\n      config.mcp = {\n        ...DEFAULT_CONFIG.mcp,\n        ...config.mcp,\n        transport: mcpTransport,\n      };\n    }\n\n    const mcpPort = process.env.CLAUDE_FLOW_MCP_PORT;\n    if (mcpPort) {\n      config.mcp = {\n        ...DEFAULT_CONFIG.mcp,\n        ...config.mcp,\n        port: parseInt(mcpPort, 10),\n      };\n    }\n\n    // Logging settings\n    const logLevel = process.env.CLAUDE_FLOW_LOG_LEVEL;\n    if (\n      logLevel === 'debug' ||\n      logLevel === 'info' ||\n      logLevel === 'warn' ||\n      logLevel === 'error'\n    ) {\n      config.logging = {\n        ...DEFAULT_CONFIG.logging,\n        ...config.logging,\n        level: logLevel,\n      };\n    }\n\n    return config;\n  }\n\n  /**\n   * Validates configuration with dependency checking\n   */\n  private validateWithDependencies(config: Config): void {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Validate all paths with rules\n    for (const [path, rule] of this.validationRules.entries()) {\n      const value = this.getValueByPath(config, path);\n\n      try {\n        this.validatePath(path, value, config);\n      } catch (error) {\n        errors.push((error as Error).message);\n      }\n    }\n\n    // Additional cross-field validations\n    if (config.orchestrator.maxConcurrentAgents > config.terminal.poolSize * 3) {\n      warnings.push('High agent-to-terminal ratio may cause resource contention');\n    }\n\n    if (config.memory.cacheSizeMB > 1000 && config.memory.backend === 'sqlite') {\n      warnings.push('Large cache size with SQLite backend may impact performance');\n    }\n\n    if (config.mcp.transport === 'http' && !config.mcp.tlsEnabled) {\n      warnings.push('HTTP transport without TLS is not recommended for production');\n    }\n\n    // Log warnings\n    if (warnings.length > 0 && config.logging?.level === 'debug') {\n      console.warn('Configuration warnings:', warnings);\n    }\n\n    // Throw errors\n    if (errors.length > 0) {\n      throw new ValidationError(`Configuration validation failed:\\n${errors.join('\\n')}`);\n    }\n  }\n\n  /**\n   * Validates a specific configuration path\n   */\n  private validatePath(path: string, value: any, config?: Config): void {\n    const rule = this.validationRules.get(path);\n    if (!rule) return;\n\n    const currentConfig = config || this.config;\n\n    // Required validation\n    if (rule.required && (value === undefined || value === null)) {\n      throw new ValidationError(`${path} is required`);\n    }\n\n    if (value === undefined || value === null) return;\n\n    // Type validation\n    if (rule.type === 'number' && (typeof value !== 'number' || isNaN(value))) {\n      throw new ValidationError(`${path} must be a number`);\n    }\n\n    if (rule.type === 'string' && typeof value !== 'string') {\n      throw new ValidationError(`${path} must be a string`);\n    }\n\n    if (rule.type === 'boolean' && typeof value !== 'boolean') {\n      throw new ValidationError(`${path} must be a boolean`);\n    }\n\n    // Range validation\n    if (typeof value === 'number') {\n      if (rule.min !== undefined && value < rule.min) {\n        throw new ValidationError(`${path} must be at least ${rule.min}`);\n      }\n      if (rule.max !== undefined && value > rule.max) {\n        throw new ValidationError(`${path} must be at most ${rule.max}`);\n      }\n    }\n\n    // Values validation\n    if (rule.values && !rule.values.includes(value)) {\n      throw new ValidationError(`${path} must be one of: ${rule.values.join(', ')}`);\n    }\n\n    // Pattern validation\n    if (rule.pattern && typeof value === 'string' && !rule.pattern.test(value)) {\n      throw new ValidationError(`${path} does not match required pattern`);\n    }\n\n    // Custom validator\n    if (rule.validator) {\n      const result = rule.validator(value, currentConfig);\n      if (result) {\n        throw new ValidationError(`${path}: ${result}`);\n      }\n    }\n  }\n\n  /**\n   * Gets a value from a configuration object by path\n   */\n  private getValueByPath(obj: any, path: string): any {\n    const keys = path.split('.');\n    let current = obj;\n\n    for (const key of keys) {\n      if (current && typeof current === 'object' && key in current) {\n        current = current[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return current;\n  }\n\n  /**\n   * Legacy validate method for backward compatibility\n   */\n  private validate(config: Config): void {\n    this.validateWithDependencies(config);\n  }\n\n  /**\n   * Masks sensitive values in configuration\n   */\n  private maskSensitiveValues(config: Config): Config {\n    const maskedConfig = deepClone(config);\n\n    // Recursively mask sensitive paths\n    const maskObject = (obj: any, path: string = ''): any => {\n      if (!obj || typeof obj !== 'object') return obj;\n\n      const masked: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        const currentPath = path ? `${path}.${key}` : key;\n\n        if (this.isSensitivePath(currentPath)) {\n          const classification = SECURITY_CLASSIFICATIONS[currentPath];\n          masked[key] = classification?.maskPattern || '****';\n        } else if (typeof value === 'object' && value !== null) {\n          masked[key] = maskObject(value, currentPath);\n        } else {\n          masked[key] = value;\n        }\n      }\n      return masked;\n    };\n\n    return maskObject(maskedConfig);\n  }\n\n  /**\n   * Tracks changes to configuration\n   */\n  private trackChanges(\n    oldConfig: Config,\n    updates: Partial<Config>,\n    options: { user?: string; reason?: string; source?: 'cli' | 'api' | 'file' | 'env' },\n  ): void {\n    // Simple implementation for tracking changes\n    for (const [key, value] of Object.entries(updates)) {\n      this.recordChange({\n        timestamp: new Date().toISOString(),\n        path: key,\n        oldValue: (oldConfig as any)[key],\n        newValue: value,\n        user: options.user,\n        reason: options.reason,\n        source: options.source || 'cli',\n      });\n    }\n  }\n\n  /**\n   * Records a configuration change\n   */\n  private recordChange(change: ConfigChange): void {\n    this.changeHistory.push(change);\n\n    // Keep only last 1000 changes\n    if (this.changeHistory.length > 1000) {\n      this.changeHistory.shift();\n    }\n  }\n\n  /**\n   * Checks if a path contains sensitive information\n   */\n  private isSensitivePath(path: string): boolean {\n    return SENSITIVE_PATHS.some((sensitive) =>\n      path.toLowerCase().includes(sensitive.toLowerCase()),\n    );\n  }\n\n  /**\n   * Encrypts a sensitive value\n   */\n  private encryptValue(value: any): string {\n    if (!this.encryptionKey) {\n      return value; // Return original if encryption not available\n    }\n\n    try {\n      // Simplified encryption - in production use proper encryption\n      const iv = randomBytes(16);\n      const key = createHash('sha256').update(this.encryptionKey).digest();\n      const cipher = createCipheriv('aes-256-cbc', key, iv);\n      let encrypted = cipher.update(JSON.stringify(value), 'utf8', 'hex');\n      encrypted += cipher.final('hex');\n      return `encrypted:${iv.toString('hex')}:${encrypted}`;\n    } catch (error) {\n      console.warn('Failed to encrypt value:', (error as Error).message);\n      return value;\n    }\n  }\n\n  /**\n   * Decrypts a sensitive value\n   */\n  private decryptValue(encryptedValue: string): any {\n    if (!this.encryptionKey || !this.isEncryptedValue(encryptedValue)) {\n      return encryptedValue;\n    }\n\n    try {\n      const parts = encryptedValue.replace('encrypted:', '').split(':');\n      if (parts.length !== 2) return encryptedValue; // Handle old format\n      const iv = Buffer.from(parts[0], 'hex');\n      const encrypted = parts[1];\n      const key = createHash('sha256').update(this.encryptionKey).digest();\n      const decipher = createDecipheriv('aes-256-cbc', key, iv);\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return JSON.parse(decrypted);\n    } catch (error) {\n      console.warn('Failed to decrypt value:', (error as Error).message);\n      return encryptedValue;\n    }\n  }\n\n  /**\n   * Checks if a value is encrypted\n   */\n  private isEncryptedValue(value: any): boolean {\n    return typeof value === 'string' && value.startsWith('encrypted:');\n  }\n}\n\n// Export singleton instance\nexport const configManager = ConfigManager.getInstance();\n\n// Helper function to load configuration\nexport async function loadConfig(path?: string): Promise<Config> {\n  return await configManager.load(path);\n}\n\nfunction deepClone<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// Export types for external use\nexport type { FormatParser, ConfigChange, SecurityClassification, ValidationRule };\n\nexport { SENSITIVE_PATHS, SECURITY_CLASSIFICATIONS };\n\n// Custom deepMerge for Config type\nfunction deepMergeConfig(target: Config, ...sources: Partial<Config>[]): Config {\n  const result = deepClone(target);\n\n  for (const source of sources) {\n    if (!source) continue;\n\n    // Merge each section\n    if (source.orchestrator) {\n      result.orchestrator = { ...result.orchestrator, ...source.orchestrator };\n    }\n    if (source.terminal) {\n      result.terminal = { ...result.terminal, ...source.terminal };\n    }\n    if (source.memory) {\n      result.memory = { ...result.memory, ...source.memory };\n    }\n    if (source.coordination) {\n      result.coordination = { ...result.coordination, ...source.coordination };\n    }\n    if (source.mcp) {\n      result.mcp = { ...result.mcp, ...source.mcp };\n    }\n    if (source.logging) {\n      result.logging = { ...result.logging, ...source.logging };\n    }\n    if (source.credentials) {\n      result.credentials = { ...result.credentials, ...source.credentials };\n    }\n    if (source.security) {\n      result.security = { ...result.security, ...source.security };\n    }\n  }\n\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["obj", "fs"]
}
