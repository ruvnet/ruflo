{"version":3,"sources":["../../../src/task/coordination.ts"],"sourcesContent":["/**\r\n * Task Coordination Layer - Integrates with TodoWrite/TodoRead and Memory for orchestration\r\n * Provides seamless coordination between task management and Claude Code batch tools\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport type { TaskEngine, WorkflowTask, TaskExecution } from './engine.js';\r\nimport type { TodoItem, MemoryEntry, CoordinationContext } from './types.js';\r\nimport { generateId } from '../utils/helpers.js';\r\n\r\nexport class TaskCoordinator extends EventEmitter {\r\n  private todoItems = new Map<string, TodoItem>();\r\n  private memoryStore = new Map<string, MemoryEntry>();\r\n  private coordinationSessions = new Map<string, CoordinationContext>();\r\n  private batchOperations = new Map<string, BatchOperation>();\r\n  private agentCoordination = new Map<string, AgentCoordinationState>();\r\n\r\n  constructor(\r\n    private taskEngine: TaskEngine,\r\n    private memoryManager?: any,\r\n  ) {\r\n    super();\r\n    this.setupCoordinationHandlers();\r\n  }\r\n\r\n  private setupCoordinationHandlers(): void {\r\n    this.taskEngine.on('task:created', this.handleTaskCreated.bind(this));\r\n    this.taskEngine.on('task:started', this.handleTaskStarted.bind(this));\r\n    this.taskEngine.on('task:completed', this.handleTaskCompleted.bind(this));\r\n    this.taskEngine.on('task:failed', this.handleTaskFailed.bind(this));\r\n    this.taskEngine.on('task:cancelled', this.handleTaskCancelled.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Create TodoWrite-style task breakdown for complex operations\r\n   */\r\n  async createTaskTodos(\r\n    objective: string,\r\n    context: CoordinationContext,\r\n    options: {\r\n      strategy?:\r\n        | 'research'\r\n        | 'development'\r\n        | 'analysis'\r\n        | 'testing'\r\n        | 'optimization'\r\n        | 'maintenance';\r\n      maxTasks?: number;\r\n      batchOptimized?: boolean;\r\n      parallelExecution?: boolean;\r\n      memoryCoordination?: boolean;\r\n    } = {},\r\n  ): Promise<TodoItem[]> {\r\n    const sessionId = context.sessionId;\r\n    this.coordinationSessions.set(sessionId, context);\r\n\r\n    // AI-powered task breakdown based on objective and strategy\r\n    const todos = await this.generateTaskBreakdown(objective, options);\r\n\r\n    // Store todos in coordination system\r\n    for (const todo of todos) {\r\n      this.todoItems.set(todo.id, todo);\r\n\r\n      // Store in memory for cross-agent coordination\r\n      if (options.memoryCoordination && this.memoryManager) {\r\n        await this.storeInMemory(`todo:${todo.id}`, todo, {\r\n          namespace: 'task_coordination',\r\n          tags: ['todo', 'task_breakdown', sessionId],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Emit coordination event\r\n    this.emit('todos:created', { sessionId, todos, context });\r\n\r\n    return todos;\r\n  }\r\n\r\n  /**\r\n   * Update TodoRead-style progress tracking\r\n   */\r\n  async updateTodoProgress(\r\n    todoId: string,\r\n    status: 'pending' | 'in_progress' | 'completed',\r\n    metadata?: Record<string, unknown>,\r\n  ): Promise<void> {\r\n    const todo = this.todoItems.get(todoId);\r\n    if (!todo) {\r\n      throw new Error(`Todo ${todoId} not found`);\r\n    }\r\n\r\n    const previousStatus = todo.status;\r\n    todo.status = status;\r\n    todo.metadata = { ...todo.metadata, ...metadata, updatedAt: new Date() };\r\n\r\n    // Update in memory for coordination\r\n    if (this.memoryManager) {\r\n      await this.storeInMemory(`todo:${todoId}`, todo, {\r\n        namespace: 'task_coordination',\r\n        tags: ['todo', 'progress_update'],\r\n      });\r\n    }\r\n\r\n    // Create corresponding task if moving to in_progress\r\n    if (status === 'in_progress' && previousStatus === 'pending') {\r\n      await this.createTaskFromTodo(todo);\r\n    }\r\n\r\n    this.emit('todo:updated', { todoId, status, previousStatus, todo });\r\n  }\r\n\r\n  /**\r\n   * Read all todos for coordination (TodoRead equivalent)\r\n   */\r\n  async readTodos(\r\n    sessionId?: string,\r\n    filter?: {\r\n      status?: TodoItem['status'][];\r\n      priority?: TodoItem['priority'][];\r\n      assignedAgent?: string;\r\n      tags?: string[];\r\n      batchOptimized?: boolean;\r\n    },\r\n  ): Promise<TodoItem[]> {\r\n    let todos = Array.from(this.todoItems.values());\r\n\r\n    // Filter by session if provided\r\n    if (sessionId) {\r\n      const sessionTodos = await this.getSessionTodos(sessionId);\r\n      todos = todos.filter((todo) => sessionTodos.some((st) => st.id === todo.id));\r\n    }\r\n\r\n    // Apply filters\r\n    if (filter) {\r\n      if (filter.status) {\r\n        todos = todos.filter((todo) => filter.status!.includes(todo.status));\r\n      }\r\n      if (filter.priority) {\r\n        todos = todos.filter((todo) => filter.priority!.includes(todo.priority));\r\n      }\r\n      if (filter.assignedAgent) {\r\n        todos = todos.filter((todo) => todo.assignedAgent === filter.assignedAgent);\r\n      }\r\n      if (filter.tags) {\r\n        todos = todos.filter((todo) => todo.tags?.some((tag) => filter.tags!.includes(tag)));\r\n      }\r\n      if (filter.batchOptimized !== undefined) {\r\n        todos = todos.filter((todo) => todo.batchOptimized === filter.batchOptimized);\r\n      }\r\n    }\r\n\r\n    return todos;\r\n  }\r\n\r\n  /**\r\n   * Store data in Memory for cross-agent coordination\r\n   */\r\n  async storeInMemory(\r\n    key: string,\r\n    value: any,\r\n    options: {\r\n      namespace?: string;\r\n      tags?: string[];\r\n      expiresAt?: Date;\r\n    } = {},\r\n  ): Promise<void> {\r\n    const entry: MemoryEntry = {\r\n      key,\r\n      value,\r\n      timestamp: new Date(),\r\n      namespace: options.namespace,\r\n      tags: options.tags,\r\n      expiresAt: options.expiresAt,\r\n    };\r\n\r\n    this.memoryStore.set(key, entry);\r\n\r\n    // Store in external memory manager if available\r\n    if (this.memoryManager) {\r\n      const memoryKey = options.namespace ? `${options.namespace}:${key}` : key;\r\n      await this.memoryManager.store(memoryKey, value, {\r\n        tags: options.tags,\r\n        expiresAt: options.expiresAt,\r\n      });\r\n    }\r\n\r\n    this.emit('memory:stored', { key, entry });\r\n  }\r\n\r\n  /**\r\n   * Retrieve data from Memory for coordination\r\n   */\r\n  async retrieveFromMemory(key: string, namespace?: string): Promise<any | null> {\r\n    const memoryKey = namespace ? `${namespace}:${key}` : key;\r\n\r\n    // Try external memory manager first\r\n    if (this.memoryManager) {\r\n      try {\r\n        const value = await this.memoryManager.retrieve(memoryKey);\r\n        if (value !== null) return value;\r\n      } catch (error) {\r\n        // Fall back to local store\r\n      }\r\n    }\r\n\r\n    // Use local store\r\n    const entry = this.memoryStore.get(key);\r\n    if (!entry) return null;\r\n\r\n    // Check expiration\r\n    if (entry.expiresAt && entry.expiresAt < new Date()) {\r\n      this.memoryStore.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry.value;\r\n  }\r\n\r\n  /**\r\n   * Query Memory with filters for coordination\r\n   */\r\n  async queryMemory(query: {\r\n    namespace?: string;\r\n    tags?: string[];\r\n    keyPattern?: string;\r\n    since?: Date;\r\n    limit?: number;\r\n  }): Promise<MemoryEntry[]> {\r\n    let entries = Array.from(this.memoryStore.values());\r\n\r\n    // Apply filters\r\n    if (query.namespace) {\r\n      entries = entries.filter((entry) => entry.namespace === query.namespace);\r\n    }\r\n    if (query.tags) {\r\n      entries = entries.filter((entry) => entry.tags?.some((tag) => query.tags!.includes(tag)));\r\n    }\r\n    if (query.keyPattern) {\r\n      const pattern = new RegExp(query.keyPattern);\r\n      entries = entries.filter((entry) => pattern.test(entry.key));\r\n    }\r\n    if (query.since) {\r\n      entries = entries.filter((entry) => entry.timestamp >= query.since!);\r\n    }\r\n\r\n    // Sort by timestamp (newest first)\r\n    entries.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\r\n\r\n    // Apply limit\r\n    if (query.limit) {\r\n      entries = entries.slice(0, query.limit);\r\n    }\r\n\r\n    return entries;\r\n  }\r\n\r\n  /**\r\n   * Launch parallel agents using Task tool pattern\r\n   */\r\n  async launchParallelAgents(\r\n    tasks: Array<{\r\n      agentType: string;\r\n      objective: string;\r\n      mode?: string;\r\n      configuration?: Record<string, unknown>;\r\n      memoryKey?: string;\r\n      batchOptimized?: boolean;\r\n    }>,\r\n    coordinationContext: CoordinationContext,\r\n  ): Promise<string[]> {\r\n    const batchId = generateId('batch');\r\n    const agentIds: string[] = [];\r\n\r\n    const batchOperation: BatchOperation = {\r\n      id: batchId,\r\n      type: 'parallel_agents',\r\n      tasks,\r\n      startedAt: new Date(),\r\n      status: 'running',\r\n      results: new Map(),\r\n      errors: new Map(),\r\n    };\r\n\r\n    this.batchOperations.set(batchId, batchOperation);\r\n\r\n    // Store batch operation in memory for coordination\r\n    await this.storeInMemory(`batch:${batchId}`, batchOperation, {\r\n      namespace: 'coordination',\r\n      tags: ['batch_operation', 'parallel_agents'],\r\n    });\r\n\r\n    // Launch each agent\r\n    for (const task of tasks) {\r\n      try {\r\n        const agentId = await this.launchAgent(task, coordinationContext, batchId);\r\n        agentIds.push(agentId);\r\n\r\n        // Store agent coordination state\r\n        this.agentCoordination.set(agentId, {\r\n          agentId,\r\n          batchId,\r\n          objective: task.objective,\r\n          status: 'running',\r\n          startedAt: new Date(),\r\n          memoryKey: task.memoryKey,\r\n          coordinationContext,\r\n        });\r\n      } catch (error) {\r\n        batchOperation.errors.set(task.agentType, error as Error);\r\n      }\r\n    }\r\n\r\n    this.emit('agents:launched', { batchId, agentIds, tasks });\r\n\r\n    return agentIds;\r\n  }\r\n\r\n  /**\r\n   * Coordinate batch operations for maximum efficiency\r\n   */\r\n  async coordinateBatchOperations(\r\n    operations: Array<{\r\n      type: 'read' | 'write' | 'edit' | 'search' | 'analyze';\r\n      targets: string[];\r\n      configuration?: Record<string, unknown>;\r\n    }>,\r\n    context: CoordinationContext,\r\n  ): Promise<Map<string, any>> {\r\n    const batchId = generateId('batch_ops');\r\n    const results = new Map<string, any>();\r\n\r\n    // Group operations by type for maximum efficiency\r\n    const groupedOps = new Map<string, Array<any>>();\r\n\r\n    for (const op of operations) {\r\n      if (!groupedOps.has(op.type)) {\r\n        groupedOps.set(op.type, []);\r\n      }\r\n      groupedOps.get(op.type)!.push(op);\r\n    }\r\n\r\n    // Store batch coordination info\r\n    await this.storeInMemory(\r\n      `batch_ops:${batchId}`,\r\n      {\r\n        operations,\r\n        groupedOps: Object.fromEntries(groupedOps),\r\n        context,\r\n        startedAt: new Date(),\r\n      },\r\n      {\r\n        namespace: 'coordination',\r\n        tags: ['batch_operations', 'efficiency'],\r\n      },\r\n    );\r\n\r\n    // Execute operations in parallel by type\r\n    const promises: Promise<void>[] = [];\r\n\r\n    for (const [type, ops] of Array.from(groupedOps.entries())) {\r\n      promises.push(this.executeBatchOperationType(type, ops, batchId, results));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    this.emit('batch:completed', { batchId, results, context });\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Swarm coordination patterns based on mode\r\n   */\r\n  async coordinateSwarm(\r\n    objective: string,\r\n    context: CoordinationContext,\r\n    agents: Array<{\r\n      type: string;\r\n      role: string;\r\n      capabilities: string[];\r\n    }>,\r\n  ): Promise<void> {\r\n    const swarmId = generateId('swarm');\r\n\r\n    // Store swarm configuration\r\n    await this.storeInMemory(\r\n      `swarm:${swarmId}`,\r\n      {\r\n        objective,\r\n        context,\r\n        agents,\r\n        startedAt: new Date(),\r\n        coordinationPattern: context.coordinationMode,\r\n      },\r\n      {\r\n        namespace: 'swarm_coordination',\r\n        tags: ['swarm', context.coordinationMode],\r\n      },\r\n    );\r\n\r\n    switch (context.coordinationMode) {\r\n      case 'centralized':\r\n        await this.coordinateCentralizedSwarm(swarmId, objective, agents);\r\n        break;\r\n      case 'distributed':\r\n        await this.coordinateDistributedSwarm(swarmId, objective, agents);\r\n        break;\r\n      case 'hierarchical':\r\n        await this.coordinateHierarchicalSwarm(swarmId, objective, agents);\r\n        break;\r\n      case 'mesh':\r\n        await this.coordinateMeshSwarm(swarmId, objective, agents);\r\n        break;\r\n      case 'hybrid':\r\n        await this.coordinateHybridSwarm(swarmId, objective, agents);\r\n        break;\r\n    }\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private async generateTaskBreakdown(objective: string, options: any): Promise<TodoItem[]> {\r\n    // AI-powered task breakdown based on strategy\r\n    const strategy = options.strategy || 'development';\r\n    const todos: TodoItem[] = [];\r\n\r\n    // Strategy-specific task patterns\r\n    switch (strategy) {\r\n      case 'research':\r\n        todos.push(\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Gather initial information and sources',\r\n            status: 'pending',\r\n            priority: 'high',\r\n            batchOptimized: true,\r\n            parallelExecution: true,\r\n            memoryKey: 'research_sources',\r\n            tags: ['research', 'information_gathering'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Analyze and synthesize findings',\r\n            status: 'pending',\r\n            priority: 'medium',\r\n            dependencies: ['research_sources'],\r\n            batchOptimized: true,\r\n            memoryKey: 'research_analysis',\r\n            tags: ['research', 'analysis'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'development':\r\n        todos.push(\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Design system architecture',\r\n            status: 'pending',\r\n            priority: 'high',\r\n            memoryKey: 'system_architecture',\r\n            tags: ['development', 'architecture'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Implement core functionality',\r\n            status: 'pending',\r\n            priority: 'high',\r\n            dependencies: ['system_architecture'],\r\n            batchOptimized: true,\r\n            parallelExecution: true,\r\n            memoryKey: 'core_implementation',\r\n            tags: ['development', 'implementation'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Write comprehensive tests',\r\n            status: 'pending',\r\n            priority: 'medium',\r\n            dependencies: ['core_implementation'],\r\n            batchOptimized: true,\r\n            memoryKey: 'test_suite',\r\n            tags: ['development', 'testing'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'analysis':\r\n        todos.push(\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Collect and preprocess data',\r\n            status: 'pending',\r\n            priority: 'high',\r\n            batchOptimized: true,\r\n            parallelExecution: true,\r\n            memoryKey: 'analysis_data',\r\n            tags: ['analysis', 'data_collection'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Perform statistical analysis',\r\n            status: 'pending',\r\n            priority: 'high',\r\n            dependencies: ['analysis_data'],\r\n            batchOptimized: true,\r\n            memoryKey: 'statistical_results',\r\n            tags: ['analysis', 'statistics'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: 'Generate insights and reports',\r\n            status: 'pending',\r\n            priority: 'medium',\r\n            dependencies: ['statistical_results'],\r\n            memoryKey: 'analysis_insights',\r\n            tags: ['analysis', 'reporting'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n        );\r\n        break;\r\n\r\n      default:\r\n        // Generic breakdown\r\n        todos.push(\r\n          {\r\n            id: generateId('todo'),\r\n            content: `Analyze requirements for: ${objective}`,\r\n            status: 'pending',\r\n            priority: 'high',\r\n            memoryKey: 'requirements_analysis',\r\n            tags: ['generic', 'requirements'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: `Execute main tasks for: ${objective}`,\r\n            status: 'pending',\r\n            priority: 'high',\r\n            dependencies: ['requirements_analysis'],\r\n            batchOptimized: true,\r\n            parallelExecution: true,\r\n            memoryKey: 'main_execution',\r\n            tags: ['generic', 'execution'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n          {\r\n            id: generateId('todo'),\r\n            content: `Validate and finalize results`,\r\n            status: 'pending',\r\n            priority: 'medium',\r\n            dependencies: ['main_execution'],\r\n            memoryKey: 'validation_results',\r\n            tags: ['generic', 'validation'],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n          },\r\n        );\r\n    }\r\n\r\n    return todos;\r\n  }\r\n\r\n  private async createTaskFromTodo(todo: TodoItem): Promise<WorkflowTask> {\r\n    const taskData = {\r\n      type: todo.tags?.[0] || 'general',\r\n      description: todo.content,\r\n      priority: this.priorityToNumber(todo.priority),\r\n      assignedAgent: todo.assignedAgent,\r\n      tags: todo.tags || [],\r\n      metadata: {\r\n        todoId: todo.id,\r\n        batchOptimized: todo.batchOptimized,\r\n        parallelExecution: todo.parallelExecution,\r\n        memoryKey: todo.memoryKey,\r\n      },\r\n    };\r\n\r\n    return await this.taskEngine.createTask(taskData);\r\n  }\r\n\r\n  private priorityToNumber(priority: 'high' | 'medium' | 'low' | 'critical'): number {\r\n    switch (priority) {\r\n      case 'critical':\r\n        return 90;\r\n      case 'high':\r\n        return 80;\r\n      case 'medium':\r\n        return 50;\r\n      case 'low':\r\n        return 20;\r\n      default:\r\n        return 50;\r\n    }\r\n  }\r\n\r\n  private async launchAgent(\r\n    task: any,\r\n    context: CoordinationContext,\r\n    batchId: string,\r\n  ): Promise<string> {\r\n    const agentId = generateId('agent');\r\n\r\n    // Store agent launch info in memory\r\n    await this.storeInMemory(\r\n      `agent:${agentId}`,\r\n      {\r\n        ...task,\r\n        agentId,\r\n        batchId,\r\n        context,\r\n        launchedAt: new Date(),\r\n      },\r\n      {\r\n        namespace: 'agent_coordination',\r\n        tags: ['agent_launch', task.agentType],\r\n      },\r\n    );\r\n\r\n    return agentId;\r\n  }\r\n\r\n  private async executeBatchOperationType(\r\n    type: string,\r\n    operations: any[],\r\n    batchId: string,\r\n    results: Map<string, any>,\r\n  ): Promise<void> {\r\n    // Simulate batch operation execution\r\n    // In real implementation, this would use actual tools\r\n\r\n    for (const op of operations) {\r\n      try {\r\n        const result = await this.simulateBatchOperation(type, op);\r\n        results.set(`${type}_${op.targets.join('_')}`, result);\r\n      } catch (error) {\r\n        results.set(`${type}_${op.targets.join('_')}_error`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async simulateBatchOperation(type: string, operation: any): Promise<any> {\r\n    // Simulate operation based on type\r\n    await new Promise((resolve) => setTimeout(resolve, 100));\r\n\r\n    return {\r\n      type,\r\n      targets: operation.targets,\r\n      result: `Simulated ${type} operation completed`,\r\n      timestamp: new Date(),\r\n    };\r\n  }\r\n\r\n  // Swarm coordination patterns\r\n\r\n  private async coordinateCentralizedSwarm(\r\n    swarmId: string,\r\n    objective: string,\r\n    agents: any[],\r\n  ): Promise<void> {\r\n    // Single coordinator manages all agents\r\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\r\n      type: 'centralized',\r\n      coordinator: 'main',\r\n      agentAssignments: agents.map((agent) => ({\r\n        agentId: agent.type,\r\n        role: agent.role,\r\n        coordinator: 'main',\r\n      })),\r\n    });\r\n  }\r\n\r\n  private async coordinateDistributedSwarm(\r\n    swarmId: string,\r\n    objective: string,\r\n    agents: any[],\r\n  ): Promise<void> {\r\n    // Multiple coordinators for different aspects\r\n    const coordinators = ['research_coord', 'impl_coord', 'test_coord'];\r\n\r\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\r\n      type: 'distributed',\r\n      coordinators,\r\n      agentAssignments: agents.map((agent, index) => ({\r\n        agentId: agent.type,\r\n        role: agent.role,\r\n        coordinator: coordinators[index % coordinators.length],\r\n      })),\r\n    });\r\n  }\r\n\r\n  private async coordinateHierarchicalSwarm(\r\n    swarmId: string,\r\n    objective: string,\r\n    agents: any[],\r\n  ): Promise<void> {\r\n    // Tree structure with team leads\r\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\r\n      type: 'hierarchical',\r\n      hierarchy: {\r\n        master: 'main_coordinator',\r\n        teamLeads: ['frontend_lead', 'backend_lead', 'devops_lead'],\r\n        teams: {\r\n          frontend_lead: agents.filter((a) => a.type.includes('frontend')),\r\n          backend_lead: agents.filter((a) => a.type.includes('backend')),\r\n          devops_lead: agents.filter((a) => a.type.includes('devops')),\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  private async coordinateMeshSwarm(\r\n    swarmId: string,\r\n    objective: string,\r\n    agents: any[],\r\n  ): Promise<void> {\r\n    // Peer-to-peer coordination\r\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\r\n      type: 'mesh',\r\n      peerConnections: agents.map((agent) => ({\r\n        agentId: agent.type,\r\n        peers: agents.filter((a) => a.type !== agent.type).map((a) => a.type),\r\n      })),\r\n    });\r\n  }\r\n\r\n  private async coordinateHybridSwarm(\r\n    swarmId: string,\r\n    objective: string,\r\n    agents: any[],\r\n  ): Promise<void> {\r\n    // Mixed patterns based on requirements\r\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\r\n      type: 'hybrid',\r\n      phases: [\r\n        { phase: 'planning', pattern: 'centralized' },\r\n        { phase: 'execution', pattern: 'distributed' },\r\n        { phase: 'integration', pattern: 'hierarchical' },\r\n      ],\r\n    });\r\n  }\r\n\r\n  private async getSessionTodos(sessionId: string): Promise<TodoItem[]> {\r\n    const entries = await this.queryMemory({\r\n      namespace: 'task_coordination',\r\n      tags: ['todo', sessionId],\r\n    });\r\n\r\n    return entries.map((entry) => entry.value as TodoItem);\r\n  }\r\n\r\n  // Event handlers\r\n\r\n  private async handleTaskCreated(data: { task: WorkflowTask }): Promise<void> {\r\n    // Update corresponding todo if exists\r\n    const todoId = data.task.metadata?.todoId;\r\n    if (todoId) {\r\n      await this.updateTodoProgress(todoId as string, 'in_progress', {\r\n        taskId: data.task.id,\r\n        createdAt: data.task.createdAt,\r\n      });\r\n    }\r\n  }\r\n\r\n  private async handleTaskStarted(data: { taskId: string; agentId: string }): Promise<void> {\r\n    // Store task start in memory for coordination\r\n    await this.storeInMemory(\r\n      `task_execution:${data.taskId}`,\r\n      {\r\n        status: 'started',\r\n        agentId: data.agentId,\r\n        startedAt: new Date(),\r\n      },\r\n      {\r\n        namespace: 'task_execution',\r\n        tags: ['task_start', data.agentId],\r\n      },\r\n    );\r\n  }\r\n\r\n  private async handleTaskCompleted(data: { taskId: string; result: unknown }): Promise<void> {\r\n    // Update todo and store results\r\n    const task = (await this.taskEngine.getTaskStatus(data.taskId))?.task;\r\n    const todoId = task?.metadata?.todoId;\r\n\r\n    if (todoId) {\r\n      await this.updateTodoProgress(todoId as string, 'completed', {\r\n        completedAt: new Date(),\r\n        result: data.result,\r\n      });\r\n    }\r\n\r\n    // Store completion in memory\r\n    await this.storeInMemory(\r\n      `task_execution:${data.taskId}`,\r\n      {\r\n        status: 'completed',\r\n        result: data.result,\r\n        completedAt: new Date(),\r\n      },\r\n      {\r\n        namespace: 'task_execution',\r\n        tags: ['task_completion'],\r\n      },\r\n    );\r\n  }\r\n\r\n  private async handleTaskFailed(data: { taskId: string; error: Error }): Promise<void> {\r\n    // Store failure info\r\n    await this.storeInMemory(\r\n      `task_execution:${data.taskId}`,\r\n      {\r\n        status: 'failed',\r\n        error: data.error.message,\r\n        failedAt: new Date(),\r\n      },\r\n      {\r\n        namespace: 'task_execution',\r\n        tags: ['task_failure'],\r\n      },\r\n    );\r\n  }\r\n\r\n  private async handleTaskCancelled(data: { taskId: string; reason: string }): Promise<void> {\r\n    // Store cancellation info\r\n    await this.storeInMemory(\r\n      `task_execution:${data.taskId}`,\r\n      {\r\n        status: 'cancelled',\r\n        reason: data.reason,\r\n        cancelledAt: new Date(),\r\n      },\r\n      {\r\n        namespace: 'task_execution',\r\n        tags: ['task_cancellation'],\r\n      },\r\n    );\r\n  }\r\n}\r\n\r\n// Supporting interfaces\r\n\r\ninterface BatchOperation {\r\n  id: string;\r\n  type: string;\r\n  tasks: any[];\r\n  startedAt: Date;\r\n  completedAt?: Date;\r\n  status: 'running' | 'completed' | 'failed';\r\n  results: Map<string, any>;\r\n  errors: Map<string, Error>;\r\n}\r\n\r\ninterface AgentCoordinationState {\r\n  agentId: string;\r\n  batchId?: string;\r\n  objective: string;\r\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\r\n  startedAt: Date;\r\n  completedAt?: Date;\r\n  memoryKey?: string;\r\n  coordinationContext: CoordinationContext;\r\n  lastHeartbeat?: Date;\r\n}\r\n"],"names":["EventEmitter","generateId","TaskCoordinator","todoItems","Map","memoryStore","coordinationSessions","batchOperations","agentCoordination","taskEngine","memoryManager","setupCoordinationHandlers","on","handleTaskCreated","bind","handleTaskStarted","handleTaskCompleted","handleTaskFailed","handleTaskCancelled","createTaskTodos","objective","context","options","sessionId","set","todos","generateTaskBreakdown","todo","id","memoryCoordination","storeInMemory","namespace","tags","emit","updateTodoProgress","todoId","status","metadata","get","Error","previousStatus","updatedAt","Date","createTaskFromTodo","readTodos","filter","Array","from","values","sessionTodos","getSessionTodos","some","st","includes","priority","assignedAgent","tag","batchOptimized","undefined","key","value","entry","timestamp","expiresAt","memoryKey","store","retrieveFromMemory","retrieve","error","delete","queryMemory","query","entries","keyPattern","pattern","RegExp","test","since","sort","a","b","getTime","limit","slice","launchParallelAgents","tasks","coordinationContext","batchId","agentIds","batchOperation","type","startedAt","results","errors","task","agentId","launchAgent","push","agentType","coordinateBatchOperations","operations","groupedOps","op","has","Object","fromEntries","promises","ops","executeBatchOperationType","Promise","all","coordinateSwarm","agents","swarmId","coordinationPattern","coordinationMode","coordinateCentralizedSwarm","coordinateDistributedSwarm","coordinateHierarchicalSwarm","coordinateMeshSwarm","coordinateHybridSwarm","strategy","content","parallelExecution","createdAt","dependencies","taskData","description","priorityToNumber","createTask","launchedAt","result","simulateBatchOperation","targets","join","operation","resolve","setTimeout","coordinator","agentAssignments","map","agent","role","coordinators","index","length","hierarchy","master","teamLeads","teams","frontend_lead","backend_lead","devops_lead","peerConnections","peers","phases","phase","data","taskId","getTaskStatus","completedAt","message","failedAt","reason","cancelledAt"],"mappings":"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"}