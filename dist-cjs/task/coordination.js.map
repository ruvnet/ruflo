{
  "version": 3,
  "sources": ["../../src/task/coordination.ts"],
  "sourcesContent": ["/**\n * Task Coordination Layer - Integrates with TodoWrite/TodoRead and Memory for orchestration\n * Provides seamless coordination between task management and Claude Code batch tools\n */\n\nimport { EventEmitter } from 'events';\nimport type { TaskEngine, WorkflowTask, TaskExecution } from './engine.js';\nimport type { TodoItem, MemoryEntry, CoordinationContext } from './types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport class TaskCoordinator extends EventEmitter {\n  private todoItems = new Map<string, TodoItem>();\n  private memoryStore = new Map<string, MemoryEntry>();\n  private coordinationSessions = new Map<string, CoordinationContext>();\n  private batchOperations = new Map<string, BatchOperation>();\n  private agentCoordination = new Map<string, AgentCoordinationState>();\n\n  constructor(\n    private taskEngine: TaskEngine,\n    private memoryManager?: any,\n  ) {\n    super();\n    this.setupCoordinationHandlers();\n  }\n\n  private setupCoordinationHandlers(): void {\n    this.taskEngine.on('task:created', this.handleTaskCreated.bind(this));\n    this.taskEngine.on('task:started', this.handleTaskStarted.bind(this));\n    this.taskEngine.on('task:completed', this.handleTaskCompleted.bind(this));\n    this.taskEngine.on('task:failed', this.handleTaskFailed.bind(this));\n    this.taskEngine.on('task:cancelled', this.handleTaskCancelled.bind(this));\n  }\n\n  /**\n   * Create TodoWrite-style task breakdown for complex operations\n   */\n  async createTaskTodos(\n    objective: string,\n    context: CoordinationContext,\n    options: {\n      strategy?:\n        | 'research'\n        | 'development'\n        | 'analysis'\n        | 'testing'\n        | 'optimization'\n        | 'maintenance';\n      maxTasks?: number;\n      batchOptimized?: boolean;\n      parallelExecution?: boolean;\n      memoryCoordination?: boolean;\n    } = {},\n  ): Promise<TodoItem[]> {\n    const sessionId = context.sessionId;\n    this.coordinationSessions.set(sessionId, context);\n\n    // AI-powered task breakdown based on objective and strategy\n    const todos = await this.generateTaskBreakdown(objective, options);\n\n    // Store todos in coordination system\n    for (const todo of todos) {\n      this.todoItems.set(todo.id, todo);\n\n      // Store in memory for cross-agent coordination\n      if (options.memoryCoordination && this.memoryManager) {\n        await this.storeInMemory(`todo:${todo.id}`, todo, {\n          namespace: 'task_coordination',\n          tags: ['todo', 'task_breakdown', sessionId],\n        });\n      }\n    }\n\n    // Emit coordination event\n    this.emit('todos:created', { sessionId, todos, context });\n\n    return todos;\n  }\n\n  /**\n   * Update TodoRead-style progress tracking\n   */\n  async updateTodoProgress(\n    todoId: string,\n    status: 'pending' | 'in_progress' | 'completed',\n    metadata?: Record<string, unknown>,\n  ): Promise<void> {\n    const todo = this.todoItems.get(todoId);\n    if (!todo) {\n      throw new Error(`Todo ${todoId} not found`);\n    }\n\n    const previousStatus = todo.status;\n    todo.status = status;\n    todo.metadata = { ...todo.metadata, ...metadata, updatedAt: new Date() };\n\n    // Update in memory for coordination\n    if (this.memoryManager) {\n      await this.storeInMemory(`todo:${todoId}`, todo, {\n        namespace: 'task_coordination',\n        tags: ['todo', 'progress_update'],\n      });\n    }\n\n    // Create corresponding task if moving to in_progress\n    if (status === 'in_progress' && previousStatus === 'pending') {\n      await this.createTaskFromTodo(todo);\n    }\n\n    this.emit('todo:updated', { todoId, status, previousStatus, todo });\n  }\n\n  /**\n   * Read all todos for coordination (TodoRead equivalent)\n   */\n  async readTodos(\n    sessionId?: string,\n    filter?: {\n      status?: TodoItem['status'][];\n      priority?: TodoItem['priority'][];\n      assignedAgent?: string;\n      tags?: string[];\n      batchOptimized?: boolean;\n    },\n  ): Promise<TodoItem[]> {\n    let todos = Array.from(this.todoItems.values());\n\n    // Filter by session if provided\n    if (sessionId) {\n      const sessionTodos = await this.getSessionTodos(sessionId);\n      todos = todos.filter((todo) => sessionTodos.some((st) => st.id === todo.id));\n    }\n\n    // Apply filters\n    if (filter) {\n      if (filter.status) {\n        todos = todos.filter((todo) => filter.status!.includes(todo.status));\n      }\n      if (filter.priority) {\n        todos = todos.filter((todo) => filter.priority!.includes(todo.priority));\n      }\n      if (filter.assignedAgent) {\n        todos = todos.filter((todo) => todo.assignedAgent === filter.assignedAgent);\n      }\n      if (filter.tags) {\n        todos = todos.filter((todo) => todo.tags?.some((tag) => filter.tags!.includes(tag)));\n      }\n      if (filter.batchOptimized !== undefined) {\n        todos = todos.filter((todo) => todo.batchOptimized === filter.batchOptimized);\n      }\n    }\n\n    return todos;\n  }\n\n  /**\n   * Store data in Memory for cross-agent coordination\n   */\n  async storeInMemory(\n    key: string,\n    value: any,\n    options: {\n      namespace?: string;\n      tags?: string[];\n      expiresAt?: Date;\n    } = {},\n  ): Promise<void> {\n    const entry: MemoryEntry = {\n      key,\n      value,\n      timestamp: new Date(),\n      namespace: options.namespace,\n      tags: options.tags,\n      expiresAt: options.expiresAt,\n    };\n\n    this.memoryStore.set(key, entry);\n\n    // Store in external memory manager if available\n    if (this.memoryManager) {\n      const memoryKey = options.namespace ? `${options.namespace}:${key}` : key;\n      await this.memoryManager.store(memoryKey, value, {\n        tags: options.tags,\n        expiresAt: options.expiresAt,\n      });\n    }\n\n    this.emit('memory:stored', { key, entry });\n  }\n\n  /**\n   * Retrieve data from Memory for coordination\n   */\n  async retrieveFromMemory(key: string, namespace?: string): Promise<any | null> {\n    const memoryKey = namespace ? `${namespace}:${key}` : key;\n\n    // Try external memory manager first\n    if (this.memoryManager) {\n      try {\n        const value = await this.memoryManager.retrieve(memoryKey);\n        if (value !== null) return value;\n      } catch (error) {\n        // Fall back to local store\n      }\n    }\n\n    // Use local store\n    const entry = this.memoryStore.get(key);\n    if (!entry) return null;\n\n    // Check expiration\n    if (entry.expiresAt && entry.expiresAt < new Date()) {\n      this.memoryStore.delete(key);\n      return null;\n    }\n\n    return entry.value;\n  }\n\n  /**\n   * Query Memory with filters for coordination\n   */\n  async queryMemory(query: {\n    namespace?: string;\n    tags?: string[];\n    keyPattern?: string;\n    since?: Date;\n    limit?: number;\n  }): Promise<MemoryEntry[]> {\n    let entries = Array.from(this.memoryStore.values());\n\n    // Apply filters\n    if (query.namespace) {\n      entries = entries.filter((entry) => entry.namespace === query.namespace);\n    }\n    if (query.tags) {\n      entries = entries.filter((entry) => entry.tags?.some((tag) => query.tags!.includes(tag)));\n    }\n    if (query.keyPattern) {\n      const pattern = new RegExp(query.keyPattern);\n      entries = entries.filter((entry) => pattern.test(entry.key));\n    }\n    if (query.since) {\n      entries = entries.filter((entry) => entry.timestamp >= query.since!);\n    }\n\n    // Sort by timestamp (newest first)\n    entries.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    // Apply limit\n    if (query.limit) {\n      entries = entries.slice(0, query.limit);\n    }\n\n    return entries;\n  }\n\n  /**\n   * Launch parallel agents using Task tool pattern\n   */\n  async launchParallelAgents(\n    tasks: Array<{\n      agentType: string;\n      objective: string;\n      mode?: string;\n      configuration?: Record<string, unknown>;\n      memoryKey?: string;\n      batchOptimized?: boolean;\n    }>,\n    coordinationContext: CoordinationContext,\n  ): Promise<string[]> {\n    const batchId = generateId('batch');\n    const agentIds: string[] = [];\n\n    const batchOperation: BatchOperation = {\n      id: batchId,\n      type: 'parallel_agents',\n      tasks,\n      startedAt: new Date(),\n      status: 'running',\n      results: new Map(),\n      errors: new Map(),\n    };\n\n    this.batchOperations.set(batchId, batchOperation);\n\n    // Store batch operation in memory for coordination\n    await this.storeInMemory(`batch:${batchId}`, batchOperation, {\n      namespace: 'coordination',\n      tags: ['batch_operation', 'parallel_agents'],\n    });\n\n    // Launch each agent\n    for (const task of tasks) {\n      try {\n        const agentId = await this.launchAgent(task, coordinationContext, batchId);\n        agentIds.push(agentId);\n\n        // Store agent coordination state\n        this.agentCoordination.set(agentId, {\n          agentId,\n          batchId,\n          objective: task.objective,\n          status: 'running',\n          startedAt: new Date(),\n          memoryKey: task.memoryKey,\n          coordinationContext,\n        });\n      } catch (error) {\n        batchOperation.errors.set(task.agentType, error as Error);\n      }\n    }\n\n    this.emit('agents:launched', { batchId, agentIds, tasks });\n\n    return agentIds;\n  }\n\n  /**\n   * Coordinate batch operations for maximum efficiency\n   */\n  async coordinateBatchOperations(\n    operations: Array<{\n      type: 'read' | 'write' | 'edit' | 'search' | 'analyze';\n      targets: string[];\n      configuration?: Record<string, unknown>;\n    }>,\n    context: CoordinationContext,\n  ): Promise<Map<string, any>> {\n    const batchId = generateId('batch_ops');\n    const results = new Map<string, any>();\n\n    // Group operations by type for maximum efficiency\n    const groupedOps = new Map<string, Array<any>>();\n\n    for (const op of operations) {\n      if (!groupedOps.has(op.type)) {\n        groupedOps.set(op.type, []);\n      }\n      groupedOps.get(op.type)!.push(op);\n    }\n\n    // Store batch coordination info\n    await this.storeInMemory(\n      `batch_ops:${batchId}`,\n      {\n        operations,\n        groupedOps: Object.fromEntries(groupedOps),\n        context,\n        startedAt: new Date(),\n      },\n      {\n        namespace: 'coordination',\n        tags: ['batch_operations', 'efficiency'],\n      },\n    );\n\n    // Execute operations in parallel by type\n    const promises: Promise<void>[] = [];\n\n    for (const [type, ops] of Array.from(groupedOps.entries())) {\n      promises.push(this.executeBatchOperationType(type, ops, batchId, results));\n    }\n\n    await Promise.all(promises);\n\n    this.emit('batch:completed', { batchId, results, context });\n\n    return results;\n  }\n\n  /**\n   * Swarm coordination patterns based on mode\n   */\n  async coordinateSwarm(\n    objective: string,\n    context: CoordinationContext,\n    agents: Array<{\n      type: string;\n      role: string;\n      capabilities: string[];\n    }>,\n  ): Promise<void> {\n    const swarmId = generateId('swarm');\n\n    // Store swarm configuration\n    await this.storeInMemory(\n      `swarm:${swarmId}`,\n      {\n        objective,\n        context,\n        agents,\n        startedAt: new Date(),\n        coordinationPattern: context.coordinationMode,\n      },\n      {\n        namespace: 'swarm_coordination',\n        tags: ['swarm', context.coordinationMode],\n      },\n    );\n\n    switch (context.coordinationMode) {\n      case 'centralized':\n        await this.coordinateCentralizedSwarm(swarmId, objective, agents);\n        break;\n      case 'distributed':\n        await this.coordinateDistributedSwarm(swarmId, objective, agents);\n        break;\n      case 'hierarchical':\n        await this.coordinateHierarchicalSwarm(swarmId, objective, agents);\n        break;\n      case 'mesh':\n        await this.coordinateMeshSwarm(swarmId, objective, agents);\n        break;\n      case 'hybrid':\n        await this.coordinateHybridSwarm(swarmId, objective, agents);\n        break;\n    }\n  }\n\n  // Private helper methods\n\n  private async generateTaskBreakdown(objective: string, options: any): Promise<TodoItem[]> {\n    // AI-powered task breakdown based on strategy\n    const strategy = options.strategy || 'development';\n    const todos: TodoItem[] = [];\n\n    // Strategy-specific task patterns\n    switch (strategy) {\n      case 'research':\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: 'Gather initial information and sources',\n            status: 'pending',\n            priority: 'high',\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'research_sources',\n            tags: ['research', 'information_gathering'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Analyze and synthesize findings',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['research_sources'],\n            batchOptimized: true,\n            memoryKey: 'research_analysis',\n            tags: ['research', 'analysis'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n        break;\n\n      case 'development':\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: 'Design system architecture',\n            status: 'pending',\n            priority: 'high',\n            memoryKey: 'system_architecture',\n            tags: ['development', 'architecture'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Implement core functionality',\n            status: 'pending',\n            priority: 'high',\n            dependencies: ['system_architecture'],\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'core_implementation',\n            tags: ['development', 'implementation'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Write comprehensive tests',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['core_implementation'],\n            batchOptimized: true,\n            memoryKey: 'test_suite',\n            tags: ['development', 'testing'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n        break;\n\n      case 'analysis':\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: 'Collect and preprocess data',\n            status: 'pending',\n            priority: 'high',\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'analysis_data',\n            tags: ['analysis', 'data_collection'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Perform statistical analysis',\n            status: 'pending',\n            priority: 'high',\n            dependencies: ['analysis_data'],\n            batchOptimized: true,\n            memoryKey: 'statistical_results',\n            tags: ['analysis', 'statistics'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Generate insights and reports',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['statistical_results'],\n            memoryKey: 'analysis_insights',\n            tags: ['analysis', 'reporting'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n        break;\n\n      default:\n        // Generic breakdown\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: `Analyze requirements for: ${objective}`,\n            status: 'pending',\n            priority: 'high',\n            memoryKey: 'requirements_analysis',\n            tags: ['generic', 'requirements'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: `Execute main tasks for: ${objective}`,\n            status: 'pending',\n            priority: 'high',\n            dependencies: ['requirements_analysis'],\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'main_execution',\n            tags: ['generic', 'execution'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: `Validate and finalize results`,\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['main_execution'],\n            memoryKey: 'validation_results',\n            tags: ['generic', 'validation'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n    }\n\n    return todos;\n  }\n\n  private async createTaskFromTodo(todo: TodoItem): Promise<WorkflowTask> {\n    const taskData = {\n      type: todo.tags?.[0] || 'general',\n      description: todo.content,\n      priority: this.priorityToNumber(todo.priority),\n      assignedAgent: todo.assignedAgent,\n      tags: todo.tags || [],\n      metadata: {\n        todoId: todo.id,\n        batchOptimized: todo.batchOptimized,\n        parallelExecution: todo.parallelExecution,\n        memoryKey: todo.memoryKey,\n      },\n    };\n\n    return await this.taskEngine.createTask(taskData);\n  }\n\n  private priorityToNumber(priority: 'high' | 'medium' | 'low' | 'critical'): number {\n    switch (priority) {\n      case 'critical':\n        return 90;\n      case 'high':\n        return 80;\n      case 'medium':\n        return 50;\n      case 'low':\n        return 20;\n      default:\n        return 50;\n    }\n  }\n\n  private async launchAgent(\n    task: any,\n    context: CoordinationContext,\n    batchId: string,\n  ): Promise<string> {\n    const agentId = generateId('agent');\n\n    // Store agent launch info in memory\n    await this.storeInMemory(\n      `agent:${agentId}`,\n      {\n        ...task,\n        agentId,\n        batchId,\n        context,\n        launchedAt: new Date(),\n      },\n      {\n        namespace: 'agent_coordination',\n        tags: ['agent_launch', task.agentType],\n      },\n    );\n\n    return agentId;\n  }\n\n  private async executeBatchOperationType(\n    type: string,\n    operations: any[],\n    batchId: string,\n    results: Map<string, any>,\n  ): Promise<void> {\n    // Simulate batch operation execution\n    // In real implementation, this would use actual tools\n\n    for (const op of operations) {\n      try {\n        const result = await this.simulateBatchOperation(type, op);\n        results.set(`${type}_${op.targets.join('_')}`, result);\n      } catch (error) {\n        results.set(`${type}_${op.targets.join('_')}_error`, error);\n      }\n    }\n  }\n\n  private async simulateBatchOperation(type: string, operation: any): Promise<any> {\n    // Simulate operation based on type\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    return {\n      type,\n      targets: operation.targets,\n      result: `Simulated ${type} operation completed`,\n      timestamp: new Date(),\n    };\n  }\n\n  // Swarm coordination patterns\n\n  private async coordinateCentralizedSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Single coordinator manages all agents\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'centralized',\n      coordinator: 'main',\n      agentAssignments: agents.map((agent) => ({\n        agentId: agent.type,\n        role: agent.role,\n        coordinator: 'main',\n      })),\n    });\n  }\n\n  private async coordinateDistributedSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Multiple coordinators for different aspects\n    const coordinators = ['research_coord', 'impl_coord', 'test_coord'];\n\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'distributed',\n      coordinators,\n      agentAssignments: agents.map((agent, index) => ({\n        agentId: agent.type,\n        role: agent.role,\n        coordinator: coordinators[index % coordinators.length],\n      })),\n    });\n  }\n\n  private async coordinateHierarchicalSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Tree structure with team leads\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'hierarchical',\n      hierarchy: {\n        master: 'main_coordinator',\n        teamLeads: ['frontend_lead', 'backend_lead', 'devops_lead'],\n        teams: {\n          frontend_lead: agents.filter((a) => a.type.includes('frontend')),\n          backend_lead: agents.filter((a) => a.type.includes('backend')),\n          devops_lead: agents.filter((a) => a.type.includes('devops')),\n        },\n      },\n    });\n  }\n\n  private async coordinateMeshSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Peer-to-peer coordination\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'mesh',\n      peerConnections: agents.map((agent) => ({\n        agentId: agent.type,\n        peers: agents.filter((a) => a.type !== agent.type).map((a) => a.type),\n      })),\n    });\n  }\n\n  private async coordinateHybridSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Mixed patterns based on requirements\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'hybrid',\n      phases: [\n        { phase: 'planning', pattern: 'centralized' },\n        { phase: 'execution', pattern: 'distributed' },\n        { phase: 'integration', pattern: 'hierarchical' },\n      ],\n    });\n  }\n\n  private async getSessionTodos(sessionId: string): Promise<TodoItem[]> {\n    const entries = await this.queryMemory({\n      namespace: 'task_coordination',\n      tags: ['todo', sessionId],\n    });\n\n    return entries.map((entry) => entry.value as TodoItem);\n  }\n\n  // Event handlers\n\n  private async handleTaskCreated(data: { task: WorkflowTask }): Promise<void> {\n    // Update corresponding todo if exists\n    const todoId = data.task.metadata?.todoId;\n    if (todoId) {\n      await this.updateTodoProgress(todoId as string, 'in_progress', {\n        taskId: data.task.id,\n        createdAt: data.task.createdAt,\n      });\n    }\n  }\n\n  private async handleTaskStarted(data: { taskId: string; agentId: string }): Promise<void> {\n    // Store task start in memory for coordination\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'started',\n        agentId: data.agentId,\n        startedAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_start', data.agentId],\n      },\n    );\n  }\n\n  private async handleTaskCompleted(data: { taskId: string; result: unknown }): Promise<void> {\n    // Update todo and store results\n    const task = (await this.taskEngine.getTaskStatus(data.taskId))?.task;\n    const todoId = task?.metadata?.todoId;\n\n    if (todoId) {\n      await this.updateTodoProgress(todoId as string, 'completed', {\n        completedAt: new Date(),\n        result: data.result,\n      });\n    }\n\n    // Store completion in memory\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'completed',\n        result: data.result,\n        completedAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_completion'],\n      },\n    );\n  }\n\n  private async handleTaskFailed(data: { taskId: string; error: Error }): Promise<void> {\n    // Store failure info\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'failed',\n        error: data.error.message,\n        failedAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_failure'],\n      },\n    );\n  }\n\n  private async handleTaskCancelled(data: { taskId: string; reason: string }): Promise<void> {\n    // Store cancellation info\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'cancelled',\n        reason: data.reason,\n        cancelledAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_cancellation'],\n      },\n    );\n  }\n}\n\n// Supporting interfaces\n\ninterface BatchOperation {\n  id: string;\n  type: string;\n  tasks: any[];\n  startedAt: Date;\n  completedAt?: Date;\n  status: 'running' | 'completed' | 'failed';\n  results: Map<string, any>;\n  errors: Map<string, Error>;\n}\n\ninterface AgentCoordinationState {\n  agentId: string;\n  batchId?: string;\n  objective: string;\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\n  startedAt: Date;\n  completedAt?: Date;\n  memoryKey?: string;\n  coordinationContext: CoordinationContext;\n  lastHeartbeat?: Date;\n}\n"],
  "mappings": "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",
  "names": []
}
