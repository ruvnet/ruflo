{
  "version": 3,
  "sources": ["../../src/maestro/maestro-swarm-coordinator.ts"],
  "sourcesContent": ["/**\n * MaestroSwarmCoordinator - Native Hive Mind Implementation\n * \n * Replaces MaestroOrchestrator with native hive mind swarm coordination.\n * Uses specs-driven topology and SwarmOrchestrator for all task management.\n * Eliminates dual agent systems and leverages collective intelligence.\n */\n\nimport { EventEmitter } from 'events';\nimport { join } from 'path';\nimport { readFile, writeFile, mkdir } from 'fs/promises';\n\n// Native hive mind components\nimport { HiveMind } from '../hive-mind/core/HiveMind.js';\nimport { Agent } from '../hive-mind/core/Agent.js';\nimport { ConsensusEngine } from '../hive-mind/integration/ConsensusEngine.js';\nimport { SwarmOrchestrator } from '../hive-mind/integration/SwarmOrchestrator.js';\nimport {\n  HiveMindConfig,\n  TaskSubmitOptions,\n  AgentCapability,\n  Task,\n  ConsensusProposal\n} from '../hive-mind/types.js';\n\n// Core infrastructure\nimport { IEventBus } from '../core/event-bus.js';\nimport { ILogger } from '../core/logger.js';\nimport { SystemError } from '../utils/errors.js';\n\n// Maestro types\nimport {\n  MaestroWorkflowState,\n  WorkflowPhase,\n  MaestroSpec\n} from './maestro-types.js';\n\nexport interface MaestroSwarmConfig {\n  // Native hive mind configuration\n  hiveMindConfig: HiveMindConfig;\n  \n  // Maestro-specific features\n  enableConsensusValidation: boolean;\n  enableLivingDocumentation: boolean;\n  enableSteeringIntegration: boolean;\n  \n  // File system settings\n  specsDirectory: string;\n  steeringDirectory: string;\n}\n\n/**\n * Native Hive Mind Maestro Coordinator\n * Leverages specs-driven swarm topology for collective intelligence\n */\nexport class MaestroSwarmCoordinator extends EventEmitter {\n  private hiveMind: HiveMind;\n  private maestroState: Map<string, MaestroWorkflowState> = new Map();\n  private specsDirectory: string;\n  private steeringDirectory: string;\n  \n  constructor(\n    private config: MaestroSwarmConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger\n  ) {\n    super();\n    \n    this.specsDirectory = config.specsDirectory || join(process.cwd(), '.claude', 'claude-flow', 'maestro', 'specs');\n    this.steeringDirectory = config.steeringDirectory || join(process.cwd(), '.claude', 'claude-flow', 'maestro', 'steering');\n    \n    this.setupEventHandlers();\n    this.logger.info('MaestroSwarmCoordinator initialized with native hive mind');\n  }\n  \n  /**\n   * Initialize the specs-driven hive mind swarm\n   */\n  async initialize(): Promise<string> {\n    try {\n      // Create specs-driven hive mind with native topology\n      const hiveMindConfig: HiveMindConfig = {\n        name: 'maestro-specs-driven-swarm',\n        topology: 'specs-driven',\n        queenMode: 'strategic',\n        maxAgents: 8,\n        consensusThreshold: 0.66,\n        memoryTTL: 86400000, // 24 hours\n        autoSpawn: true,  // Automatically spawn topology agents\n        enableConsensus: this.config.enableConsensusValidation,\n        enableMemory: true,\n        enableCommunication: true,\n        ...this.config.hiveMindConfig\n      };\n      \n      // Initialize native hive mind\n      this.hiveMind = new HiveMind(hiveMindConfig);\n      const swarmId = await this.hiveMind.initialize();\n      \n      // Initialize steering docs in swarm memory if enabled\n      if (this.config.enableSteeringIntegration) {\n        await this.initializeSteeringMemory();\n      }\n      \n      this.logger.info(`Maestro specs-driven swarm initialized: ${swarmId}`);\n      this.emit('initialized', { swarmId });\n      \n      return swarmId;\n      \n    } catch (error) {\n      this.logger.error(`Failed to initialize maestro swarm: ${error instanceof Error ? error.message : String(error)}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create specification using native requirements_analyst agent\n   */\n  async createSpec(featureName: string, initialRequest: string): Promise<void> {\n    const featurePath = join(this.specsDirectory, featureName);\n    await mkdir(featurePath, { recursive: true });\n    \n    // Initialize workflow state\n    const workflowState: MaestroWorkflowState = {\n      featureName,\n      currentPhase: 'Requirements Clarification' as WorkflowPhase,\n      currentTaskIndex: 0,\n      status: 'running',\n      lastActivity: new Date(),\n      history: [{\n        phase: 'Requirements Clarification' as WorkflowPhase,\n        status: 'in-progress',\n        timestamp: new Date()\n      }]\n    };\n    \n    this.maestroState.set(featureName, workflowState);\n    \n    // Submit requirements analysis task to native swarm\n    const requirementsTask: TaskSubmitOptions = {\n      description: `Generate comprehensive requirements for feature: ${featureName}`,\n      priority: 'high',\n      strategy: 'sequential',\n      requiredCapabilities: ['requirements_analysis' as AgentCapability, 'user_story_creation' as AgentCapability, 'acceptance_criteria' as AgentCapability],\n      metadata: {\n        maestroFeature: featureName,\n        maestroPhase: 'Requirements Clarification',\n        initialRequest,\n        outputFile: join(featurePath, 'requirements.md')\n      }\n    };\n    \n    // Use native SwarmOrchestrator through HiveMind\n    const task = await this.hiveMind.submitTask(requirementsTask);\n    await this.waitForTaskCompletion(task.id, 120000); // 2 minutes\n    \n    this.logger.info(`Created specification for '${featureName}' using native swarm`);\n    this.eventBus.emit('maestro:spec_created', { featureName });\n  }\n  \n  /**\n   * Generate design using native design_architect agents with consensus\n   */\n  async generateDesign(featureName: string): Promise<void> {\n    const state = this.maestroState.get(featureName);\n    if (!state) {\n      throw new SystemError(`No workflow state found for '${featureName}'`);\n    }\n    \n    const featurePath = join(this.specsDirectory, featureName);\n    const requirementsPath = join(featurePath, 'requirements.md');\n    const requirementsContent = await readFile(requirementsPath, 'utf8');\n    \n    // Submit design generation task with consensus requirement\n    const designTask: TaskSubmitOptions = {\n      description: `Generate comprehensive technical design for ${featureName}`,\n      priority: 'high',\n      strategy: 'parallel',  // Multiple design_architect agents work in parallel\n      requiredCapabilities: ['system_design' as AgentCapability, 'architecture' as AgentCapability, 'specs_driven_design' as AgentCapability],\n      requireConsensus: this.config.enableConsensusValidation,\n      maxAgents: 2,  // Use both design_architect agents\n      metadata: {\n        maestroFeature: featureName,\n        maestroPhase: 'Research & Design',\n        requirements: requirementsContent,\n        outputFile: join(featurePath, 'design.md')\n      }\n    };\n    \n    // Native SwarmOrchestrator handles parallel execution and consensus\n    const task = await this.hiveMind.submitTask(designTask);\n    await this.waitForTaskCompletion(task.id, 300000); // 5 minutes\n    \n    // Update workflow state\n    state.currentPhase = 'Research & Design' as WorkflowPhase;\n    state.lastActivity = new Date();\n    state.history.push({\n      phase: 'Research & Design' as WorkflowPhase,\n      status: 'completed',\n      timestamp: new Date()\n    });\n    \n    this.logger.info(`Generated design for '${featureName}' using native swarm consensus`);\n    this.eventBus.emit('maestro:design_generated', { featureName });\n  }\n  \n  /**\n   * Generate tasks using native task_planner agent\n   */\n  async generateTasks(featureName: string): Promise<void> {\n    const state = this.maestroState.get(featureName);\n    if (!state) {\n      throw new SystemError(`No workflow state found for '${featureName}'`);\n    }\n    \n    const featurePath = join(this.specsDirectory, featureName);\n    const designPath = join(featurePath, 'design.md');\n    const designContent = await readFile(designPath, 'utf8');\n    \n    // Submit task planning to native task_planner agent\n    const taskPlanningTask: TaskSubmitOptions = {\n      description: `Generate implementation task breakdown for ${featureName}`,\n      priority: 'high',\n      strategy: 'sequential',\n      requiredCapabilities: ['task_management' as AgentCapability, 'workflow_orchestration' as AgentCapability],\n      metadata: {\n        maestroFeature: featureName,\n        maestroPhase: 'Implementation Planning',\n        designContent,\n        outputFile: join(featurePath, 'tasks.md')\n      }\n    };\n    \n    const task = await this.hiveMind.submitTask(taskPlanningTask);\n    await this.waitForTaskCompletion(task.id, 180000); // 3 minutes\n    \n    // Update workflow state\n    state.currentPhase = 'Implementation Planning' as WorkflowPhase;\n    state.lastActivity = new Date();\n    state.history.push({\n      phase: 'Implementation Planning' as WorkflowPhase,\n      status: 'completed',\n      timestamp: new Date()\n    });\n    \n    this.logger.info(`Generated tasks for '${featureName}' using native swarm planner`);\n    this.eventBus.emit('maestro:tasks_generated', { featureName });\n  }\n  \n  /**\n   * Implement task using native implementation_coder agents\n   */\n  async implementTask(featureName: string, taskId: number): Promise<void> {\n    const state = this.maestroState.get(featureName);\n    if (!state) {\n      throw new SystemError(`No workflow state found for '${featureName}'`);\n    }\n    \n    const featurePath = join(this.specsDirectory, featureName);\n    const tasksPath = join(featurePath, 'tasks.md');\n    const tasksContent = await readFile(tasksPath, 'utf8');\n    \n    // Parse task description\n    const taskLines = tasksContent.split('\\n').filter(line => line.startsWith('- [ ]') || line.startsWith('- [x]'));\n    if (taskId < 1 || taskId > taskLines.length) {\n      throw new SystemError(`Invalid task ID ${taskId} for feature '${featureName}'`);\n    }\n    \n    const taskDescription = taskLines[taskId - 1].substring(taskLines[taskId - 1].indexOf(']') + 2).trim();\n    \n    // Submit implementation task to native coders\n    const implementationTask: TaskSubmitOptions = {\n      description: `Implement task: ${taskDescription}`,\n      priority: 'high',\n      strategy: 'parallel',  // Multiple implementation_coder agents can work\n      requiredCapabilities: ['code_generation' as AgentCapability, 'implementation' as AgentCapability],\n      maxAgents: 2,\n      metadata: {\n        maestroFeature: featureName,\n        maestroPhase: 'Task Execution',\n        taskId,\n        taskDescription,\n        steeringContext: await this.getSteeringContext()\n      }\n    };\n    \n    const task = await this.hiveMind.submitTask(implementationTask);\n    await this.waitForTaskCompletion(task.id, 600000); // 10 minutes\n    \n    // Mark task as completed in tasks.md\n    const updatedTasksContent = tasksContent.replace(\n      taskLines[taskId - 1],\n      taskLines[taskId - 1].replace('- [ ]', '- [x]')\n    );\n    await writeFile(tasksPath, updatedTasksContent, 'utf8');\n    \n    // Update workflow state\n    state.currentPhase = 'Task Execution' as WorkflowPhase;\n    state.currentTaskIndex = taskId;\n    state.lastActivity = new Date();\n    \n    this.logger.info(`Implemented task ${taskId} for '${featureName}' using native swarm`);\n    this.eventBus.emit('maestro:task_implemented', { featureName, taskId, taskDescription });\n  }\n  \n  /**\n   * Review implemented tasks using native quality_reviewer agent\n   */\n  async reviewTasks(featureName: string): Promise<void> {\n    const state = this.maestroState.get(featureName);\n    if (!state) {\n      throw new SystemError(`No workflow state found for '${featureName}'`);\n    }\n    \n    const featurePath = join(this.specsDirectory, featureName);\n    const tasksPath = join(featurePath, 'tasks.md');\n    const tasksContent = await readFile(tasksPath, 'utf8');\n    \n    // Submit quality review task to native quality_reviewer agent\n    const reviewTask: TaskSubmitOptions = {\n      description: `Review implementation quality for ${featureName}`,\n      priority: 'high',\n      strategy: 'sequential',  // Sequential validation for consistency\n      requiredCapabilities: ['code_review' as AgentCapability, 'quality_assurance' as AgentCapability, 'testing' as AgentCapability],\n      metadata: {\n        maestroFeature: featureName,\n        maestroPhase: 'Quality Gates',\n        tasksContent,\n        steeringContext: await this.getSteeringContext()\n      }\n    };\n    \n    const task = await this.hiveMind.submitTask(reviewTask);\n    await this.waitForTaskCompletion(task.id, 300000); // 5 minutes\n    \n    // Update workflow state\n    state.currentPhase = 'Quality Gates' as WorkflowPhase;\n    state.lastActivity = new Date();\n    state.history.push({\n      phase: 'Quality Gates' as WorkflowPhase,\n      status: 'completed',\n      timestamp: new Date()\n    });\n    \n    this.logger.info(`Completed quality review for '${featureName}' using native quality_reviewer`);\n    this.eventBus.emit('maestro:quality_review_completed', { featureName });\n  }\n  \n  /**\n   * Approve workflow phase with optional consensus\n   */\n  async approvePhase(featureName: string): Promise<void> {\n    const state = this.maestroState.get(featureName);\n    if (!state) {\n      throw new SystemError(`No workflow state found for '${featureName}'`);\n    }\n    \n    // Use native consensus if enabled\n    if (this.config.enableConsensusValidation) {\n      const consensusProposal: ConsensusProposal = {\n        id: `maestro-phase-approval-${featureName}-${Date.now()}`,\n        swarmId: (this.hiveMind as any).id,\n        proposal: {\n          action: 'approve_phase',\n          featureName,\n          currentPhase: state.currentPhase,\n          details: `Approve completion of ${state.currentPhase} phase for ${featureName}`\n        },\n        requiredThreshold: 0.66,\n        deadline: new Date(Date.now() + 300000), // 5 minutes\n        taskId: `maestro-approval-${featureName}`,\n        metadata: {\n          type: 'phase_approval',\n          featureName,\n          phase: state.currentPhase\n        }\n      };\n      \n      // Submit for consensus validation\n      const consensusEngine = (this.hiveMind as any).consensus as ConsensusEngine;\n      const proposalId = await consensusEngine.createProposal(consensusProposal);\n      const consensusResult = await this.waitForConsensusResult(proposalId, 300000);\n      \n      if (!consensusResult.achieved) {\n        throw new SystemError(`Phase approval consensus failed: ${consensusResult.reason}`);\n      }\n    }\n    \n    // Progress to next phase\n    const phaseProgression: Record<string, string> = {\n      'Requirements Clarification': 'Research & Design',\n      'Research & Design': 'Implementation Planning',\n      'Implementation Planning': 'Task Execution',\n      'Task Execution': 'Completed'\n    };\n    \n    const nextPhase = phaseProgression[state.currentPhase];\n    if (nextPhase) {\n      state.currentPhase = nextPhase as WorkflowPhase;\n      state.lastActivity = new Date();\n      state.history.push({\n        phase: nextPhase as WorkflowPhase,\n        status: 'approved',\n        timestamp: new Date()\n      });\n    }\n    \n    this.logger.info(`Approved phase transition for '${featureName}': ${state.currentPhase} -> ${nextPhase}`);\n    this.eventBus.emit('maestro:phase_approved', { featureName, nextPhase });\n  }\n  \n  /**\n   * Get workflow state\n   */\n  getWorkflowState(featureName: string): MaestroWorkflowState | undefined {\n    return this.maestroState.get(featureName);\n  }\n  \n  /**\n   * Create steering document in native swarm memory\n   */\n  async createSteeringDocument(domain: string, content: string): Promise<void> {\n    if (!this.config.enableSteeringIntegration) {\n      throw new SystemError('Steering integration is disabled');\n    }\n    \n    // Store in native hive mind memory instead of files\n    await this.hiveMind.memory.store(`steering/${domain}`, {\n      content,\n      domain,\n      lastUpdated: new Date(),\n      maintainer: 'steering_documenter'\n    });\n    \n    // Notify all agents through native communication\n    await this.hiveMind.communication.broadcast({\n      type: 'steering_update',\n      domain,\n      content: content.substring(0, 200) + '...' // Summary for notification\n    });\n    \n    this.logger.info(`Created steering document for '${domain}' in swarm memory`);\n  }\n  \n  /**\n   * Get steering context from swarm memory\n   */\n  private async getSteeringContext(): Promise<string> {\n    if (!this.config.enableSteeringIntegration) {\n      return 'No steering context available.';\n    }\n    \n    try {\n      // Retrieve all steering documents from swarm memory\n      const steeringKeys = await this.hiveMind.memory.search('steering/*');\n      const steeringDocs = await Promise.all(\n        steeringKeys.map(key => this.hiveMind.memory.retrieve(key))\n      );\n      \n      return steeringDocs\n        .filter(doc => doc)\n        .map(doc => `## ${doc.domain}\\n${doc.content}`)\n        .join('\\n\\n---\\n\\n');\n        \n    } catch (error) {\n      this.logger.warn(`Failed to retrieve steering context: ${error instanceof Error ? error.message : String(error)}`);\n      return 'Steering context temporarily unavailable.';\n    }\n  }\n  \n  /**\n   * Initialize steering documents in swarm memory\n   */\n  private async initializeSteeringMemory(): Promise<void> {\n    // Initialize default steering documents in memory\n    const defaultSteering = {\n      'product': 'Focus on user value and clear requirements specification.',\n      'tech': 'Follow clean architecture patterns and maintainable code practices.',\n      'workflow': 'Use specs-driven development with clear phase progression.'\n    };\n    \n    for (const [domain, content] of Object.entries(defaultSteering)) {\n      await this.hiveMind.memory.store(`steering/${domain}`, {\n        content,\n        domain,\n        lastUpdated: new Date(),\n        maintainer: 'system'\n      });\n    }\n    \n    this.logger.info('Initialized default steering documents in swarm memory');\n  }\n  \n  /**\n   * Wait for task completion using native swarm tracking\n   */\n  private async waitForTaskCompletion(taskId: string, timeoutMs: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`Task timeout: ${taskId}`));\n      }, timeoutMs);\n      \n      const checkInterval = setInterval(async () => {\n        try {\n          const task = await this.hiveMind.getTask(taskId);\n          \n          if (task.status === 'completed') {\n            clearTimeout(timeout);\n            clearInterval(checkInterval);\n            resolve(task.result ? JSON.parse(task.result) : {});\n          } else if (task.status === 'failed') {\n            clearTimeout(timeout);\n            clearInterval(checkInterval);\n            reject(new Error(`Task failed: ${task.error || 'Unknown error'}`));\n          }\n        } catch (error) {\n          clearTimeout(timeout);\n          clearInterval(checkInterval);\n          reject(error);\n        }\n      }, 2000);\n    });\n  }\n  \n  /**\n   * Wait for consensus result using native ConsensusEngine\n   */\n  private async waitForConsensusResult(proposalId: string, timeoutMs: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`Consensus timeout for proposal ${proposalId}`));\n      }, timeoutMs);\n      \n      const checkInterval = setInterval(async () => {\n        try {\n          const consensusEngine = (this.hiveMind as any).consensus as ConsensusEngine;\n          const status = await consensusEngine.getProposalStatus(proposalId);\n          \n          if (status.status === 'achieved') {\n            clearTimeout(timeout);\n            clearInterval(checkInterval);\n            resolve({\n              achieved: true,\n              finalRatio: status.currentRatio,\n              reason: 'Consensus achieved'\n            });\n          } else if (status.status === 'failed') {\n            clearTimeout(timeout);\n            clearInterval(checkInterval);\n            resolve({\n              achieved: false,\n              finalRatio: status.currentRatio,\n              reason: 'Consensus failed'\n            });\n          }\n        } catch (error) {\n          clearTimeout(timeout);\n          clearInterval(checkInterval);\n          reject(error);\n        }\n      }, 1000);\n    });\n  }\n  \n  /**\n   * Setup event handlers\n   */\n  private setupEventHandlers(): void {\n    this.eventBus.on('maestro:spec_created', this.handleSpecCreated.bind(this));\n    this.eventBus.on('maestro:phase_approved', this.handlePhaseApproved.bind(this));\n    this.eventBus.on('maestro:task_implemented', this.handleTaskImplemented.bind(this));\n  }\n  \n  /**\n   * Event handlers\n   */\n  private async handleSpecCreated(data: any): Promise<void> {\n    this.logger.info(`Spec created via native swarm: ${JSON.stringify(data)}`);\n  }\n  \n  private async handlePhaseApproved(data: any): Promise<void> {\n    this.logger.info(`Phase approved via native consensus: ${JSON.stringify(data)}`);\n  }\n  \n  private async handleTaskImplemented(data: any): Promise<void> {\n    this.logger.info(`Task implemented via native swarm: ${JSON.stringify(data)}`);\n  }\n  \n  /**\n   * Shutdown coordinator and native swarm\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down MaestroSwarmCoordinator');\n    \n    if (this.hiveMind) {\n      await this.hiveMind.shutdown();\n      this.logger.info('Native hive mind swarm shutdown complete');\n    }\n    \n    this.logger.info('MaestroSwarmCoordinator shutdown complete');\n  }\n}"],
  "mappings": "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",
  "names": []
}
