{
  "version": 3,
  "sources": ["../../src/coordination/dependency-graph.ts"],
  "sourcesContent": ["/**\n * Dependency graph management for task scheduling\n */\n\nimport type { Task } from '../utils/types.js';\nimport { TaskDependencyError } from '../utils/errors.js';\nimport type { ILogger } from '../core/logger.js';\n\nexport interface DependencyNode {\n  taskId: string;\n  dependencies: Set<string>;\n  dependents: Set<string>;\n  status: 'pending' | 'ready' | 'running' | 'completed' | 'failed';\n}\n\nexport interface DependencyPath {\n  from: string;\n  to: string;\n  path: string[];\n}\n\n/**\n * Manages task dependencies and determines execution order\n */\nexport class DependencyGraph {\n  private nodes = new Map<string, DependencyNode>();\n  private completedTasks = new Set<string>();\n\n  constructor(private logger: ILogger) {}\n\n  /**\n   * Add a task to the dependency graph\n   */\n  addTask(task: Task): void {\n    if (this.nodes.has(task.id)) {\n      this.logger.warn('Task already exists in dependency graph', { taskId: task.id });\n      return;\n    }\n\n    const node: DependencyNode = {\n      taskId: task.id,\n      dependencies: new Set(task.dependencies),\n      dependents: new Set(),\n      status: 'pending',\n    };\n\n    // Validate dependencies exist\n    for (const depId of task.dependencies) {\n      if (!this.nodes.has(depId) && !this.completedTasks.has(depId)) {\n        throw new TaskDependencyError(task.id, [depId]);\n      }\n    }\n\n    // Add node\n    this.nodes.set(task.id, node);\n\n    // Update dependents for dependencies\n    for (const depId of task.dependencies) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.dependents.add(task.id);\n      }\n    }\n\n    // Check if task is ready\n    if (this.isTaskReady(task.id)) {\n      node.status = 'ready';\n    }\n  }\n\n  /**\n   * Remove a task from the dependency graph\n   */\n  removeTask(taskId: string): void {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      return;\n    }\n\n    // Remove from dependents of dependencies\n    for (const depId of node.dependencies) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.dependents.delete(taskId);\n      }\n    }\n\n    // Remove from dependencies of dependents\n    for (const depId of node.dependents) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.dependencies.delete(taskId);\n        // Check if dependent is now ready\n        if (this.isTaskReady(depId)) {\n          depNode.status = 'ready';\n        }\n      }\n    }\n\n    this.nodes.delete(taskId);\n  }\n\n  /**\n   * Mark a task as completed\n   */\n  markCompleted(taskId: string): string[] {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      this.logger.warn('Task not found in dependency graph', { taskId });\n      return [];\n    }\n\n    node.status = 'completed';\n    this.completedTasks.add(taskId);\n\n    // Find newly ready tasks\n    const readyTasks: string[] = [];\n\n    for (const dependentId of node.dependents) {\n      const dependent = this.nodes.get(dependentId);\n      if (dependent && dependent.status === 'pending' && this.isTaskReady(dependentId)) {\n        dependent.status = 'ready';\n        readyTasks.push(dependentId);\n      }\n    }\n\n    // Remove from active graph\n    this.removeTask(taskId);\n\n    return readyTasks;\n  }\n\n  /**\n   * Mark a task as failed\n   */\n  markFailed(taskId: string): string[] {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      return [];\n    }\n\n    node.status = 'failed';\n\n    // Get all dependent tasks that need to be cancelled\n    const toCancelIds = this.getAllDependents(taskId);\n\n    // Mark all dependents as failed\n    for (const depId of toCancelIds) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.status = 'failed';\n      }\n    }\n\n    return toCancelIds;\n  }\n\n  /**\n   * Check if a task is ready to run\n   */\n  isTaskReady(taskId: string): boolean {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      return false;\n    }\n\n    // All dependencies must be completed\n    for (const depId of node.dependencies) {\n      if (!this.completedTasks.has(depId)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get all ready tasks\n   */\n  getReadyTasks(): string[] {\n    const ready: string[] = [];\n\n    for (const [taskId, node] of this.nodes) {\n      if (node.status === 'ready' || (node.status === 'pending' && this.isTaskReady(taskId))) {\n        ready.push(taskId);\n        node.status = 'ready';\n      }\n    }\n\n    return ready;\n  }\n\n  /**\n   * Get all dependents of a task (recursive)\n   */\n  getAllDependents(taskId: string): string[] {\n    const visited = new Set<string>();\n    const dependents: string[] = [];\n\n    const visit = (id: string) => {\n      if (visited.has(id)) {\n        return;\n      }\n      visited.add(id);\n\n      const node = this.nodes.get(id);\n      if (!node) {\n        return;\n      }\n\n      for (const depId of node.dependents) {\n        if (!visited.has(depId)) {\n          dependents.push(depId);\n          visit(depId);\n        }\n      }\n    };\n\n    visit(taskId);\n    return dependents;\n  }\n\n  /**\n   * Detect circular dependencies\n   */\n  detectCycles(): string[][] {\n    const cycles: string[][] = [];\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const currentPath: string[] = [];\n\n    const hasCycle = (taskId: string): boolean => {\n      visited.add(taskId);\n      recursionStack.add(taskId);\n      currentPath.push(taskId);\n\n      const node = this.nodes.get(taskId);\n      if (!node) {\n        currentPath.pop();\n        recursionStack.delete(taskId);\n        return false;\n      }\n\n      for (const depId of node.dependencies) {\n        if (!visited.has(depId)) {\n          if (hasCycle(depId)) {\n            return true;\n          }\n        } else if (recursionStack.has(depId)) {\n          // Found cycle\n          const cycleStart = currentPath.indexOf(depId);\n          const cycle = currentPath.slice(cycleStart);\n          cycle.push(depId); // Complete the cycle\n          cycles.push(cycle);\n          return true;\n        }\n      }\n\n      currentPath.pop();\n      recursionStack.delete(taskId);\n      return false;\n    };\n\n    // Check all nodes\n    for (const taskId of this.nodes.keys()) {\n      if (!visited.has(taskId)) {\n        hasCycle(taskId);\n      }\n    }\n\n    return cycles;\n  }\n\n  /**\n   * Get topological sort of tasks\n   */\n  topologicalSort(): string[] | null {\n    // Check for cycles first\n    const cycles = this.detectCycles();\n    if (cycles.length > 0) {\n      this.logger.error('Cannot perform topological sort due to cycles', { cycles });\n      return null;\n    }\n\n    const sorted: string[] = [];\n    const visited = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (visited.has(taskId)) {\n        return;\n      }\n      visited.add(taskId);\n\n      const node = this.nodes.get(taskId);\n      if (!node) {\n        return;\n      }\n\n      // Visit dependencies first\n      for (const depId of node.dependencies) {\n        if (!visited.has(depId)) {\n          visit(depId);\n        }\n      }\n\n      sorted.push(taskId);\n    };\n\n    // Visit all nodes\n    for (const taskId of this.nodes.keys()) {\n      if (!visited.has(taskId)) {\n        visit(taskId);\n      }\n    }\n\n    return sorted;\n  }\n\n  /**\n   * Find critical path (longest path through the graph)\n   */\n  findCriticalPath(): DependencyPath | null {\n    const paths: DependencyPath[] = [];\n\n    // Find all paths from tasks with no dependencies to tasks with no dependents\n    const sources = Array.from(this.nodes.entries())\n      .filter(([_, node]) => node.dependencies.size === 0)\n      .map(([id]) => id);\n\n    const sinks = Array.from(this.nodes.entries())\n      .filter(([_, node]) => node.dependents.size === 0)\n      .map(([id]) => id);\n\n    for (const source of sources) {\n      for (const sink of sinks) {\n        const path = this.findPath(source, sink);\n        if (path) {\n          paths.push({ from: source, to: sink, path });\n        }\n      }\n    }\n\n    // Return longest path\n    if (paths.length === 0) {\n      return null;\n    }\n\n    return paths.reduce((longest, current) =>\n      current.path.length > longest.path.length ? current : longest,\n    );\n  }\n\n  /**\n   * Find path between two tasks\n   */\n  private findPath(from: string, to: string): string[] | null {\n    if (from === to) {\n      return [from];\n    }\n\n    const visited = new Set<string>();\n    const queue: Array<{ taskId: string; path: string[] }> = [{ taskId: from, path: [from] }];\n\n    while (queue.length > 0) {\n      const { taskId, path } = queue.shift()!;\n\n      if (visited.has(taskId)) {\n        continue;\n      }\n      visited.add(taskId);\n\n      const node = this.nodes.get(taskId);\n      if (!node) {\n        continue;\n      }\n\n      for (const depId of node.dependents) {\n        if (depId === to) {\n          return [...path, to];\n        }\n\n        if (!visited.has(depId)) {\n          queue.push({ taskId: depId, path: [...path, depId] });\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get graph statistics\n   */\n  getStats(): Record<string, unknown> {\n    const stats = {\n      totalTasks: this.nodes.size,\n      completedTasks: this.completedTasks.size,\n      readyTasks: 0,\n      pendingTasks: 0,\n      runningTasks: 0,\n      failedTasks: 0,\n      avgDependencies: 0,\n      maxDependencies: 0,\n      cycles: this.detectCycles(),\n    };\n\n    let totalDeps = 0;\n    for (const node of this.nodes.values()) {\n      totalDeps += node.dependencies.size;\n      stats.maxDependencies = Math.max(stats.maxDependencies, node.dependencies.size);\n\n      switch (node.status) {\n        case 'ready':\n          stats.readyTasks++;\n          break;\n        case 'pending':\n          stats.pendingTasks++;\n          break;\n        case 'running':\n          stats.runningTasks++;\n          break;\n        case 'failed':\n          stats.failedTasks++;\n          break;\n      }\n    }\n\n    stats.avgDependencies = this.nodes.size > 0 ? totalDeps / this.nodes.size : 0;\n\n    return stats;\n  }\n\n  /**\n   * Export graph to DOT format for visualization\n   */\n  toDot(): string {\n    let dot = 'digraph TaskDependencies {\\n';\n    dot += '  rankdir=LR;\\n';\n    dot += '  node [shape=box];\\n\\n';\n\n    // Add nodes with status colors\n    for (const [taskId, node] of this.nodes) {\n      let color = 'white';\n      switch (node.status) {\n        case 'ready':\n          color = 'lightgreen';\n          break;\n        case 'running':\n          color = 'yellow';\n          break;\n        case 'completed':\n          color = 'green';\n          break;\n        case 'failed':\n          color = 'red';\n          break;\n      }\n      dot += `  \"${taskId}\" [style=filled, fillcolor=${color}];\\n`;\n    }\n\n    dot += '\\n';\n\n    // Add edges\n    for (const [taskId, node] of this.nodes) {\n      for (const depId of node.dependencies) {\n        dot += `  \"${depId}\" -> \"${taskId}\";\\n`;\n      }\n    }\n\n    dot += '}\\n';\n    return dot;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
