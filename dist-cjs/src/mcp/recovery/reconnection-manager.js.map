{"version":3,"sources":["../../../../src/mcp/recovery/reconnection-manager.ts"],"sourcesContent":["/**\r\n * Reconnection Manager for MCP\r\n * Handles automatic reconnection with exponential backoff\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport type { ILogger } from '../../core/logger.js';\r\nimport type { MCPClient } from '../client.js';\r\n\r\nexport interface ReconnectionConfig {\r\n  maxRetries: number;\r\n  initialDelay: number;\r\n  maxDelay: number;\r\n  backoffMultiplier: number;\r\n  jitterFactor: number;\r\n  resetAfterSuccess: boolean;\r\n}\r\n\r\nexport interface ReconnectionState {\r\n  attempts: number;\r\n  nextDelay: number;\r\n  isReconnecting: boolean;\r\n  lastAttempt?: Date;\r\n  lastError?: Error;\r\n}\r\n\r\nexport class ReconnectionManager extends EventEmitter {\r\n  private state: ReconnectionState;\r\n  private reconnectTimer?: NodeJS.Timeout;\r\n  private reconnectPromise?: Promise<boolean>;\r\n\r\n  private readonly defaultConfig: ReconnectionConfig = {\r\n    maxRetries: 10,\r\n    initialDelay: 1000,\r\n    maxDelay: 30000,\r\n    backoffMultiplier: 2,\r\n    jitterFactor: 0.1,\r\n    resetAfterSuccess: true,\r\n  };\r\n\r\n  constructor(\r\n    private client: MCPClient,\r\n    private logger: ILogger,\r\n    config?: Partial<ReconnectionConfig>,\r\n  ) {\r\n    super();\r\n    this.config = { ...this.defaultConfig, ...config };\r\n\r\n    this.state = {\r\n      attempts: 0,\r\n      nextDelay: this.config.initialDelay,\r\n      isReconnecting: false,\r\n    };\r\n  }\r\n\r\n  private config: ReconnectionConfig;\r\n\r\n  /**\r\n   * Attempt to reconnect\r\n   */\r\n  async attemptReconnection(): Promise<boolean> {\r\n    // Prevent concurrent reconnection attempts\r\n    if (this.reconnectPromise) {\r\n      this.logger.debug('Reconnection already in progress');\r\n      return this.reconnectPromise;\r\n    }\r\n\r\n    if (this.state.attempts >= this.config.maxRetries) {\r\n      this.logger.error('Max reconnection attempts exceeded');\r\n      this.emit('maxRetriesExceeded', this.state);\r\n      return false;\r\n    }\r\n\r\n    this.reconnectPromise = this.performReconnection();\r\n    const result = await this.reconnectPromise;\r\n    this.reconnectPromise = undefined;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Start automatic reconnection\r\n   */\r\n  startAutoReconnect(): void {\r\n    if (this.state.isReconnecting) {\r\n      this.logger.debug('Auto-reconnect already active');\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Starting automatic reconnection');\r\n    this.state.isReconnecting = true;\r\n    this.emit('reconnectStart');\r\n\r\n    this.scheduleReconnect();\r\n  }\r\n\r\n  /**\r\n   * Stop reconnection attempts\r\n   */\r\n  stopReconnection(): void {\r\n    if (!this.state.isReconnecting) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Stopping reconnection attempts');\r\n\r\n    if (this.reconnectTimer) {\r\n      clearTimeout(this.reconnectTimer);\r\n      this.reconnectTimer = undefined;\r\n    }\r\n\r\n    this.state.isReconnecting = false;\r\n    this.emit('reconnectStop');\r\n  }\r\n\r\n  /**\r\n   * Reset reconnection state\r\n   */\r\n  reset(): void {\r\n    this.logger.debug('Resetting reconnection manager');\r\n\r\n    this.stopReconnection();\r\n    this.state = {\r\n      attempts: 0,\r\n      nextDelay: this.config.initialDelay,\r\n      isReconnecting: false,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current reconnection state\r\n   */\r\n  getState(): ReconnectionState {\r\n    return { ...this.state };\r\n  }\r\n\r\n  /**\r\n   * Calculate next retry delay\r\n   */\r\n  getNextDelay(): number {\r\n    return this.state.nextDelay;\r\n  }\r\n\r\n  private async performReconnection(): Promise<boolean> {\r\n    this.state.attempts++;\r\n    this.state.lastAttempt = new Date();\r\n\r\n    this.logger.info('Attempting reconnection', {\r\n      attempt: this.state.attempts,\r\n      maxRetries: this.config.maxRetries,\r\n      delay: this.state.nextDelay,\r\n    });\r\n\r\n    this.emit('attemptStart', {\r\n      attempt: this.state.attempts,\r\n      delay: this.state.nextDelay,\r\n    });\r\n\r\n    try {\r\n      // Disconnect first if needed\r\n      if (this.client.isConnected()) {\r\n        await this.client.disconnect();\r\n      }\r\n\r\n      // Attempt to reconnect\r\n      await this.client.connect();\r\n\r\n      // Success!\r\n      this.logger.info('Reconnection successful', {\r\n        attempts: this.state.attempts,\r\n      });\r\n\r\n      this.emit('success', {\r\n        attempts: this.state.attempts,\r\n        duration: Date.now() - this.state.lastAttempt.getTime(),\r\n      });\r\n\r\n      // Reset state if configured\r\n      if (this.config.resetAfterSuccess) {\r\n        this.reset();\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.state.lastError = error as Error;\r\n\r\n      this.logger.error('Reconnection failed', {\r\n        attempt: this.state.attempts,\r\n        error: (error as Error).message,\r\n      });\r\n\r\n      this.emit('attemptFailed', {\r\n        attempt: this.state.attempts,\r\n        error: error as Error,\r\n      });\r\n\r\n      // Calculate next delay with exponential backoff\r\n      this.calculateNextDelay();\r\n\r\n      // Schedule next attempt if within retry limit\r\n      if (this.state.attempts < this.config.maxRetries && this.state.isReconnecting) {\r\n        this.scheduleReconnect();\r\n      } else if (this.state.attempts >= this.config.maxRetries) {\r\n        this.logger.error('Max reconnection attempts reached');\r\n        this.emit('maxRetriesExceeded', this.state);\r\n        this.state.isReconnecting = false;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private scheduleReconnect(): void {\r\n    if (!this.state.isReconnecting) {\r\n      return;\r\n    }\r\n\r\n    const delay = this.addJitter(this.state.nextDelay);\r\n\r\n    this.logger.debug('Scheduling next reconnection attempt', {\r\n      delay,\r\n      baseDelay: this.state.nextDelay,\r\n    });\r\n\r\n    this.reconnectTimer = setTimeout(() => {\r\n      this.attemptReconnection().catch((error) => {\r\n        this.logger.error('Scheduled reconnection error', error);\r\n      });\r\n    }, delay);\r\n\r\n    this.emit('attemptScheduled', {\r\n      attempt: this.state.attempts + 1,\r\n      delay,\r\n    });\r\n  }\r\n\r\n  private calculateNextDelay(): void {\r\n    // Exponential backoff calculation\r\n    const nextDelay = Math.min(\r\n      this.state.nextDelay * this.config.backoffMultiplier,\r\n      this.config.maxDelay,\r\n    );\r\n\r\n    this.state.nextDelay = nextDelay;\r\n\r\n    this.logger.debug('Calculated next delay', {\r\n      delay: nextDelay,\r\n      multiplier: this.config.backoffMultiplier,\r\n      maxDelay: this.config.maxDelay,\r\n    });\r\n  }\r\n\r\n  private addJitter(delay: number): number {\r\n    // Add random jitter to prevent thundering herd\r\n    const jitter = delay * this.config.jitterFactor;\r\n    const randomJitter = (Math.random() - 0.5) * 2 * jitter;\r\n\r\n    return Math.max(0, delay + randomJitter);\r\n  }\r\n\r\n  /**\r\n   * Force immediate reconnection attempt\r\n   */\r\n  async forceReconnect(): Promise<boolean> {\r\n    this.logger.info('Forcing immediate reconnection');\r\n\r\n    // Cancel any scheduled reconnect\r\n    if (this.reconnectTimer) {\r\n      clearTimeout(this.reconnectTimer);\r\n      this.reconnectTimer = undefined;\r\n    }\r\n\r\n    // Reset delay for immediate attempt\r\n    const originalDelay = this.state.nextDelay;\r\n    this.state.nextDelay = 0;\r\n\r\n    const result = await this.attemptReconnection();\r\n\r\n    // Restore delay if failed\r\n    if (!result) {\r\n      this.state.nextDelay = originalDelay;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get estimated time until next reconnection attempt\r\n   */\r\n  getTimeUntilNextAttempt(): number | null {\r\n    if (!this.state.isReconnecting || !this.reconnectTimer) {\r\n      return null;\r\n    }\r\n\r\n    // This is an approximation since we don't track the exact timer start\r\n    return this.state.nextDelay;\r\n  }\r\n}\r\n"],"names":["EventEmitter","ReconnectionManager","state","reconnectTimer","reconnectPromise","defaultConfig","maxRetries","initialDelay","maxDelay","backoffMultiplier","jitterFactor","resetAfterSuccess","client","logger","config","attempts","nextDelay","isReconnecting","attemptReconnection","debug","error","emit","performReconnection","result","undefined","startAutoReconnect","info","scheduleReconnect","stopReconnection","clearTimeout","reset","getState","getNextDelay","lastAttempt","Date","attempt","delay","isConnected","disconnect","connect","duration","now","getTime","lastError","message","calculateNextDelay","addJitter","baseDelay","setTimeout","catch","Math","min","multiplier","jitter","randomJitter","random","max","forceReconnect","originalDelay","getTimeUntilNextAttempt"],"mappings":"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"}