{"version":3,"sources":["../../../src/mcp/claude-flow-tools.ts"],"sourcesContent":["/**\r\n * Claude-Flow specific MCP tools\r\n */\r\n\r\nimport type { MCPTool, MCPContext, AgentProfile, Task, MemoryEntry } from '../utils/types.js';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { getAvailableAgentTypes, getAgentTypeSchema } from '../constants/agent-types.js';\r\nimport type { Permissions } from './auth.js';\r\n\r\nexport interface ClaudeFlowToolContext extends MCPContext {\r\n  orchestrator?: any; // Reference to orchestrator instance\r\n}\r\n\r\n/**\r\n * Enhance tool schema with dynamic agent types\r\n */\r\nasync function enhanceToolWithAgentTypes(tool: MCPTool): Promise<MCPTool> {\r\n  const availableTypes = await getAvailableAgentTypes();\r\n  \r\n  // Clone the tool to avoid modifying the original\r\n  const enhancedTool = JSON.parse(JSON.stringify(tool));\r\n  \r\n  // Find and populate enum fields for agent types\r\n  function addEnumToAgentTypeFields(obj: any) {\r\n    if (typeof obj !== 'object' || obj === null) return;\r\n    \r\n    for (const [key, value] of Object.entries(obj)) {\r\n      if (typeof value === 'object' && value !== null) {\r\n        // Check if this is an agent type field\r\n        if (key === 'type' || key === 'filterByType' || key === 'assignToAgentType') {\r\n          const field = value as any;\r\n          if (field.type === 'string' && field.description?.includes('loaded dynamically from .claude/agents/')) {\r\n            field.enum = availableTypes;\r\n          }\r\n        }\r\n        addEnumToAgentTypeFields(value);\r\n      }\r\n    }\r\n  }\r\n  \r\n  addEnumToAgentTypeFields(enhancedTool.inputSchema);\r\n  return enhancedTool;\r\n}\r\n\r\n/**\r\n * Create all Claude-Flow specific MCP tools\r\n */\r\nexport async function createClaudeFlowTools(logger: ILogger): Promise<MCPTool[]> {\r\n  const tools = [\r\n    // Agent management tools\r\n    createSpawnAgentTool(logger),\r\n    createSpawnParallelAgentsTool(logger), // NEW: Phase 4 - Parallel spawning\r\n    createListAgentsTool(logger),\r\n    createTerminateAgentTool(logger),\r\n    createGetAgentInfoTool(logger),\r\n\r\n    // Query control tools (NEW: Phase 4 - Real-time control)\r\n    createQueryControlTool(logger),\r\n    createListQueriesTool(logger),\r\n\r\n    // Task management tools\r\n    createCreateTaskTool(logger),\r\n    createListTasksTool(logger),\r\n    createGetTaskStatusTool(logger),\r\n    createCancelTaskTool(logger),\r\n    createAssignTaskTool(logger),\r\n\r\n    // Memory management tools\r\n    createQueryMemoryTool(logger),\r\n    createStoreMemoryTool(logger),\r\n    createDeleteMemoryTool(logger),\r\n    createExportMemoryTool(logger),\r\n    createImportMemoryTool(logger),\r\n\r\n    // System monitoring tools\r\n    createGetSystemStatusTool(logger),\r\n    createGetMetricsTool(logger),\r\n    createHealthCheckTool(logger),\r\n\r\n    // Configuration tools\r\n    createGetConfigTool(logger),\r\n    createUpdateConfigTool(logger),\r\n    createValidateConfigTool(logger),\r\n\r\n    // Workflow tools\r\n    createExecuteWorkflowTool(logger),\r\n    createCreateWorkflowTool(logger),\r\n    createListWorkflowsTool(logger),\r\n\r\n    // Terminal management tools\r\n    createExecuteCommandTool(logger),\r\n    createListTerminalsTool(logger),\r\n    createCreateTerminalTool(logger),\r\n  ];\r\n\r\n  // Enhance tools with dynamic agent types\r\n  const enhancedTools = await Promise.all(\r\n    tools.map(tool => enhanceToolWithAgentTypes(tool))\r\n  );\r\n\r\n  return enhancedTools;\r\n}\r\n\r\nfunction createSpawnAgentTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'agents/spawn',\r\n    description: 'Spawn a new Claude agent with specified configuration',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        type: {\r\n          type: 'string',\r\n          // Note: enum will be populated dynamically at runtime\r\n          description: 'Type of specialized agent to spawn (loaded dynamically from .claude/agents/)',\r\n        },\r\n        name: {\r\n          type: 'string',\r\n          description: 'Display name for the agent',\r\n        },\r\n        capabilities: {\r\n          type: 'array',\r\n          items: { type: 'string' },\r\n          description: 'List of capabilities for the agent',\r\n        },\r\n        systemPrompt: {\r\n          type: 'string',\r\n          description: 'Custom system prompt for the agent',\r\n        },\r\n        maxConcurrentTasks: {\r\n          type: 'number',\r\n          default: 3,\r\n          description: 'Maximum number of concurrent tasks',\r\n        },\r\n        priority: {\r\n          type: 'number',\r\n          default: 5,\r\n          description: 'Agent priority level (1-10)',\r\n        },\r\n        environment: {\r\n          type: 'object',\r\n          description: 'Environment variables for the agent',\r\n        },\r\n        workingDirectory: {\r\n          type: 'string',\r\n          description: 'Working directory for the agent',\r\n        },\r\n      },\r\n      required: ['type', 'name'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Spawning agent', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const profile: AgentProfile = {\r\n        id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        name: input.name,\r\n        type: input.type,\r\n        capabilities: input.capabilities || [],\r\n        systemPrompt: input.systemPrompt || getDefaultSystemPrompt(input.type),\r\n        maxConcurrentTasks: input.maxConcurrentTasks || 3,\r\n        priority: input.priority || 5,\r\n        environment: input.environment,\r\n        workingDirectory: input.workingDirectory,\r\n      };\r\n\r\n      const sessionId = await context.orchestrator.spawnAgent(profile);\r\n\r\n      return {\r\n        agentId: profile.id,\r\n        sessionId,\r\n        profile,\r\n        status: 'spawned',\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createListAgentsTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'agents/list',\r\n    description: 'List all active agents in the system',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        includeTerminated: {\r\n          type: 'boolean',\r\n          default: false,\r\n          description: 'Include terminated agents in the list',\r\n        },\r\n        filterByType: {\r\n          type: 'string',\r\n          // Note: enum will be populated dynamically at runtime\r\n          description: 'Filter agents by type (loaded dynamically from .claude/agents/)',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Listing agents', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const agents = await context.orchestrator.listAgents();\r\n\r\n      let filteredAgents = agents;\r\n\r\n      if (!input.includeTerminated) {\r\n        filteredAgents = filteredAgents.filter((agent: any) => agent.status !== 'terminated');\r\n      }\r\n\r\n      if (input.filterByType) {\r\n        filteredAgents = filteredAgents.filter((agent: any) => agent.type === input.filterByType);\r\n      }\r\n\r\n      return {\r\n        agents: filteredAgents,\r\n        count: filteredAgents.length,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createTerminateAgentTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'agents/terminate',\r\n    description: 'Terminate a specific agent',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'ID of the agent to terminate',\r\n        },\r\n        reason: {\r\n          type: 'string',\r\n          description: 'Reason for termination',\r\n        },\r\n        graceful: {\r\n          type: 'boolean',\r\n          default: true,\r\n          description: 'Whether to perform graceful shutdown',\r\n        },\r\n      },\r\n      required: ['agentId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Terminating agent', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      await context.orchestrator.terminateAgent(input.agentId, {\r\n        reason: input.reason || 'Manual termination',\r\n        graceful: input.graceful !== false,\r\n      });\r\n\r\n      return {\r\n        agentId: input.agentId,\r\n        status: 'terminated',\r\n        reason: input.reason || 'Manual termination',\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createGetAgentInfoTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'agents/info',\r\n    description: 'Get detailed information about a specific agent',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'ID of the agent',\r\n        },\r\n      },\r\n      required: ['agentId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Getting agent info', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const agentInfo = await context.orchestrator.getAgentInfo(input.agentId);\r\n\r\n      if (!agentInfo) {\r\n        throw new Error(`Agent not found: ${input.agentId}`);\r\n      }\r\n\r\n      return {\r\n        agent: agentInfo,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createCreateTaskTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'tasks/create',\r\n    description: 'Create a new task for execution',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        type: {\r\n          type: 'string',\r\n          description: 'Type of task to create',\r\n        },\r\n        description: {\r\n          type: 'string',\r\n          description: 'Description of the task',\r\n        },\r\n        priority: {\r\n          type: 'number',\r\n          default: 5,\r\n          description: 'Task priority (1-10)',\r\n        },\r\n        dependencies: {\r\n          type: 'array',\r\n          items: { type: 'string' },\r\n          description: 'List of task IDs this task depends on',\r\n        },\r\n        assignToAgent: {\r\n          type: 'string',\r\n          description: 'Specific agent ID to assign the task to',\r\n        },\r\n        assignToAgentType: {\r\n          type: 'string',\r\n          // Note: enum will be populated dynamically at runtime\r\n          description: 'Type of specialized agent to assign the task to (loaded dynamically from .claude/agents/)',\r\n        },\r\n        input: {\r\n          type: 'object',\r\n          description: 'Input data for the task',\r\n        },\r\n        timeout: {\r\n          type: 'number',\r\n          description: 'Task timeout in milliseconds',\r\n        },\r\n      },\r\n      required: ['type', 'description'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Creating task', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const task: Partial<Task> = {\r\n        type: input.type,\r\n        description: input.description,\r\n        priority: input.priority || 5,\r\n        dependencies: input.dependencies || [],\r\n        input: input.input || {},\r\n        status: 'pending',\r\n        createdAt: new Date(),\r\n      };\r\n\r\n      const taskId = await context.orchestrator.createTask(task);\r\n\r\n      // Handle assignment\r\n      if (input.assignToAgent) {\r\n        await context.orchestrator.assignTask(taskId, input.assignToAgent);\r\n      } else if (input.assignToAgentType) {\r\n        await context.orchestrator.assignTaskToType(taskId, input.assignToAgentType);\r\n      }\r\n\r\n      return {\r\n        taskId,\r\n        task: { ...task, id: taskId },\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createListTasksTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'tasks/list',\r\n    description: 'List tasks with optional filtering',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        status: {\r\n          type: 'string',\r\n          enum: ['pending', 'queued', 'assigned', 'running', 'completed', 'failed', 'cancelled'],\r\n          description: 'Filter by task status',\r\n        },\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'Filter by assigned agent ID',\r\n        },\r\n        type: {\r\n          type: 'string',\r\n          description: 'Filter by task type',\r\n        },\r\n        limit: {\r\n          type: 'number',\r\n          default: 50,\r\n          description: 'Maximum number of tasks to return',\r\n        },\r\n        offset: {\r\n          type: 'number',\r\n          default: 0,\r\n          description: 'Number of tasks to skip',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Listing tasks', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const tasks = await context.orchestrator.listTasks({\r\n        status: input.status,\r\n        agentId: input.agentId,\r\n        type: input.type,\r\n        limit: input.limit || 50,\r\n        offset: input.offset || 0,\r\n      });\r\n\r\n      return {\r\n        tasks,\r\n        count: tasks.length,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createGetTaskStatusTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'tasks/status',\r\n    description: 'Get detailed status of a specific task',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        taskId: {\r\n          type: 'string',\r\n          description: 'ID of the task',\r\n        },\r\n      },\r\n      required: ['taskId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Getting task status', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const task = await context.orchestrator.getTask(input.taskId);\r\n\r\n      if (!task) {\r\n        throw new Error(`Task not found: ${input.taskId}`);\r\n      }\r\n\r\n      return {\r\n        task,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createCancelTaskTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'tasks/cancel',\r\n    description: 'Cancel a pending or running task',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        taskId: {\r\n          type: 'string',\r\n          description: 'ID of the task to cancel',\r\n        },\r\n        reason: {\r\n          type: 'string',\r\n          description: 'Reason for cancellation',\r\n        },\r\n      },\r\n      required: ['taskId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Cancelling task', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      await context.orchestrator.cancelTask(input.taskId, input.reason || 'Manual cancellation');\r\n\r\n      return {\r\n        taskId: input.taskId,\r\n        status: 'cancelled',\r\n        reason: input.reason || 'Manual cancellation',\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createAssignTaskTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'tasks/assign',\r\n    description: 'Assign a task to a specific agent',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        taskId: {\r\n          type: 'string',\r\n          description: 'ID of the task to assign',\r\n        },\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'ID of the agent to assign the task to',\r\n        },\r\n      },\r\n      required: ['taskId', 'agentId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Assigning task', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      await context.orchestrator.assignTask(input.taskId, input.agentId);\r\n\r\n      return {\r\n        taskId: input.taskId,\r\n        agentId: input.agentId,\r\n        status: 'assigned',\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createQueryMemoryTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'memory/query',\r\n    description: 'Query agent memory with filters and search',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'Filter by agent ID',\r\n        },\r\n        sessionId: {\r\n          type: 'string',\r\n          description: 'Filter by session ID',\r\n        },\r\n        type: {\r\n          type: 'string',\r\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\r\n          description: 'Filter by entry type',\r\n        },\r\n        tags: {\r\n          type: 'array',\r\n          items: { type: 'string' },\r\n          description: 'Filter by tags',\r\n        },\r\n        search: {\r\n          type: 'string',\r\n          description: 'Full-text search query',\r\n        },\r\n        startTime: {\r\n          type: 'string',\r\n          format: 'date-time',\r\n          description: 'Filter entries after this time',\r\n        },\r\n        endTime: {\r\n          type: 'string',\r\n          format: 'date-time',\r\n          description: 'Filter entries before this time',\r\n        },\r\n        limit: {\r\n          type: 'number',\r\n          default: 50,\r\n          description: 'Maximum number of entries to return',\r\n        },\r\n        offset: {\r\n          type: 'number',\r\n          default: 0,\r\n          description: 'Number of entries to skip',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Querying memory', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const query = {\r\n        agentId: input.agentId,\r\n        sessionId: input.sessionId,\r\n        type: input.type,\r\n        tags: input.tags,\r\n        search: input.search,\r\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\r\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\r\n        limit: input.limit || 50,\r\n        offset: input.offset || 0,\r\n      };\r\n\r\n      const entries = await context.orchestrator.queryMemory(query);\r\n\r\n      return {\r\n        entries,\r\n        count: entries.length,\r\n        query,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createStoreMemoryTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'memory/store',\r\n    description: 'Store a new memory entry',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'Agent ID for the memory entry',\r\n        },\r\n        sessionId: {\r\n          type: 'string',\r\n          description: 'Session ID for the memory entry',\r\n        },\r\n        type: {\r\n          type: 'string',\r\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\r\n          description: 'Type of memory entry',\r\n        },\r\n        content: {\r\n          type: 'string',\r\n          description: 'Content of the memory entry',\r\n        },\r\n        context: {\r\n          type: 'object',\r\n          description: 'Context data for the memory entry',\r\n        },\r\n        tags: {\r\n          type: 'array',\r\n          items: { type: 'string' },\r\n          description: 'Tags for the memory entry',\r\n        },\r\n        parentId: {\r\n          type: 'string',\r\n          description: 'Parent memory entry ID',\r\n        },\r\n      },\r\n      required: ['agentId', 'sessionId', 'type', 'content'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Storing memory', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const entry: Partial<MemoryEntry> = {\r\n        agentId: input.agentId,\r\n        sessionId: input.sessionId,\r\n        type: input.type,\r\n        content: input.content,\r\n        context: input.context || {},\r\n        tags: input.tags || [],\r\n        parentId: input.parentId,\r\n        timestamp: new Date(),\r\n        version: 1,\r\n      };\r\n\r\n      const entryId = await context.orchestrator.storeMemory(entry);\r\n\r\n      return {\r\n        entryId,\r\n        entry: { ...entry, id: entryId },\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createDeleteMemoryTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'memory/delete',\r\n    description: 'Delete a memory entry',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        entryId: {\r\n          type: 'string',\r\n          description: 'ID of the memory entry to delete',\r\n        },\r\n      },\r\n      required: ['entryId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Deleting memory', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      await context.orchestrator.deleteMemory(input.entryId);\r\n\r\n      return {\r\n        entryId: input.entryId,\r\n        status: 'deleted',\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createExportMemoryTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'memory/export',\r\n    description: 'Export memory entries to a file',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        format: {\r\n          type: 'string',\r\n          enum: ['json', 'csv', 'markdown'],\r\n          default: 'json',\r\n          description: 'Export format',\r\n        },\r\n        agentId: {\r\n          type: 'string',\r\n          description: 'Filter by agent ID',\r\n        },\r\n        sessionId: {\r\n          type: 'string',\r\n          description: 'Filter by session ID',\r\n        },\r\n        startTime: {\r\n          type: 'string',\r\n          format: 'date-time',\r\n          description: 'Export entries after this time',\r\n        },\r\n        endTime: {\r\n          type: 'string',\r\n          format: 'date-time',\r\n          description: 'Export entries before this time',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Exporting memory', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const exportResult = await context.orchestrator.exportMemory({\r\n        format: input.format || 'json',\r\n        agentId: input.agentId,\r\n        sessionId: input.sessionId,\r\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\r\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\r\n      });\r\n\r\n      return {\r\n        ...exportResult,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createImportMemoryTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'memory/import',\r\n    description: 'Import memory entries from a file',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        filePath: {\r\n          type: 'string',\r\n          description: 'Path to the file to import',\r\n        },\r\n        format: {\r\n          type: 'string',\r\n          enum: ['json', 'csv'],\r\n          default: 'json',\r\n          description: 'Import format',\r\n        },\r\n        mergeStrategy: {\r\n          type: 'string',\r\n          enum: ['skip', 'overwrite', 'version'],\r\n          default: 'skip',\r\n          description: 'Strategy for handling duplicate entries',\r\n        },\r\n      },\r\n      required: ['filePath'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Importing memory', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const importResult = await context.orchestrator.importMemory({\r\n        filePath: input.filePath,\r\n        format: input.format || 'json',\r\n        mergeStrategy: input.mergeStrategy || 'skip',\r\n      });\r\n\r\n      return {\r\n        ...importResult,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createGetSystemStatusTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'system/status',\r\n    description: 'Get comprehensive system status information',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {},\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Getting system status', { sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const status = await context.orchestrator.getSystemStatus();\r\n\r\n      return {\r\n        ...status,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createGetMetricsTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'system/metrics',\r\n    description: 'Get system performance metrics',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        timeRange: {\r\n          type: 'string',\r\n          enum: ['1h', '6h', '24h', '7d'],\r\n          default: '1h',\r\n          description: 'Time range for metrics',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Getting system metrics', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const metrics = await context.orchestrator.getMetrics(input.timeRange || '1h');\r\n\r\n      return {\r\n        metrics,\r\n        timeRange: input.timeRange || '1h',\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createHealthCheckTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'system/health',\r\n    description: 'Perform a comprehensive health check',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        deep: {\r\n          type: 'boolean',\r\n          default: false,\r\n          description: 'Perform deep health check including component tests',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Performing health check', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const healthCheck = await context.orchestrator.performHealthCheck(input.deep || false);\r\n\r\n      return {\r\n        ...healthCheck,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createGetConfigTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'config/get',\r\n    description: 'Get current system configuration',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        section: {\r\n          type: 'string',\r\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\r\n          description: 'Specific configuration section to retrieve',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Getting configuration', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const config = await context.orchestrator.getConfig(input.section);\r\n\r\n      return {\r\n        config,\r\n        section: input.section,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createUpdateConfigTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'config/update',\r\n    description: 'Update system configuration',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        section: {\r\n          type: 'string',\r\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\r\n          description: 'Configuration section to update',\r\n        },\r\n        config: {\r\n          type: 'object',\r\n          description: 'Configuration values to update',\r\n        },\r\n        restart: {\r\n          type: 'boolean',\r\n          default: false,\r\n          description: 'Restart affected components after update',\r\n        },\r\n      },\r\n      required: ['section', 'config'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Updating configuration', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const result = await context.orchestrator.updateConfig(\r\n        input.section,\r\n        input.config,\r\n        input.restart || false,\r\n      );\r\n\r\n      return {\r\n        ...result,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createValidateConfigTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'config/validate',\r\n    description: 'Validate a configuration object',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        config: {\r\n          type: 'object',\r\n          description: 'Configuration object to validate',\r\n        },\r\n      },\r\n      required: ['config'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Validating configuration', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const validation = await context.orchestrator.validateConfig(input.config);\r\n\r\n      return {\r\n        ...validation,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createExecuteWorkflowTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'workflow/execute',\r\n    description: 'Execute a workflow from a file or definition',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        filePath: {\r\n          type: 'string',\r\n          description: 'Path to workflow file',\r\n        },\r\n        workflow: {\r\n          type: 'object',\r\n          description: 'Inline workflow definition',\r\n        },\r\n        parameters: {\r\n          type: 'object',\r\n          description: 'Parameters to pass to the workflow',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Executing workflow', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      if (!input.filePath && !input.workflow) {\r\n        throw new Error('Either filePath or workflow must be provided');\r\n      }\r\n\r\n      const result = await context.orchestrator.executeWorkflow({\r\n        filePath: input.filePath,\r\n        workflow: input.workflow,\r\n        parameters: input.parameters || {},\r\n      });\r\n\r\n      return {\r\n        ...result,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createCreateWorkflowTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'workflow/create',\r\n    description: 'Create a new workflow definition',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        name: {\r\n          type: 'string',\r\n          description: 'Name of the workflow',\r\n        },\r\n        description: {\r\n          type: 'string',\r\n          description: 'Description of the workflow',\r\n        },\r\n        tasks: {\r\n          type: 'array',\r\n          items: {\r\n            type: 'object',\r\n            properties: {\r\n              id: { type: 'string' },\r\n              type: { type: 'string' },\r\n              description: { type: 'string' },\r\n              dependencies: {\r\n                type: 'array',\r\n                items: { type: 'string' },\r\n              },\r\n              assignTo: { type: 'string' },\r\n            },\r\n            required: ['id', 'type', 'description'],\r\n          },\r\n          description: 'List of tasks in the workflow',\r\n        },\r\n        savePath: {\r\n          type: 'string',\r\n          description: 'Path to save the workflow file',\r\n        },\r\n      },\r\n      required: ['name', 'tasks'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Creating workflow', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const workflow = {\r\n        name: input.name,\r\n        description: input.description,\r\n        tasks: input.tasks,\r\n        created: new Date().toISOString(),\r\n      };\r\n\r\n      const result = await context.orchestrator.createWorkflow(workflow, input.savePath);\r\n\r\n      return {\r\n        ...result,\r\n        workflow,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createListWorkflowsTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'workflow/list',\r\n    description: 'List available workflows',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        directory: {\r\n          type: 'string',\r\n          description: 'Directory to search for workflows',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Listing workflows', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const workflows = await context.orchestrator.listWorkflows(input.directory);\r\n\r\n      return {\r\n        workflows,\r\n        count: workflows.length,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createExecuteCommandTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'terminal/execute',\r\n    description: 'Execute a command in a terminal session',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        command: {\r\n          type: 'string',\r\n          description: 'Command to execute',\r\n        },\r\n        args: {\r\n          type: 'array',\r\n          items: { type: 'string' },\r\n          description: 'Command arguments',\r\n        },\r\n        cwd: {\r\n          type: 'string',\r\n          description: 'Working directory for the command',\r\n        },\r\n        env: {\r\n          type: 'object',\r\n          description: 'Environment variables',\r\n        },\r\n        timeout: {\r\n          type: 'number',\r\n          default: 30000,\r\n          description: 'Command timeout in milliseconds',\r\n        },\r\n        terminalId: {\r\n          type: 'string',\r\n          description: 'Specific terminal ID to use',\r\n        },\r\n      },\r\n      required: ['command'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Executing command', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const result = await context.orchestrator.executeCommand({\r\n        command: input.command,\r\n        args: input.args,\r\n        cwd: input.cwd,\r\n        env: input.env,\r\n        timeout: input.timeout || 30000,\r\n        terminalId: input.terminalId,\r\n      });\r\n\r\n      return {\r\n        ...result,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createListTerminalsTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'terminal/list',\r\n    description: 'List all terminal sessions',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        includeIdle: {\r\n          type: 'boolean',\r\n          default: true,\r\n          description: 'Include idle terminals',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Listing terminals', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const terminals = await context.orchestrator.listTerminals(input.includeIdle !== false);\r\n\r\n      return {\r\n        terminals,\r\n        count: terminals.length,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction createCreateTerminalTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'terminal/create',\r\n    description: 'Create a new terminal session',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        cwd: {\r\n          type: 'string',\r\n          description: 'Working directory for the terminal',\r\n        },\r\n        env: {\r\n          type: 'object',\r\n          description: 'Environment variables',\r\n        },\r\n        shell: {\r\n          type: 'string',\r\n          description: 'Shell to use (bash, zsh, etc.)',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Creating terminal', { input, sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const terminal = await context.orchestrator.createTerminal({\r\n        cwd: input.cwd,\r\n        env: input.env,\r\n        shell: input.shell,\r\n      });\r\n\r\n      return {\r\n        terminal,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * NEW: Phase 4 - Parallel Agent Spawning (10-20x faster)\r\n * Spawn multiple agents in parallel using ParallelSwarmExecutor\r\n */\r\nfunction createSpawnParallelAgentsTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'agents/spawn_parallel',\r\n    description: 'Spawn multiple agents in parallel (10-20x faster than sequential spawning)',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        agents: {\r\n          type: 'array',\r\n          items: {\r\n            type: 'object',\r\n            properties: {\r\n              type: { type: 'string', description: 'Agent type' },\r\n              name: { type: 'string', description: 'Agent name' },\r\n              capabilities: { type: 'array', items: { type: 'string' } },\r\n              priority: {\r\n                type: 'string',\r\n                enum: ['low', 'medium', 'high', 'critical'],\r\n                default: 'medium'\r\n              },\r\n            },\r\n            required: ['type', 'name'],\r\n          },\r\n          description: 'Array of agent configurations to spawn in parallel',\r\n        },\r\n        maxConcurrency: {\r\n          type: 'number',\r\n          default: 5,\r\n          description: 'Maximum number of agents to spawn concurrently',\r\n        },\r\n        batchSize: {\r\n          type: 'number',\r\n          default: 3,\r\n          description: 'Number of agents per batch',\r\n        },\r\n      },\r\n      required: ['agents'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Spawning parallel agents', {\r\n        count: input.agents?.length,\r\n        sessionId: context?.sessionId\r\n      });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const executor = context.orchestrator.getParallelExecutor();\r\n      if (!executor) {\r\n        throw new Error('ParallelSwarmExecutor not initialized');\r\n      }\r\n\r\n      // Convert input agents to ParallelAgentConfig format\r\n      const agentConfigs = input.agents.map((agent: any) => ({\r\n        agentId: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        agentType: agent.type,\r\n        task: `Spawn ${agent.name} agent`,\r\n        capabilities: agent.capabilities || [],\r\n        priority: agent.priority || 'medium',\r\n      }));\r\n\r\n      const startTime = Date.now();\r\n      const sessions = await executor.spawnParallelAgents(agentConfigs, {\r\n        maxConcurrency: input.maxConcurrency || 5,\r\n        batchSize: input.batchSize || 3,\r\n      });\r\n\r\n      const elapsedTime = Date.now() - startTime;\r\n\r\n      return {\r\n        success: true,\r\n        agentsSpawned: sessions.size,\r\n        sessions: Array.from(sessions.entries()).map(([id, session]) => ({\r\n          agentId: id,\r\n          sessionId: session.sessionId,\r\n          status: session.status,\r\n        })),\r\n        performance: {\r\n          totalTime: elapsedTime,\r\n          averageTimePerAgent: elapsedTime / sessions.size,\r\n          speedupVsSequential: `~${Math.round((sessions.size * 750) / elapsedTime)}x`,\r\n        },\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * NEW: Phase 4 - Real-Time Query Control\r\n * Control running queries: pause, resume, terminate, change model\r\n */\r\nfunction createQueryControlTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'query/control',\r\n    description: 'Control running queries (pause, resume, terminate, change model)',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        action: {\r\n          type: 'string',\r\n          enum: ['pause', 'resume', 'terminate', 'change_model', 'change_permissions', 'execute_command'],\r\n          description: 'Control action to perform',\r\n        },\r\n        queryId: {\r\n          type: 'string',\r\n          description: 'ID of the query to control',\r\n        },\r\n        model: {\r\n          type: 'string',\r\n          enum: ['claude-3-5-sonnet-20241022', 'claude-3-5-haiku-20241022', 'claude-3-opus-20240229'],\r\n          description: 'Model to switch to (for change_model action)',\r\n        },\r\n        permissionMode: {\r\n          type: 'string',\r\n          enum: ['default', 'acceptEdits', 'bypassPermissions', 'plan'],\r\n          description: 'Permission mode to switch to (for change_permissions action)',\r\n        },\r\n        command: {\r\n          type: 'string',\r\n          description: 'Command to execute (for execute_command action)',\r\n        },\r\n      },\r\n      required: ['action', 'queryId'],\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Query control action', {\r\n        action: input.action,\r\n        queryId: input.queryId,\r\n        sessionId: context?.sessionId\r\n      });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const controller = context.orchestrator.getQueryController();\r\n      if (!controller) {\r\n        throw new Error('RealTimeQueryController not initialized');\r\n      }\r\n\r\n      let result;\r\n      switch (input.action) {\r\n        case 'pause':\r\n          result = await controller.pauseQuery(input.queryId);\r\n          break;\r\n        case 'resume':\r\n          result = await controller.resumeQuery(input.queryId);\r\n          break;\r\n        case 'terminate':\r\n          result = await controller.terminateQuery(input.queryId);\r\n          break;\r\n        case 'change_model':\r\n          if (!input.model) {\r\n            throw new Error('model parameter required for change_model action');\r\n          }\r\n          result = await controller.changeModel(input.queryId, input.model);\r\n          break;\r\n        case 'change_permissions':\r\n          if (!input.permissionMode) {\r\n            throw new Error('permissionMode parameter required for change_permissions action');\r\n          }\r\n          result = await controller.changePermissionMode(input.queryId, input.permissionMode);\r\n          break;\r\n        case 'execute_command':\r\n          if (!input.command) {\r\n            throw new Error('command parameter required for execute_command action');\r\n          }\r\n          result = await controller.executeCommand(input.queryId, input.command);\r\n          break;\r\n        default:\r\n          throw new Error(`Unknown action: ${input.action}`);\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        action: input.action,\r\n        queryId: input.queryId,\r\n        result,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * NEW: Phase 4 - List Active Queries\r\n * Get status of all active queries being controlled\r\n */\r\nfunction createListQueriesTool(logger: ILogger): MCPTool {\r\n  return {\r\n    name: 'query/list',\r\n    description: 'List all active queries and their status',\r\n    inputSchema: {\r\n      type: 'object',\r\n      properties: {\r\n        includeHistory: {\r\n          type: 'boolean',\r\n          default: false,\r\n          description: 'Include completed queries in the list',\r\n        },\r\n      },\r\n    },\r\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\r\n      logger.info('Listing queries', { sessionId: context?.sessionId });\r\n\r\n      if (!context?.orchestrator) {\r\n        throw new Error('Orchestrator not available');\r\n      }\r\n\r\n      const controller = context.orchestrator.getQueryController();\r\n      if (!controller) {\r\n        throw new Error('RealTimeQueryController not initialized');\r\n      }\r\n\r\n      const queries = controller.getAllQueries();\r\n\r\n      return {\r\n        success: true,\r\n        queries: Array.from(queries.entries()).map(([id, status]) => ({\r\n          queryId: id,\r\n          ...status,\r\n        })),\r\n        count: queries.size,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n  };\r\n}\r\n\r\nfunction getDefaultSystemPrompt(type: string): string {\r\n  const prompts = {\r\n    coordinator:\r\n      'You are a coordinator agent responsible for planning, delegating, and orchestrating tasks across multiple agents.',\r\n    researcher:\r\n      'You are a research agent specialized in gathering, analyzing, and synthesizing information from various sources.',\r\n    implementer:\r\n      'You are an implementation agent focused on writing code, creating solutions, and executing technical tasks.',\r\n    analyst:\r\n      'You are an analysis agent that identifies patterns, generates insights, and provides data-driven recommendations.',\r\n    custom: 'You are a specialized agent with custom capabilities defined by your configuration.',\r\n  };\r\n\r\n  return prompts[type as keyof typeof prompts] || prompts.custom;\r\n}\r\n"],"names":["getAvailableAgentTypes","enhanceToolWithAgentTypes","tool","availableTypes","enhancedTool","JSON","parse","stringify","addEnumToAgentTypeFields","obj","key","value","Object","entries","field","type","description","includes","enum","inputSchema","createClaudeFlowTools","logger","tools","createSpawnAgentTool","createSpawnParallelAgentsTool","createListAgentsTool","createTerminateAgentTool","createGetAgentInfoTool","createQueryControlTool","createListQueriesTool","createCreateTaskTool","createListTasksTool","createGetTaskStatusTool","createCancelTaskTool","createAssignTaskTool","createQueryMemoryTool","createStoreMemoryTool","createDeleteMemoryTool","createExportMemoryTool","createImportMemoryTool","createGetSystemStatusTool","createGetMetricsTool","createHealthCheckTool","createGetConfigTool","createUpdateConfigTool","createValidateConfigTool","createExecuteWorkflowTool","createCreateWorkflowTool","createListWorkflowsTool","createExecuteCommandTool","createListTerminalsTool","createCreateTerminalTool","enhancedTools","Promise","all","map","name","properties","capabilities","items","systemPrompt","maxConcurrentTasks","default","priority","environment","workingDirectory","required","handler","input","context","info","sessionId","orchestrator","Error","profile","id","Date","now","Math","random","toString","substr","getDefaultSystemPrompt","spawnAgent","agentId","status","timestamp","toISOString","includeTerminated","filterByType","agents","listAgents","filteredAgents","filter","agent","count","length","reason","graceful","terminateAgent","agentInfo","getAgentInfo","dependencies","assignToAgent","assignToAgentType","timeout","task","createdAt","taskId","createTask","assignTask","assignTaskToType","limit","offset","tasks","listTasks","getTask","cancelTask","tags","search","startTime","format","endTime","query","undefined","queryMemory","content","parentId","entry","version","entryId","storeMemory","deleteMemory","exportResult","exportMemory","filePath","mergeStrategy","importResult","importMemory","getSystemStatus","timeRange","metrics","getMetrics","deep","healthCheck","performHealthCheck","section","config","getConfig","restart","result","updateConfig","validation","validateConfig","workflow","parameters","executeWorkflow","assignTo","savePath","created","createWorkflow","directory","workflows","listWorkflows","command","args","cwd","env","terminalId","executeCommand","includeIdle","terminals","listTerminals","shell","terminal","createTerminal","maxConcurrency","batchSize","executor","getParallelExecutor","agentConfigs","agentType","sessions","spawnParallelAgents","elapsedTime","success","agentsSpawned","size","Array","from","session","performance","totalTime","averageTimePerAgent","speedupVsSequential","round","action","queryId","model","permissionMode","controller","getQueryController","pauseQuery","resumeQuery","terminateQuery","changeModel","changePermissionMode","includeHistory","queries","getAllQueries","prompts","coordinator","researcher","implementer","analyst","custom"],"mappings":"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"}