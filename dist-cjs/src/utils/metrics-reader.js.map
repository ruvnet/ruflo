{"version":3,"sources":["../../../src/utils/metrics-reader.ts"],"sourcesContent":["import * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport { exec } from 'child_process';\r\nimport { promisify } from 'util';\r\n\r\nconst execAsync = promisify(exec);\r\n\r\ninterface SystemMetrics {\r\n  timestamp: number;\r\n  memoryTotal: number;\r\n  memoryUsed: number;\r\n  memoryFree: number;\r\n  memoryUsagePercent: number;\r\n  memoryEfficiency: number;\r\n  cpuCount: number;\r\n  cpuLoad: number;\r\n  platform: string;\r\n  uptime: number;\r\n}\r\n\r\ninterface TaskMetric {\r\n  id: string;\r\n  type: string;\r\n  success: boolean;\r\n  duration: number;\r\n  timestamp: number;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\ninterface PerformanceMetrics {\r\n  startTime: number;\r\n  totalTasks: number;\r\n  successfulTasks: number;\r\n  failedTasks: number;\r\n  totalAgents: number;\r\n  activeAgents: number;\r\n  neuralEvents: number;\r\n}\r\n\r\ninterface Agent {\r\n  id: string;\r\n  name: string;\r\n  type: string;\r\n  status: 'active' | 'idle' | 'busy';\r\n  activeTasks: number;\r\n  lastActivity?: number;\r\n}\r\n\r\ninterface SessionData {\r\n  id: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  agents: Agent[];\r\n  tasks: any[];\r\n  status: 'active' | 'completed' | 'paused';\r\n}\r\n\r\ninterface MCPServerStatus {\r\n  running: boolean;\r\n  processCount: number;\r\n  orchestratorRunning: boolean;\r\n  port: number | null;\r\n  connections: number;\r\n}\r\n\r\nexport class MetricsReader {\r\n  private metricsDir = '.claude-flow/metrics';\r\n  private sessionsDir = '.claude-flow/sessions';\r\n\r\n  async getSystemMetrics(): Promise<SystemMetrics | null> {\r\n    try {\r\n      const filePath = path.join(this.metricsDir, 'system-metrics.json');\r\n      const content = await fs.readFile(filePath, 'utf8');\r\n      const metrics: SystemMetrics[] = JSON.parse(content);\r\n      \r\n      // Return the most recent metric\r\n      return metrics.length > 0 ? metrics[metrics.length - 1] : null;\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getTaskMetrics(): Promise<TaskMetric[]> {\r\n    try {\r\n      const filePath = path.join(this.metricsDir, 'task-metrics.json');\r\n      const content = await fs.readFile(filePath, 'utf8');\r\n      return JSON.parse(content);\r\n    } catch (error) {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getPerformanceMetrics(): Promise<PerformanceMetrics | null> {\r\n    try {\r\n      const filePath = path.join(this.metricsDir, 'performance.json');\r\n      const content = await fs.readFile(filePath, 'utf8');\r\n      return JSON.parse(content);\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getActiveAgents(): Promise<Agent[]> {\r\n    try {\r\n      // First check performance metrics for agent count\r\n      const perfMetrics = await this.getPerformanceMetrics();\r\n      \r\n      // Also check session files for more detailed agent info\r\n      const sessionFiles = await this.getSessionFiles();\r\n      const agents: Agent[] = [];\r\n      \r\n      for (const file of sessionFiles) {\r\n        try {\r\n          const content = await fs.readFile(path.join(this.sessionsDir, 'pair', file), 'utf8');\r\n          const sessionData = JSON.parse(content);\r\n          \r\n          if (sessionData.agents && Array.isArray(sessionData.agents)) {\r\n            agents.push(...sessionData.agents);\r\n          }\r\n        } catch {\r\n          // Skip invalid session files\r\n        }\r\n      }\r\n      \r\n      // If no agents found in sessions, create mock agents based on performance metrics\r\n      if (agents.length === 0 && perfMetrics) {\r\n        const activeCount = perfMetrics.activeAgents || 0;\r\n        const totalCount = perfMetrics.totalAgents || 0;\r\n        \r\n        for (let i = 0; i < totalCount; i++) {\r\n          agents.push({\r\n            id: `agent-${i + 1}`,\r\n            name: `Agent ${i + 1}`,\r\n            type: i === 0 ? 'orchestrator' : 'worker',\r\n            status: i < activeCount ? 'active' : 'idle',\r\n            activeTasks: i < activeCount ? 1 : 0,\r\n            lastActivity: Date.now() - (i * 1000)\r\n          });\r\n        }\r\n      }\r\n      \r\n      return agents;\r\n    } catch (error) {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getSessionStatus(): Promise<SessionData | null> {\r\n    try {\r\n      const sessionFiles = await this.getSessionFiles();\r\n      \r\n      if (sessionFiles.length === 0) {\r\n        return null;\r\n      }\r\n      \r\n      // Get the most recent session\r\n      const mostRecentFile = sessionFiles[sessionFiles.length - 1];\r\n      const content = await fs.readFile(path.join(this.sessionsDir, 'pair', mostRecentFile), 'utf8');\r\n      return JSON.parse(content);\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getRecentTasks(limit: number = 10): Promise<any[]> {\r\n    try {\r\n      const taskMetrics = await this.getTaskMetrics();\r\n      \r\n      // Sort by timestamp descending and take the limit\r\n      return taskMetrics\r\n        .sort((a, b) => b.timestamp - a.timestamp)\r\n        .slice(0, limit)\r\n        .map(task => ({\r\n          id: task.id,\r\n          type: task.type,\r\n          status: task.success ? 'completed' : 'failed',\r\n          startTime: task.timestamp - task.duration,\r\n          endTime: task.timestamp,\r\n          duration: task.duration\r\n        }));\r\n    } catch (error) {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getOverallHealth(): Promise<'healthy' | 'warning' | 'error'> {\r\n    try {\r\n      const systemMetrics = await this.getSystemMetrics();\r\n      const perfMetrics = await this.getPerformanceMetrics();\r\n      \r\n      if (!systemMetrics && !perfMetrics) {\r\n        return 'error';\r\n      }\r\n      \r\n      // Check memory usage\r\n      if (systemMetrics && systemMetrics.memoryUsagePercent > 90) {\r\n        return 'error';\r\n      }\r\n      \r\n      if (systemMetrics && systemMetrics.memoryUsagePercent > 75) {\r\n        return 'warning';\r\n      }\r\n      \r\n      // Check CPU load\r\n      if (systemMetrics && systemMetrics.cpuLoad > 0.8) {\r\n        return 'warning';\r\n      }\r\n      \r\n      // Check task failure rate\r\n      if (perfMetrics && perfMetrics.totalTasks > 0) {\r\n        const failureRate = perfMetrics.failedTasks / perfMetrics.totalTasks;\r\n        if (failureRate > 0.5) {\r\n          return 'error';\r\n        }\r\n        if (failureRate > 0.2) {\r\n          return 'warning';\r\n        }\r\n      }\r\n      \r\n      return 'healthy';\r\n    } catch (error) {\r\n      return 'error';\r\n    }\r\n  }\r\n\r\n  private async getSessionFiles(): Promise<string[]> {\r\n    try {\r\n      const files = await fs.readdir(path.join(this.sessionsDir, 'pair'));\r\n      return files.filter(f => f.endsWith('.json')).sort();\r\n    } catch (error) {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getMCPServerStatus(): Promise<MCPServerStatus> {\r\n    try {\r\n      // Check if MCP server process is running\r\n      const { stdout } = await execAsync('ps aux | grep -E \"mcp-server\\\\.js|claude-flow mcp start\" | grep -v grep | wc -l');\r\n      const processCount = parseInt(stdout.trim(), 10);\r\n      \r\n      // Check for orchestrator running\r\n      const { stdout: orchestratorOut } = await execAsync('ps aux | grep -E \"claude-flow start\" | grep -v grep | wc -l');\r\n      const orchestratorRunning = parseInt(orchestratorOut.trim(), 10) > 0;\r\n      \r\n      // Determine status\r\n      const isRunning = processCount > 0;\r\n      \r\n      // Try to get port from process (default is 3000)\r\n      let port: number | null = 3000;\r\n      try {\r\n        const { stdout: portOut } = await execAsync('lsof -i :3000 2>/dev/null | grep LISTEN | wc -l');\r\n        if (parseInt(portOut.trim(), 10) === 0) {\r\n          // If port 3000 not listening, check other common ports\r\n          port = null;\r\n        }\r\n      } catch {\r\n        // lsof might not be available or port not in use\r\n      }\r\n      \r\n      return {\r\n        running: isRunning,\r\n        processCount,\r\n        orchestratorRunning,\r\n        port,\r\n        connections: processCount > 0 ? Math.max(1, processCount - 1) : 0 // Estimate connections\r\n      };\r\n    } catch (error) {\r\n      // Fallback if commands fail\r\n      return {\r\n        running: false,\r\n        processCount: 0,\r\n        orchestratorRunning: false,\r\n        port: null,\r\n        connections: 0\r\n      };\r\n    }\r\n  }\r\n}"],"names":["fs","path","exec","promisify","execAsync","MetricsReader","metricsDir","sessionsDir","getSystemMetrics","filePath","join","content","readFile","metrics","JSON","parse","length","error","getTaskMetrics","getPerformanceMetrics","getActiveAgents","perfMetrics","sessionFiles","getSessionFiles","agents","file","sessionData","Array","isArray","push","activeCount","activeAgents","totalCount","totalAgents","i","id","name","type","status","activeTasks","lastActivity","Date","now","getSessionStatus","mostRecentFile","getRecentTasks","limit","taskMetrics","sort","a","b","timestamp","slice","map","task","success","startTime","duration","endTime","getOverallHealth","systemMetrics","memoryUsagePercent","cpuLoad","totalTasks","failureRate","failedTasks","files","readdir","filter","f","endsWith","getMCPServerStatus","stdout","processCount","parseInt","trim","orchestratorOut","orchestratorRunning","isRunning","port","portOut","running","connections","Math","max"],"mappings":"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"}