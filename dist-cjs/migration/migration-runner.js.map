{
  "version": 3,
  "sources": ["../../src/migration/migration-runner.ts"],
  "sourcesContent": ["import { dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n/**\n * Migration Runner - Executes migration strategies\n */\n\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport type {\n  MigrationOptions,\n  MigrationResult,\n  MigrationBackup,\n  BackupFile,\n  ValidationResult,\n  MigrationProgress,\n  MigrationManifest,\n} from './types.js';\nimport { MigrationAnalyzer } from './migration-analyzer.js';\nimport { logger } from './logger.js';\nimport { ProgressReporter } from './progress-reporter.js';\nimport { MigrationValidator } from './migration-validator.js';\nimport { glob } from 'glob';\nimport * as inquirer from 'inquirer';\nimport * as chalk from 'chalk';\n\nexport class MigrationRunner {\n  private options: MigrationOptions;\n  private progress: ProgressReporter;\n  private analyzer: MigrationAnalyzer;\n  private validator: MigrationValidator;\n  private manifest: MigrationManifest;\n\n  constructor(options: MigrationOptions) {\n    this.options = options;\n    this.progress = new ProgressReporter();\n    this.analyzer = new MigrationAnalyzer();\n    this.validator = new MigrationValidator();\n    this.manifest = this.loadManifest();\n  }\n\n  async run(): Promise<MigrationResult> {\n    const result: MigrationResult = {\n      success: false,\n      filesModified: [],\n      filesCreated: [],\n      filesBackedUp: [],\n      errors: [],\n      warnings: [],\n    };\n\n    try {\n      // Analyze project\n      this.progress.start('analyzing', 'Analyzing project...');\n      const analysis = await this.analyzer.analyze(this.options.projectPath);\n\n      // Show analysis and confirm\n      if (!this.options.force && !this.options.dryRun) {\n        this.analyzer.printAnalysis(analysis);\n        const confirm = await this.confirmMigration(analysis);\n        if (!confirm) {\n          logger.info('Migration cancelled');\n          return result;\n        }\n      }\n\n      // Create backup\n      if (!this.options.dryRun && analysis.hasClaudeFolder) {\n        this.progress.update('backing-up', 'Creating backup...');\n        const backup = await this.createBackup();\n        result.rollbackPath = backup.timestamp.toISOString();\n        result.filesBackedUp = backup.files.map((f) => f.path);\n      }\n\n      // Execute migration based on strategy\n      this.progress.update('migrating', 'Migrating files...');\n\n      switch (this.options.strategy) {\n        case 'full':\n          await this.fullMigration(result);\n          break;\n        case 'selective':\n          await this.selectiveMigration(result, analysis);\n          break;\n        case 'merge':\n          await this.mergeMigration(result, analysis);\n          break;\n      }\n\n      // Validate migration\n      if (!this.options.skipValidation && !this.options.dryRun) {\n        this.progress.update('validating', 'Validating migration...');\n        const validation = await this.validator.validate(this.options.projectPath);\n\n        if (!validation.valid) {\n          result.errors.push(...validation.errors.map((e) => ({ error: e })));\n          result.warnings.push(...validation.warnings);\n        }\n      }\n\n      result.success = result.errors.length === 0;\n      this.progress.complete(\n        result.success ? 'Migration completed successfully!' : 'Migration completed with errors',\n      );\n\n      // Print summary\n      this.printSummary(result);\n    } catch (error) {\n      result.errors.push({\n        error: error instanceof Error ? error.message : String(error),\n        stack: error.stack,\n      });\n      this.progress.error('Migration failed');\n\n      // Attempt rollback on failure\n      if (result.rollbackPath && !this.options.dryRun) {\n        logger.warn('Attempting automatic rollback...');\n        try {\n          await this.rollback(result.rollbackPath);\n          logger.success('Rollback completed');\n        } catch (rollbackError) {\n          logger.error('Rollback failed:', rollbackError);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async fullMigration(result: MigrationResult): Promise<void> {\n    const sourcePath = path.join(__dirname, '../../.claude');\n    const targetPath = path.join(this.options.projectPath, '.claude');\n\n    if (this.options.dryRun) {\n      logger.info('[DRY RUN] Would replace entire .claude folder');\n      return;\n    }\n\n    // Remove existing .claude folder\n    if (await fs.pathExists(targetPath)) {\n      await fs.remove(targetPath);\n    }\n\n    // Copy new .claude folder\n    await fs.copy(sourcePath, targetPath);\n    result.filesCreated.push('.claude');\n\n    // Copy other required files\n    await this.copyRequiredFiles(result);\n  }\n\n  private async selectiveMigration(result: MigrationResult, analysis: any): Promise<void> {\n    const sourcePath = path.join(__dirname, '../../.claude');\n    const targetPath = path.join(this.options.projectPath, '.claude');\n\n    // Ensure target directory exists\n    await fs.ensureDir(targetPath);\n\n    // Migrate commands selectively\n    const commandsSource = path.join(sourcePath, 'commands');\n    const commandsTarget = path.join(targetPath, 'commands');\n    await fs.ensureDir(commandsTarget);\n\n    // Copy optimized commands\n    for (const command of this.manifest.files.commands) {\n      const sourceFile = path.join(commandsSource, command.source);\n      const targetFile = path.join(commandsTarget, command.target);\n\n      if (\n        this.options.preserveCustom &&\n        analysis.customCommands.includes(path.basename(command.target, '.md'))\n      ) {\n        result.warnings.push(`Skipped ${command.target} (custom command preserved)`);\n        continue;\n      }\n\n      if (this.options.dryRun) {\n        logger.info(`[DRY RUN] Would copy ${command.source} to ${command.target}`);\n      } else {\n        await fs.copy(sourceFile, targetFile, { overwrite: true });\n        result.filesCreated.push(command.target);\n      }\n    }\n\n    // Copy optimization guides\n    const guides = [\n      'BATCHTOOLS_GUIDE.md',\n      'BATCHTOOLS_BEST_PRACTICES.md',\n      'MIGRATION_GUIDE.md',\n      'PERFORMANCE_BENCHMARKS.md',\n    ];\n\n    for (const guide of guides) {\n      const sourceFile = path.join(sourcePath, guide);\n      const targetFile = path.join(targetPath, guide);\n\n      if (await fs.pathExists(sourceFile)) {\n        if (this.options.dryRun) {\n          logger.info(`[DRY RUN] Would copy ${guide}`);\n        } else {\n          await fs.copy(sourceFile, targetFile, { overwrite: true });\n          result.filesCreated.push(guide);\n        }\n      }\n    }\n\n    // Update configurations\n    await this.updateConfigurations(result);\n  }\n\n  private async mergeMigration(result: MigrationResult, analysis: any): Promise<void> {\n    // Similar to selective but merges configurations\n    await this.selectiveMigration(result, analysis);\n\n    // Merge configurations\n    if (!this.options.dryRun) {\n      await this.mergeConfigurations(result, analysis);\n    }\n  }\n\n  private async mergeConfigurations(result: MigrationResult, analysis: any): Promise<void> {\n    // Merge CLAUDE.md\n    const claudeMdPath = path.join(this.options.projectPath, 'CLAUDE.md');\n    if (await fs.pathExists(claudeMdPath)) {\n      const existingContent = await fs.readFile(claudeMdPath, 'utf-8');\n      const newContent = await this.getMergedClaudeMd(existingContent);\n\n      await fs.writeFile(claudeMdPath, newContent);\n      result.filesModified.push('CLAUDE.md');\n    }\n\n    // Merge .roomodes\n    const roomodesPath = path.join(this.options.projectPath, '.roomodes');\n    if (await fs.pathExists(roomodesPath)) {\n      const existing = await fs.readJson(roomodesPath);\n      const updated = await this.getMergedRoomodes(existing);\n\n      await fs.writeJson(roomodesPath, updated, { spaces: 2 });\n      result.filesModified.push('.roomodes');\n    }\n  }\n\n  private async copyRequiredFiles(result: MigrationResult): Promise<void> {\n    const files = [\n      { source: 'CLAUDE.md', target: 'CLAUDE.md' },\n      { source: '.roomodes', target: '.roomodes' },\n    ];\n\n    for (const file of files) {\n      const sourcePath = path.join(__dirname, '../../', file.source);\n      const targetPath = path.join(this.options.projectPath, file.target);\n\n      if (await fs.pathExists(sourcePath)) {\n        if (this.options.dryRun) {\n          logger.info(`[DRY RUN] Would copy ${file.source}`);\n        } else {\n          await fs.copy(sourcePath, targetPath, { overwrite: true });\n          result.filesCreated.push(file.target);\n        }\n      }\n    }\n  }\n\n  private async updateConfigurations(result: MigrationResult): Promise<void> {\n    // Update package.json scripts if needed\n    const packageJsonPath = path.join(this.options.projectPath, 'package.json');\n    if (await fs.pathExists(packageJsonPath)) {\n      const packageJson = await fs.readJson(packageJsonPath);\n\n      if (!packageJson.scripts) {\n        packageJson.scripts = {};\n      }\n\n      const scripts = {\n        migrate: 'claude-flow migrate',\n        'migrate:analyze': 'claude-flow migrate analyze',\n        'migrate:rollback': 'claude-flow migrate rollback',\n      };\n\n      let modified = false;\n      for (const [name, command] of Object.entries(scripts)) {\n        if (!packageJson.scripts[name]) {\n          packageJson.scripts[name] = command;\n          modified = true;\n        }\n      }\n\n      if (modified && !this.options.dryRun) {\n        await fs.writeJson(packageJsonPath, packageJson, { spaces: 2 });\n        result.filesModified.push('package.json');\n      }\n    }\n  }\n\n  private async createBackup(): Promise<MigrationBackup> {\n    const backupDir = path.join(\n      this.options.projectPath,\n      this.options.backupDir || '.claude-backup',\n    );\n    const timestamp = new Date();\n    const backupPath = path.join(backupDir, timestamp.toISOString().replace(/:/g, '-'));\n\n    await fs.ensureDir(backupPath);\n\n    const backup: MigrationBackup = {\n      timestamp,\n      version: '1.0.0',\n      files: [],\n      metadata: {\n        strategy: this.options.strategy,\n        projectPath: this.options.projectPath,\n      },\n    };\n\n    // Backup .claude folder\n    const claudePath = path.join(this.options.projectPath, '.claude');\n    if (await fs.pathExists(claudePath)) {\n      await fs.copy(claudePath, path.join(backupPath, '.claude'));\n\n      // Record backed up files\n      const files = await glob('**/*', { cwd: claudePath, nodir: true });\n      for (const file of files) {\n        const content = await fs.readFile(path.join(claudePath, file), 'utf-8');\n        backup.files.push({\n          path: `.claude/${file}`,\n          content,\n          checksum: crypto.createHash('md5').update(content).digest('hex'),\n        });\n      }\n    }\n\n    // Backup other important files\n    const importantFiles = ['CLAUDE.md', '.roomodes', 'package.json'];\n    for (const file of importantFiles) {\n      const filePath = path.join(this.options.projectPath, file);\n      if (await fs.pathExists(filePath)) {\n        await fs.copy(filePath, path.join(backupPath, file));\n        const content = await fs.readFile(filePath, 'utf-8');\n        backup.files.push({\n          path: file,\n          content,\n          checksum: crypto.createHash('md5').update(content).digest('hex'),\n        });\n      }\n    }\n\n    // Save backup manifest\n    await fs.writeJson(path.join(backupPath, 'backup.json'), backup, { spaces: 2 });\n\n    logger.success(`Backup created at ${backupPath}`);\n    return backup;\n  }\n\n  async rollback(timestamp?: string): Promise<void> {\n    const backupDir = path.join(\n      this.options.projectPath,\n      this.options.backupDir || '.claude-backup',\n    );\n\n    if (!(await fs.pathExists(backupDir))) {\n      throw new Error('No backups found');\n    }\n\n    let backupPath: string;\n\n    if (timestamp) {\n      backupPath = path.join(backupDir, timestamp);\n    } else {\n      // Use most recent backup\n      const backups = await fs.readdir(backupDir);\n      if (backups.length === 0) {\n        throw new Error('No backups found');\n      }\n      backups.sort().reverse();\n      backupPath = path.join(backupDir, backups[0]);\n    }\n\n    if (!(await fs.pathExists(backupPath))) {\n      throw new Error(`Backup not found: ${backupPath}`);\n    }\n\n    logger.info(`Rolling back from ${backupPath}...`);\n\n    // Confirm rollback\n    if (!this.options.force) {\n      const confirm = await inquirer.prompt([\n        {\n          type: 'confirm',\n          name: 'proceed',\n          message: 'Are you sure you want to rollback? This will overwrite current files.',\n          default: false,\n        },\n      ]);\n\n      if (!confirm.proceed) {\n        logger.info('Rollback cancelled');\n        return;\n      }\n    }\n\n    // Restore files\n    const backup = await fs.readJson(path.join(backupPath, 'backup.json'));\n\n    for (const file of backup.files) {\n      const targetPath = path.join(this.options.projectPath, file.path);\n      await fs.ensureDir(path.dirname(targetPath));\n      await fs.writeFile(targetPath, file.content);\n    }\n\n    logger.success('Rollback completed successfully');\n  }\n\n  async validate(verbose: boolean = false): Promise<boolean> {\n    const validation = await this.validator.validate(this.options.projectPath);\n\n    if (verbose) {\n      this.validator.printValidation(validation);\n    }\n\n    return validation.valid;\n  }\n\n  async listBackups(): Promise<void> {\n    const backupDir = path.join(\n      this.options.projectPath,\n      this.options.backupDir || '.claude-backup',\n    );\n\n    if (!(await fs.pathExists(backupDir))) {\n      logger.info('No backups found');\n      return;\n    }\n\n    const backups = await fs.readdir(backupDir);\n    if (backups.length === 0) {\n      logger.info('No backups found');\n      return;\n    }\n\n    console.log(chalk.bold('\\n\uD83D\uDCE6 Available Backups'));\n    console.log(chalk.gray('\u2500'.repeat(50)));\n\n    for (const backup of backups.sort().reverse()) {\n      const backupPath = path.join(backupDir, backup);\n      const stats = await fs.stat(backupPath);\n      const manifest = await fs.readJson(path.join(backupPath, 'backup.json')).catch(() => null);\n\n      console.log(`\\n${chalk.bold(backup)}`);\n      console.log(`  Created: ${stats.mtime.toLocaleString()}`);\n      console.log(`  Size: ${(stats.size / 1024).toFixed(2)} KB`);\n\n      if (manifest) {\n        console.log(`  Version: ${manifest.version}`);\n        console.log(`  Strategy: ${manifest.metadata.strategy}`);\n        console.log(`  Files: ${manifest.files.length}`);\n      }\n    }\n\n    console.log(chalk.gray('\\n' + '\u2500'.repeat(50)));\n  }\n\n  private async confirmMigration(analysis: any): Promise<boolean> {\n    const questions = [\n      {\n        type: 'confirm',\n        name: 'proceed',\n        message: `Proceed with ${this.options.strategy} migration?`,\n        default: true,\n      },\n    ];\n\n    if (analysis.customCommands.length > 0 && !this.options.preserveCustom) {\n      questions.unshift({\n        type: 'confirm',\n        name: 'preserveCustom',\n        message: `Found ${analysis.customCommands.length} custom commands. Preserve them?`,\n        default: true,\n      });\n    }\n\n    const answers = await inquirer.prompt(questions);\n\n    if (answers.preserveCustom) {\n      this.options.preserveCustom = true;\n    }\n\n    return answers.proceed;\n  }\n\n  private loadManifest(): MigrationManifest {\n    // This would normally load from a manifest file\n    return {\n      version: '1.0.0',\n      files: {\n        commands: [\n          { source: 'sparc.md', target: 'sparc.md' },\n          { source: 'sparc/architect.md', target: 'sparc-architect.md' },\n          { source: 'sparc/code.md', target: 'sparc-code.md' },\n          { source: 'sparc/tdd.md', target: 'sparc-tdd.md' },\n          { source: 'claude-flow-help.md', target: 'claude-flow-help.md' },\n          { source: 'claude-flow-memory.md', target: 'claude-flow-memory.md' },\n          { source: 'claude-flow-swarm.md', target: 'claude-flow-swarm.md' },\n        ],\n        configurations: {},\n        templates: {},\n      },\n    };\n  }\n\n  private async getMergedClaudeMd(existingContent: string): Promise<string> {\n    // Merge logic for CLAUDE.md\n    const templatePath = path.join(__dirname, '../../CLAUDE.md');\n    const templateContent = await fs.readFile(templatePath, 'utf-8');\n\n    // Simple merge: append custom content to template\n    if (!existingContent.includes('SPARC Development Environment')) {\n      return templateContent + '\\n\\n## Previous Configuration\\n\\n' + existingContent;\n    }\n\n    return templateContent;\n  }\n\n  private async getMergedRoomodes(existing: any): Promise<any> {\n    const templatePath = path.join(__dirname, '../../.roomodes');\n    const template = await fs.readJson(templatePath);\n\n    // Merge custom modes with template\n    const merged = { ...template };\n\n    for (const [mode, config] of Object.entries(existing)) {\n      if (!merged[mode]) {\n        merged[mode] = config;\n      }\n    }\n\n    return merged;\n  }\n\n  private printSummary(result: MigrationResult): void {\n    console.log(chalk.bold('\\n\uD83D\uDCCB Migration Summary'));\n    console.log(chalk.gray('\u2500'.repeat(50)));\n\n    console.log(\n      `\\n${chalk.bold('Status:')} ${result.success ? chalk.green('Success') : chalk.red('Failed')}`,\n    );\n\n    if (result.filesCreated.length > 0) {\n      console.log(`\\n${chalk.bold('Files Created:')} ${chalk.green(result.filesCreated.length)}`);\n      if (result.filesCreated.length <= 10) {\n        result.filesCreated.forEach((file) => console.log(`  \u2022 ${file}`));\n      }\n    }\n\n    if (result.filesModified.length > 0) {\n      console.log(\n        `\\n${chalk.bold('Files Modified:')} ${chalk.yellow(result.filesModified.length)}`,\n      );\n      result.filesModified.forEach((file) => console.log(`  \u2022 ${file}`));\n    }\n\n    if (result.filesBackedUp.length > 0) {\n      console.log(`\\n${chalk.bold('Files Backed Up:')} ${chalk.blue(result.filesBackedUp.length)}`);\n    }\n\n    if (result.warnings.length > 0) {\n      console.log(`\\n${chalk.bold('Warnings:')}`);\n      result.warnings.forEach((warning) => console.log(`  \u26A0\uFE0F  ${warning}`));\n    }\n\n    if (result.errors.length > 0) {\n      console.log(`\\n${chalk.bold('Errors:')}`);\n      result.errors.forEach((error) => console.log(`  \u274C ${error.error}`));\n    }\n\n    if (result.rollbackPath) {\n      console.log(`\\n${chalk.bold('Rollback Available:')} ${result.rollbackPath}`);\n      console.log(\n        chalk.gray(`  Run \"claude-flow migrate rollback -t ${result.rollbackPath}\" to revert`),\n      );\n    }\n\n    console.log(chalk.gray('\\n' + '\u2500'.repeat(50)));\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
