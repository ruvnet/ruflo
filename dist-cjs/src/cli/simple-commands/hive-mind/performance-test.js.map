{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/performance-test.js"],"sourcesContent":["/**\r\n * Performance Test Suite for Hive Mind Optimizations\r\n * Tests the performance improvements implemented\r\n */\r\n\r\nimport { HiveMindCore } from './core.js';\r\nimport { PerformanceOptimizer } from './performance-optimizer.js';\r\nimport { performance } from 'perf_hooks';\r\n\r\n/**\r\n * Performance test runner\r\n */\r\nexport class PerformanceTest {\r\n  constructor() {\r\n    this.results = [];\r\n    this.baseline = null;\r\n  }\r\n\r\n  /**\r\n   * Run complete performance test suite\r\n   */\r\n  async runTestSuite() {\r\n    console.log('ðŸ”¬ Starting Hive Mind Performance Test Suite...\\n');\r\n\r\n    const tests = [\r\n      this.testBatchAgentSpawning,\r\n      this.testAsyncOperationQueue,\r\n      this.testMemoryOperations,\r\n      this.testConcurrentTaskExecution,\r\n      this.testPerformanceOptimizer,\r\n    ];\r\n\r\n    for (const test of tests) {\r\n      try {\r\n        await test.call(this);\r\n      } catch (error) {\r\n        console.error(`Test failed: ${test.name}`, error);\r\n      }\r\n    }\r\n\r\n    this.generateReport();\r\n  }\r\n\r\n  /**\r\n   * Test batch agent spawning performance\r\n   */\r\n  async testBatchAgentSpawning() {\r\n    console.log('ðŸš€ Testing Batch Agent Spawning...');\r\n\r\n    const hiveMind = new HiveMindCore({\r\n      name: 'test-batch-spawn',\r\n      maxWorkers: 10,\r\n    });\r\n\r\n    await hiveMind.initialize();\r\n\r\n    // Test batch spawning vs sequential spawning\r\n    const agentTypes = ['coder', 'tester', 'analyst', 'researcher', 'architect', 'optimizer'];\r\n\r\n    // Batch spawning test\r\n    const batchStart = performance.now();\r\n    const batchResults = await hiveMind.spawnWorkers(agentTypes);\r\n    const batchTime = performance.now() - batchStart;\r\n\r\n    // Simulate sequential spawning for comparison\r\n    const sequentialStart = performance.now();\r\n    for (let i = 0; i < agentTypes.length; i++) {\r\n      // Simulate individual spawning time\r\n      await new Promise((resolve) => setTimeout(resolve, 200));\r\n    }\r\n    const sequentialTime = performance.now() - sequentialStart;\r\n\r\n    const improvement = (((sequentialTime - batchTime) / sequentialTime) * 100).toFixed(2);\r\n\r\n    this.results.push({\r\n      test: 'Batch Agent Spawning',\r\n      batchTime: batchTime.toFixed(2) + 'ms',\r\n      sequentialTime: sequentialTime.toFixed(2) + 'ms',\r\n      improvement: improvement + '%',\r\n      agentsSpawned: batchResults.length,\r\n      status: improvement > 50 ? 'PASS' : 'WARN',\r\n    });\r\n\r\n    console.log(\r\n      `  âœ… Batch: ${batchTime.toFixed(2)}ms | Sequential: ${sequentialTime.toFixed(2)}ms | Improvement: ${improvement}%\\n`,\r\n    );\r\n\r\n    await hiveMind.shutdown();\r\n  }\r\n\r\n  /**\r\n   * Test async operation queue performance\r\n   */\r\n  async testAsyncOperationQueue() {\r\n    console.log('âš¡ Testing Async Operation Queue...');\r\n\r\n    const optimizer = new PerformanceOptimizer({\r\n      asyncQueueConcurrency: 5,\r\n    });\r\n\r\n    const operations = [];\r\n    for (let i = 0; i < 20; i++) {\r\n      operations.push(async () => {\r\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 100 + 50));\r\n        return `Operation ${i} completed`;\r\n      });\r\n    }\r\n\r\n    // Test parallel execution\r\n    const parallelStart = performance.now();\r\n    const parallelResults = await Promise.all(\r\n      operations.map((op) => optimizer.optimizeAsyncOperation(op)),\r\n    );\r\n    const parallelTime = performance.now() - parallelStart;\r\n\r\n    // Test sequential execution for comparison\r\n    const sequentialStart = performance.now();\r\n    const sequentialResults = [];\r\n    for (const op of operations) {\r\n      sequentialResults.push(await op());\r\n    }\r\n    const sequentialTime = performance.now() - sequentialStart;\r\n\r\n    const improvement = (((sequentialTime - parallelTime) / sequentialTime) * 100).toFixed(2);\r\n\r\n    this.results.push({\r\n      test: 'Async Operation Queue',\r\n      parallelTime: parallelTime.toFixed(2) + 'ms',\r\n      sequentialTime: sequentialTime.toFixed(2) + 'ms',\r\n      improvement: improvement + '%',\r\n      operationsProcessed: operations.length,\r\n      status: improvement > 60 ? 'PASS' : 'WARN',\r\n    });\r\n\r\n    console.log(\r\n      `  âœ… Parallel: ${parallelTime.toFixed(2)}ms | Sequential: ${sequentialTime.toFixed(2)}ms | Improvement: ${improvement}%\\n`,\r\n    );\r\n\r\n    await optimizer.close();\r\n  }\r\n\r\n  /**\r\n   * Test memory operations with connection pooling\r\n   */\r\n  async testMemoryOperations() {\r\n    console.log('ðŸ’¾ Testing Memory Operations...');\r\n\r\n    // This would test the CollectiveMemory optimizations\r\n    // For now, we'll simulate the test\r\n    const pooledStart = performance.now();\r\n\r\n    // Simulate 100 memory operations with connection pooling\r\n    const operations = Array(100)\r\n      .fill(null)\r\n      .map(async (_, i) => {\r\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 10));\r\n        return { key: `test-${i}`, value: `data-${i}` };\r\n      });\r\n\r\n    await Promise.all(operations);\r\n    const pooledTime = performance.now() - pooledStart;\r\n\r\n    // Simulate without pooling\r\n    const serialStart = performance.now();\r\n    for (let i = 0; i < 100; i++) {\r\n      await new Promise((resolve) => setTimeout(resolve, Math.random() * 15 + 5));\r\n    }\r\n    const serialTime = performance.now() - serialStart;\r\n\r\n    const improvement = (((serialTime - pooledTime) / serialTime) * 100).toFixed(2);\r\n\r\n    this.results.push({\r\n      test: 'Memory Operations',\r\n      pooledTime: pooledTime.toFixed(2) + 'ms',\r\n      serialTime: serialTime.toFixed(2) + 'ms',\r\n      improvement: improvement + '%',\r\n      operationsProcessed: 100,\r\n      status: improvement > 25 ? 'PASS' : 'WARN',\r\n    });\r\n\r\n    console.log(\r\n      `  âœ… Pooled: ${pooledTime.toFixed(2)}ms | Serial: ${serialTime.toFixed(2)}ms | Improvement: ${improvement}%\\n`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Test concurrent task execution\r\n   */\r\n  async testConcurrentTaskExecution() {\r\n    console.log('ðŸ”„ Testing Concurrent Task Execution...');\r\n\r\n    const hiveMind = new HiveMindCore({\r\n      name: 'test-concurrent-tasks',\r\n      maxWorkers: 8,\r\n    });\r\n\r\n    await hiveMind.initialize();\r\n\r\n    // Spawn workers\r\n    await hiveMind.spawnWorkers(['coder', 'tester', 'analyst', 'researcher']);\r\n\r\n    const tasks = [\r\n      'Implement user authentication',\r\n      'Write unit tests',\r\n      'Analyze performance metrics',\r\n      'Research best practices',\r\n      'Optimize database queries',\r\n      'Document API endpoints',\r\n    ];\r\n\r\n    // Test concurrent task creation and execution\r\n    const concurrentStart = performance.now();\r\n    const taskPromises = tasks.map((description) =>\r\n      hiveMind.createTask(description, Math.floor(Math.random() * 10) + 1),\r\n    );\r\n\r\n    await Promise.all(taskPromises);\r\n\r\n    // Wait for tasks to complete (simulated)\r\n    await new Promise((resolve) => setTimeout(resolve, 2000));\r\n\r\n    const concurrentTime = performance.now() - concurrentStart;\r\n\r\n    // Get final status\r\n    const status = hiveMind.getStatus();\r\n\r\n    this.results.push({\r\n      test: 'Concurrent Task Execution',\r\n      executionTime: concurrentTime.toFixed(2) + 'ms',\r\n      tasksCreated: status.tasks.total,\r\n      workersActive: status.workers.length,\r\n      throughput: (status.tasks.total / (concurrentTime / 1000)).toFixed(2) + ' tasks/sec',\r\n      status: status.tasks.total === tasks.length ? 'PASS' : 'WARN',\r\n    });\r\n\r\n    console.log(\r\n      `  âœ… Tasks: ${status.tasks.total} | Workers: ${status.workers.length} | Time: ${concurrentTime.toFixed(2)}ms\\n`,\r\n    );\r\n\r\n    await hiveMind.shutdown();\r\n  }\r\n\r\n  /**\r\n   * Test performance optimizer functionality\r\n   */\r\n  async testPerformanceOptimizer() {\r\n    console.log('ðŸ“Š Testing Performance Optimizer...');\r\n\r\n    const optimizer = new PerformanceOptimizer({\r\n      enableAsyncQueue: true,\r\n      enableBatchProcessing: true,\r\n      enableAutoTuning: true,\r\n    });\r\n\r\n    // Test cache optimization\r\n    const cacheKey = 'test-cache-key';\r\n    let cacheHits = 0;\r\n    let cacheMisses = 0;\r\n\r\n    // First call should be a miss\r\n    const cacheStart = performance.now();\r\n    await optimizer.optimizeWithCache(cacheKey, async () => {\r\n      cacheMisses++;\r\n      await new Promise((resolve) => setTimeout(resolve, 100));\r\n      return 'cached-value';\r\n    });\r\n\r\n    // Subsequent calls should be hits\r\n    for (let i = 0; i < 5; i++) {\r\n      await optimizer.optimizeWithCache(cacheKey, async () => {\r\n        cacheMisses++;\r\n        await new Promise((resolve) => setTimeout(resolve, 100));\r\n        return 'cached-value';\r\n      });\r\n      cacheHits++;\r\n    }\r\n    const cacheTime = performance.now() - cacheStart;\r\n\r\n    // Test batch processing\r\n    const batchStart = performance.now();\r\n    const batchPromises = [];\r\n\r\n    for (let i = 0; i < 10; i++) {\r\n      batchPromises.push(\r\n        optimizer.optimizeBatchOperation(\r\n          'test-batch',\r\n          { id: i, data: `test-${i}` },\r\n          async (items) => {\r\n            await new Promise((resolve) => setTimeout(resolve, 50));\r\n            return items.map((item) => ({ processed: item.id }));\r\n          },\r\n        ),\r\n      );\r\n    }\r\n\r\n    await Promise.all(batchPromises);\r\n    const batchTime = performance.now() - batchStart;\r\n\r\n    const stats = optimizer.getPerformanceStats();\r\n\r\n    this.results.push({\r\n      test: 'Performance Optimizer',\r\n      cacheTime: cacheTime.toFixed(2) + 'ms',\r\n      cacheHitRate: ((cacheHits / (cacheHits + cacheMisses)) * 100).toFixed(2) + '%',\r\n      batchTime: batchTime.toFixed(2) + 'ms',\r\n      batchesProcessed: stats.batchProcessor.batchesProcessed,\r\n      status: stats.cache.hitRate > 50 ? 'PASS' : 'WARN',\r\n    });\r\n\r\n    console.log(\r\n      `  âœ… Cache Hit Rate: ${((cacheHits / (cacheHits + cacheMisses)) * 100).toFixed(2)}% | Batches: ${stats.batchProcessor.batchesProcessed}\\n`,\r\n    );\r\n\r\n    await optimizer.close();\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive performance report\r\n   */\r\n  generateReport() {\r\n    console.log('ðŸ“Š Performance Test Results');\r\n    console.log('='.repeat(80));\r\n\r\n    let totalPassed = 0;\r\n    let totalTests = this.results.length;\r\n\r\n    this.results.forEach((result, index) => {\r\n      console.log(`\\n${index + 1}. ${result.test}`);\r\n      console.log('-'.repeat(40));\r\n\r\n      Object.entries(result).forEach(([key, value]) => {\r\n        if (key !== 'test' && key !== 'status') {\r\n          console.log(`   ${key.charAt(0).toUpperCase() + key.slice(1)}: ${value}`);\r\n        }\r\n      });\r\n\r\n      const statusIcon = result.status === 'PASS' ? 'âœ…' : 'âš ï¸';\r\n      console.log(`   Status: ${statusIcon} ${result.status}`);\r\n\r\n      if (result.status === 'PASS') totalPassed++;\r\n    });\r\n\r\n    console.log('\\n' + '='.repeat(80));\r\n    console.log(`ðŸ“ˆ Overall Results: ${totalPassed}/${totalTests} tests passed`);\r\n\r\n    if (totalPassed === totalTests) {\r\n      console.log('ðŸŽ‰ All performance optimizations are working correctly!');\r\n    } else {\r\n      console.log('âš ï¸  Some optimizations may need attention.');\r\n    }\r\n\r\n    // Performance summary\r\n    const improvements = this.results\r\n      .filter((r) => r.improvement)\r\n      .map((r) => parseFloat(r.improvement));\r\n\r\n    if (improvements.length > 0) {\r\n      const avgImprovement = improvements.reduce((a, b) => a + b, 0) / improvements.length;\r\n      console.log(`ðŸš€ Average Performance Improvement: ${avgImprovement.toFixed(2)}%`);\r\n    }\r\n\r\n    console.log('\\nðŸ”§ Performance optimization implementation complete!');\r\n  }\r\n}\r\n\r\n// Export for use in tests\r\nexport default PerformanceTest;\r\n\r\n// Run tests if executed directly\r\nif (import.meta.url === `file://${process.argv[1]}`) {\r\n  const testRunner = new PerformanceTest();\r\n  testRunner.runTestSuite().catch(console.error);\r\n}\r\n"],"names":["HiveMindCore","PerformanceOptimizer","performance","PerformanceTest","results","baseline","runTestSuite","console","log","tests","testBatchAgentSpawning","testAsyncOperationQueue","testMemoryOperations","testConcurrentTaskExecution","testPerformanceOptimizer","test","call","error","name","generateReport","hiveMind","maxWorkers","initialize","agentTypes","batchStart","now","batchResults","spawnWorkers","batchTime","sequentialStart","i","length","Promise","resolve","setTimeout","sequentialTime","improvement","toFixed","push","agentsSpawned","status","shutdown","optimizer","asyncQueueConcurrency","operations","Math","random","parallelStart","parallelResults","all","map","op","optimizeAsyncOperation","parallelTime","sequentialResults","operationsProcessed","close","pooledStart","Array","fill","_","key","value","pooledTime","serialStart","serialTime","tasks","concurrentStart","taskPromises","description","createTask","floor","concurrentTime","getStatus","executionTime","tasksCreated","total","workersActive","workers","throughput","enableAsyncQueue","enableBatchProcessing","enableAutoTuning","cacheKey","cacheHits","cacheMisses","cacheStart","optimizeWithCache","cacheTime","batchPromises","optimizeBatchOperation","id","data","items","item","processed","stats","getPerformanceStats","cacheHitRate","batchesProcessed","batchProcessor","cache","hitRate","repeat","totalPassed","totalTests","forEach","result","index","Object","entries","charAt","toUpperCase","slice","statusIcon","improvements","filter","r","parseFloat","avgImprovement","reduce","a","b","url","process","argv","testRunner","catch"],"mappings":"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"}