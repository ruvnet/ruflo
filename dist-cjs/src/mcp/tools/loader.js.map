{"version":3,"sources":["../../../../src/mcp/tools/loader.ts"],"sourcesContent":["/**\r\n * Dynamic Tool Loader for Progressive Disclosure\r\n *\r\n * Implements filesystem-based tool discovery pattern recommended by Anthropic:\r\n * - Scans tool directories for metadata only (lightweight)\r\n * - Loads full tool definitions on-demand (lazy loading)\r\n * - Supports tiered detail levels for search\r\n * - Achieves 98.7% token reduction (150k â†’ 2k tokens)\r\n */\r\n\r\nimport { promises as fs } from 'fs';\r\nimport { join, dirname, extname, resolve } from 'path';\r\nimport { fileURLToPath } from 'url';\r\nimport type { MCPTool } from '../types.js';\r\nimport type { ILogger } from '../../interfaces/logger.js';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\n\r\n/**\r\n * Lightweight tool metadata for discovery\r\n * Loaded without executing full tool definition\r\n */\r\nexport interface ToolMetadata {\r\n  name: string;\r\n  description: string;\r\n  category: string;\r\n  detailLevel: 'basic' | 'standard' | 'full';\r\n  filePath: string;\r\n  tags?: string[];\r\n}\r\n\r\n/**\r\n * Tool search query interface\r\n */\r\nexport interface ToolSearchQuery {\r\n  category?: string;\r\n  tags?: string[];\r\n  detailLevel?: 'basic' | 'standard' | 'full';\r\n  namePattern?: string;\r\n}\r\n\r\n/**\r\n * Dynamic tool loader with progressive disclosure\r\n */\r\nexport class DynamicToolLoader {\r\n  private metadataCache: Map<string, ToolMetadata> = new Map();\r\n  private toolCache: Map<string, MCPTool> = new Map();\r\n  private scanComplete = false;\r\n\r\n  constructor(\r\n    private toolsDir: string = join(__dirname, '.'),\r\n    private logger: ILogger\r\n  ) {}\r\n\r\n  /**\r\n   * Scan tool directory and build metadata index\r\n   * Only reads metadata exports, not full tool definitions\r\n   * This is the key to achieving 98.7% token reduction\r\n   */\r\n  async scanTools(): Promise<Map<string, ToolMetadata>> {\r\n    if (this.scanComplete) {\r\n      return this.metadataCache;\r\n    }\r\n\r\n    this.logger.info('Scanning tools directory for metadata', {\r\n      toolsDir: this.toolsDir,\r\n    });\r\n\r\n    const startTime = Date.now();\r\n    let scannedFiles = 0;\r\n    let loadedMetadata = 0;\r\n\r\n    try {\r\n      // Resolve tools directory to absolute path\r\n      const resolvedToolsDir = resolve(this.toolsDir);\r\n\r\n      // Get all subdirectories (categories)\r\n      const entries = await fs.readdir(resolvedToolsDir, { withFileTypes: true });\r\n      const categories = entries.filter(e => e.isDirectory() && !e.name.startsWith('_'));\r\n\r\n      // Scan each category\r\n      for (const categoryEntry of categories) {\r\n        const category = categoryEntry.name;\r\n        const categoryPath = resolve(resolvedToolsDir, category);\r\n\r\n        // Prevent path traversal - ensure category is within tools directory\r\n        if (!categoryPath.startsWith(resolvedToolsDir)) {\r\n          this.logger.warn('Skipping category outside tools directory', {\r\n            category,\r\n            categoryPath,\r\n            toolsDir: resolvedToolsDir,\r\n          });\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          // Get tool files in category\r\n          const toolFiles = await fs.readdir(categoryPath);\r\n          const validToolFiles = toolFiles.filter(f => {\r\n            const ext = extname(f);\r\n            return (ext === '.ts' || ext === '.js') && !f.startsWith('_');\r\n          });\r\n\r\n          // Load metadata from each file\r\n          for (const toolFile of validToolFiles) {\r\n            scannedFiles++;\r\n            const toolPath = resolve(categoryPath, toolFile);\r\n\r\n            // Prevent path traversal - ensure tool file is within category\r\n            if (!toolPath.startsWith(categoryPath)) {\r\n              this.logger.warn('Skipping tool file outside category directory', {\r\n                toolFile,\r\n                toolPath,\r\n                categoryPath,\r\n              });\r\n              continue;\r\n            }\r\n\r\n            try {\r\n              // Dynamic import to load metadata only\r\n              const module = await import(toolPath);\r\n\r\n              if (module.toolMetadata) {\r\n                const metadata: ToolMetadata = {\r\n                  ...module.toolMetadata,\r\n                  category, // Override with directory category\r\n                  filePath: toolPath,\r\n                };\r\n\r\n                this.metadataCache.set(metadata.name, metadata);\r\n                loadedMetadata++;\r\n\r\n                this.logger.debug('Loaded tool metadata', {\r\n                  name: metadata.name,\r\n                  category: metadata.category,\r\n                  filePath: toolPath,\r\n                });\r\n              } else {\r\n                this.logger.warn('Tool file missing toolMetadata export', {\r\n                  filePath: toolPath,\r\n                });\r\n              }\r\n            } catch (error) {\r\n              this.logger.error('Failed to load tool metadata', {\r\n                filePath: toolPath,\r\n                error: error instanceof Error ? error.message : String(error),\r\n              });\r\n            }\r\n          }\r\n        } catch (error) {\r\n          this.logger.error('Failed to scan category directory', {\r\n            category,\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n      }\r\n\r\n      const scanTime = Date.now() - startTime;\r\n      this.scanComplete = true;\r\n\r\n      this.logger.info('Tool scan complete', {\r\n        scannedFiles,\r\n        loadedMetadata,\r\n        totalTools: this.metadataCache.size,\r\n        scanTimeMs: scanTime,\r\n      });\r\n\r\n      return this.metadataCache;\r\n    } catch (error) {\r\n      this.logger.error('Failed to scan tools directory', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Lazy load a specific tool by name\r\n   * Only loads when actually needed (on invocation)\r\n   */\r\n  async loadTool(toolName: string, logger: ILogger): Promise<MCPTool | null> {\r\n    // Check cache first\r\n    if (this.toolCache.has(toolName)) {\r\n      this.logger.debug('Tool loaded from cache', { toolName });\r\n      return this.toolCache.get(toolName)!;\r\n    }\r\n\r\n    // Get metadata\r\n    const metadata = this.metadataCache.get(toolName);\r\n    if (!metadata) {\r\n      this.logger.warn('Tool not found in metadata cache', { toolName });\r\n      return null;\r\n    }\r\n\r\n    // Load full tool definition\r\n    try {\r\n      this.logger.debug('Loading full tool definition', {\r\n        toolName,\r\n        filePath: metadata.filePath,\r\n      });\r\n\r\n      const module = await import(metadata.filePath);\r\n\r\n      // Find tool creator function (convention: createXxxTool)\r\n      const creatorFn = Object.values(module).find(\r\n        (exp: any) => typeof exp === 'function' && exp.name.startsWith('create')\r\n      ) as ((logger: ILogger) => MCPTool) | undefined;\r\n\r\n      if (!creatorFn) {\r\n        throw new Error(\r\n          `No tool creator function found in ${metadata.filePath}. ` +\r\n          `Expected function name starting with 'create'.`\r\n        );\r\n      }\r\n\r\n      // Create tool instance\r\n      const tool = creatorFn(logger);\r\n\r\n      // Validate tool name matches metadata\r\n      if (tool.name !== toolName) {\r\n        this.logger.warn('Tool name mismatch', {\r\n          expected: toolName,\r\n          actual: tool.name,\r\n          filePath: metadata.filePath,\r\n        });\r\n      }\r\n\r\n      // Cache for future use\r\n      this.toolCache.set(toolName, tool);\r\n\r\n      this.logger.info('Tool loaded successfully', {\r\n        toolName,\r\n        category: metadata.category,\r\n      });\r\n\r\n      return tool;\r\n    } catch (error) {\r\n      this.logger.error('Failed to load tool', {\r\n        toolName,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get tool metadata without loading full definition\r\n   * Used for tool discovery with minimal token usage\r\n   */\r\n  getToolMetadata(toolName: string): ToolMetadata | undefined {\r\n    return this.metadataCache.get(toolName);\r\n  }\r\n\r\n  /**\r\n   * Search tools by query\r\n   * Returns only metadata for matching tools (lightweight)\r\n   */\r\n  searchTools(query: ToolSearchQuery): ToolMetadata[] {\r\n    const results: ToolMetadata[] = [];\r\n\r\n    for (const metadata of this.metadataCache.values()) {\r\n      // Filter by category\r\n      if (query.category && metadata.category !== query.category) {\r\n        continue;\r\n      }\r\n\r\n      // Filter by detail level\r\n      if (query.detailLevel && metadata.detailLevel !== query.detailLevel) {\r\n        continue;\r\n      }\r\n\r\n      // Filter by tags\r\n      if (query.tags && query.tags.length > 0) {\r\n        const toolTags = metadata.tags || [];\r\n        const hasAllTags = query.tags.every(tag => toolTags.includes(tag));\r\n        if (!hasAllTags) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Filter by name pattern\r\n      if (query.namePattern) {\r\n        const pattern = query.namePattern.toLowerCase();\r\n        if (!metadata.name.toLowerCase().includes(pattern) &&\r\n            !metadata.description.toLowerCase().includes(pattern)) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      results.push(metadata);\r\n    }\r\n\r\n    // Sort by name\r\n    results.sort((a, b) => a.name.localeCompare(b.name));\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Get all tool names (minimal metadata)\r\n   * Used for quick tool listing\r\n   */\r\n  getAllToolNames(): string[] {\r\n    return Array.from(this.metadataCache.keys()).sort();\r\n  }\r\n\r\n  /**\r\n   * Get tools grouped by category\r\n   */\r\n  getToolsByCategory(): Map<string, ToolMetadata[]> {\r\n    const byCategory = new Map<string, ToolMetadata[]>();\r\n\r\n    for (const metadata of this.metadataCache.values()) {\r\n      const category = metadata.category;\r\n      if (!byCategory.has(category)) {\r\n        byCategory.set(category, []);\r\n      }\r\n      byCategory.get(category)!.push(metadata);\r\n    }\r\n\r\n    return byCategory;\r\n  }\r\n\r\n  /**\r\n   * Get statistics about loaded tools\r\n   */\r\n  getStats() {\r\n    const byCategory = this.getToolsByCategory();\r\n\r\n    return {\r\n      totalTools: this.metadataCache.size,\r\n      cachedTools: this.toolCache.size,\r\n      categories: Array.from(byCategory.keys()).sort(),\r\n      toolsByCategory: Object.fromEntries(\r\n        Array.from(byCategory.entries()).map(([cat, tools]) => [cat, tools.length])\r\n      ),\r\n      scanComplete: this.scanComplete,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear tool cache (useful for hot reloading during development)\r\n   */\r\n  clearCache(): void {\r\n    this.toolCache.clear();\r\n    this.logger.info('Tool cache cleared', {\r\n      previouslyCached: this.toolCache.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reload metadata (useful for hot reloading during development)\r\n   */\r\n  async reload(): Promise<void> {\r\n    this.metadataCache.clear();\r\n    this.toolCache.clear();\r\n    this.scanComplete = false;\r\n    await this.scanTools();\r\n    this.logger.info('Tool loader reloaded');\r\n  }\r\n}\r\n"],"names":["promises","fs","join","dirname","extname","resolve","fileURLToPath","__filename","url","__dirname","DynamicToolLoader","metadataCache","Map","toolCache","scanComplete","toolsDir","logger","scanTools","info","startTime","Date","now","scannedFiles","loadedMetadata","resolvedToolsDir","entries","readdir","withFileTypes","categories","filter","e","isDirectory","name","startsWith","categoryEntry","category","categoryPath","warn","toolFiles","validToolFiles","f","ext","toolFile","toolPath","module","toolMetadata","metadata","filePath","set","debug","error","Error","message","String","scanTime","totalTools","size","scanTimeMs","loadTool","toolName","has","get","creatorFn","Object","values","find","exp","tool","expected","actual","getToolMetadata","searchTools","query","results","detailLevel","tags","length","toolTags","hasAllTags","every","tag","includes","namePattern","pattern","toLowerCase","description","push","sort","a","b","localeCompare","getAllToolNames","Array","from","keys","getToolsByCategory","byCategory","getStats","cachedTools","toolsByCategory","fromEntries","map","cat","tools","clearCache","clear","previouslyCached","reload"],"mappings":"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"}