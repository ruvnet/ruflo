{"version":3,"sources":["../../../../src/cli/simple-commands/verification-training-integration.js"],"sourcesContent":["/**\r\n * Verification-Training Integration Module\r\n * Connects verification results to the neural training system for continuous improvement\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { execSync } from 'child_process';\r\n\r\n/**\r\n * Integration between Verification and Training Systems\r\n * Feeds verification results into training to improve agent performance\r\n */\r\nexport class VerificationTrainingIntegration {\r\n  constructor() {\r\n    this.trainingDataPath = '.claude-flow/training/verification-data.jsonl';\r\n    this.modelPath = '.claude-flow/models/verification-model.json';\r\n    this.metricsPath = '.claude-flow/metrics/agent-performance.json';\r\n    this.learningRate = 0.1;\r\n    this.initialized = false;\r\n  }\r\n\r\n  /**\r\n   * Initialize the integration\r\n   */\r\n  async initialize() {\r\n    // Ensure directories exist\r\n    const dirs = [\r\n      '.claude-flow/training',\r\n      '.claude-flow/models',\r\n      '.claude-flow/metrics'\r\n    ];\r\n    \r\n    for (const dir of dirs) {\r\n      await fs.mkdir(dir, { recursive: true });\r\n    }\r\n\r\n    // Load or create model\r\n    await this.loadModel();\r\n    this.initialized = true;\r\n    \r\n    console.log('âœ… Verification-Training integration initialized');\r\n  }\r\n\r\n  /**\r\n   * Feed verification results to training system\r\n   */\r\n  async feedVerificationToTraining(verification) {\r\n    if (!this.initialized) await this.initialize();\r\n\r\n    // Extract training features from verification\r\n    const trainingData = {\r\n      input: {\r\n        taskId: verification.taskId,\r\n        agentType: verification.agentType,\r\n        timestamp: verification.timestamp,\r\n        mode: verification.mode || 'moderate',\r\n        checksPerformed: verification.results?.map(r => r.name) || []\r\n      },\r\n      output: {\r\n        score: verification.score,\r\n        passed: verification.passed,\r\n        threshold: verification.threshold\r\n      },\r\n      metadata: {\r\n        sessionId: process.env.SESSION_ID || 'default',\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    };\r\n\r\n    // Append to training data\r\n    await this.appendTrainingData(trainingData);\r\n\r\n    // Update agent-specific model\r\n    await this.updateAgentModel(verification.agentType, verification);\r\n\r\n    // Trigger incremental learning\r\n    await this.incrementalLearn(trainingData);\r\n\r\n    // Update performance metrics\r\n    await this.updatePerformanceMetrics(verification);\r\n\r\n    return trainingData;\r\n  }\r\n\r\n  /**\r\n   * Incremental learning from new verification data\r\n   */\r\n  async incrementalLearn(trainingData) {\r\n    const model = await this.loadModel();\r\n    \r\n    // Update agent reliability scores\r\n    const agentType = trainingData.input.agentType;\r\n    if (!model.agentReliability) model.agentReliability = {};\r\n    \r\n    const currentReliability = model.agentReliability[agentType] || 0.5;\r\n    const newScore = trainingData.output.score;\r\n    \r\n    // Exponential moving average for reliability\r\n    model.agentReliability[agentType] = \r\n      currentReliability * (1 - this.learningRate) + newScore * this.learningRate;\r\n\r\n    // Update verification patterns\r\n    if (!model.patterns) model.patterns = {};\r\n    const patternKey = `${agentType}_${trainingData.output.passed ? 'success' : 'failure'}`;\r\n    \r\n    if (!model.patterns[patternKey]) {\r\n      model.patterns[patternKey] = {\r\n        count: 0,\r\n        avgScore: 0,\r\n        checks: {}\r\n      };\r\n    }\r\n\r\n    const pattern = model.patterns[patternKey];\r\n    pattern.count++;\r\n    pattern.avgScore = (pattern.avgScore * (pattern.count - 1) + newScore) / pattern.count;\r\n\r\n    // Track which checks lead to success/failure\r\n    for (const check of trainingData.input.checksPerformed) {\r\n      if (!pattern.checks[check]) {\r\n        pattern.checks[check] = { success: 0, failure: 0 };\r\n      }\r\n      pattern.checks[check][trainingData.output.passed ? 'success' : 'failure']++;\r\n    }\r\n\r\n    // Save updated model\r\n    await this.saveModel(model);\r\n\r\n    // Log learning progress\r\n    console.log(`ðŸ“Š Learning update for ${agentType}: reliability ${model.agentReliability[agentType].toFixed(3)}`);\r\n  }\r\n\r\n  /**\r\n   * Predict verification outcome based on historical data\r\n   */\r\n  async predictVerificationOutcome(taskType, agentType) {\r\n    const model = await this.loadModel();\r\n    \r\n    // Get agent reliability\r\n    const reliability = model.agentReliability?.[agentType] || 0.5;\r\n    \r\n    // Get pattern statistics\r\n    const successPattern = model.patterns?.[`${agentType}_success`];\r\n    const failurePattern = model.patterns?.[`${agentType}_failure`];\r\n    \r\n    if (!successPattern && !failurePattern) {\r\n      return {\r\n        predictedScore: reliability,\r\n        confidence: 0.1,\r\n        recommendation: 'insufficient_data'\r\n      };\r\n    }\r\n\r\n    // Calculate prediction\r\n    const totalCount = (successPattern?.count || 0) + (failurePattern?.count || 0);\r\n    const successRate = (successPattern?.count || 0) / totalCount;\r\n    \r\n    const predictedScore = reliability * 0.7 + successRate * 0.3;\r\n    const confidence = Math.min(totalCount / 100, 1.0); // Confidence increases with data\r\n\r\n    // Generate recommendation\r\n    let recommendation = 'proceed';\r\n    if (predictedScore < 0.5) {\r\n      recommendation = 'use_different_agent';\r\n    } else if (predictedScore < 0.75) {\r\n      recommendation = 'add_additional_checks';\r\n    } else if (confidence < 0.3) {\r\n      recommendation = 'low_confidence_proceed_with_caution';\r\n    }\r\n\r\n    return {\r\n      predictedScore,\r\n      confidence,\r\n      recommendation,\r\n      agentReliability: reliability,\r\n      historicalSuccessRate: successRate,\r\n      dataPoints: totalCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get agent recommendations based on task type\r\n   */\r\n  async recommendAgent(taskType) {\r\n    const model = await this.loadModel();\r\n    \r\n    if (!model.agentReliability) {\r\n      return {\r\n        recommended: 'coder', // Default\r\n        reason: 'no_historical_data'\r\n      };\r\n    }\r\n\r\n    // Sort agents by reliability\r\n    const agents = Object.entries(model.agentReliability)\r\n      .sort(([, a], [, b]) => b - a);\r\n\r\n    if (agents.length === 0) {\r\n      return {\r\n        recommended: 'coder',\r\n        reason: 'no_agent_data'\r\n      };\r\n    }\r\n\r\n    const [bestAgent, bestScore] = agents[0];\r\n    \r\n    return {\r\n      recommended: bestAgent,\r\n      reliability: bestScore,\r\n      alternatives: agents.slice(1, 3).map(([agent, score]) => ({\r\n        agent,\r\n        reliability: score\r\n      })),\r\n      reason: `highest_reliability_score`\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update agent-specific model\r\n   */\r\n  async updateAgentModel(agentType, verification) {\r\n    const modelFile = `.claude-flow/models/agent-${agentType}.json`;\r\n    \r\n    let agentModel = {};\r\n    try {\r\n      const data = await fs.readFile(modelFile, 'utf8');\r\n      agentModel = JSON.parse(data);\r\n    } catch {\r\n      agentModel = {\r\n        agentType,\r\n        totalTasks: 0,\r\n        successfulTasks: 0,\r\n        averageScore: 0,\r\n        scoreHistory: [],\r\n        checkPerformance: {}\r\n      };\r\n    }\r\n\r\n    // Update statistics\r\n    agentModel.totalTasks++;\r\n    if (verification.passed) agentModel.successfulTasks++;\r\n    \r\n    // Update average score\r\n    agentModel.averageScore = \r\n      (agentModel.averageScore * (agentModel.totalTasks - 1) + verification.score) / \r\n      agentModel.totalTasks;\r\n\r\n    // Keep last 100 scores for trend analysis\r\n    agentModel.scoreHistory.push({\r\n      score: verification.score,\r\n      timestamp: verification.timestamp,\r\n      passed: verification.passed\r\n    });\r\n    if (agentModel.scoreHistory.length > 100) {\r\n      agentModel.scoreHistory = agentModel.scoreHistory.slice(-100);\r\n    }\r\n\r\n    // Track performance by check type\r\n    if (verification.results) {\r\n      for (const result of verification.results) {\r\n        if (!agentModel.checkPerformance[result.name]) {\r\n          agentModel.checkPerformance[result.name] = {\r\n            total: 0,\r\n            passed: 0,\r\n            avgScore: 0\r\n          };\r\n        }\r\n        \r\n        const checkPerf = agentModel.checkPerformance[result.name];\r\n        checkPerf.total++;\r\n        if (result.passed) checkPerf.passed++;\r\n        checkPerf.avgScore = \r\n          (checkPerf.avgScore * (checkPerf.total - 1) + result.score) / checkPerf.total;\r\n      }\r\n    }\r\n\r\n    // Calculate performance trend (last 10 vs previous 10)\r\n    if (agentModel.scoreHistory.length >= 20) {\r\n      const recent10 = agentModel.scoreHistory.slice(-10);\r\n      const previous10 = agentModel.scoreHistory.slice(-20, -10);\r\n      \r\n      const recentAvg = recent10.reduce((sum, h) => sum + h.score, 0) / 10;\r\n      const previousAvg = previous10.reduce((sum, h) => sum + h.score, 0) / 10;\r\n      \r\n      agentModel.trend = {\r\n        direction: recentAvg > previousAvg ? 'improving' : 'declining',\r\n        change: recentAvg - previousAvg,\r\n        recentAverage: recentAvg,\r\n        previousAverage: previousAvg\r\n      };\r\n    }\r\n\r\n    // Save agent model\r\n    await fs.writeFile(modelFile, JSON.stringify(agentModel, null, 2));\r\n\r\n    // Log if agent is improving or declining\r\n    if (agentModel.trend) {\r\n      const emoji = agentModel.trend.direction === 'improving' ? 'ðŸ“ˆ' : 'ðŸ“‰';\r\n      console.log(`${emoji} Agent ${agentType} is ${agentModel.trend.direction} (${agentModel.trend.change > 0 ? '+' : ''}${agentModel.trend.change.toFixed(3)})`);\r\n    }\r\n\r\n    return agentModel;\r\n  }\r\n\r\n  /**\r\n   * Generate training recommendations\r\n   */\r\n  async generateTrainingRecommendations() {\r\n    const model = await this.loadModel();\r\n    const recommendations = [];\r\n\r\n    // Check agent reliability\r\n    if (model.agentReliability) {\r\n      for (const [agent, reliability] of Object.entries(model.agentReliability)) {\r\n        if (reliability < 0.7) {\r\n          recommendations.push({\r\n            type: 'retrain_agent',\r\n            agent,\r\n            currentReliability: reliability,\r\n            action: `Retrain ${agent} agent - reliability below 70%`\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check patterns\r\n    if (model.patterns) {\r\n      for (const [pattern, data] of Object.entries(model.patterns)) {\r\n        if (pattern.includes('failure') && data.count > 10) {\r\n          const [agentType] = pattern.split('_');\r\n          \r\n          // Find most common failing checks\r\n          const failingChecks = Object.entries(data.checks || {})\r\n            .filter(([, stats]) => stats.failure > stats.success)\r\n            .map(([check]) => check);\r\n\r\n          if (failingChecks.length > 0) {\r\n            recommendations.push({\r\n              type: 'improve_checks',\r\n              agent: agentType,\r\n              checks: failingChecks,\r\n              action: `Focus training on ${failingChecks.join(', ')} for ${agentType}`\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check if we need more data\r\n    const totalDataPoints = Object.values(model.patterns || {})\r\n      .reduce((sum, p) => sum + p.count, 0);\r\n    \r\n    if (totalDataPoints < 50) {\r\n      recommendations.push({\r\n        type: 'collect_more_data',\r\n        currentDataPoints: totalDataPoints,\r\n        action: 'Run more verification cycles to improve training accuracy'\r\n      });\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   */\r\n  async updatePerformanceMetrics(verification) {\r\n    let metrics = {};\r\n    \r\n    try {\r\n      const data = await fs.readFile(this.metricsPath, 'utf8');\r\n      metrics = JSON.parse(data);\r\n    } catch {\r\n      metrics = {\r\n        totalVerifications: 0,\r\n        passedVerifications: 0,\r\n        averageScore: 0,\r\n        byAgent: {},\r\n        byHour: {},\r\n        created: new Date().toISOString()\r\n      };\r\n    }\r\n\r\n    // Update totals\r\n    metrics.totalVerifications++;\r\n    if (verification.passed) metrics.passedVerifications++;\r\n    metrics.averageScore = \r\n      (metrics.averageScore * (metrics.totalVerifications - 1) + verification.score) / \r\n      metrics.totalVerifications;\r\n\r\n    // Update by agent\r\n    if (!metrics.byAgent[verification.agentType]) {\r\n      metrics.byAgent[verification.agentType] = {\r\n        total: 0,\r\n        passed: 0,\r\n        avgScore: 0\r\n      };\r\n    }\r\n    \r\n    const agentMetrics = metrics.byAgent[verification.agentType];\r\n    agentMetrics.total++;\r\n    if (verification.passed) agentMetrics.passed++;\r\n    agentMetrics.avgScore = \r\n      (agentMetrics.avgScore * (agentMetrics.total - 1) + verification.score) / \r\n      agentMetrics.total;\r\n\r\n    // Update by hour (for pattern detection)\r\n    const hour = new Date().getHours();\r\n    if (!metrics.byHour[hour]) {\r\n      metrics.byHour[hour] = {\r\n        total: 0,\r\n        avgScore: 0\r\n      };\r\n    }\r\n    \r\n    metrics.byHour[hour].total++;\r\n    metrics.byHour[hour].avgScore = \r\n      (metrics.byHour[hour].avgScore * (metrics.byHour[hour].total - 1) + verification.score) / \r\n      metrics.byHour[hour].total;\r\n\r\n    metrics.lastUpdated = new Date().toISOString();\r\n\r\n    await fs.writeFile(this.metricsPath, JSON.stringify(metrics, null, 2));\r\n    return metrics;\r\n  }\r\n\r\n  /**\r\n   * Train neural network for pattern recognition\r\n   */\r\n  async trainNeuralPatterns() {\r\n    console.log('ðŸ§  Training neural patterns from verification data...');\r\n    \r\n    try {\r\n      // Call the training command\r\n      const result = execSync(\r\n        'npx claude-flow training neural-train --data .claude-flow/training/verification-data.jsonl --model verification-predictor --epochs 100',\r\n        { encoding: 'utf8', stdio: 'pipe' }\r\n      );\r\n      \r\n      console.log('âœ… Neural training completed');\r\n      return { success: true, output: result };\r\n    } catch (error) {\r\n      console.error('âŒ Neural training failed:', error.message);\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  async appendTrainingData(data) {\r\n    const line = JSON.stringify(data) + '\\n';\r\n    await fs.appendFile(this.trainingDataPath, line);\r\n  }\r\n\r\n  async loadModel() {\r\n    try {\r\n      const data = await fs.readFile(this.modelPath, 'utf8');\r\n      return JSON.parse(data);\r\n    } catch {\r\n      return {\r\n        version: '1.0.0',\r\n        created: new Date().toISOString(),\r\n        agentReliability: {},\r\n        patterns: {},\r\n        checkWeights: {}\r\n      };\r\n    }\r\n  }\r\n\r\n  async saveModel(model) {\r\n    model.lastUpdated = new Date().toISOString();\r\n    await fs.writeFile(this.modelPath, JSON.stringify(model, null, 2));\r\n  }\r\n\r\n  /**\r\n   * Get training status and statistics\r\n   */\r\n  async getTrainingStatus() {\r\n    const model = await this.loadModel();\r\n    const metrics = await this.loadMetrics();\r\n    \r\n    // Count training data\r\n    let trainingDataCount = 0;\r\n    try {\r\n      const data = await fs.readFile(this.trainingDataPath, 'utf8');\r\n      trainingDataCount = data.split('\\n').filter(line => line.trim()).length;\r\n    } catch {\r\n      // File doesn't exist\r\n    }\r\n\r\n    return {\r\n      modelVersion: model.version,\r\n      lastUpdated: model.lastUpdated,\r\n      trainingDataPoints: trainingDataCount,\r\n      agentReliability: model.agentReliability,\r\n      totalVerifications: metrics.totalVerifications || 0,\r\n      averageScore: metrics.averageScore || 0,\r\n      passRate: metrics.totalVerifications > 0 \r\n        ? metrics.passedVerifications / metrics.totalVerifications \r\n        : 0,\r\n      agentPerformance: metrics.byAgent || {},\r\n      recommendations: await this.generateTrainingRecommendations()\r\n    };\r\n  }\r\n\r\n  async loadMetrics() {\r\n    try {\r\n      const data = await fs.readFile(this.metricsPath, 'utf8');\r\n      return JSON.parse(data);\r\n    } catch {\r\n      return {};\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * CLI integration for verification-training\r\n */\r\nexport async function verificationTrainingCommand(args, flags) {\r\n  const integration = new VerificationTrainingIntegration();\r\n  await integration.initialize();\r\n\r\n  const subcommand = args[0] || 'status';\r\n\r\n  switch (subcommand) {\r\n    case 'feed':\r\n      // Feed current verification data to training\r\n      const verificationFile = '.swarm/verification-memory.json';\r\n      try {\r\n        const data = await fs.readFile(verificationFile, 'utf8');\r\n        const memory = JSON.parse(data);\r\n        \r\n        if (memory.history && memory.history.length > 0) {\r\n          console.log(`ðŸ“Š Feeding ${memory.history.length} verification records to training...`);\r\n          \r\n          for (const verification of memory.history) {\r\n            await integration.feedVerificationToTraining(verification);\r\n          }\r\n          \r\n          console.log('âœ… Training data updated');\r\n        } else {\r\n          console.log('No verification history to feed');\r\n        }\r\n      } catch (error) {\r\n        console.error('Error reading verification data:', error.message);\r\n      }\r\n      break;\r\n\r\n    case 'predict':\r\n      // Predict verification outcome\r\n      const taskType = args[1] || 'default';\r\n      const agentType = args[2] || 'coder';\r\n      \r\n      const prediction = await integration.predictVerificationOutcome(taskType, agentType);\r\n      console.log('\\nðŸ”® Verification Prediction:');\r\n      console.log(`   Predicted Score: ${prediction.predictedScore.toFixed(3)}`);\r\n      console.log(`   Confidence: ${(prediction.confidence * 100).toFixed(1)}%`);\r\n      console.log(`   Recommendation: ${prediction.recommendation}`);\r\n      console.log(`   Historical Success Rate: ${(prediction.historicalSuccessRate * 100).toFixed(1)}%`);\r\n      console.log(`   Data Points: ${prediction.dataPoints}`);\r\n      break;\r\n\r\n    case 'recommend':\r\n      // Get agent recommendation\r\n      const task = args[1] || 'default';\r\n      const recommendation = await integration.recommendAgent(task);\r\n      \r\n      console.log('\\nðŸ¤– Agent Recommendation:');\r\n      console.log(`   Recommended: ${recommendation.recommended}`);\r\n      console.log(`   Reliability: ${(recommendation.reliability * 100).toFixed(1)}%`);\r\n      console.log(`   Reason: ${recommendation.reason}`);\r\n      \r\n      if (recommendation.alternatives && recommendation.alternatives.length > 0) {\r\n        console.log('   Alternatives:');\r\n        for (const alt of recommendation.alternatives) {\r\n          console.log(`     â€¢ ${alt.agent}: ${(alt.reliability * 100).toFixed(1)}%`);\r\n        }\r\n      }\r\n      break;\r\n\r\n    case 'train':\r\n      // Trigger neural training\r\n      await integration.trainNeuralPatterns();\r\n      break;\r\n\r\n    case 'recommendations':\r\n      // Get training recommendations\r\n      const recs = await integration.generateTrainingRecommendations();\r\n      \r\n      console.log('\\nðŸ’¡ Training Recommendations:');\r\n      if (recs.length === 0) {\r\n        console.log('   No recommendations at this time');\r\n      } else {\r\n        for (const rec of recs) {\r\n          console.log(`   â€¢ ${rec.action}`);\r\n        }\r\n      }\r\n      break;\r\n\r\n    case 'status':\r\n    default:\r\n      // Show training status\r\n      const status = await integration.getTrainingStatus();\r\n      \r\n      console.log('\\nðŸ“Š Verification-Training Status');\r\n      console.log('â”'.repeat(50));\r\n      console.log(`Model Version: ${status.modelVersion}`);\r\n      console.log(`Last Updated: ${status.lastUpdated || 'Never'}`);\r\n      console.log(`Training Data Points: ${status.trainingDataPoints}`);\r\n      console.log(`Total Verifications: ${status.totalVerifications}`);\r\n      console.log(`Average Score: ${status.averageScore.toFixed(3)}`);\r\n      console.log(`Pass Rate: ${(status.passRate * 100).toFixed(1)}%`);\r\n      \r\n      if (Object.keys(status.agentReliability).length > 0) {\r\n        console.log('\\nðŸ¤– Agent Reliability:');\r\n        for (const [agent, reliability] of Object.entries(status.agentReliability)) {\r\n          console.log(`   ${agent}: ${(reliability * 100).toFixed(1)}%`);\r\n        }\r\n      }\r\n      \r\n      if (status.recommendations.length > 0) {\r\n        console.log('\\nðŸ’¡ Recommendations:');\r\n        for (const rec of status.recommendations) {\r\n          console.log(`   â€¢ ${rec.action}`);\r\n        }\r\n      }\r\n      \r\n      console.log('\\nðŸ“š Commands:');\r\n      console.log('   feed        - Feed verification data to training');\r\n      console.log('   predict     - Predict verification outcome');\r\n      console.log('   recommend   - Get agent recommendation');\r\n      console.log('   train       - Trigger neural training');\r\n      console.log('   status      - Show training status');\r\n      break;\r\n  }\r\n}\r\n\r\n// Export for use in other modules\r\nexport default {\r\n  VerificationTrainingIntegration,\r\n  verificationTrainingCommand\r\n};"],"names":["fs","execSync","VerificationTrainingIntegration","trainingDataPath","modelPath","metricsPath","learningRate","initialized","initialize","dirs","dir","mkdir","recursive","loadModel","console","log","feedVerificationToTraining","verification","trainingData","input","taskId","agentType","timestamp","mode","checksPerformed","results","map","r","name","output","score","passed","threshold","metadata","sessionId","process","env","SESSION_ID","Date","toISOString","appendTrainingData","updateAgentModel","incrementalLearn","updatePerformanceMetrics","model","agentReliability","currentReliability","newScore","patterns","patternKey","count","avgScore","checks","pattern","check","success","failure","saveModel","toFixed","predictVerificationOutcome","taskType","reliability","successPattern","failurePattern","predictedScore","confidence","recommendation","totalCount","successRate","Math","min","historicalSuccessRate","dataPoints","recommendAgent","recommended","reason","agents","Object","entries","sort","a","b","length","bestAgent","bestScore","alternatives","slice","agent","modelFile","agentModel","data","readFile","JSON","parse","totalTasks","successfulTasks","averageScore","scoreHistory","checkPerformance","push","result","total","checkPerf","recent10","previous10","recentAvg","reduce","sum","h","previousAvg","trend","direction","change","recentAverage","previousAverage","writeFile","stringify","emoji","generateTrainingRecommendations","recommendations","type","action","includes","split","failingChecks","filter","stats","join","totalDataPoints","values","p","currentDataPoints","metrics","totalVerifications","passedVerifications","byAgent","byHour","created","agentMetrics","hour","getHours","lastUpdated","trainNeuralPatterns","encoding","stdio","error","message","line","appendFile","version","checkWeights","getTrainingStatus","loadMetrics","trainingDataCount","trim","modelVersion","trainingDataPoints","passRate","agentPerformance","verificationTrainingCommand","args","flags","integration","subcommand","verificationFile","memory","history","prediction","task","alt","recs","rec","status","repeat","keys"],"mappings":"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"}