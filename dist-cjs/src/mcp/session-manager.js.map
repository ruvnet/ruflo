{"version":3,"sources":["../../../src/mcp/session-manager.ts"],"sourcesContent":["/**\r\n * Session manager for MCP connections\r\n */\r\n\r\nimport {\r\n  MCPSession,\r\n  MCPInitializeParams,\r\n  MCPProtocolVersion,\r\n  MCPCapabilities,\r\n  MCPAuthConfig,\r\n  MCPConfig,\r\n} from '../utils/types.js';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { MCPError } from '../utils/errors.js';\r\nimport { createHash, timingSafeEqual } from 'node:crypto';\r\n\r\nexport interface ISessionManager {\r\n  createSession(transport: 'stdio' | 'http' | 'websocket'): MCPSession;\r\n  getSession(id: string): MCPSession | undefined;\r\n  initializeSession(sessionId: string, params: MCPInitializeParams): void;\r\n  authenticateSession(sessionId: string, credentials: unknown): boolean;\r\n  updateActivity(sessionId: string): void;\r\n  removeSession(sessionId: string): void;\r\n  getActiveSessions(): MCPSession[];\r\n  cleanupExpiredSessions(): void;\r\n  getSessionMetrics(): {\r\n    total: number;\r\n    active: number;\r\n    authenticated: number;\r\n    expired: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Session manager implementation\r\n */\r\nexport class SessionManager implements ISessionManager {\r\n  private sessions = new Map<string, MCPSession>();\r\n  private authConfig: MCPAuthConfig;\r\n  private sessionTimeout: number;\r\n  private maxSessions: number;\r\n  private cleanupInterval?: number;\r\n\r\n  constructor(\r\n    private config: MCPConfig,\r\n    private logger: ILogger,\r\n  ) {\r\n    this.authConfig = config.auth || { enabled: false, method: 'token' };\r\n    this.sessionTimeout = config.sessionTimeout || 3600000; // 1 hour default\r\n    this.maxSessions = config.maxSessions || 100;\r\n\r\n    // Start cleanup timer\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanupExpiredSessions();\r\n    }, 60000); // Clean up every minute\r\n  }\r\n\r\n  createSession(transport: 'stdio' | 'http' | 'websocket'): MCPSession {\r\n    // Check session limit\r\n    if (this.sessions.size >= this.maxSessions) {\r\n      // Try to clean up expired sessions first\r\n      this.cleanupExpiredSessions();\r\n\r\n      if (this.sessions.size >= this.maxSessions) {\r\n        throw new MCPError('Maximum number of sessions reached');\r\n      }\r\n    }\r\n\r\n    const sessionId = this.generateSessionId();\r\n    const now = new Date();\r\n\r\n    const session: MCPSession = {\r\n      id: sessionId,\r\n      clientInfo: { name: 'unknown', version: 'unknown' },\r\n      protocolVersion: { major: 0, minor: 0, patch: 0 },\r\n      capabilities: {},\r\n      isInitialized: false,\r\n      createdAt: now,\r\n      lastActivity: now,\r\n      transport,\r\n      authenticated: !this.authConfig.enabled, // If auth disabled, session is authenticated\r\n    };\r\n\r\n    this.sessions.set(sessionId, session);\r\n\r\n    this.logger.info('Session created', {\r\n      sessionId,\r\n      transport,\r\n      totalSessions: this.sessions.size,\r\n    });\r\n\r\n    return session;\r\n  }\r\n\r\n  getSession(id: string): MCPSession | undefined {\r\n    const session = this.sessions.get(id);\r\n    if (session && this.isSessionExpired(session)) {\r\n      this.removeSession(id);\r\n      return undefined;\r\n    }\r\n    return session;\r\n  }\r\n\r\n  initializeSession(sessionId: string, params: MCPInitializeParams): void {\r\n    const session = this.getSession(sessionId);\r\n    if (!session) {\r\n      throw new MCPError(`Session not found: ${sessionId}`);\r\n    }\r\n\r\n    // Validate protocol version\r\n    this.validateProtocolVersion(params.protocolVersion);\r\n\r\n    // Update session with initialization params\r\n    session.clientInfo = params.clientInfo;\r\n    session.protocolVersion = params.protocolVersion;\r\n    session.capabilities = params.capabilities;\r\n    session.isInitialized = true;\r\n    session.lastActivity = new Date();\r\n\r\n    this.logger.info('Session initialized', {\r\n      sessionId,\r\n      clientInfo: params.clientInfo,\r\n      protocolVersion: params.protocolVersion,\r\n    });\r\n  }\r\n\r\n  authenticateSession(sessionId: string, credentials: unknown): boolean {\r\n    const session = this.getSession(sessionId);\r\n    if (!session) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.authConfig.enabled) {\r\n      session.authenticated = true;\r\n      return true;\r\n    }\r\n\r\n    let authenticated = false;\r\n\r\n    switch (this.authConfig.method) {\r\n      case 'token':\r\n        authenticated = this.authenticateToken(credentials);\r\n        break;\r\n      case 'basic':\r\n        authenticated = this.authenticateBasic(credentials);\r\n        break;\r\n      case 'oauth':\r\n        authenticated = this.authenticateOAuth(credentials);\r\n        break;\r\n      default:\r\n        this.logger.warn('Unknown authentication method', {\r\n          method: this.authConfig.method,\r\n        });\r\n        return false;\r\n    }\r\n\r\n    if (authenticated) {\r\n      session.authenticated = true;\r\n      session.authData = this.extractAuthData(credentials);\r\n      session.lastActivity = new Date();\r\n\r\n      this.logger.info('Session authenticated', {\r\n        sessionId,\r\n        method: this.authConfig.method,\r\n      });\r\n    } else {\r\n      this.logger.warn('Session authentication failed', {\r\n        sessionId,\r\n        method: this.authConfig.method,\r\n      });\r\n    }\r\n\r\n    return authenticated;\r\n  }\r\n\r\n  updateActivity(sessionId: string): void {\r\n    const session = this.getSession(sessionId);\r\n    if (session) {\r\n      session.lastActivity = new Date();\r\n    }\r\n  }\r\n\r\n  removeSession(sessionId: string): void {\r\n    const session = this.sessions.get(sessionId);\r\n    if (session) {\r\n      this.sessions.delete(sessionId);\r\n      this.logger.info('Session removed', {\r\n        sessionId,\r\n        duration: Date.now() - session.createdAt.getTime(),\r\n        transport: session.transport,\r\n      });\r\n    }\r\n  }\r\n\r\n  getActiveSessions(): MCPSession[] {\r\n    const activeSessions: MCPSession[] = [];\r\n    for (const session of this.sessions.values()) {\r\n      if (!this.isSessionExpired(session)) {\r\n        activeSessions.push(session);\r\n      }\r\n    }\r\n    return activeSessions;\r\n  }\r\n\r\n  cleanupExpiredSessions(): void {\r\n    const expiredSessions: string[] = [];\r\n\r\n    for (const [sessionId, session] of this.sessions) {\r\n      if (this.isSessionExpired(session)) {\r\n        expiredSessions.push(sessionId);\r\n      }\r\n    }\r\n\r\n    for (const sessionId of expiredSessions) {\r\n      this.removeSession(sessionId);\r\n    }\r\n\r\n    if (expiredSessions.length > 0) {\r\n      this.logger.info('Cleaned up expired sessions', {\r\n        count: expiredSessions.length,\r\n        remainingSessions: this.sessions.size,\r\n      });\r\n    }\r\n  }\r\n\r\n  getSessionMetrics(): {\r\n    total: number;\r\n    active: number;\r\n    authenticated: number;\r\n    expired: number;\r\n  } {\r\n    let active = 0;\r\n    let authenticated = 0;\r\n    let expired = 0;\r\n\r\n    for (const session of this.sessions.values()) {\r\n      if (this.isSessionExpired(session)) {\r\n        expired++;\r\n      } else {\r\n        active++;\r\n        if (session.authenticated) {\r\n          authenticated++;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      total: this.sessions.size,\r\n      active,\r\n      authenticated,\r\n      expired,\r\n    };\r\n  }\r\n\r\n  destroy(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n    this.sessions.clear();\r\n  }\r\n\r\n  private generateSessionId(): string {\r\n    const timestamp = Date.now().toString(36);\r\n    const random = Math.random().toString(36).substr(2, 9);\r\n    return `session_${timestamp}_${random}`;\r\n  }\r\n\r\n  private isSessionExpired(session: MCPSession): boolean {\r\n    const now = Date.now();\r\n    const sessionAge = now - session.lastActivity.getTime();\r\n    return sessionAge > this.sessionTimeout;\r\n  }\r\n\r\n  private validateProtocolVersion(version: MCPProtocolVersion): void {\r\n    // Currently supporting MCP version 2024-11-05\r\n    const supportedVersions = [{ major: 2024, minor: 11, patch: 5 }];\r\n\r\n    const isSupported = supportedVersions.some(\r\n      (supported) =>\r\n        supported.major === version.major &&\r\n        supported.minor === version.minor &&\r\n        supported.patch === version.patch,\r\n    );\r\n\r\n    if (!isSupported) {\r\n      throw new MCPError(\r\n        `Unsupported protocol version: ${version.major}.${version.minor}.${version.patch}`,\r\n        { supportedVersions },\r\n      );\r\n    }\r\n  }\r\n\r\n  private authenticateToken(credentials: unknown): boolean {\r\n    if (!this.authConfig.tokens || this.authConfig.tokens.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    const token = this.extractToken(credentials);\r\n    if (!token) {\r\n      return false;\r\n    }\r\n\r\n    // Use timing-safe comparison to prevent timing attacks\r\n    return this.authConfig.tokens.some((validToken) => {\r\n      const encoder = new TextEncoder();\r\n      const validTokenBytes = encoder.encode(validToken);\r\n      const providedTokenBytes = encoder.encode(token);\r\n\r\n      if (validTokenBytes.length !== providedTokenBytes.length) {\r\n        return false;\r\n      }\r\n\r\n      return timingSafeEqual(validTokenBytes, providedTokenBytes);\r\n    });\r\n  }\r\n\r\n  private authenticateBasic(credentials: unknown): boolean {\r\n    if (!this.authConfig.users || this.authConfig.users.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    const { username, password } = this.extractBasicAuth(credentials);\r\n    if (!username || !password) {\r\n      return false;\r\n    }\r\n\r\n    const user = this.authConfig.users.find((u) => u.username === username);\r\n    if (!user) {\r\n      return false;\r\n    }\r\n\r\n    // Hash the provided password and compare\r\n    const hashedPassword = this.hashPassword(password);\r\n    const expectedHashedPassword = this.hashPassword(user.password);\r\n\r\n    const encoder = new TextEncoder();\r\n    const hashedPasswordBytes = encoder.encode(hashedPassword);\r\n    const expectedHashedPasswordBytes = encoder.encode(expectedHashedPassword);\r\n\r\n    if (hashedPasswordBytes.length !== expectedHashedPasswordBytes.length) {\r\n      return false;\r\n    }\r\n\r\n    return timingSafeEqual(hashedPasswordBytes, expectedHashedPasswordBytes);\r\n  }\r\n\r\n  private authenticateOAuth(credentials: unknown): boolean {\r\n    // TODO: Implement OAuth authentication\r\n    // This would typically involve validating JWT tokens\r\n    this.logger.warn('OAuth authentication not yet implemented');\r\n    return false;\r\n  }\r\n\r\n  private extractToken(credentials: unknown): string | null {\r\n    if (typeof credentials === 'string') {\r\n      return credentials;\r\n    }\r\n\r\n    if (typeof credentials === 'object' && credentials !== null) {\r\n      const creds = credentials as Record<string, unknown>;\r\n      if (typeof creds.token === 'string') {\r\n        return creds.token;\r\n      }\r\n      if (typeof creds.authorization === 'string') {\r\n        const match = creds.authorization.match(/^Bearer\\s+(.+)$/);\r\n        return match ? match[1] : null;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private extractBasicAuth(credentials: unknown): { username?: string; password?: string } {\r\n    if (typeof credentials === 'object' && credentials !== null) {\r\n      const creds = credentials as Record<string, unknown>;\r\n\r\n      if (typeof creds.username === 'string' && typeof creds.password === 'string') {\r\n        return {\r\n          username: creds.username,\r\n          password: creds.password,\r\n        };\r\n      }\r\n\r\n      if (typeof creds.authorization === 'string') {\r\n        const match = creds.authorization.match(/^Basic\\s+(.+)$/);\r\n        if (match) {\r\n          try {\r\n            const decoded = atob(match[1]);\r\n            const [username, password] = decoded.split(':', 2);\r\n            return { username, password };\r\n          } catch {\r\n            return {};\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {};\r\n  }\r\n\r\n  private extractAuthData(credentials: unknown): any {\r\n    if (typeof credentials === 'object' && credentials !== null) {\r\n      const creds = credentials as Record<string, unknown>;\r\n      return {\r\n        token: this.extractToken(credentials),\r\n        user: creds.username || creds.user,\r\n        permissions: creds.permissions || [],\r\n      };\r\n    }\r\n    return {};\r\n  }\r\n\r\n  private hashPassword(password: string): string {\r\n    return createHash('sha256').update(password).digest('hex');\r\n  }\r\n}\r\n"],"names":["MCPError","createHash","timingSafeEqual","SessionManager","sessions","Map","authConfig","sessionTimeout","maxSessions","cleanupInterval","config","logger","auth","enabled","method","setInterval","cleanupExpiredSessions","createSession","transport","size","sessionId","generateSessionId","now","Date","session","id","clientInfo","name","version","protocolVersion","major","minor","patch","capabilities","isInitialized","createdAt","lastActivity","authenticated","set","info","totalSessions","getSession","get","isSessionExpired","removeSession","undefined","initializeSession","params","validateProtocolVersion","authenticateSession","credentials","authenticateToken","authenticateBasic","authenticateOAuth","warn","authData","extractAuthData","updateActivity","delete","duration","getTime","getActiveSessions","activeSessions","values","push","expiredSessions","length","count","remainingSessions","getSessionMetrics","active","expired","total","destroy","clearInterval","clear","timestamp","toString","random","Math","substr","sessionAge","supportedVersions","isSupported","some","supported","tokens","token","extractToken","validToken","encoder","TextEncoder","validTokenBytes","encode","providedTokenBytes","users","username","password","extractBasicAuth","user","find","u","hashedPassword","hashPassword","expectedHashedPassword","hashedPasswordBytes","expectedHashedPasswordBytes","creds","authorization","match","decoded","atob","split","permissions","update","digest"],"mappings":"AAaA,SAASA,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,UAAU,EAAEC,eAAe,QAAQ,cAAc;AAsB1D,OAAO,MAAMC;;;IACHC,WAAW,IAAIC,MAA0B;IACzCC,WAA0B;IAC1BC,eAAuB;IACvBC,YAAoB;IACpBC,gBAAyB;IAEjC,YACE,AAAQC,MAAiB,EACzB,AAAQC,MAAe,CACvB;aAFQD,SAAAA;aACAC,SAAAA;QAER,IAAI,CAACL,UAAU,GAAGI,OAAOE,IAAI,IAAI;YAAEC,SAAS;YAAOC,QAAQ;QAAQ;QACnE,IAAI,CAACP,cAAc,GAAGG,OAAOH,cAAc,IAAI;QAC/C,IAAI,CAACC,WAAW,GAAGE,OAAOF,WAAW,IAAI;QAGzC,IAAI,CAACC,eAAe,GAAGM,YAAY;YACjC,IAAI,CAACC,sBAAsB;QAC7B,GAAG;IACL;IAEAC,cAAcC,SAAyC,EAAc;QAEnE,IAAI,IAAI,CAACd,QAAQ,CAACe,IAAI,IAAI,IAAI,CAACX,WAAW,EAAE;YAE1C,IAAI,CAACQ,sBAAsB;YAE3B,IAAI,IAAI,CAACZ,QAAQ,CAACe,IAAI,IAAI,IAAI,CAACX,WAAW,EAAE;gBAC1C,MAAM,IAAIR,SAAS;YACrB;QACF;QAEA,MAAMoB,YAAY,IAAI,CAACC,iBAAiB;QACxC,MAAMC,MAAM,IAAIC;QAEhB,MAAMC,UAAsB;YAC1BC,IAAIL;YACJM,YAAY;gBAAEC,MAAM;gBAAWC,SAAS;YAAU;YAClDC,iBAAiB;gBAAEC,OAAO;gBAAGC,OAAO;gBAAGC,OAAO;YAAE;YAChDC,cAAc,CAAC;YACfC,eAAe;YACfC,WAAWb;YACXc,cAAcd;YACdJ;YACAmB,eAAe,CAAC,IAAI,CAAC/B,UAAU,CAACO,OAAO;QACzC;QAEA,IAAI,CAACT,QAAQ,CAACkC,GAAG,CAAClB,WAAWI;QAE7B,IAAI,CAACb,MAAM,CAAC4B,IAAI,CAAC,mBAAmB;YAClCnB;YACAF;YACAsB,eAAe,IAAI,CAACpC,QAAQ,CAACe,IAAI;QACnC;QAEA,OAAOK;IACT;IAEAiB,WAAWhB,EAAU,EAA0B;QAC7C,MAAMD,UAAU,IAAI,CAACpB,QAAQ,CAACsC,GAAG,CAACjB;QAClC,IAAID,WAAW,IAAI,CAACmB,gBAAgB,CAACnB,UAAU;YAC7C,IAAI,CAACoB,aAAa,CAACnB;YACnB,OAAOoB;QACT;QACA,OAAOrB;IACT;IAEAsB,kBAAkB1B,SAAiB,EAAE2B,MAA2B,EAAQ;QACtE,MAAMvB,UAAU,IAAI,CAACiB,UAAU,CAACrB;QAChC,IAAI,CAACI,SAAS;YACZ,MAAM,IAAIxB,SAAS,CAAC,mBAAmB,EAAEoB,WAAW;QACtD;QAGA,IAAI,CAAC4B,uBAAuB,CAACD,OAAOlB,eAAe;QAGnDL,QAAQE,UAAU,GAAGqB,OAAOrB,UAAU;QACtCF,QAAQK,eAAe,GAAGkB,OAAOlB,eAAe;QAChDL,QAAQS,YAAY,GAAGc,OAAOd,YAAY;QAC1CT,QAAQU,aAAa,GAAG;QACxBV,QAAQY,YAAY,GAAG,IAAIb;QAE3B,IAAI,CAACZ,MAAM,CAAC4B,IAAI,CAAC,uBAAuB;YACtCnB;YACAM,YAAYqB,OAAOrB,UAAU;YAC7BG,iBAAiBkB,OAAOlB,eAAe;QACzC;IACF;IAEAoB,oBAAoB7B,SAAiB,EAAE8B,WAAoB,EAAW;QACpE,MAAM1B,UAAU,IAAI,CAACiB,UAAU,CAACrB;QAChC,IAAI,CAACI,SAAS;YACZ,OAAO;QACT;QAEA,IAAI,CAAC,IAAI,CAAClB,UAAU,CAACO,OAAO,EAAE;YAC5BW,QAAQa,aAAa,GAAG;YACxB,OAAO;QACT;QAEA,IAAIA,gBAAgB;QAEpB,OAAQ,IAAI,CAAC/B,UAAU,CAACQ,MAAM;YAC5B,KAAK;gBACHuB,gBAAgB,IAAI,CAACc,iBAAiB,CAACD;gBACvC;YACF,KAAK;gBACHb,gBAAgB,IAAI,CAACe,iBAAiB,CAACF;gBACvC;YACF,KAAK;gBACHb,gBAAgB,IAAI,CAACgB,iBAAiB,CAACH;gBACvC;YACF;gBACE,IAAI,CAACvC,MAAM,CAAC2C,IAAI,CAAC,iCAAiC;oBAChDxC,QAAQ,IAAI,CAACR,UAAU,CAACQ,MAAM;gBAChC;gBACA,OAAO;QACX;QAEA,IAAIuB,eAAe;YACjBb,QAAQa,aAAa,GAAG;YACxBb,QAAQ+B,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACN;YACxC1B,QAAQY,YAAY,GAAG,IAAIb;YAE3B,IAAI,CAACZ,MAAM,CAAC4B,IAAI,CAAC,yBAAyB;gBACxCnB;gBACAN,QAAQ,IAAI,CAACR,UAAU,CAACQ,MAAM;YAChC;QACF,OAAO;YACL,IAAI,CAACH,MAAM,CAAC2C,IAAI,CAAC,iCAAiC;gBAChDlC;gBACAN,QAAQ,IAAI,CAACR,UAAU,CAACQ,MAAM;YAChC;QACF;QAEA,OAAOuB;IACT;IAEAoB,eAAerC,SAAiB,EAAQ;QACtC,MAAMI,UAAU,IAAI,CAACiB,UAAU,CAACrB;QAChC,IAAII,SAAS;YACXA,QAAQY,YAAY,GAAG,IAAIb;QAC7B;IACF;IAEAqB,cAAcxB,SAAiB,EAAQ;QACrC,MAAMI,UAAU,IAAI,CAACpB,QAAQ,CAACsC,GAAG,CAACtB;QAClC,IAAII,SAAS;YACX,IAAI,CAACpB,QAAQ,CAACsD,MAAM,CAACtC;YACrB,IAAI,CAACT,MAAM,CAAC4B,IAAI,CAAC,mBAAmB;gBAClCnB;gBACAuC,UAAUpC,KAAKD,GAAG,KAAKE,QAAQW,SAAS,CAACyB,OAAO;gBAChD1C,WAAWM,QAAQN,SAAS;YAC9B;QACF;IACF;IAEA2C,oBAAkC;QAChC,MAAMC,iBAA+B,EAAE;QACvC,KAAK,MAAMtC,WAAW,IAAI,CAACpB,QAAQ,CAAC2D,MAAM,GAAI;YAC5C,IAAI,CAAC,IAAI,CAACpB,gBAAgB,CAACnB,UAAU;gBACnCsC,eAAeE,IAAI,CAACxC;YACtB;QACF;QACA,OAAOsC;IACT;IAEA9C,yBAA+B;QAC7B,MAAMiD,kBAA4B,EAAE;QAEpC,KAAK,MAAM,CAAC7C,WAAWI,QAAQ,IAAI,IAAI,CAACpB,QAAQ,CAAE;YAChD,IAAI,IAAI,CAACuC,gBAAgB,CAACnB,UAAU;gBAClCyC,gBAAgBD,IAAI,CAAC5C;YACvB;QACF;QAEA,KAAK,MAAMA,aAAa6C,gBAAiB;YACvC,IAAI,CAACrB,aAAa,CAACxB;QACrB;QAEA,IAAI6C,gBAAgBC,MAAM,GAAG,GAAG;YAC9B,IAAI,CAACvD,MAAM,CAAC4B,IAAI,CAAC,+BAA+B;gBAC9C4B,OAAOF,gBAAgBC,MAAM;gBAC7BE,mBAAmB,IAAI,CAAChE,QAAQ,CAACe,IAAI;YACvC;QACF;IACF;IAEAkD,oBAKE;QACA,IAAIC,SAAS;QACb,IAAIjC,gBAAgB;QACpB,IAAIkC,UAAU;QAEd,KAAK,MAAM/C,WAAW,IAAI,CAACpB,QAAQ,CAAC2D,MAAM,GAAI;YAC5C,IAAI,IAAI,CAACpB,gBAAgB,CAACnB,UAAU;gBAClC+C;YACF,OAAO;gBACLD;gBACA,IAAI9C,QAAQa,aAAa,EAAE;oBACzBA;gBACF;YACF;QACF;QAEA,OAAO;YACLmC,OAAO,IAAI,CAACpE,QAAQ,CAACe,IAAI;YACzBmD;YACAjC;YACAkC;QACF;IACF;IAEAE,UAAgB;QACd,IAAI,IAAI,CAAChE,eAAe,EAAE;YACxBiE,cAAc,IAAI,CAACjE,eAAe;QACpC;QACA,IAAI,CAACL,QAAQ,CAACuE,KAAK;IACrB;IAEQtD,oBAA4B;QAClC,MAAMuD,YAAYrD,KAAKD,GAAG,GAAGuD,QAAQ,CAAC;QACtC,MAAMC,SAASC,KAAKD,MAAM,GAAGD,QAAQ,CAAC,IAAIG,MAAM,CAAC,GAAG;QACpD,OAAO,CAAC,QAAQ,EAAEJ,UAAU,CAAC,EAAEE,QAAQ;IACzC;IAEQnC,iBAAiBnB,OAAmB,EAAW;QACrD,MAAMF,MAAMC,KAAKD,GAAG;QACpB,MAAM2D,aAAa3D,MAAME,QAAQY,YAAY,CAACwB,OAAO;QACrD,OAAOqB,aAAa,IAAI,CAAC1E,cAAc;IACzC;IAEQyC,wBAAwBpB,OAA2B,EAAQ;QAEjE,MAAMsD,oBAAoB;YAAC;gBAAEpD,OAAO;gBAAMC,OAAO;gBAAIC,OAAO;YAAE;SAAE;QAEhE,MAAMmD,cAAcD,kBAAkBE,IAAI,CACxC,CAACC,YACCA,UAAUvD,KAAK,KAAKF,QAAQE,KAAK,IACjCuD,UAAUtD,KAAK,KAAKH,QAAQG,KAAK,IACjCsD,UAAUrD,KAAK,KAAKJ,QAAQI,KAAK;QAGrC,IAAI,CAACmD,aAAa;YAChB,MAAM,IAAInF,SACR,CAAC,8BAA8B,EAAE4B,QAAQE,KAAK,CAAC,CAAC,EAAEF,QAAQG,KAAK,CAAC,CAAC,EAAEH,QAAQI,KAAK,EAAE,EAClF;gBAAEkD;YAAkB;QAExB;IACF;IAEQ/B,kBAAkBD,WAAoB,EAAW;QACvD,IAAI,CAAC,IAAI,CAAC5C,UAAU,CAACgF,MAAM,IAAI,IAAI,CAAChF,UAAU,CAACgF,MAAM,CAACpB,MAAM,KAAK,GAAG;YAClE,OAAO;QACT;QAEA,MAAMqB,QAAQ,IAAI,CAACC,YAAY,CAACtC;QAChC,IAAI,CAACqC,OAAO;YACV,OAAO;QACT;QAGA,OAAO,IAAI,CAACjF,UAAU,CAACgF,MAAM,CAACF,IAAI,CAAC,CAACK;YAClC,MAAMC,UAAU,IAAIC;YACpB,MAAMC,kBAAkBF,QAAQG,MAAM,CAACJ;YACvC,MAAMK,qBAAqBJ,QAAQG,MAAM,CAACN;YAE1C,IAAIK,gBAAgB1B,MAAM,KAAK4B,mBAAmB5B,MAAM,EAAE;gBACxD,OAAO;YACT;YAEA,OAAOhE,gBAAgB0F,iBAAiBE;QAC1C;IACF;IAEQ1C,kBAAkBF,WAAoB,EAAW;QACvD,IAAI,CAAC,IAAI,CAAC5C,UAAU,CAACyF,KAAK,IAAI,IAAI,CAACzF,UAAU,CAACyF,KAAK,CAAC7B,MAAM,KAAK,GAAG;YAChE,OAAO;QACT;QAEA,MAAM,EAAE8B,QAAQ,EAAEC,QAAQ,EAAE,GAAG,IAAI,CAACC,gBAAgB,CAAChD;QACrD,IAAI,CAAC8C,YAAY,CAACC,UAAU;YAC1B,OAAO;QACT;QAEA,MAAME,OAAO,IAAI,CAAC7F,UAAU,CAACyF,KAAK,CAACK,IAAI,CAAC,CAACC,IAAMA,EAAEL,QAAQ,KAAKA;QAC9D,IAAI,CAACG,MAAM;YACT,OAAO;QACT;QAGA,MAAMG,iBAAiB,IAAI,CAACC,YAAY,CAACN;QACzC,MAAMO,yBAAyB,IAAI,CAACD,YAAY,CAACJ,KAAKF,QAAQ;QAE9D,MAAMP,UAAU,IAAIC;QACpB,MAAMc,sBAAsBf,QAAQG,MAAM,CAACS;QAC3C,MAAMI,8BAA8BhB,QAAQG,MAAM,CAACW;QAEnD,IAAIC,oBAAoBvC,MAAM,KAAKwC,4BAA4BxC,MAAM,EAAE;YACrE,OAAO;QACT;QAEA,OAAOhE,gBAAgBuG,qBAAqBC;IAC9C;IAEQrD,kBAAkBH,WAAoB,EAAW;QAGvD,IAAI,CAACvC,MAAM,CAAC2C,IAAI,CAAC;QACjB,OAAO;IACT;IAEQkC,aAAatC,WAAoB,EAAiB;QACxD,IAAI,OAAOA,gBAAgB,UAAU;YACnC,OAAOA;QACT;QAEA,IAAI,OAAOA,gBAAgB,YAAYA,gBAAgB,MAAM;YAC3D,MAAMyD,QAAQzD;YACd,IAAI,OAAOyD,MAAMpB,KAAK,KAAK,UAAU;gBACnC,OAAOoB,MAAMpB,KAAK;YACpB;YACA,IAAI,OAAOoB,MAAMC,aAAa,KAAK,UAAU;gBAC3C,MAAMC,QAAQF,MAAMC,aAAa,CAACC,KAAK,CAAC;gBACxC,OAAOA,QAAQA,KAAK,CAAC,EAAE,GAAG;YAC5B;QACF;QAEA,OAAO;IACT;IAEQX,iBAAiBhD,WAAoB,EAA4C;QACvF,IAAI,OAAOA,gBAAgB,YAAYA,gBAAgB,MAAM;YAC3D,MAAMyD,QAAQzD;YAEd,IAAI,OAAOyD,MAAMX,QAAQ,KAAK,YAAY,OAAOW,MAAMV,QAAQ,KAAK,UAAU;gBAC5E,OAAO;oBACLD,UAAUW,MAAMX,QAAQ;oBACxBC,UAAUU,MAAMV,QAAQ;gBAC1B;YACF;YAEA,IAAI,OAAOU,MAAMC,aAAa,KAAK,UAAU;gBAC3C,MAAMC,QAAQF,MAAMC,aAAa,CAACC,KAAK,CAAC;gBACxC,IAAIA,OAAO;oBACT,IAAI;wBACF,MAAMC,UAAUC,KAAKF,KAAK,CAAC,EAAE;wBAC7B,MAAM,CAACb,UAAUC,SAAS,GAAGa,QAAQE,KAAK,CAAC,KAAK;wBAChD,OAAO;4BAAEhB;4BAAUC;wBAAS;oBAC9B,EAAE,OAAM;wBACN,OAAO,CAAC;oBACV;gBACF;YACF;QACF;QAEA,OAAO,CAAC;IACV;IAEQzC,gBAAgBN,WAAoB,EAAO;QACjD,IAAI,OAAOA,gBAAgB,YAAYA,gBAAgB,MAAM;YAC3D,MAAMyD,QAAQzD;YACd,OAAO;gBACLqC,OAAO,IAAI,CAACC,YAAY,CAACtC;gBACzBiD,MAAMQ,MAAMX,QAAQ,IAAIW,MAAMR,IAAI;gBAClCc,aAAaN,MAAMM,WAAW,IAAI,EAAE;YACtC;QACF;QACA,OAAO,CAAC;IACV;IAEQV,aAAaN,QAAgB,EAAU;QAC7C,OAAOhG,WAAW,UAAUiH,MAAM,CAACjB,UAAUkB,MAAM,CAAC;IACtD;AACF"}