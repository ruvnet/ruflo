{
  "version": 3,
  "sources": ["../../../src/mcp/recovery/recovery-manager.ts"],
  "sourcesContent": ["/**\n * Recovery Manager for MCP\n * Orchestrates all recovery components for comprehensive connection stability\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPClient } from '../client.js';\nimport { ConnectionHealthMonitor, HealthStatus } from './connection-health-monitor.js';\nimport { ReconnectionManager } from './reconnection-manager.js';\nimport { FallbackCoordinator } from './fallback-coordinator.js';\nimport { ConnectionStateManager } from './connection-state-manager.js';\nimport type { MCPConfig, MCPRequest } from '../../utils/types.js';\n\nexport interface RecoveryConfig {\n  enableRecovery: boolean;\n  healthMonitor?: {\n    heartbeatInterval?: number;\n    heartbeatTimeout?: number;\n    maxMissedHeartbeats?: number;\n  };\n  reconnection?: {\n    maxRetries?: number;\n    initialDelay?: number;\n    maxDelay?: number;\n    backoffMultiplier?: number;\n  };\n  fallback?: {\n    enableFallback?: boolean;\n    maxQueueSize?: number;\n    cliPath?: string;\n  };\n  state?: {\n    enablePersistence?: boolean;\n    stateDirectory?: string;\n  };\n}\n\nexport interface RecoveryStatus {\n  isRecoveryActive: boolean;\n  connectionHealth: HealthStatus;\n  reconnectionState: {\n    attempts: number;\n    isReconnecting: boolean;\n    nextDelay?: number;\n  };\n  fallbackState: {\n    isFallbackActive: boolean;\n    queuedOperations: number;\n  };\n  metrics: {\n    totalRecoveries: number;\n    successfulRecoveries: number;\n    failedRecoveries: number;\n    averageRecoveryTime: number;\n  };\n}\n\nexport class RecoveryManager extends EventEmitter {\n  private healthMonitor: ConnectionHealthMonitor;\n  private reconnectionManager: ReconnectionManager;\n  private fallbackCoordinator: FallbackCoordinator;\n  private stateManager: ConnectionStateManager;\n\n  private isRecoveryActive = false;\n  private recoveryStartTime?: Date;\n  private metrics = {\n    totalRecoveries: 0,\n    successfulRecoveries: 0,\n    failedRecoveries: 0,\n    totalRecoveryTime: 0,\n  };\n\n  constructor(\n    private client: MCPClient,\n    private mcpConfig: MCPConfig,\n    private logger: ILogger,\n    config?: RecoveryConfig,\n  ) {\n    super();\n\n    // Initialize components\n    this.healthMonitor = new ConnectionHealthMonitor(client, logger, config?.healthMonitor);\n\n    this.reconnectionManager = new ReconnectionManager(client, logger, config?.reconnection);\n\n    this.fallbackCoordinator = new FallbackCoordinator(logger, config?.fallback);\n\n    this.stateManager = new ConnectionStateManager(logger, config?.state);\n\n    // Set up component event handlers\n    this.setupEventHandlers();\n\n    this.logger.info('Recovery manager initialized');\n  }\n\n  /**\n   * Start recovery management\n   */\n  async start(): Promise<void> {\n    this.logger.info('Starting recovery manager');\n\n    // Start health monitoring\n    await this.healthMonitor.start();\n\n    // Restore any previous state\n    const previousState = this.stateManager.restoreState();\n    if (previousState && previousState.pendingRequests.length > 0) {\n      this.logger.info('Restored previous connection state', {\n        sessionId: previousState.sessionId,\n        pendingRequests: previousState.pendingRequests.length,\n      });\n\n      // Queue pending requests for retry\n      previousState.pendingRequests.forEach((request) => {\n        this.fallbackCoordinator.queueOperation({\n          type: 'tool',\n          method: request.method,\n          params: request.params,\n          priority: 'high',\n          retryable: true,\n        });\n      });\n    }\n\n    this.emit('started');\n  }\n\n  /**\n   * Stop recovery management\n   */\n  async stop(): Promise<void> {\n    this.logger.info('Stopping recovery manager');\n\n    // Stop all components\n    await this.healthMonitor.stop();\n    this.reconnectionManager.stopReconnection();\n    this.fallbackCoordinator.disableCLIFallback();\n    await this.stateManager.cleanup();\n\n    this.emit('stopped');\n  }\n\n  /**\n   * Get current recovery status\n   */\n  getStatus(): RecoveryStatus {\n    const healthStatus = this.healthMonitor.getHealthStatus();\n    const reconnectionState = this.reconnectionManager.getState();\n    const fallbackState = this.fallbackCoordinator.getState();\n\n    return {\n      isRecoveryActive: this.isRecoveryActive,\n      connectionHealth: healthStatus,\n      reconnectionState: {\n        attempts: reconnectionState.attempts,\n        isReconnecting: reconnectionState.isReconnecting,\n        nextDelay: reconnectionState.nextDelay,\n      },\n      fallbackState: {\n        isFallbackActive: fallbackState.isFallbackActive,\n        queuedOperations: fallbackState.queuedOperations,\n      },\n      metrics: {\n        totalRecoveries: this.metrics.totalRecoveries,\n        successfulRecoveries: this.metrics.successfulRecoveries,\n        failedRecoveries: this.metrics.failedRecoveries,\n        averageRecoveryTime:\n          this.metrics.totalRecoveries > 0\n            ? this.metrics.totalRecoveryTime / this.metrics.totalRecoveries\n            : 0,\n      },\n    };\n  }\n\n  /**\n   * Force a recovery attempt\n   */\n  async forceRecovery(): Promise<boolean> {\n    this.logger.info('Forcing recovery attempt');\n\n    // Check if already recovering\n    if (this.isRecoveryActive) {\n      this.logger.warn('Recovery already in progress');\n      return false;\n    }\n\n    return this.startRecovery('manual');\n  }\n\n  /**\n   * Handle a request that needs recovery consideration\n   */\n  async handleRequest(request: MCPRequest): Promise<void> {\n    // Add to pending requests if disconnected\n    if (!this.client.isConnected()) {\n      this.stateManager.addPendingRequest(request);\n\n      // Queue for fallback execution\n      this.fallbackCoordinator.queueOperation({\n        type: 'tool',\n        method: request.method,\n        params: request.params,\n        priority: 'medium',\n        retryable: true,\n      });\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Health monitor events\n    this.healthMonitor.on('connectionLost', async ({ error }) => {\n      this.logger.error('Connection lost, initiating recovery', error);\n      await this.startRecovery('health-check');\n    });\n\n    this.healthMonitor.on('healthChange', (newStatus, oldStatus) => {\n      this.emit('healthChange', newStatus, oldStatus);\n\n      // Record state change\n      this.stateManager.recordEvent({\n        type: newStatus.healthy ? 'connect' : 'disconnect',\n        sessionId: this.generateSessionId(),\n        details: { health: newStatus },\n      });\n    });\n\n    // Reconnection manager events\n    this.reconnectionManager.on('success', async ({ attempts, duration }) => {\n      this.logger.info('Reconnection successful', { attempts, duration });\n      await this.completeRecovery(true);\n    });\n\n    this.reconnectionManager.on('maxRetriesExceeded', async () => {\n      this.logger.error('Max reconnection attempts exceeded');\n      await this.completeRecovery(false);\n    });\n\n    this.reconnectionManager.on('attemptFailed', ({ attempt, error }) => {\n      this.emit('recoveryAttemptFailed', { attempt, error });\n    });\n\n    // Fallback coordinator events\n    this.fallbackCoordinator.on('fallbackEnabled', (state) => {\n      this.logger.warn('Fallback mode activated', state);\n      this.emit('fallbackActivated', state);\n    });\n\n    this.fallbackCoordinator.on('replayOperation', async (operation) => {\n      // Replay operation through MCP client\n      if (this.client.isConnected()) {\n        try {\n          await this.client.request(operation.method, operation.params);\n          this.stateManager.removePendingRequest(operation.id);\n        } catch (error) {\n          this.logger.error('Failed to replay operation', { operation, error });\n        }\n      }\n    });\n  }\n\n  private async startRecovery(trigger: string): Promise<boolean> {\n    if (this.isRecoveryActive) {\n      return false;\n    }\n\n    this.isRecoveryActive = true;\n    this.recoveryStartTime = new Date();\n    this.metrics.totalRecoveries++;\n\n    this.logger.info('Starting recovery process', { trigger });\n    this.emit('recoveryStart', { trigger });\n\n    // Save current state\n    this.stateManager.saveState({\n      sessionId: this.generateSessionId(),\n      lastConnected: new Date(),\n      pendingRequests: [],\n      configuration: this.mcpConfig,\n      metadata: { trigger },\n    });\n\n    // Enable fallback mode immediately\n    this.fallbackCoordinator.enableCLIFallback();\n\n    // Start reconnection attempts\n    this.reconnectionManager.startAutoReconnect();\n\n    return true;\n  }\n\n  private async completeRecovery(success: boolean): Promise<void> {\n    if (!this.isRecoveryActive) {\n      return;\n    }\n\n    const duration = this.recoveryStartTime ? Date.now() - this.recoveryStartTime.getTime() : 0;\n\n    this.isRecoveryActive = false;\n    this.recoveryStartTime = undefined;\n\n    if (success) {\n      this.metrics.successfulRecoveries++;\n      this.metrics.totalRecoveryTime += duration;\n\n      // Disable fallback mode\n      this.fallbackCoordinator.disableCLIFallback();\n\n      // Process any queued operations\n      await this.fallbackCoordinator.processQueue();\n\n      // Reset health monitor\n      this.healthMonitor.reset();\n\n      // Record reconnection\n      this.stateManager.recordEvent({\n        type: 'reconnect',\n        sessionId: this.generateSessionId(),\n        details: { duration },\n      });\n\n      this.logger.info('Recovery completed successfully', { duration });\n      this.emit('recoveryComplete', { success: true, duration });\n    } else {\n      this.metrics.failedRecoveries++;\n\n      this.logger.error('Recovery failed');\n      this.emit('recoveryComplete', { success: false, duration });\n\n      // Keep fallback active\n      this.emit('fallbackPermanent');\n    }\n  }\n\n  private generateSessionId(): string {\n    return `recovery-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    await this.stop();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,yBAA6B;AAG7B,uCAAsD;AACtD,kCAAoC;AACpC,kCAAoC;AACpC,sCAAuC;AA+ChC,MAAM,wBAAwB,gCAAa;AAAA,EAehD,YACU,QACA,WACA,QACR,QACA;AACA,UAAM;AALE;AACA;AACA;AAMR,SAAK,gBAAgB,IAAI,yDAAwB,QAAQ,QAAQ,QAAQ,aAAa;AAEtF,SAAK,sBAAsB,IAAI,gDAAoB,QAAQ,QAAQ,QAAQ,YAAY;AAEvF,SAAK,sBAAsB,IAAI,gDAAoB,QAAQ,QAAQ,QAAQ;AAE3E,SAAK,eAAe,IAAI,uDAAuB,QAAQ,QAAQ,KAAK;AAGpE,SAAK,mBAAmB;AAExB,SAAK,OAAO,KAAK,8BAA8B;AAAA,EACjD;AAAA,EA9FF,OA0DkD;AAAA;AAAA;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,mBAAmB;AAAA,EACnB;AAAA,EACA,UAAU;AAAA,IAChB,iBAAiB;AAAA,IACjB,sBAAsB;AAAA,IACtB,kBAAkB;AAAA,IAClB,mBAAmB;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EA4BA,MAAM,QAAuB;AAC3B,SAAK,OAAO,KAAK,2BAA2B;AAG5C,UAAM,KAAK,cAAc,MAAM;AAG/B,UAAM,gBAAgB,KAAK,aAAa,aAAa;AACrD,QAAI,iBAAiB,cAAc,gBAAgB,SAAS,GAAG;AAC7D,WAAK,OAAO,KAAK,sCAAsC;AAAA,QACrD,WAAW,cAAc;AAAA,QACzB,iBAAiB,cAAc,gBAAgB;AAAA,MACjD,CAAC;AAGD,oBAAc,gBAAgB,QAAQ,CAAC,YAAY;AACjD,aAAK,oBAAoB,eAAe;AAAA,UACtC,MAAM;AAAA,UACN,QAAQ,QAAQ;AAAA,UAChB,QAAQ,QAAQ;AAAA,UAChB,UAAU;AAAA,UACV,WAAW;AAAA,QACb,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,SAAK,KAAK,SAAS;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAsB;AAC1B,SAAK,OAAO,KAAK,2BAA2B;AAG5C,UAAM,KAAK,cAAc,KAAK;AAC9B,SAAK,oBAAoB,iBAAiB;AAC1C,SAAK,oBAAoB,mBAAmB;AAC5C,UAAM,KAAK,aAAa,QAAQ;AAEhC,SAAK,KAAK,SAAS;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,YAA4B;AAC1B,UAAM,eAAe,KAAK,cAAc,gBAAgB;AACxD,UAAM,oBAAoB,KAAK,oBAAoB,SAAS;AAC5D,UAAM,gBAAgB,KAAK,oBAAoB,SAAS;AAExD,WAAO;AAAA,MACL,kBAAkB,KAAK;AAAA,MACvB,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,QACjB,UAAU,kBAAkB;AAAA,QAC5B,gBAAgB,kBAAkB;AAAA,QAClC,WAAW,kBAAkB;AAAA,MAC/B;AAAA,MACA,eAAe;AAAA,QACb,kBAAkB,cAAc;AAAA,QAChC,kBAAkB,cAAc;AAAA,MAClC;AAAA,MACA,SAAS;AAAA,QACP,iBAAiB,KAAK,QAAQ;AAAA,QAC9B,sBAAsB,KAAK,QAAQ;AAAA,QACnC,kBAAkB,KAAK,QAAQ;AAAA,QAC/B,qBACE,KAAK,QAAQ,kBAAkB,IAC3B,KAAK,QAAQ,oBAAoB,KAAK,QAAQ,kBAC9C;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAkC;AACtC,SAAK,OAAO,KAAK,0BAA0B;AAG3C,QAAI,KAAK,kBAAkB;AACzB,WAAK,OAAO,KAAK,8BAA8B;AAC/C,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,cAAc,QAAQ;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,SAAoC;AAEtD,QAAI,CAAC,KAAK,OAAO,YAAY,GAAG;AAC9B,WAAK,aAAa,kBAAkB,OAAO;AAG3C,WAAK,oBAAoB,eAAe;AAAA,QACtC,MAAM;AAAA,QACN,QAAQ,QAAQ;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,UAAU;AAAA,QACV,WAAW;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,qBAA2B;AAEjC,SAAK,cAAc,GAAG,kBAAkB,OAAO,EAAE,MAAM,MAAM;AAC3D,WAAK,OAAO,MAAM,wCAAwC,KAAK;AAC/D,YAAM,KAAK,cAAc,cAAc;AAAA,IACzC,CAAC;AAED,SAAK,cAAc,GAAG,gBAAgB,CAAC,WAAW,cAAc;AAC9D,WAAK,KAAK,gBAAgB,WAAW,SAAS;AAG9C,WAAK,aAAa,YAAY;AAAA,QAC5B,MAAM,UAAU,UAAU,YAAY;AAAA,QACtC,WAAW,KAAK,kBAAkB;AAAA,QAClC,SAAS,EAAE,QAAQ,UAAU;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAGD,SAAK,oBAAoB,GAAG,WAAW,OAAO,EAAE,UAAU,SAAS,MAAM;AACvE,WAAK,OAAO,KAAK,2BAA2B,EAAE,UAAU,SAAS,CAAC;AAClE,YAAM,KAAK,iBAAiB,IAAI;AAAA,IAClC,CAAC;AAED,SAAK,oBAAoB,GAAG,sBAAsB,YAAY;AAC5D,WAAK,OAAO,MAAM,oCAAoC;AACtD,YAAM,KAAK,iBAAiB,KAAK;AAAA,IACnC,CAAC;AAED,SAAK,oBAAoB,GAAG,iBAAiB,CAAC,EAAE,SAAS,MAAM,MAAM;AACnE,WAAK,KAAK,yBAAyB,EAAE,SAAS,MAAM,CAAC;AAAA,IACvD,CAAC;AAGD,SAAK,oBAAoB,GAAG,mBAAmB,CAAC,UAAU;AACxD,WAAK,OAAO,KAAK,2BAA2B,KAAK;AACjD,WAAK,KAAK,qBAAqB,KAAK;AAAA,IACtC,CAAC;AAED,SAAK,oBAAoB,GAAG,mBAAmB,OAAO,cAAc;AAElE,UAAI,KAAK,OAAO,YAAY,GAAG;AAC7B,YAAI;AACF,gBAAM,KAAK,OAAO,QAAQ,UAAU,QAAQ,UAAU,MAAM;AAC5D,eAAK,aAAa,qBAAqB,UAAU,EAAE;AAAA,QACrD,SAAS,OAAO;AACd,eAAK,OAAO,MAAM,8BAA8B,EAAE,WAAW,MAAM,CAAC;AAAA,QACtE;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,cAAc,SAAmC;AAC7D,QAAI,KAAK,kBAAkB;AACzB,aAAO;AAAA,IACT;AAEA,SAAK,mBAAmB;AACxB,SAAK,oBAAoB,oBAAI,KAAK;AAClC,SAAK,QAAQ;AAEb,SAAK,OAAO,KAAK,6BAA6B,EAAE,QAAQ,CAAC;AACzD,SAAK,KAAK,iBAAiB,EAAE,QAAQ,CAAC;AAGtC,SAAK,aAAa,UAAU;AAAA,MAC1B,WAAW,KAAK,kBAAkB;AAAA,MAClC,eAAe,oBAAI,KAAK;AAAA,MACxB,iBAAiB,CAAC;AAAA,MAClB,eAAe,KAAK;AAAA,MACpB,UAAU,EAAE,QAAQ;AAAA,IACtB,CAAC;AAGD,SAAK,oBAAoB,kBAAkB;AAG3C,SAAK,oBAAoB,mBAAmB;AAE5C,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,iBAAiB,SAAiC;AAC9D,QAAI,CAAC,KAAK,kBAAkB;AAC1B;AAAA,IACF;AAEA,UAAM,WAAW,KAAK,oBAAoB,KAAK,IAAI,IAAI,KAAK,kBAAkB,QAAQ,IAAI;AAE1F,SAAK,mBAAmB;AACxB,SAAK,oBAAoB;AAEzB,QAAI,SAAS;AACX,WAAK,QAAQ;AACb,WAAK,QAAQ,qBAAqB;AAGlC,WAAK,oBAAoB,mBAAmB;AAG5C,YAAM,KAAK,oBAAoB,aAAa;AAG5C,WAAK,cAAc,MAAM;AAGzB,WAAK,aAAa,YAAY;AAAA,QAC5B,MAAM;AAAA,QACN,WAAW,KAAK,kBAAkB;AAAA,QAClC,SAAS,EAAE,SAAS;AAAA,MACtB,CAAC;AAED,WAAK,OAAO,KAAK,mCAAmC,EAAE,SAAS,CAAC;AAChE,WAAK,KAAK,oBAAoB,EAAE,SAAS,MAAM,SAAS,CAAC;AAAA,IAC3D,OAAO;AACL,WAAK,QAAQ;AAEb,WAAK,OAAO,MAAM,iBAAiB;AACnC,WAAK,KAAK,oBAAoB,EAAE,SAAS,OAAO,SAAS,CAAC;AAG1D,WAAK,KAAK,mBAAmB;AAAA,IAC/B;AAAA,EACF;AAAA,EAEQ,oBAA4B;AAClC,WAAO,YAAY,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAyB;AAC7B,UAAM,KAAK,KAAK;AAAA,EAClB;AACF;",
  "names": []
}
