{"version":3,"sources":["../../../../src/swarm/optimizations/ttl-map.ts"],"sourcesContent":["/**\r\n * TTL Map Implementation\r\n * Map with time-to-live for automatic entry expiration\r\n */\r\n\r\ninterface TTLItem<T> {\r\n  value: T;\r\n  expiry: number;\r\n  createdAt: number;\r\n  accessCount: number;\r\n  lastAccessedAt: number;\r\n}\r\n\r\nexport interface TTLMapOptions {\r\n  defaultTTL?: number;\r\n  cleanupInterval?: number;\r\n  maxSize?: number;\r\n  onExpire?: <K, V>(key: K, value: V) => void;\r\n}\r\n\r\nexport class TTLMap<K, V> {\r\n  private items = new Map<K, TTLItem<V>>();\r\n  private cleanupTimer?: NodeJS.Timeout;\r\n  private defaultTTL: number;\r\n  private cleanupInterval: number;\r\n  private maxSize?: number;\r\n  private onExpire?: <K, V>(key: K, value: V) => void;\r\n  private stats = {\r\n    hits: 0,\r\n    misses: 0,\r\n    evictions: 0,\r\n    expirations: 0,\r\n  };\r\n\r\n  constructor(options: TTLMapOptions = {}) {\r\n    this.defaultTTL = options.defaultTTL || 3600000; // 1 hour default\r\n    this.cleanupInterval = options.cleanupInterval || 60000; // 1 minute default\r\n    this.maxSize = options.maxSize;\r\n    this.onExpire = options.onExpire;\r\n\r\n    this.startCleanup();\r\n  }\r\n\r\n  set(key: K, value: V, ttl?: number): void {\r\n    const now = Date.now();\r\n    const expiry = now + (ttl || this.defaultTTL);\r\n\r\n    // Check if we need to evict items due to size limit\r\n    if (this.maxSize && this.items.size >= this.maxSize && !this.items.has(key)) {\r\n      this.evictLRU();\r\n    }\r\n\r\n    this.items.set(key, {\r\n      value,\r\n      expiry,\r\n      createdAt: now,\r\n      accessCount: 0,\r\n      lastAccessedAt: now,\r\n    });\r\n  }\r\n\r\n  get(key: K): V | undefined {\r\n    const item = this.items.get(key);\r\n\r\n    if (!item) {\r\n      this.stats.misses++;\r\n      return undefined;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    if (now > item.expiry) {\r\n      this.items.delete(key);\r\n      this.stats.expirations++;\r\n      this.stats.misses++;\r\n\r\n      if (this.onExpire) {\r\n        this.onExpire(key, item.value);\r\n      }\r\n\r\n      return undefined;\r\n    }\r\n\r\n    // Update access stats\r\n    item.accessCount++;\r\n    item.lastAccessedAt = now;\r\n    this.stats.hits++;\r\n\r\n    return item.value;\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    const item = this.items.get(key);\r\n\r\n    if (!item) {\r\n      return false;\r\n    }\r\n\r\n    if (Date.now() > item.expiry) {\r\n      this.items.delete(key);\r\n      this.stats.expirations++;\r\n\r\n      if (this.onExpire) {\r\n        this.onExpire(key, item.value);\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.items.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.items.clear();\r\n  }\r\n\r\n  /**\r\n   * Update TTL for an existing key\r\n   */\r\n  touch(key: K, ttl?: number): boolean {\r\n    const item = this.items.get(key);\r\n\r\n    if (!item || Date.now() > item.expiry) {\r\n      return false;\r\n    }\r\n\r\n    item.expiry = Date.now() + (ttl || this.defaultTTL);\r\n    item.lastAccessedAt = Date.now();\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get remaining TTL for a key\r\n   */\r\n  getTTL(key: K): number {\r\n    const item = this.items.get(key);\r\n\r\n    if (!item) {\r\n      return -1;\r\n    }\r\n\r\n    const remaining = item.expiry - Date.now();\r\n    return remaining > 0 ? remaining : -1;\r\n  }\r\n\r\n  /**\r\n   * Get all keys (excluding expired ones)\r\n   */\r\n  keys(): K[] {\r\n    const now = Date.now();\r\n    const validKeys: K[] = [];\r\n\r\n    for (const [key, item] of this.items) {\r\n      if (now <= item.expiry) {\r\n        validKeys.push(key);\r\n      }\r\n    }\r\n\r\n    return validKeys;\r\n  }\r\n\r\n  /**\r\n   * Get all values (excluding expired ones)\r\n   */\r\n  values(): V[] {\r\n    const now = Date.now();\r\n    const validValues: V[] = [];\r\n\r\n    for (const item of this.items.values()) {\r\n      if (now <= item.expiry) {\r\n        validValues.push(item.value);\r\n      }\r\n    }\r\n\r\n    return validValues;\r\n  }\r\n\r\n  /**\r\n   * Get all entries (excluding expired ones)\r\n   */\r\n  entries(): Array<[K, V]> {\r\n    const now = Date.now();\r\n    const validEntries: Array<[K, V]> = [];\r\n\r\n    for (const [key, item] of this.items) {\r\n      if (now <= item.expiry) {\r\n        validEntries.push([key, item.value]);\r\n      }\r\n    }\r\n\r\n    return validEntries;\r\n  }\r\n\r\n  /**\r\n   * Get size (excluding expired items)\r\n   */\r\n  get size(): number {\r\n    this.cleanup(); // Clean up expired items first\r\n    return this.items.size;\r\n  }\r\n\r\n  private startCleanup(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanup();\r\n    }, this.cleanupInterval);\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n\r\n    for (const [key, item] of this.items) {\r\n      if (now > item.expiry) {\r\n        this.items.delete(key);\r\n        cleaned++;\r\n        this.stats.expirations++;\r\n\r\n        if (this.onExpire) {\r\n          this.onExpire(key, item.value);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      // Optional: Log cleanup stats\r\n    }\r\n  }\r\n\r\n  private evictLRU(): void {\r\n    let lruKey: K | undefined;\r\n    let lruTime = Infinity;\r\n\r\n    // Find least recently used item\r\n    for (const [key, item] of this.items) {\r\n      if (item.lastAccessedAt < lruTime) {\r\n        lruTime = item.lastAccessedAt;\r\n        lruKey = key;\r\n      }\r\n    }\r\n\r\n    if (lruKey !== undefined) {\r\n      this.items.delete(lruKey);\r\n      this.stats.evictions++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the cleanup timer\r\n   */\r\n  destroy(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = undefined;\r\n    }\r\n    this.items.clear();\r\n  }\r\n\r\n  /**\r\n   * Get statistics about the map\r\n   */\r\n  getStats() {\r\n    return {\r\n      ...this.stats,\r\n      size: this.items.size,\r\n      hitRate: this.stats.hits / (this.stats.hits + this.stats.misses) || 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get detailed information about all items\r\n   */\r\n  inspect(): Map<\r\n    K,\r\n    {\r\n      value: V;\r\n      ttl: number;\r\n      age: number;\r\n      accessCount: number;\r\n      lastAccessed: number;\r\n    }\r\n  > {\r\n    const now = Date.now();\r\n    const result = new Map();\r\n\r\n    for (const [key, item] of this.items) {\r\n      if (now <= item.expiry) {\r\n        result.set(key, {\r\n          value: item.value,\r\n          ttl: item.expiry - now,\r\n          age: now - item.createdAt,\r\n          accessCount: item.accessCount,\r\n          lastAccessed: now - item.lastAccessedAt,\r\n        });\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"],"names":["TTLMap","items","Map","cleanupTimer","defaultTTL","cleanupInterval","maxSize","onExpire","stats","hits","misses","evictions","expirations","options","startCleanup","set","key","value","ttl","now","Date","expiry","size","has","evictLRU","createdAt","accessCount","lastAccessedAt","get","item","undefined","delete","clear","touch","getTTL","remaining","keys","validKeys","push","values","validValues","entries","validEntries","cleanup","setInterval","cleaned","lruKey","lruTime","Infinity","destroy","clearInterval","getStats","hitRate","inspect","result","age","lastAccessed"],"mappings":"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"}