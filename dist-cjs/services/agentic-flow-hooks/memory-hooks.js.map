{
  "version": 3,
  "sources": ["../../../src/services/agentic-flow-hooks/memory-hooks.ts"],
  "sourcesContent": ["/**\n * Memory persistence hooks for agentic-flow\n * \n * Provides cross-provider memory state management with\n * synchronization and persistence capabilities.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  MemoryHookPayload,\n  SideEffect,\n} from './types.js';\n\n// ===== Pre-Memory Store Hook =====\n\nexport const preMemoryStoreHook = {\n  id: 'agentic-pre-memory-store',\n  type: 'pre-memory-store' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key, value, ttl, provider } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate memory constraints\n    const validation = await validateMemoryStore(namespace, key, value, context);\n    if (!validation.valid) {\n      return {\n        continue: false,\n        sideEffects: [\n          {\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'error',\n              message: 'Memory store validation failed',\n              data: validation,\n            },\n          },\n        ],\n      };\n    }\n    \n    // Compress large values\n    let processedValue = value;\n    if (shouldCompress(value)) {\n      processedValue = await compressValue(value);\n      sideEffects.push({\n        type: 'metric',\n        action: 'increment',\n        data: { name: 'memory.compressions' },\n      });\n    }\n    \n    // Add metadata\n    const enrichedValue = {\n      data: processedValue,\n      metadata: {\n        stored: Date.now(),\n        provider,\n        sessionId: context.sessionId,\n        compressed: processedValue !== value,\n        size: getValueSize(processedValue),\n      },\n    };\n    \n    // Track memory usage\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `memory.usage.${namespace}`,\n        value: getValueSize(enrichedValue),\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        value: enrichedValue,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Post-Memory Store Hook =====\n\nexport const postMemoryStoreHook = {\n  id: 'agentic-post-memory-store',\n  type: 'post-memory-store' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key, value, crossProvider, syncTargets } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Cross-provider sync if enabled\n    if (crossProvider && syncTargets && syncTargets.length > 0) {\n      for (const target of syncTargets) {\n        sideEffects.push({\n          type: 'memory',\n          action: 'sync',\n          data: {\n            source: payload.provider,\n            target,\n            namespace,\n            key,\n            value,\n          },\n        });\n      }\n    }\n    \n    // Update memory index for search\n    await updateMemoryIndex(namespace, key, value, context);\n    \n    // Neural pattern detection\n    const patterns = await detectMemoryPatterns(namespace, key, value, context);\n    if (patterns.length > 0) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'analyze',\n        data: {\n          patterns,\n          context: { namespace, key },\n        },\n      });\n    }\n    \n    // Emit memory change event\n    sideEffects.push({\n      type: 'notification',\n      action: 'emit',\n      data: {\n        event: 'memory:stored',\n        data: { namespace, key, size: getValueSize(value) },\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Pre-Memory Retrieve Hook =====\n\nexport const preMemoryRetrieveHook = {\n  id: 'agentic-pre-memory-retrieve',\n  type: 'pre-memory-retrieve' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key } = payload;\n    \n    // Check local cache first\n    const cached = await checkLocalCache(namespace, key!, context);\n    if (cached) {\n      return {\n        continue: false,\n        modified: true,\n        payload: {\n          ...payload,\n          value: cached,\n        },\n        sideEffects: [\n          {\n            type: 'metric',\n            action: 'increment',\n            data: { name: 'memory.cache.hits' },\n          },\n        ],\n      };\n    }\n    \n    // Pre-fetch related keys\n    const relatedKeys = await findRelatedKeys(namespace, key!, context);\n    if (relatedKeys.length > 0) {\n      // Trigger background fetch\n      prefetchKeys(namespace, relatedKeys, context);\n    }\n    \n    return {\n      continue: true,\n      sideEffects: [\n        {\n          type: 'metric',\n          action: 'increment',\n          data: { name: `memory.retrievals.${namespace}` },\n        },\n      ],\n    };\n  },\n};\n\n// ===== Post-Memory Retrieve Hook =====\n\nexport const postMemoryRetrieveHook = {\n  id: 'agentic-post-memory-retrieve',\n  type: 'post-memory-retrieve' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key, value } = payload;\n    \n    if (!value) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Decompress if needed\n    let processedValue = value;\n    if (value.metadata?.compressed) {\n      processedValue = await decompressValue(value.data);\n      sideEffects.push({\n        type: 'metric',\n        action: 'increment',\n        data: { name: 'memory.decompressions' },\n      });\n    }\n    \n    // Update access patterns\n    await updateAccessPattern(namespace, key!, context);\n    \n    // Cache locally for fast access\n    await cacheLocally(namespace, key!, processedValue, context);\n    \n    // Track retrieval latency\n    const latency = Date.now() - context.timestamp;\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `memory.latency.${namespace}`,\n        value: latency,\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        value: processedValue.data || processedValue,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Memory Sync Hook =====\n\nexport const memorySyncHook = {\n  id: 'agentic-memory-sync',\n  type: 'memory-sync' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { operation, namespace, provider, syncTargets } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    switch (operation) {\n      case 'sync':\n        // Bidirectional sync\n        const changes = await detectMemoryChanges(namespace, provider, context);\n        \n        if (changes.length > 0) {\n          sideEffects.push({\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'info',\n              message: `Syncing ${changes.length} memory changes`,\n              data: { namespace, provider, targets: syncTargets },\n            },\n          });\n          \n          // Apply changes\n          for (const change of changes) {\n            await applyMemoryChange(change, syncTargets || [], context);\n          }\n          \n          sideEffects.push({\n            type: 'metric',\n            action: 'update',\n            data: {\n              name: 'memory.sync.changes',\n              value: changes.length,\n            },\n          });\n        }\n        break;\n        \n      case 'persist':\n        // Persist to long-term storage\n        const snapshot = await createMemorySnapshot(namespace, context);\n        \n        sideEffects.push({\n          type: 'memory',\n          action: 'store',\n          data: {\n            key: `snapshot:${namespace}:${Date.now()}`,\n            value: snapshot,\n            ttl: 0, // No expiration\n          },\n        });\n        \n        sideEffects.push({\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'memory:persisted',\n            data: { namespace, size: snapshot.size },\n          },\n        });\n        break;\n        \n      case 'expire':\n        // Clean up expired entries\n        const expired = await findExpiredEntries(namespace, context);\n        \n        if (expired.length > 0) {\n          for (const key of expired) {\n            await removeMemoryEntry(namespace, key, context);\n          }\n          \n          sideEffects.push({\n            type: 'metric',\n            action: 'update',\n            data: {\n              name: 'memory.expired',\n              value: expired.length,\n            },\n          });\n        }\n        break;\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Memory Persist Hook =====\n\nexport const memoryPersistHook = {\n  id: 'agentic-memory-persist',\n  type: 'memory-persist' as const,\n  priority: 90,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace } = payload;\n    \n    // Create full memory backup\n    const backup = await createFullBackup(namespace, context);\n    \n    // Store backup with metadata\n    const backupData = {\n      timestamp: Date.now(),\n      sessionId: context.sessionId,\n      namespace,\n      entries: backup.entries,\n      size: backup.size,\n      checksum: calculateChecksum(backup),\n    };\n    \n    return {\n      continue: true,\n      sideEffects: [\n        {\n          type: 'memory',\n          action: 'store',\n          data: {\n            key: `backup:${namespace}:${context.sessionId}`,\n            value: backupData,\n            ttl: 604800, // 7 days\n          },\n        },\n        {\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'memory:backup:created',\n            data: {\n              namespace,\n              size: backup.size,\n              entries: backup.entries.length,\n            },\n          },\n        },\n      ],\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nasync function validateMemoryStore(\n  namespace: string,\n  key: string | undefined,\n  value: any,\n  context: AgenticHookContext\n): Promise<{ valid: boolean; reason?: string }> {\n  // Check size limits\n  const size = getValueSize(value);\n  const maxSize = 10 * 1024 * 1024; // 10MB\n  \n  if (size > maxSize) {\n    return {\n      valid: false,\n      reason: `Value size ${size} exceeds limit ${maxSize}`,\n    };\n  }\n  \n  // Check namespace quota\n  const quota = await getNamespaceQuota(namespace, context);\n  const usage = await getNamespaceUsage(namespace, context);\n  \n  if (usage + size > quota) {\n    return {\n      valid: false,\n      reason: `Namespace quota exceeded: ${usage + size} > ${quota}`,\n    };\n  }\n  \n  // Validate key format\n  if (key && !isValidKey(key)) {\n    return {\n      valid: false,\n      reason: `Invalid key format: ${key}`,\n    };\n  }\n  \n  return { valid: true };\n}\n\nfunction shouldCompress(value: any): boolean {\n  const size = getValueSize(value);\n  return size > 1024; // Compress if larger than 1KB\n}\n\nasync function compressValue(value: any): Promise<any> {\n  // Implement compression (placeholder)\n  // In real implementation, use zlib or similar\n  return {\n    compressed: true,\n    data: JSON.stringify(value),\n  };\n}\n\nasync function decompressValue(value: any): Promise<any> {\n  // Implement decompression (placeholder)\n  if (value.compressed) {\n    return JSON.parse(value.data);\n  }\n  return value;\n}\n\nfunction getValueSize(value: any): number {\n  return Buffer.byteLength(JSON.stringify(value), 'utf8');\n}\n\nasync function updateMemoryIndex(\n  namespace: string,\n  key: string,\n  value: any,\n  context: AgenticHookContext\n): Promise<void> {\n  // Update search index (placeholder)\n  // In real implementation, update inverted index for search\n}\n\nasync function detectMemoryPatterns(\n  namespace: string,\n  key: string,\n  value: any,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Detect patterns in memory usage\n  const patterns = [];\n  \n  // Check for sequential access pattern\n  const accessHistory = await getAccessHistory(namespace, context);\n  if (isSequentialPattern(accessHistory)) {\n    patterns.push({\n      type: 'sequential',\n      confidence: 0.8,\n      suggestion: 'prefetch-next',\n    });\n  }\n  \n  // Check for temporal patterns\n  if (isTemporalPattern(accessHistory)) {\n    patterns.push({\n      type: 'temporal',\n      confidence: 0.7,\n      suggestion: 'cache-duration',\n    });\n  }\n  \n  return patterns;\n}\n\nasync function checkLocalCache(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<any | null> {\n  const cacheKey = `${namespace}:${key}`;\n  return context.memory.cache.get(cacheKey);\n}\n\nasync function findRelatedKeys(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<string[]> {\n  // Find related keys based on patterns\n  // Placeholder implementation\n  return [];\n}\n\nasync function prefetchKeys(\n  namespace: string,\n  keys: string[],\n  context: AgenticHookContext\n): Promise<void> {\n  // Trigger background prefetch\n  // Placeholder implementation\n}\n\nasync function updateAccessPattern(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Track access patterns for optimization\n  const patternKey = `pattern:${namespace}:${key}`;\n  const pattern = await context.memory.cache.get(patternKey) || {\n    accesses: [],\n    lastAccess: 0,\n  };\n  \n  pattern.accesses.push(Date.now());\n  pattern.lastAccess = Date.now();\n  \n  // Keep last 100 accesses\n  if (pattern.accesses.length > 100) {\n    pattern.accesses = pattern.accesses.slice(-100);\n  }\n  \n  await context.memory.cache.set(patternKey, pattern);\n}\n\nasync function cacheLocally(\n  namespace: string,\n  key: string,\n  value: any,\n  context: AgenticHookContext\n): Promise<void> {\n  const cacheKey = `${namespace}:${key}`;\n  context.memory.cache.set(cacheKey, value);\n}\n\nasync function detectMemoryChanges(\n  namespace: string,\n  provider: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Detect changes for sync\n  // Placeholder implementation\n  return [];\n}\n\nasync function applyMemoryChange(\n  change: any,\n  targets: string[],\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply memory change to targets\n  // Placeholder implementation\n}\n\nasync function createMemorySnapshot(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<any> {\n  // Create snapshot of namespace\n  // Placeholder implementation\n  return {\n    namespace,\n    timestamp: Date.now(),\n    entries: [],\n    size: 0,\n  };\n}\n\nasync function findExpiredEntries(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<string[]> {\n  // Find expired entries\n  // Placeholder implementation\n  return [];\n}\n\nasync function removeMemoryEntry(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Remove memory entry\n  // Placeholder implementation\n}\n\nasync function createFullBackup(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<any> {\n  // Create full backup\n  // Placeholder implementation\n  return {\n    entries: [],\n    size: 0,\n  };\n}\n\nfunction calculateChecksum(data: any): string {\n  // Calculate checksum\n  // Placeholder implementation\n  return 'checksum';\n}\n\nasync function getNamespaceQuota(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<number> {\n  // Get namespace quota\n  return 100 * 1024 * 1024; // 100MB default\n}\n\nasync function getNamespaceUsage(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<number> {\n  // Get current usage\n  // Placeholder implementation\n  return 0;\n}\n\nfunction isValidKey(key: string): boolean {\n  // Validate key format\n  return /^[a-zA-Z0-9:_\\-./]+$/.test(key);\n}\n\nasync function getAccessHistory(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Get access history\n  // Placeholder implementation\n  return [];\n}\n\nfunction isSequentialPattern(history: any[]): boolean {\n  // Check for sequential access\n  // Placeholder implementation\n  return false;\n}\n\nfunction isTemporalPattern(history: any[]): boolean {\n  // Check for temporal patterns\n  // Placeholder implementation\n  return false;\n}\n\n// ===== Register Hooks =====\n\nexport function registerMemoryHooks(): void {\n  agenticHookManager.register(preMemoryStoreHook);\n  agenticHookManager.register(postMemoryStoreHook);\n  agenticHookManager.register(preMemoryRetrieveHook);\n  agenticHookManager.register(postMemoryRetrieveHook);\n  agenticHookManager.register(memorySyncHook);\n  agenticHookManager.register(memoryPersistHook);\n}"],
  "mappings": "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",
  "names": []
}
