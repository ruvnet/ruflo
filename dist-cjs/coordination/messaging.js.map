{
  "version": 3,
  "sources": ["../../src/coordination/messaging.ts"],
  "sourcesContent": ["/**\n * Inter-agent messaging system\n */\n\nimport { Message, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport type { CoordinationError } from '../utils/errors.js';\nimport { generateId, timeout as timeoutHelper } from '../utils/helpers.js';\n\ninterface MessageQueue {\n  messages: Message[];\n  handlers: Map<string, (message: Message) => void>;\n}\n\ninterface PendingResponse {\n  resolve: (response: unknown) => void;\n  reject: (error: Error) => void;\n  timeout: number;\n}\n\n/**\n * Message router for inter-agent communication\n */\nexport class MessageRouter {\n  private queues = new Map<string, MessageQueue>(); // agentId -> queue\n  private pendingResponses = new Map<string, PendingResponse>();\n  private messageCount = 0;\n\n  constructor(\n    private config: CoordinationConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing message router');\n\n    // Set up periodic cleanup\n    setInterval(() => this.cleanup(), 60000); // Every minute\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down message router');\n\n    // Reject all pending responses\n    for (const [id, pending] of this.pendingResponses) {\n      pending.reject(new Error('Message router shutdown'));\n      clearTimeout(pending.timeout);\n    }\n\n    this.queues.clear();\n    this.pendingResponses.clear();\n  }\n\n  async send(from: string, to: string, payload: unknown): Promise<void> {\n    const message: Message = {\n      id: generateId('msg'),\n      type: 'agent-message',\n      payload,\n      timestamp: new Date(),\n      priority: 0,\n    };\n\n    await this.sendMessage(from, to, message);\n  }\n\n  async sendWithResponse<T = unknown>(\n    from: string,\n    to: string,\n    payload: unknown,\n    timeoutMs?: number,\n  ): Promise<T> {\n    const message: Message = {\n      id: generateId('msg'),\n      type: 'agent-request',\n      payload,\n      timestamp: new Date(),\n      priority: 1,\n    };\n\n    // Create response promise\n    const responsePromise = new Promise<T>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingResponses.delete(message.id);\n        reject(new Error(`Message response timeout: ${message.id}`));\n      }, timeoutMs || this.config.messageTimeout);\n\n      this.pendingResponses.set(message.id, {\n        resolve: resolve as (response: unknown) => void,\n        reject,\n        timeout: timeout as unknown as number,\n      });\n    });\n\n    // Send message\n    await this.sendMessage(from, to, message);\n\n    // Wait for response\n    return await responsePromise;\n  }\n\n  async broadcast(from: string, payload: unknown): Promise<void> {\n    const message: Message = {\n      id: generateId('broadcast'),\n      type: 'broadcast',\n      payload,\n      timestamp: new Date(),\n      priority: 0,\n    };\n\n    // Send to all agents\n    const agents = Array.from(this.queues.keys()).filter((id) => id !== from);\n\n    await Promise.all(agents.map((to) => this.sendMessage(from, to, message)));\n  }\n\n  subscribe(agentId: string, handler: (message: Message) => void): void {\n    const queue = this.ensureQueue(agentId);\n    queue.handlers.set(generateId('handler'), handler);\n  }\n\n  unsubscribe(agentId: string, handlerId: string): void {\n    const queue = this.queues.get(agentId);\n    if (queue) {\n      queue.handlers.delete(handlerId);\n    }\n  }\n\n  async sendResponse(originalMessageId: string, response: unknown): Promise<void> {\n    const pending = this.pendingResponses.get(originalMessageId);\n    if (!pending) {\n      this.logger.warn('No pending response found', { messageId: originalMessageId });\n      return;\n    }\n\n    clearTimeout(pending.timeout);\n    this.pendingResponses.delete(originalMessageId);\n    pending.resolve(response);\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const totalQueues = this.queues.size;\n    let totalMessages = 0;\n    let totalHandlers = 0;\n\n    for (const queue of this.queues.values()) {\n      totalMessages += queue.messages.length;\n      totalHandlers += queue.handlers.size;\n    }\n\n    return {\n      healthy: true,\n      metrics: {\n        activeQueues: totalQueues,\n        pendingMessages: totalMessages,\n        registeredHandlers: totalHandlers,\n        pendingResponses: this.pendingResponses.size,\n        totalMessagesSent: this.messageCount,\n      },\n    };\n  }\n\n  private async sendMessage(from: string, to: string, message: Message): Promise<void> {\n    this.logger.debug('Sending message', {\n      from,\n      to,\n      messageId: message.id,\n      type: message.type,\n    });\n\n    // Ensure destination queue exists\n    const queue = this.ensureQueue(to);\n\n    // Add to queue\n    queue.messages.push(message);\n    this.messageCount++;\n\n    // Emit event\n    this.eventBus.emit(SystemEvents.MESSAGE_SENT, { from, to, message });\n\n    // Process message immediately if handlers exist\n    if (queue.handlers.size > 0) {\n      await this.processMessage(to, message);\n    }\n  }\n\n  private async processMessage(agentId: string, message: Message): Promise<void> {\n    const queue = this.queues.get(agentId);\n    if (!queue) {\n      return;\n    }\n\n    // Remove message from queue\n    const index = queue.messages.indexOf(message);\n    if (index !== -1) {\n      queue.messages.splice(index, 1);\n    }\n\n    // Call all handlers\n    const handlers = Array.from(queue.handlers.values());\n    await Promise.all(\n      handlers.map((handler) => {\n        try {\n          handler(message);\n        } catch (error) {\n          this.logger.error('Message handler error', {\n            agentId,\n            messageId: message.id,\n            error,\n          });\n        }\n      }),\n    );\n\n    // Emit received event\n    this.eventBus.emit(SystemEvents.MESSAGE_RECEIVED, {\n      from: '', // Would need to track this\n      to: agentId,\n      message,\n    });\n  }\n\n  private ensureQueue(agentId: string): MessageQueue {\n    if (!this.queues.has(agentId)) {\n      this.queues.set(agentId, {\n        messages: [],\n        handlers: new Map(),\n      });\n    }\n    return this.queues.get(agentId)!;\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing message router maintenance');\n    this.cleanup();\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n\n    // Clean up old messages\n    for (const [agentId, queue] of this.queues) {\n      const filtered = queue.messages.filter((msg) => {\n        const age = now - msg.timestamp.getTime();\n        const maxAge = msg.expiry\n          ? msg.expiry.getTime() - msg.timestamp.getTime()\n          : this.config.messageTimeout;\n\n        if (age > maxAge) {\n          this.logger.warn('Dropping expired message', {\n            agentId,\n            messageId: msg.id,\n            age,\n          });\n          return false;\n        }\n        return true;\n      });\n\n      queue.messages = filtered;\n\n      // Remove empty queues\n      if (queue.messages.length === 0 && queue.handlers.size === 0) {\n        this.queues.delete(agentId);\n      }\n    }\n\n    // Clean up timed out responses\n    for (const [id, pending] of this.pendingResponses) {\n      // This is handled by the timeout, but double-check\n      clearTimeout(pending.timeout);\n      pending.reject(new Error('Response timeout during cleanup'));\n    }\n    this.pendingResponses.clear();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
