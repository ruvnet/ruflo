{"version":3,"sources":["../../../src/swarm/prompt-copier-enhanced.ts"],"sourcesContent":["import { dirname } from 'node:path';\r\nimport { fileURLToPath } from 'node:url';\r\nconst __dirname = dirname(fileURLToPath(import.meta.url));\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport { Worker } from 'worker_threads';\r\nimport { PromptCopier } from './prompt-copier.js';\r\nimport type { CopyOptions, CopyResult, FileInfo } from './prompt-copier.js';\r\nimport { logger } from '../core/logger.js';\r\n\r\ninterface WorkerPool {\r\n  workers: Worker[];\r\n  busy: Set<number>;\r\n  queue: Array<() => void>;\r\n}\r\n\r\nexport class EnhancedPromptCopier extends PromptCopier {\r\n  private workerPool?: WorkerPool;\r\n  private workerResults: Map<string, any> = new Map();\r\n\r\n  constructor(options: CopyOptions) {\r\n    super(options);\r\n  }\r\n\r\n  public async copyFilesParallel(): Promise<void> {\r\n    const workerCount = Math.min((this as any).options.maxWorkers, (this as any).fileQueue.length);\r\n\r\n    // Initialize worker pool\r\n    this.workerPool = await this.initializeWorkerPool(workerCount);\r\n\r\n    try {\r\n      // Process files using worker pool\r\n      await this.processWithWorkerPool();\r\n    } finally {\r\n      // Cleanup workers\r\n      await this.terminateWorkers();\r\n    }\r\n  }\r\n\r\n  private async initializeWorkerPool(workerCount: number): Promise<WorkerPool> {\r\n    const workers: Worker[] = [];\r\n    const pool: WorkerPool = {\r\n      workers,\r\n      busy: new Set(),\r\n      queue: [],\r\n    };\r\n\r\n    // Create workers\r\n    for (let i = 0; i < workerCount; i++) {\r\n      const worker = new Worker(path.join(__dirname, 'workers', 'copy-worker.js'), {\r\n        workerData: { workerId: i },\r\n      });\r\n\r\n      // Setup worker message handler\r\n      worker.on('message', (result) => {\r\n        this.handleWorkerResult(result, i, pool);\r\n      });\r\n\r\n      worker.on('error', (error) => {\r\n        logger.error(`Worker ${i} error:`, error);\r\n        (this as any).errors.push({\r\n          file: 'worker',\r\n          error: error instanceof Error ? error.message : String(error),\r\n          phase: 'write',\r\n        });\r\n      });\r\n\r\n      workers.push(worker);\r\n    }\r\n\r\n    return pool;\r\n  }\r\n\r\n  private async processWithWorkerPool(): Promise<void> {\r\n    const chunkSize = Math.max(\r\n      1,\r\n      Math.floor((this as any).fileQueue.length / this.workerPool!.workers.length / 2),\r\n    );\r\n    const chunks: FileInfo[][] = [];\r\n\r\n    // Create chunks for better distribution\r\n    for (let i = 0; i < (this as any).fileQueue.length; i += chunkSize) {\r\n      chunks.push((this as any).fileQueue.slice(i, i + chunkSize));\r\n    }\r\n\r\n    // Process chunks\r\n    const promises: Promise<void>[] = [];\r\n\r\n    for (const chunk of chunks) {\r\n      promises.push(this.processChunkWithWorker(chunk));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n  }\r\n\r\n  private async processChunkWithWorker(chunk: FileInfo[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const pool = this.workerPool!;\r\n\r\n      const tryAssignWork = () => {\r\n        // Find available worker\r\n        const availableWorkerIndex = pool.workers.findIndex((_, index) => !pool.busy.has(index));\r\n\r\n        if (availableWorkerIndex === -1) {\r\n          // No workers available, queue the work\r\n          pool.queue.push(tryAssignWork);\r\n          return;\r\n        }\r\n\r\n        // Mark worker as busy\r\n        pool.busy.add(availableWorkerIndex);\r\n\r\n        // Prepare worker data\r\n        const workerData = {\r\n          files: chunk.map((file) => ({\r\n            sourcePath: file.path,\r\n            destPath: path.join((this as any).options.destination, file.relativePath),\r\n            permissions: (this as any).options.preservePermissions ? file.permissions : undefined,\r\n            verify: (this as any).options.verify,\r\n          })),\r\n          workerId: availableWorkerIndex,\r\n        };\r\n\r\n        let remainingFiles = chunk.length;\r\n        const chunkResults: any[] = [];\r\n\r\n        // Setup temporary message handler for this chunk\r\n        const messageHandler = (result: any) => {\r\n          chunkResults.push(result);\r\n          remainingFiles--;\r\n\r\n          if (remainingFiles === 0) {\r\n            // Chunk complete\r\n            pool.workers[availableWorkerIndex].off('message', messageHandler);\r\n            pool.busy.delete(availableWorkerIndex);\r\n\r\n            // Process next queued work\r\n            if (pool.queue.length > 0) {\r\n              const nextWork = pool.queue.shift()!;\r\n              nextWork();\r\n            }\r\n\r\n            // Process results\r\n            this.processChunkResults(chunk, chunkResults);\r\n            resolve();\r\n          }\r\n        };\r\n\r\n        pool.workers[availableWorkerIndex].on('message', messageHandler);\r\n        pool.workers[availableWorkerIndex].postMessage(workerData);\r\n      };\r\n\r\n      tryAssignWork();\r\n    });\r\n  }\r\n\r\n  private processChunkResults(chunk: FileInfo[], results: any[]): void {\r\n    for (const result of results) {\r\n      if (result.success) {\r\n        (this as any).copiedFiles.add(result.file);\r\n        if (result.hash) {\r\n          this.workerResults.set(result.file, { hash: result.hash });\r\n        }\r\n      } else {\r\n        (this as any).errors.push({\r\n          file: result.file,\r\n          error: result.error,\r\n          phase: 'write',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Report progress through the callback if available\r\n    if ((this as any).options.progressCallback) {\r\n      (this as any).options.progressCallback(\r\n        (this as any).copiedFiles.size,\r\n        (this as any).totalFiles,\r\n      );\r\n    }\r\n  }\r\n\r\n  private handleWorkerResult(result: any, workerId: number, pool: WorkerPool): void {\r\n    // This is a fallback handler, actual handling happens in processChunkWithWorker\r\n    logger.debug(`Worker ${workerId} result:`, result);\r\n  }\r\n\r\n  private async terminateWorkers(): Promise<void> {\r\n    if (!this.workerPool) return;\r\n\r\n    const terminationPromises = this.workerPool.workers.map((worker) => worker.terminate());\r\n\r\n    await Promise.all(terminationPromises);\r\n    this.workerPool = undefined;\r\n  }\r\n\r\n  // Override verification to use worker results\r\n  protected override async verifyFiles(): Promise<void> {\r\n    logger.info('Verifying copied files...');\r\n\r\n    for (const file of (this as any).fileQueue) {\r\n      if (!(this as any).copiedFiles.has(file.path)) continue;\r\n\r\n      try {\r\n        const destPath = path.join((this as any).options.destination, file.relativePath);\r\n\r\n        // Verify file exists\r\n        if (!(await (this as any).fileExists(destPath))) {\r\n          throw new Error('Destination file not found');\r\n        }\r\n\r\n        // Verify size\r\n        const destStats = await fs.stat(destPath);\r\n        const sourceStats = await fs.stat(file.path);\r\n\r\n        if (destStats.size !== sourceStats.size) {\r\n          throw new Error(`Size mismatch: ${destStats.size} != ${sourceStats.size}`);\r\n        }\r\n\r\n        // Use hash from worker if available\r\n        const workerResult = this.workerResults.get(file.path);\r\n        if (workerResult?.hash) {\r\n          const sourceHash = await (this as any).calculateFileHash(file.path);\r\n          if (sourceHash !== workerResult.hash) {\r\n            throw new Error(`Hash mismatch: ${sourceHash} != ${workerResult.hash}`);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        (this as any).errors.push({\r\n          file: file.path,\r\n          error: error instanceof Error ? error.message : String(error),\r\n          phase: 'verify',\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Export enhanced copy function\r\nexport async function copyPromptsEnhanced(options: CopyOptions): Promise<CopyResult> {\r\n  const copier = new EnhancedPromptCopier(options);\r\n  return copier.copy();\r\n}\r\n"],"names":["dirname","fileURLToPath","__dirname","url","fs","path","Worker","PromptCopier","logger","EnhancedPromptCopier","workerPool","workerResults","Map","options","copyFilesParallel","workerCount","Math","min","maxWorkers","fileQueue","length","initializeWorkerPool","processWithWorkerPool","terminateWorkers","workers","pool","busy","Set","queue","i","worker","join","workerData","workerId","on","result","handleWorkerResult","error","errors","push","file","Error","message","String","phase","chunkSize","max","floor","chunks","slice","promises","chunk","processChunkWithWorker","Promise","all","resolve","reject","tryAssignWork","availableWorkerIndex","findIndex","_","index","has","add","files","map","sourcePath","destPath","destination","relativePath","permissions","preservePermissions","undefined","verify","remainingFiles","chunkResults","messageHandler","off","delete","nextWork","shift","processChunkResults","postMessage","results","success","copiedFiles","hash","set","progressCallback","size","totalFiles","debug","terminationPromises","terminate","verifyFiles","info","fileExists","destStats","stat","sourceStats","workerResult","get","sourceHash","calculateFileHash","copyPromptsEnhanced","copier","copy"],"mappings":"AAAA,SAASA,OAAO,QAAQ,YAAY;AACpC,SAASC,aAAa,QAAQ,WAAW;AACzC,MAAMC,YAAYF,QAAQC,cAAc,YAAYE,GAAG;AACvD,YAAYC,QAAQ,cAAc;AAClC,YAAYC,UAAU,OAAO;AAC7B,SAASC,MAAM,QAAQ,iBAAiB;AACxC,SAASC,YAAY,QAAQ,qBAAqB;AAElD,SAASC,MAAM,QAAQ,oBAAoB;AAQ3C,OAAO,MAAMC,6BAA6BF;IAChCG,WAAwB;IACxBC,gBAAkC,IAAIC,MAAM;IAEpD,YAAYC,OAAoB,CAAE;QAChC,KAAK,CAACA;IACR;IAEA,MAAaC,oBAAmC;QAC9C,MAAMC,cAAcC,KAAKC,GAAG,CAAC,AAAC,IAAI,CAASJ,OAAO,CAACK,UAAU,EAAE,AAAC,IAAI,CAASC,SAAS,CAACC,MAAM;QAG7F,IAAI,CAACV,UAAU,GAAG,MAAM,IAAI,CAACW,oBAAoB,CAACN;QAElD,IAAI;YAEF,MAAM,IAAI,CAACO,qBAAqB;QAClC,SAAU;YAER,MAAM,IAAI,CAACC,gBAAgB;QAC7B;IACF;IAEA,MAAcF,qBAAqBN,WAAmB,EAAuB;QAC3E,MAAMS,UAAoB,EAAE;QAC5B,MAAMC,OAAmB;YACvBD;YACAE,MAAM,IAAIC;YACVC,OAAO,EAAE;QACX;QAGA,IAAK,IAAIC,IAAI,GAAGA,IAAId,aAAac,IAAK;YACpC,MAAMC,SAAS,IAAIxB,OAAOD,KAAK0B,IAAI,CAAC7B,WAAW,WAAW,mBAAmB;gBAC3E8B,YAAY;oBAAEC,UAAUJ;gBAAE;YAC5B;YAGAC,OAAOI,EAAE,CAAC,WAAW,CAACC;gBACpB,IAAI,CAACC,kBAAkB,CAACD,QAAQN,GAAGJ;YACrC;YAEAK,OAAOI,EAAE,CAAC,SAAS,CAACG;gBAClB7B,OAAO6B,KAAK,CAAC,CAAC,OAAO,EAAER,EAAE,OAAO,CAAC,EAAEQ;gBACnC,AAAC,IAAI,CAASC,MAAM,CAACC,IAAI,CAAC;oBACxBC,MAAM;oBACNH,OAAOA,iBAAiBI,QAAQJ,MAAMK,OAAO,GAAGC,OAAON;oBACvDO,OAAO;gBACT;YACF;YAEApB,QAAQe,IAAI,CAACT;QACf;QAEA,OAAOL;IACT;IAEA,MAAcH,wBAAuC;QACnD,MAAMuB,YAAY7B,KAAK8B,GAAG,CACxB,GACA9B,KAAK+B,KAAK,CAAC,AAAC,IAAI,CAAS5B,SAAS,CAACC,MAAM,GAAG,IAAI,CAACV,UAAU,CAAEc,OAAO,CAACJ,MAAM,GAAG;QAEhF,MAAM4B,SAAuB,EAAE;QAG/B,IAAK,IAAInB,IAAI,GAAGA,IAAI,AAAC,IAAI,CAASV,SAAS,CAACC,MAAM,EAAES,KAAKgB,UAAW;YAClEG,OAAOT,IAAI,CAAC,AAAC,IAAI,CAASpB,SAAS,CAAC8B,KAAK,CAACpB,GAAGA,IAAIgB;QACnD;QAGA,MAAMK,WAA4B,EAAE;QAEpC,KAAK,MAAMC,SAASH,OAAQ;YAC1BE,SAASX,IAAI,CAAC,IAAI,CAACa,sBAAsB,CAACD;QAC5C;QAEA,MAAME,QAAQC,GAAG,CAACJ;IACpB;IAEA,MAAcE,uBAAuBD,KAAiB,EAAiB;QACrE,OAAO,IAAIE,QAAQ,CAACE,SAASC;YAC3B,MAAM/B,OAAO,IAAI,CAACf,UAAU;YAE5B,MAAM+C,gBAAgB;gBAEpB,MAAMC,uBAAuBjC,KAAKD,OAAO,CAACmC,SAAS,CAAC,CAACC,GAAGC,QAAU,CAACpC,KAAKC,IAAI,CAACoC,GAAG,CAACD;gBAEjF,IAAIH,yBAAyB,CAAC,GAAG;oBAE/BjC,KAAKG,KAAK,CAACW,IAAI,CAACkB;oBAChB;gBACF;gBAGAhC,KAAKC,IAAI,CAACqC,GAAG,CAACL;gBAGd,MAAM1B,aAAa;oBACjBgC,OAAOb,MAAMc,GAAG,CAAC,CAACzB,OAAU,CAAA;4BAC1B0B,YAAY1B,KAAKnC,IAAI;4BACrB8D,UAAU9D,KAAK0B,IAAI,CAAC,AAAC,IAAI,CAASlB,OAAO,CAACuD,WAAW,EAAE5B,KAAK6B,YAAY;4BACxEC,aAAa,AAAC,IAAI,CAASzD,OAAO,CAAC0D,mBAAmB,GAAG/B,KAAK8B,WAAW,GAAGE;4BAC5EC,QAAQ,AAAC,IAAI,CAAS5D,OAAO,CAAC4D,MAAM;wBACtC,CAAA;oBACAxC,UAAUyB;gBACZ;gBAEA,IAAIgB,iBAAiBvB,MAAM/B,MAAM;gBACjC,MAAMuD,eAAsB,EAAE;gBAG9B,MAAMC,iBAAiB,CAACzC;oBACtBwC,aAAapC,IAAI,CAACJ;oBAClBuC;oBAEA,IAAIA,mBAAmB,GAAG;wBAExBjD,KAAKD,OAAO,CAACkC,qBAAqB,CAACmB,GAAG,CAAC,WAAWD;wBAClDnD,KAAKC,IAAI,CAACoD,MAAM,CAACpB;wBAGjB,IAAIjC,KAAKG,KAAK,CAACR,MAAM,GAAG,GAAG;4BACzB,MAAM2D,WAAWtD,KAAKG,KAAK,CAACoD,KAAK;4BACjCD;wBACF;wBAGA,IAAI,CAACE,mBAAmB,CAAC9B,OAAOwB;wBAChCpB;oBACF;gBACF;gBAEA9B,KAAKD,OAAO,CAACkC,qBAAqB,CAACxB,EAAE,CAAC,WAAW0C;gBACjDnD,KAAKD,OAAO,CAACkC,qBAAqB,CAACwB,WAAW,CAAClD;YACjD;YAEAyB;QACF;IACF;IAEQwB,oBAAoB9B,KAAiB,EAAEgC,OAAc,EAAQ;QACnE,KAAK,MAAMhD,UAAUgD,QAAS;YAC5B,IAAIhD,OAAOiD,OAAO,EAAE;gBAClB,AAAC,IAAI,CAASC,WAAW,CAACtB,GAAG,CAAC5B,OAAOK,IAAI;gBACzC,IAAIL,OAAOmD,IAAI,EAAE;oBACf,IAAI,CAAC3E,aAAa,CAAC4E,GAAG,CAACpD,OAAOK,IAAI,EAAE;wBAAE8C,MAAMnD,OAAOmD,IAAI;oBAAC;gBAC1D;YACF,OAAO;gBACL,AAAC,IAAI,CAAShD,MAAM,CAACC,IAAI,CAAC;oBACxBC,MAAML,OAAOK,IAAI;oBACjBH,OAAOF,OAAOE,KAAK;oBACnBO,OAAO;gBACT;YACF;QACF;QAGA,IAAI,AAAC,IAAI,CAAS/B,OAAO,CAAC2E,gBAAgB,EAAE;YAC1C,AAAC,IAAI,CAAS3E,OAAO,CAAC2E,gBAAgB,CACpC,AAAC,IAAI,CAASH,WAAW,CAACI,IAAI,EAC9B,AAAC,IAAI,CAASC,UAAU;QAE5B;IACF;IAEQtD,mBAAmBD,MAAW,EAAEF,QAAgB,EAAER,IAAgB,EAAQ;QAEhFjB,OAAOmF,KAAK,CAAC,CAAC,OAAO,EAAE1D,SAAS,QAAQ,CAAC,EAAEE;IAC7C;IAEA,MAAcZ,mBAAkC;QAC9C,IAAI,CAAC,IAAI,CAACb,UAAU,EAAE;QAEtB,MAAMkF,sBAAsB,IAAI,CAAClF,UAAU,CAACc,OAAO,CAACyC,GAAG,CAAC,CAACnC,SAAWA,OAAO+D,SAAS;QAEpF,MAAMxC,QAAQC,GAAG,CAACsC;QAClB,IAAI,CAAClF,UAAU,GAAG8D;IACpB;IAGA,MAAyBsB,cAA6B;QACpDtF,OAAOuF,IAAI,CAAC;QAEZ,KAAK,MAAMvD,QAAQ,AAAC,IAAI,CAASrB,SAAS,CAAE;YAC1C,IAAI,CAAC,AAAC,IAAI,CAASkE,WAAW,CAACvB,GAAG,CAACtB,KAAKnC,IAAI,GAAG;YAE/C,IAAI;gBACF,MAAM8D,WAAW9D,KAAK0B,IAAI,CAAC,AAAC,IAAI,CAASlB,OAAO,CAACuD,WAAW,EAAE5B,KAAK6B,YAAY;gBAG/E,IAAI,CAAE,MAAM,AAAC,IAAI,CAAS2B,UAAU,CAAC7B,WAAY;oBAC/C,MAAM,IAAI1B,MAAM;gBAClB;gBAGA,MAAMwD,YAAY,MAAM7F,GAAG8F,IAAI,CAAC/B;gBAChC,MAAMgC,cAAc,MAAM/F,GAAG8F,IAAI,CAAC1D,KAAKnC,IAAI;gBAE3C,IAAI4F,UAAUR,IAAI,KAAKU,YAAYV,IAAI,EAAE;oBACvC,MAAM,IAAIhD,MAAM,CAAC,eAAe,EAAEwD,UAAUR,IAAI,CAAC,IAAI,EAAEU,YAAYV,IAAI,EAAE;gBAC3E;gBAGA,MAAMW,eAAe,IAAI,CAACzF,aAAa,CAAC0F,GAAG,CAAC7D,KAAKnC,IAAI;gBACrD,IAAI+F,cAAcd,MAAM;oBACtB,MAAMgB,aAAa,MAAM,AAAC,IAAI,CAASC,iBAAiB,CAAC/D,KAAKnC,IAAI;oBAClE,IAAIiG,eAAeF,aAAad,IAAI,EAAE;wBACpC,MAAM,IAAI7C,MAAM,CAAC,eAAe,EAAE6D,WAAW,IAAI,EAAEF,aAAad,IAAI,EAAE;oBACxE;gBACF;YACF,EAAE,OAAOjD,OAAO;gBACd,AAAC,IAAI,CAASC,MAAM,CAACC,IAAI,CAAC;oBACxBC,MAAMA,KAAKnC,IAAI;oBACfgC,OAAOA,iBAAiBI,QAAQJ,MAAMK,OAAO,GAAGC,OAAON;oBACvDO,OAAO;gBACT;YACF;QACF;IACF;AACF;AAGA,OAAO,eAAe4D,oBAAoB3F,OAAoB;IAC5D,MAAM4F,SAAS,IAAIhG,qBAAqBI;IACxC,OAAO4F,OAAOC,IAAI;AACpB"}