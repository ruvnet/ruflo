{"version":3,"sources":["../../../src/mcp/tool-filter-config.ts"],"sourcesContent":["/**\n * Tool Filter Configuration Loader\n *\n * Loads tool filter configuration from multiple sources:\n * 1. Dedicated config file (.claude-flow/mcp-tools.json)\n * 2. Alternative config files (.claude-flow/mcp-tools.yaml, mcp-tools.json)\n * 3. Environment variables\n *\n * Priority order (highest to lowest):\n * 1. Environment variables (override file config)\n * 2. Config files (first found wins)\n *\n * @module tool-filter-config\n */\n\n/*\n * ============================================================================\n * CONFIGURATION FILE FORMAT SUPPORT\n * ============================================================================\n *\n * JSON files (.json):\n *   - Full support for all configuration options\n *   - Recommended for complex configurations\n *   - Supports all nested structures, arrays, and data types\n *\n * YAML files (.yaml, .yml):\n *   - Full YAML 1.2 support via the 'yaml' library\n *   - Supports all standard YAML features including:\n *     - Multi-line strings (block scalars: | and >)\n *     - Anchors and aliases (&anchor, *alias)\n *     - Flow style collections ({key: value}, [item1, item2])\n *     - Tags (!!str, !!int, etc.)\n *     - Multiple documents (--- separator)\n *     - Complex keys\n *\n * Both formats work equally well. Choose based on your preference:\n *   - JSON: Stricter syntax, better IDE support, easier to validate\n *   - YAML: More human-readable, supports comments, less verbose\n *\n * Example YAML configuration:\n *   toolFilter:\n *     enabled: true\n *     mode: allowlist\n *     tools:\n *       - swarm_init\n *       - agent_spawn\n *     maxTools: 50\n *\n * Example JSON configuration:\n *   {\n *     \"toolFilter\": {\n *       \"enabled\": true,\n *       \"mode\": \"allowlist\",\n *       \"tools\": [\"swarm_init\", \"agent_spawn\"],\n *       \"maxTools\": 50\n *     }\n *   }\n * ============================================================================\n */\n\nimport { promises as fs } from 'node:fs';\nimport { join } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport type { MCPToolFilterConfig } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { validateGlobPattern, MAX_PATTERN_LENGTH } from './tool-filter.js';\n\n/**\n * Default paths to search for tool filter configuration files\n * Searched in order, first found wins\n */\nconst DEFAULT_CONFIG_PATHS = [\n  '.claude-flow/mcp-tools.json',\n  '.claude-flow/mcp-tools.yaml',\n  'mcp-tools.json',\n];\n\n/**\n * Result of loading tool filter configuration\n */\nexport interface LoadedToolFilterConfig {\n  /** The loaded configuration */\n  config: MCPToolFilterConfig;\n  /** Source of the configuration (file path or 'environment') */\n  source: string;\n}\n\n/**\n * Result of configuration validation\n */\nexport interface ConfigValidationResult {\n  /** Whether the configuration is valid (no errors) */\n  valid: boolean;\n  /** List of validation errors (invalid configuration) */\n  errors: string[];\n  /** List of warnings (valid but potentially problematic) */\n  warnings: string[];\n}\n\n/** Known properties in MCPToolFilterConfig */\nconst KNOWN_CONFIG_PROPERTIES = new Set([\n  'enabled',\n  'mode',\n  'tools',\n  'categories',\n  'maxTools',\n  'priorities',\n]);\n\n/** Maximum recommended number of patterns before performance warning */\nconst MAX_RECOMMENDED_PATTERNS = 100;\n\n/**\n * Validate tool filter configuration schema\n *\n * Performs comprehensive validation of the configuration structure and values.\n * Returns errors for invalid configurations and warnings for edge cases.\n *\n * @param config - The configuration to validate (unknown type for runtime validation)\n * @returns Validation result with errors and warnings\n */\nexport function validateToolFilterConfig(config: unknown): ConfigValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Must be an object\n  if (config === null || typeof config !== 'object') {\n    return {\n      valid: false,\n      errors: ['Configuration must be an object'],\n      warnings: [],\n    };\n  }\n\n  const configObj = config as Record<string, unknown>;\n\n  // Check for unknown properties\n  for (const key of Object.keys(configObj)) {\n    if (!KNOWN_CONFIG_PROPERTIES.has(key)) {\n      warnings.push(`Unknown property '${key}' will be ignored`);\n    }\n  }\n\n  // Validate 'enabled' - must be boolean if present\n  if ('enabled' in configObj && typeof configObj.enabled !== 'boolean') {\n    errors.push(`'enabled' must be a boolean, got ${typeof configObj.enabled}`);\n  }\n\n  // Validate 'mode' - must be 'allowlist' or 'denylist' if present\n  if ('mode' in configObj) {\n    if (configObj.mode !== 'allowlist' && configObj.mode !== 'denylist') {\n      errors.push(`'mode' must be 'allowlist' or 'denylist', got '${String(configObj.mode)}'`);\n    }\n  }\n\n  // Validate 'tools' - must be array of strings if present\n  if ('tools' in configObj) {\n    if (!Array.isArray(configObj.tools)) {\n      errors.push(`'tools' must be an array, got ${typeof configObj.tools}`);\n    } else {\n      // Check each element is a string\n      const nonStrings = configObj.tools\n        .map((t, i) => ({ value: t, index: i }))\n        .filter(({ value }) => typeof value !== 'string');\n\n      if (nonStrings.length > 0) {\n        const indices = nonStrings.map(({ index }) => index).join(', ');\n        errors.push(`'tools' array must contain only strings, non-string values at indices: ${indices}`);\n      }\n\n      // Validate each pattern for ReDoS protection\n      for (let i = 0; i < configObj.tools.length; i++) {\n        const pattern = configObj.tools[i];\n        if (typeof pattern === 'string') {\n          const validationResult = validateGlobPattern(pattern);\n          if (!validationResult.valid) {\n            warnings.push(`Tool pattern at index ${i} ('${pattern.substring(0, 50)}${pattern.length > 50 ? '...' : ''}'): ${validationResult.reason}`);\n          }\n        }\n      }\n\n      // Warn about empty tools array in allowlist mode\n      const mode = configObj.mode ?? 'allowlist';\n      if (configObj.tools.length === 0 && mode === 'allowlist') {\n        warnings.push(\"Empty 'tools' array in allowlist mode will match nothing\");\n      }\n\n      // Performance warning for large number of patterns\n      if (configObj.tools.length > MAX_RECOMMENDED_PATTERNS) {\n        warnings.push(\n          `Large number of tool patterns (${configObj.tools.length}) may impact performance. Consider using categories or wildcards.`\n        );\n      }\n    }\n  }\n\n  // Validate 'categories' - must be array of strings if present\n  if ('categories' in configObj) {\n    if (!Array.isArray(configObj.categories)) {\n      errors.push(`'categories' must be an array, got ${typeof configObj.categories}`);\n    } else {\n      // Check each element is a string\n      const nonStrings = configObj.categories\n        .map((c, i) => ({ value: c, index: i }))\n        .filter(({ value }) => typeof value !== 'string');\n\n      if (nonStrings.length > 0) {\n        const indices = nonStrings.map(({ index }) => index).join(', ');\n        errors.push(`'categories' array must contain only strings, non-string values at indices: ${indices}`);\n      }\n\n      // Validate each category for ReDoS protection\n      for (let i = 0; i < configObj.categories.length; i++) {\n        const category = configObj.categories[i];\n        if (typeof category === 'string') {\n          const validationResult = validateGlobPattern(category);\n          if (!validationResult.valid) {\n            warnings.push(`Category pattern at index ${i} ('${category.substring(0, 50)}${category.length > 50 ? '...' : ''}'): ${validationResult.reason}`);\n          }\n        }\n      }\n\n      // Performance warning for large number of categories\n      if (configObj.categories.length > MAX_RECOMMENDED_PATTERNS) {\n        warnings.push(\n          `Large number of category patterns (${configObj.categories.length}) may impact performance.`\n        );\n      }\n    }\n  }\n\n  // Validate 'maxTools' - must be positive integer if present\n  if ('maxTools' in configObj) {\n    const maxTools = configObj.maxTools;\n    if (typeof maxTools !== 'number') {\n      errors.push(`'maxTools' must be a number, got ${typeof maxTools}`);\n    } else if (!Number.isInteger(maxTools)) {\n      errors.push(`'maxTools' must be an integer, got ${maxTools}`);\n    } else if (maxTools <= 0) {\n      warnings.push(`'maxTools' is ${maxTools}, which will be ignored (must be positive)`);\n    }\n  }\n\n  // Validate 'priorities' - must be object with string keys and number values if present\n  if ('priorities' in configObj) {\n    const priorities = configObj.priorities;\n    if (priorities === null || typeof priorities !== 'object' || Array.isArray(priorities)) {\n      errors.push(`'priorities' must be an object, got ${Array.isArray(priorities) ? 'array' : typeof priorities}`);\n    } else {\n      const prioritiesObj = priorities as Record<string, unknown>;\n      for (const [key, value] of Object.entries(prioritiesObj)) {\n        if (typeof value !== 'number') {\n          errors.push(`'priorities.${key}' must be a number, got ${typeof value}`);\n        }\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * Default configuration when no config is found\n */\nconst DEFAULT_CONFIG: MCPToolFilterConfig = {\n  enabled: false,\n  mode: 'allowlist',\n  tools: [],\n};\n\n/**\n * Load tool filter configuration from multiple sources\n *\n * @param logger - Logger instance for debugging\n * @param workingDirectory - Base directory to search for config files (defaults to cwd)\n * @returns Loaded configuration or null if none found/disabled\n */\nexport async function loadToolFilterConfig(\n  logger: ILogger,\n  workingDirectory?: string\n): Promise<LoadedToolFilterConfig | null> {\n  const cwd = workingDirectory || process.cwd();\n\n  // First, try to load from config files\n  const fileConfig = await loadFromConfigFiles(cwd, logger);\n\n  // If we found a file config, optionally merge with env overrides\n  if (fileConfig) {\n    const envOverrides = loadEnvironmentOverrides();\n\n    // If env has explicit enabled setting, it overrides file\n    if (envOverrides.hasExplicitEnabled) {\n      fileConfig.config.enabled = envOverrides.config.enabled;\n    }\n\n    // Merge other env overrides if they exist\n    if (envOverrides.config.tools.length > 0) {\n      fileConfig.config.tools = envOverrides.config.tools;\n    }\n    if (envOverrides.config.maxTools !== undefined) {\n      fileConfig.config.maxTools = envOverrides.config.maxTools;\n    }\n    if (envOverrides.hasExplicitMode) {\n      fileConfig.config.mode = envOverrides.config.mode;\n    }\n\n    logger.debug('Tool filter config loaded', {\n      source: fileConfig.source,\n      enabled: fileConfig.config.enabled,\n      mode: fileConfig.config.mode,\n      toolCount: fileConfig.config.tools.length,\n    });\n\n    return fileConfig;\n  }\n\n  // No file config found, try environment-only configuration\n  const envConfig = loadFromEnvironment();\n  if (envConfig.enabled) {\n    logger.info('Tool filter config loaded from environment variables');\n    return {\n      config: envConfig,\n      source: 'environment',\n    };\n  }\n\n  // No configuration found\n  logger.debug('No tool filter configuration found, filtering disabled');\n  return null;\n}\n\n/**\n * Attempt to load configuration from config files\n */\nasync function loadFromConfigFiles(\n  cwd: string,\n  logger: ILogger\n): Promise<LoadedToolFilterConfig | null> {\n  for (const configPath of DEFAULT_CONFIG_PATHS) {\n    const fullPath = join(cwd, configPath);\n\n    try {\n      const content = await fs.readFile(fullPath, 'utf-8');\n      const parsed = parseConfigFile(content, configPath);\n\n      // Look for toolFilter in the parsed config\n      if (parsed.toolFilter) {\n        // Validate the configuration\n        const validation = validateToolFilterConfig(parsed.toolFilter);\n        logValidationResults(logger, validation, configPath);\n\n        if (!validation.valid) {\n          logger.error(`Invalid tool filter configuration in ${configPath}, using defaults`);\n          continue;\n        }\n\n        const config = validateAndNormalize(parsed.toolFilter, validation);\n        logger.info('Loaded tool filter config from file', { source: configPath });\n        return {\n          config,\n          source: configPath,\n        };\n      }\n\n      // Also support root-level config (entire file is the tool filter config)\n      if (parsed.enabled !== undefined && parsed.mode !== undefined) {\n        // Validate the configuration\n        const validation = validateToolFilterConfig(parsed);\n        logValidationResults(logger, validation, configPath);\n\n        if (!validation.valid) {\n          logger.error(`Invalid tool filter configuration in ${configPath}, using defaults`);\n          continue;\n        }\n\n        const config = validateAndNormalize(parsed, validation);\n        logger.info('Loaded tool filter config from file (root level)', { source: configPath });\n        return {\n          config,\n          source: configPath,\n        };\n      }\n    } catch (error) {\n      // File doesn't exist or can't be read, continue to next\n      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n        logger.warn(`Failed to parse config file: ${configPath}`, { error });\n      }\n      continue;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Log validation errors and warnings\n */\nfunction logValidationResults(\n  logger: ILogger,\n  validation: ConfigValidationResult,\n  source: string\n): void {\n  for (const error of validation.errors) {\n    logger.error(`Config validation error in ${source}: ${error}`);\n  }\n  for (const warning of validation.warnings) {\n    logger.warn(`Config validation warning in ${source}: ${warning}`);\n  }\n}\n\n/**\n * Parse configuration file based on extension\n *\n * Supports JSON and YAML formats. YAML parsing uses the full-featured 'yaml'\n * library which supports all YAML 1.2 features including:\n * - Multi-line strings (block scalars)\n * - Anchors and aliases\n * - Flow style collections\n * - Tags and custom types\n * - Multiple documents\n */\nfunction parseConfigFile(content: string, path: string): Record<string, unknown> {\n  if (path.endsWith('.json')) {\n    return JSON.parse(content);\n  }\n\n  if (path.endsWith('.yaml') || path.endsWith('.yml')) {\n    const parsed = parseYaml(content);\n    // Ensure we return an object (YAML can parse to primitives)\n    if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {\n      return {};\n    }\n    return parsed as Record<string, unknown>;\n  }\n\n  // Try JSON by default\n  return JSON.parse(content);\n}\n\n/**\n * Load configuration entirely from environment variables\n */\nfunction loadFromEnvironment(): MCPToolFilterConfig {\n  const enabled = process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_ENABLED === 'true';\n  const modeEnv = process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_MODE;\n  const mode: 'allowlist' | 'denylist' =\n    modeEnv === 'allowlist' || modeEnv === 'denylist' ? modeEnv : 'allowlist';\n  const toolsEnv = process.env.CLAUDE_FLOW_MCP_TOOLS_ALLOWED || '';\n  const tools = toolsEnv\n    ? toolsEnv\n        .split(',')\n        .map((t) => t.trim())\n        .filter((t) => t.length > 0)\n    : [];\n  const maxToolsEnv = process.env.CLAUDE_FLOW_MCP_MAX_TOOLS;\n  const maxTools = maxToolsEnv ? parseInt(maxToolsEnv, 10) : undefined;\n\n  return {\n    enabled,\n    mode,\n    tools,\n    maxTools: maxTools && !isNaN(maxTools) ? maxTools : undefined,\n  };\n}\n\n/**\n * Load environment variable overrides (for merging with file config)\n */\nfunction loadEnvironmentOverrides(): {\n  config: MCPToolFilterConfig;\n  hasExplicitEnabled: boolean;\n  hasExplicitMode: boolean;\n} {\n  const enabledEnv = process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_ENABLED;\n  const hasExplicitEnabled = enabledEnv === 'true' || enabledEnv === 'false';\n  const enabled = enabledEnv === 'true';\n\n  const modeEnv = process.env.CLAUDE_FLOW_MCP_TOOL_FILTER_MODE;\n  const hasExplicitMode = modeEnv === 'allowlist' || modeEnv === 'denylist';\n  const mode: 'allowlist' | 'denylist' = hasExplicitMode\n    ? (modeEnv as 'allowlist' | 'denylist')\n    : 'allowlist';\n\n  const toolsEnv = process.env.CLAUDE_FLOW_MCP_TOOLS_ALLOWED || '';\n  const tools = toolsEnv\n    ? toolsEnv\n        .split(',')\n        .map((t) => t.trim())\n        .filter((t) => t.length > 0)\n    : [];\n\n  const maxToolsEnv = process.env.CLAUDE_FLOW_MCP_MAX_TOOLS;\n  const maxTools = maxToolsEnv ? parseInt(maxToolsEnv, 10) : undefined;\n\n  return {\n    config: {\n      enabled,\n      mode,\n      tools,\n      maxTools: maxTools && !isNaN(maxTools) ? maxTools : undefined,\n    },\n    hasExplicitEnabled,\n    hasExplicitMode,\n  };\n}\n\n/**\n * Validate and normalize configuration to ensure all required fields are present\n *\n * Uses validation result to filter out invalid values and use defaults instead.\n *\n * @param config - Partial configuration to normalize\n * @param validation - Optional validation result to use for filtering invalid values\n * @returns Fully normalized configuration with all required fields\n */\nfunction validateAndNormalize(\n  config: Partial<MCPToolFilterConfig>,\n  validation?: ConfigValidationResult\n): MCPToolFilterConfig {\n  const hasError = (field: string): boolean => {\n    if (!validation) return false;\n    return validation.errors.some((e) => e.includes(`'${field}'`));\n  };\n\n  // Filter tools array - remove non-strings if validation passed but array has issues\n  let tools = DEFAULT_CONFIG.tools;\n  if (Array.isArray(config.tools) && !hasError('tools')) {\n    tools = config.tools.filter((t): t is string => typeof t === 'string');\n  }\n\n  // Filter categories array - remove non-strings\n  let categories: string[] | undefined = undefined;\n  if (Array.isArray(config.categories) && !hasError('categories')) {\n    const filtered = config.categories.filter((c): c is string => typeof c === 'string');\n    categories = filtered.length > 0 ? filtered : undefined;\n  }\n\n  // Filter priorities - remove non-number values\n  let priorities: Record<string, number> | undefined = undefined;\n  if (\n    typeof config.priorities === 'object' &&\n    config.priorities !== null &&\n    !Array.isArray(config.priorities) &&\n    !hasError('priorities')\n  ) {\n    const filtered: Record<string, number> = {};\n    for (const [key, value] of Object.entries(config.priorities)) {\n      if (typeof value === 'number') {\n        filtered[key] = value;\n      }\n    }\n    priorities = Object.keys(filtered).length > 0 ? filtered : undefined;\n  }\n\n  return {\n    enabled: hasError('enabled') ? DEFAULT_CONFIG.enabled : (config.enabled ?? DEFAULT_CONFIG.enabled),\n    mode: hasError('mode') ? DEFAULT_CONFIG.mode : (config.mode ?? DEFAULT_CONFIG.mode),\n    tools,\n    categories,\n    maxTools:\n      typeof config.maxTools === 'number' && config.maxTools > 0 && !hasError('maxTools')\n        ? config.maxTools\n        : undefined,\n    priorities,\n  };\n}\n\n"],"names":["promises","fs","join","parse","parseYaml","validateGlobPattern","DEFAULT_CONFIG_PATHS","KNOWN_CONFIG_PROPERTIES","Set","MAX_RECOMMENDED_PATTERNS","validateToolFilterConfig","config","errors","warnings","valid","configObj","key","Object","keys","has","push","enabled","mode","String","Array","isArray","tools","nonStrings","map","t","i","value","index","filter","length","indices","pattern","validationResult","substring","reason","categories","c","category","maxTools","Number","isInteger","priorities","prioritiesObj","entries","DEFAULT_CONFIG","loadToolFilterConfig","logger","workingDirectory","cwd","process","fileConfig","loadFromConfigFiles","envOverrides","loadEnvironmentOverrides","hasExplicitEnabled","undefined","hasExplicitMode","debug","source","toolCount","envConfig","loadFromEnvironment","info","configPath","fullPath","content","readFile","parsed","parseConfigFile","toolFilter","validation","logValidationResults","error","validateAndNormalize","code","warn","warning","path","endsWith","JSON","env","CLAUDE_FLOW_MCP_TOOL_FILTER_ENABLED","modeEnv","CLAUDE_FLOW_MCP_TOOL_FILTER_MODE","toolsEnv","CLAUDE_FLOW_MCP_TOOLS_ALLOWED","split","trim","maxToolsEnv","CLAUDE_FLOW_MCP_MAX_TOOLS","parseInt","isNaN","enabledEnv","hasError","field","some","e","includes","filtered"],"mappings":"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"}