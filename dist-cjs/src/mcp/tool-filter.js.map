{"version":3,"sources":["../../../src/mcp/tool-filter.ts"],"sourcesContent":["/**\n * MCP Tool Filtering Implementation\n *\n * Provides configurable tool filtering for MCP servers to meet platform\n * tool limits (e.g., Cursor's limit on total tools across MCP servers).\n *\n * Supports:\n * - Allowlist mode: Only include tools that match patterns\n * - Denylist mode: Exclude tools that match patterns\n * - Glob pattern matching using minimatch (e.g., 'system/*', 'agents/spawn')\n * - Category-based filtering\n * - Maximum tool limiting with priority-based ordering\n */\n\nimport { minimatch } from 'minimatch';\nimport type { MCPTool, MCPToolFilterConfig } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\n\n/**\n * Statistics about tool filtering operations\n */\nexport interface ToolFilterStats {\n  /** Total number of tools before filtering */\n  totalTools: number;\n  /** Number of tools after filtering */\n  filteredTools: number;\n  /** Number of tools excluded by allowlist/denylist filter */\n  excludedTools: number;\n  /** Number of tools excluded by maxTools limit */\n  truncatedTools: number;\n  /** Names of tools excluded by allowlist/denylist filter */\n  excludedToolNames: string[];\n  /** Names of tools excluded by maxTools limit */\n  truncatedToolNames: string[];\n  /** Filter mode used */\n  filterMode: 'allowlist' | 'denylist' | 'disabled';\n  /** Whether filtering is enabled */\n  enabled: boolean;\n  /** Timestamp of last filter operation */\n  lastFilterTimestamp: Date | null;\n}\n\n/**\n * Interface for tool filtering implementations\n */\nexport interface IToolFilter {\n  /**\n   * Check if a tool should be included based on filter configuration\n   * Does not consider maxTools limit - only pattern matching\n   * @param toolName - Name of the tool to check\n   * @returns true if the tool should be included, false otherwise\n   */\n  shouldIncludeTool(toolName: string): boolean;\n\n  /**\n   * Filter a list of tools based on configuration\n   * Applies both pattern filtering and maxTools limiting\n   * @param tools - Array of MCP tools to filter\n   * @returns Filtered array of tools\n   */\n  filterTools(tools: MCPTool[]): MCPTool[];\n\n  /**\n   * Get statistics about the most recent filtering operation\n   * @returns Filter statistics\n   */\n  getFilterStats(): ToolFilterStats;\n\n  /**\n   * Update the filter configuration at runtime\n   * @param config - New filter configuration\n   */\n  updateConfig(config: MCPToolFilterConfig): void;\n}\n\n/**\n * Default tool priorities for common tool categories\n * Higher values indicate higher priority (kept when maxTools limit is reached)\n */\nconst DEFAULT_PRIORITIES: Record<string, number> = {\n  // System tools - highest priority\n  'system/info': 100,\n  'system/health': 100,\n\n  // Core agent operations\n  'agents/spawn': 90,\n  'agents/list': 90,\n  'agents/status': 85,\n\n  // Core task operations\n  'tasks/create': 90,\n  'tasks/status': 85,\n  'tasks/list': 80,\n\n  // Core memory operations\n  'memory/store': 85,\n  'memory/retrieve': 85,\n  'memory/search': 80,\n\n  // Swarm coordination\n  'swarm/init': 80,\n  'swarm/status': 75,\n};\n\n/**\n * Default priority for tools not in the priority map\n */\nconst DEFAULT_TOOL_PRIORITY = 50;\n\n/**\n * Tool Filter Implementation\n *\n * Filters MCP tools based on configuration settings including\n * allowlist/denylist modes, glob patterns, and priority-based limiting.\n *\n * @example\n * ```typescript\n * const filter = new ToolFilter(\n *   {\n *     enabled: true,\n *     mode: 'allowlist',\n *     tools: ['system/*', 'agents/spawn'],\n *     categories: ['memory'],\n *     maxTools: 20,\n *     priorities: { 'custom/tool': 95 }\n *   },\n *   logger\n * );\n *\n * const filteredTools = filter.filterTools(allTools);\n * const stats = filter.getFilterStats();\n * ```\n */\nexport class ToolFilter implements IToolFilter {\n  private config: MCPToolFilterConfig;\n  private logger: ILogger;\n  private stats: ToolFilterStats;\n\n  /**\n   * Create a new ToolFilter instance\n   * @param config - Filter configuration (or undefined for no filtering)\n   * @param logger - Logger instance for debugging and info output\n   */\n  constructor(config: MCPToolFilterConfig | undefined, logger: ILogger) {\n    this.config = config ?? {\n      enabled: false,\n      mode: 'allowlist',\n      tools: [],\n    };\n    this.logger = logger;\n    this.stats = this.createEmptyStats();\n\n    if (this.config.enabled) {\n      this.logger.info('Tool filter initialized', {\n        mode: this.config.mode,\n        toolPatterns: this.config.tools.length,\n        categories: this.config.categories?.length ?? 0,\n        maxTools: this.config.maxTools,\n      });\n    } else {\n      this.logger.debug('Tool filtering disabled');\n    }\n  }\n\n  /**\n   * Create empty statistics object with current configuration state\n   */\n  private createEmptyStats(): ToolFilterStats {\n    return {\n      totalTools: 0,\n      filteredTools: 0,\n      excludedTools: 0,\n      truncatedTools: 0,\n      excludedToolNames: [],\n      truncatedToolNames: [],\n      filterMode: this.config.enabled ? this.config.mode : 'disabled',\n      enabled: this.config.enabled,\n      lastFilterTimestamp: null,\n    };\n  }\n\n  /**\n   * Check if a tool name matches any pattern in a list using minimatch\n   * @param toolName - Tool name to check\n   * @param patterns - Array of patterns (exact names or globs)\n   * @returns true if any pattern matches\n   */\n  private matchesPatterns(toolName: string, patterns: string[]): boolean {\n    for (const pattern of patterns) {\n      // Check for exact match first (faster)\n      if (pattern === toolName) {\n        return true;\n      }\n\n      // Check glob pattern match using minimatch\n      if (minimatch(toolName, pattern, { nocase: false })) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a tool matches any category pattern\n   * Categories match tool name prefixes with common separators\n   * @param toolName - Tool name to check\n   * @param categories - Array of category prefixes\n   * @returns true if tool belongs to any category\n   */\n  private matchesCategories(toolName: string, categories: string[]): boolean {\n    for (const category of categories) {\n      // Category matches if tool name starts with \"category/\" or \"category_\" or \"category-\"\n      if (\n        toolName.startsWith(`${category}/`) ||\n        toolName.startsWith(`${category}_`) ||\n        toolName.startsWith(`${category}-`)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get priority for a tool, used for ordering when maxTools limit applies\n   * @param toolName - Tool name\n   * @returns Priority value (higher = more important, kept first when truncating)\n   */\n  private getToolPriority(toolName: string): number {\n    // Check configured priorities first\n    if (this.config.priorities?.[toolName] !== undefined) {\n      return this.config.priorities[toolName];\n    }\n\n    // Fall back to default priorities\n    if (DEFAULT_PRIORITIES[toolName] !== undefined) {\n      return DEFAULT_PRIORITIES[toolName];\n    }\n\n    // Extract category for category-based default priority\n    const category = toolName.split(/[/_-]/)[0];\n    const categoryPriorities = Object.entries(DEFAULT_PRIORITIES)\n      .filter(([key]) => key.startsWith(`${category}/`))\n      .map(([, value]) => value);\n\n    if (categoryPriorities.length > 0) {\n      // Return slightly lower than explicit category tools\n      return Math.min(...categoryPriorities) - 5;\n    }\n\n    return DEFAULT_TOOL_PRIORITY;\n  }\n\n  /**\n   * Check if a single tool should be included based on filter rules\n   * Does not consider maxTools limit - only pattern/category matching\n   */\n  shouldIncludeTool(toolName: string): boolean {\n    // If filtering is disabled, include all tools\n    if (!this.config.enabled) {\n      return true;\n    }\n\n    const { mode, tools, categories } = this.config;\n\n    // Check tool patterns\n    const matchesToolPattern = tools.length > 0 && this.matchesPatterns(toolName, tools);\n\n    // Check category patterns\n    const matchesCategory =\n      categories && categories.length > 0 && this.matchesCategories(toolName, categories);\n\n    // Combine matches - tool is matched if it matches patterns OR categories\n    const matches = matchesToolPattern || matchesCategory;\n\n    if (mode === 'allowlist') {\n      // In allowlist mode: include only if matches\n      return matches;\n    } else {\n      // In denylist mode: include only if NOT matches\n      return !matches;\n    }\n  }\n\n  /**\n   * Filter an array of tools based on configuration\n   * Applies pattern filtering first, then maxTools limit if configured\n   */\n  filterTools(tools: MCPTool[]): MCPTool[] {\n    // Reset stats for this operation\n    this.stats = this.createEmptyStats();\n    this.stats.totalTools = tools.length;\n    this.stats.lastFilterTimestamp = new Date();\n\n    // If filtering is disabled, return all tools\n    if (!this.config.enabled) {\n      this.stats.filteredTools = tools.length;\n      this.logger.debug('Tool filtering disabled, returning all tools', {\n        count: tools.length,\n      });\n      return tools;\n    }\n\n    this.logger.debug('Filtering tools', {\n      mode: this.config.mode,\n      toolPatterns: this.config.tools,\n      categories: this.config.categories,\n      maxTools: this.config.maxTools,\n    });\n\n    // Step 1: Apply allowlist/denylist filtering\n    const filteredByPattern: MCPTool[] = [];\n    const excludedByPattern: string[] = [];\n\n    for (const tool of tools) {\n      if (this.shouldIncludeTool(tool.name)) {\n        filteredByPattern.push(tool);\n      } else {\n        excludedByPattern.push(tool.name);\n      }\n    }\n\n    this.stats.excludedToolNames = excludedByPattern;\n    this.stats.excludedTools = excludedByPattern.length;\n\n    this.logger.debug('Pattern filtering complete', {\n      included: filteredByPattern.length,\n      excluded: excludedByPattern.length,\n    });\n\n    // Step 2: Apply maxTools limit with priority ordering\n    let result = filteredByPattern;\n\n    if (this.config.maxTools !== undefined && filteredByPattern.length > this.config.maxTools) {\n      // Sort by priority (descending), then by name for stable ordering\n      const toolsWithPriority = filteredByPattern.map((tool) => ({\n        tool,\n        priority: this.getToolPriority(tool.name),\n      }));\n\n      toolsWithPriority.sort((a, b) => {\n        if (b.priority !== a.priority) {\n          return b.priority - a.priority;\n        }\n        return a.tool.name.localeCompare(b.tool.name);\n      });\n\n      // Take top N tools based on maxTools limit\n      const keptTools = toolsWithPriority.slice(0, this.config.maxTools);\n      const truncatedTools = toolsWithPriority.slice(this.config.maxTools);\n\n      this.stats.truncatedToolNames = truncatedTools.map((t) => t.tool.name);\n      this.stats.truncatedTools = truncatedTools.length;\n\n      result = keptTools.map((t) => t.tool);\n\n      this.logger.warn('Applied maxTools limit', {\n        maxTools: this.config.maxTools,\n        originalCount: filteredByPattern.length,\n        resultCount: result.length,\n        truncatedCount: this.stats.truncatedTools,\n      });\n    }\n\n    this.stats.filteredTools = result.length;\n\n    this.logger.info('Tool filtering complete', {\n      total: this.stats.totalTools,\n      filtered: this.stats.filteredTools,\n      excluded: this.stats.excludedTools,\n      truncated: this.stats.truncatedTools,\n    });\n\n    return result;\n  }\n\n  /**\n   * Get statistics from the most recent filter operation\n   * Returns a copy to prevent external modification\n   */\n  getFilterStats(): ToolFilterStats {\n    return {\n      ...this.stats,\n      excludedToolNames: [...this.stats.excludedToolNames],\n      truncatedToolNames: [...this.stats.truncatedToolNames],\n    };\n  }\n\n  /**\n   * Update the filter configuration at runtime\n   * Resets statistics and re-initializes with new config\n   */\n  updateConfig(config: MCPToolFilterConfig): void {\n    this.config = config;\n    this.stats = this.createEmptyStats();\n\n    this.logger.info('Tool filter configuration updated', {\n      enabled: config.enabled,\n      mode: config.mode,\n      toolPatterns: config.tools.length,\n      categories: config.categories?.length ?? 0,\n      maxTools: config.maxTools,\n    });\n  }\n}\n\n/**\n * Factory function to create a ToolFilter instance\n *\n * @param config - Filter configuration (optional, defaults to disabled filtering)\n * @param logger - Logger instance for output\n * @returns Configured IToolFilter instance\n *\n * @example\n * ```typescript\n * // Create with allowlist configuration\n * const filter = createToolFilter(\n *   {\n *     enabled: true,\n *     mode: 'allowlist',\n *     tools: ['system/*', 'agents/spawn', 'memory/*'],\n *     maxTools: 20\n *   },\n *   logger\n * );\n *\n * // Filter tools\n * const filteredTools = filter.filterTools(allTools);\n *\n * // Check statistics\n * const stats = filter.getFilterStats();\n * console.log(`Filtered ${stats.excludedTools} tools`);\n * ```\n *\n * @example\n * ```typescript\n * // Create with denylist configuration\n * const filter = createToolFilter(\n *   {\n *     enabled: true,\n *     mode: 'denylist',\n *     tools: ['debug/*', 'experimental/*'],\n *     categories: ['internal']\n *   },\n *   logger\n * );\n * ```\n */\nexport function createToolFilter(\n  config: MCPToolFilterConfig | undefined,\n  logger: ILogger\n): IToolFilter {\n  return new ToolFilter(config, logger);\n}\n"],"names":["minimatch","DEFAULT_PRIORITIES","DEFAULT_TOOL_PRIORITY","ToolFilter","config","logger","stats","enabled","mode","tools","createEmptyStats","info","toolPatterns","length","categories","maxTools","debug","totalTools","filteredTools","excludedTools","truncatedTools","excludedToolNames","truncatedToolNames","filterMode","lastFilterTimestamp","matchesPatterns","toolName","patterns","pattern","nocase","matchesCategories","category","startsWith","getToolPriority","priorities","undefined","split","categoryPriorities","Object","entries","filter","key","map","value","Math","min","shouldIncludeTool","matchesToolPattern","matchesCategory","matches","filterTools","Date","count","filteredByPattern","excludedByPattern","tool","name","push","included","excluded","result","toolsWithPriority","priority","sort","a","b","localeCompare","keptTools","slice","t","warn","originalCount","resultCount","truncatedCount","total","filtered","truncated","getFilterStats","updateConfig","createToolFilter"],"mappings":"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"}