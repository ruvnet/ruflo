{
  "version": 3,
  "sources": ["../../src/mcp/auth.ts"],
  "sourcesContent": ["/**\n * Authentication and authorization for MCP\n */\n\nimport type { MCPAuthConfig, MCPSession } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport type { MCPError } from '../utils/errors.js';\nimport { createHash, timingSafeEqual } from 'node:crypto';\n\nexport interface IAuthManager {\n  authenticate(credentials: unknown): Promise<AuthResult>;\n  authorize(session: MCPSession, permission: string): boolean;\n  validateToken(token: string): Promise<TokenValidation>;\n  generateToken(userId: string, permissions: string[]): Promise<string>;\n  revokeToken(token: string): Promise<void>;\n}\n\nexport interface AuthResult {\n  success: boolean;\n  user?: string;\n  permissions?: string[];\n  token?: string;\n  error?: string;\n}\n\nexport interface TokenValidation {\n  valid: boolean;\n  user?: string;\n  permissions?: string[];\n  expiresAt?: Date;\n  error?: string;\n}\n\n/**\n * Authentication manager implementation\n */\nexport class AuthManager implements IAuthManager {\n  private revokedTokens = new Set<string>();\n  private tokenStore = new Map<\n    string,\n    {\n      user: string;\n      permissions: string[];\n      createdAt: Date;\n      expiresAt: Date;\n    }\n  >();\n\n  constructor(\n    private config: MCPAuthConfig,\n    private logger: ILogger,\n  ) {\n    // Start token cleanup timer\n    if (config.enabled) {\n      setInterval(() => {\n        this.cleanupExpiredTokens();\n      }, 300000); // Clean up every 5 minutes\n    }\n  }\n\n  async authenticate(credentials: unknown): Promise<AuthResult> {\n    if (!this.config.enabled) {\n      return {\n        success: true,\n        user: 'anonymous',\n        permissions: ['*'],\n      };\n    }\n\n    this.logger.debug('Authenticating credentials', {\n      method: this.config.method,\n      hasCredentials: !!credentials,\n    });\n\n    try {\n      switch (this.config.method) {\n        case 'token':\n          return await this.authenticateToken(credentials);\n        case 'basic':\n          return await this.authenticateBasic(credentials);\n        case 'oauth':\n          return await this.authenticateOAuth(credentials);\n        default:\n          return {\n            success: false,\n            error: `Unsupported authentication method: ${this.config.method}`,\n          };\n      }\n    } catch (error) {\n      this.logger.error('Authentication error', error);\n      return {\n        success: false,\n        error:\n          error instanceof Error\n            ? error instanceof Error\n              ? error.message\n              : String(error)\n            : 'Authentication failed',\n      };\n    }\n  }\n\n  authorize(session: MCPSession, permission: string): boolean {\n    if (!this.config.enabled || !session.authenticated) {\n      return !this.config.enabled; // If auth disabled, allow all\n    }\n\n    const permissions = session.authData?.permissions || [];\n\n    // Check for wildcard permission\n    if (permissions.includes('*')) {\n      return true;\n    }\n\n    // Check for exact permission match\n    if (permissions.includes(permission)) {\n      return true;\n    }\n\n    // Check for prefix-based permissions (e.g., \"tools.*\" matches \"tools.list\")\n    for (const perm of permissions) {\n      if (perm.endsWith('*') && permission.startsWith(perm.slice(0, -1))) {\n        return true;\n      }\n    }\n\n    this.logger.warn('Authorization denied', {\n      sessionId: session.id,\n      user: session.authData?.user,\n      permission,\n      userPermissions: permissions,\n    });\n\n    return false;\n  }\n\n  async validateToken(token: string): Promise<TokenValidation> {\n    if (this.revokedTokens.has(token)) {\n      return {\n        valid: false,\n        error: 'Token has been revoked',\n      };\n    }\n\n    const tokenData = this.tokenStore.get(token);\n    if (!tokenData) {\n      return {\n        valid: false,\n        error: 'Invalid token',\n      };\n    }\n\n    if (tokenData.expiresAt < new Date()) {\n      this.tokenStore.delete(token);\n      return {\n        valid: false,\n        error: 'Token has expired',\n      };\n    }\n\n    return {\n      valid: true,\n      user: tokenData.user,\n      permissions: tokenData.permissions,\n      expiresAt: tokenData.expiresAt,\n    };\n  }\n\n  async generateToken(userId: string, permissions: string[]): Promise<string> {\n    const token = this.createSecureToken();\n    const now = new Date();\n    const expiresAt = new Date(now.getTime() + (this.config.sessionTimeout || 3600000));\n\n    this.tokenStore.set(token, {\n      user: userId,\n      permissions,\n      createdAt: now,\n      expiresAt,\n    });\n\n    this.logger.info('Token generated', {\n      userId,\n      permissions,\n      expiresAt,\n    });\n\n    return token;\n  }\n\n  async revokeToken(token: string): Promise<void> {\n    this.revokedTokens.add(token);\n    this.tokenStore.delete(token);\n    this.logger.info('Token revoked', { token: token.substring(0, 8) + '...' });\n  }\n\n  private async authenticateToken(credentials: unknown): Promise<AuthResult> {\n    const token = this.extractToken(credentials);\n    if (!token) {\n      return {\n        success: false,\n        error: 'Token not provided',\n      };\n    }\n\n    // Check if it's a stored token (generated by us)\n    const validation = await this.validateToken(token);\n    if (validation.valid) {\n      return {\n        success: true,\n        user: validation.user!,\n        permissions: validation.permissions!,\n        token,\n      };\n    }\n\n    // Check against configured static tokens\n    if (this.config.tokens && this.config.tokens.length > 0) {\n      const isValid = this.config.tokens.some((validToken) => {\n        return this.timingSafeEqual(token, validToken);\n      });\n\n      if (isValid) {\n        return {\n          success: true,\n          user: 'token-user',\n          permissions: ['*'], // Static tokens get all permissions\n          token,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: 'Invalid token',\n    };\n  }\n\n  private async authenticateBasic(credentials: unknown): Promise<AuthResult> {\n    const { username, password } = this.extractBasicAuth(credentials);\n    if (!username || !password) {\n      return {\n        success: false,\n        error: 'Username and password required',\n      };\n    }\n\n    if (!this.config.users || this.config.users.length === 0) {\n      return {\n        success: false,\n        error: 'No users configured',\n      };\n    }\n\n    const user = this.config.users.find((u) => u.username === username);\n    if (!user) {\n      return {\n        success: false,\n        error: 'Invalid username or password',\n      };\n    }\n\n    // Verify password\n    const isValidPassword = this.verifyPassword(password, user.password);\n    if (!isValidPassword) {\n      return {\n        success: false,\n        error: 'Invalid username or password',\n      };\n    }\n\n    // Generate a session token\n    const token = await this.generateToken(username, user.permissions);\n\n    return {\n      success: true,\n      user: username,\n      permissions: user.permissions,\n      token,\n    };\n  }\n\n  private async authenticateOAuth(credentials: unknown): Promise<AuthResult> {\n    // TODO: Implement OAuth authentication\n    // This would typically involve:\n    // 1. Validating JWT tokens\n    // 2. Checking token expiration\n    // 3. Extracting user info and permissions from token claims\n\n    this.logger.warn('OAuth authentication not yet implemented');\n    return {\n      success: false,\n      error: 'OAuth authentication not implemented',\n    };\n  }\n\n  private extractToken(credentials: unknown): string | null {\n    if (typeof credentials === 'string') {\n      return credentials;\n    }\n\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n\n      if (typeof creds.token === 'string') {\n        return creds.token;\n      }\n\n      if (typeof creds.authorization === 'string') {\n        const match = creds.authorization.match(/^Bearer\\s+(.+)$/i);\n        return match ? match[1] : null;\n      }\n    }\n\n    return null;\n  }\n\n  private extractBasicAuth(credentials: unknown): { username?: string; password?: string } {\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n\n      if (typeof creds.username === 'string' && typeof creds.password === 'string') {\n        return {\n          username: creds.username,\n          password: creds.password,\n        };\n      }\n\n      if (typeof creds.authorization === 'string') {\n        const match = creds.authorization.match(/^Basic\\s+(.+)$/i);\n        if (match) {\n          try {\n            const decoded = atob(match[1]);\n            const colonIndex = decoded.indexOf(':');\n            if (colonIndex >= 0) {\n              return {\n                username: decoded.substring(0, colonIndex),\n                password: decoded.substring(colonIndex + 1),\n              };\n            }\n          } catch {\n            // Invalid base64\n          }\n        }\n      }\n    }\n\n    return {};\n  }\n\n  private verifyPassword(providedPassword: string, storedPassword: string): boolean {\n    // For now, using simple hash comparison\n    // In production, use proper password hashing like bcrypt\n    const hashedProvided = this.hashPassword(providedPassword);\n    const hashedStored = this.hashPassword(storedPassword);\n\n    return this.timingSafeEqual(hashedProvided, hashedStored);\n  }\n\n  private hashPassword(password: string): string {\n    return createHash('sha256').update(password).digest('hex');\n  }\n\n  private timingSafeEqual(a: string, b: string): boolean {\n    const encoder = new TextEncoder();\n    const bufferA = encoder.encode(a);\n    const bufferB = encoder.encode(b);\n\n    if (bufferA.length !== bufferB.length) {\n      return false;\n    }\n\n    return timingSafeEqual(bufferA, bufferB);\n  }\n\n  private createSecureToken(): string {\n    // Generate a secure random token\n    const timestamp = Date.now().toString(36);\n    const random1 = Math.random().toString(36).substring(2, 15);\n    const random2 = Math.random().toString(36).substring(2, 15);\n    const hash = createHash('sha256')\n      .update(`${timestamp}${random1}${random2}`)\n      .digest('hex')\n      .substring(0, 32);\n\n    return `mcp_${timestamp}_${hash}`;\n  }\n\n  private cleanupExpiredTokens(): void {\n    const now = new Date();\n    let cleaned = 0;\n\n    for (const [token, data] of this.tokenStore.entries()) {\n      if (data.expiresAt < now) {\n        this.tokenStore.delete(token);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.debug('Cleaned up expired tokens', { count: cleaned });\n    }\n  }\n}\n\n/**\n * Permission constants for common operations\n */\nexport const Permissions = {\n  // System operations\n  SYSTEM_INFO: 'system.info',\n  SYSTEM_HEALTH: 'system.health',\n  SYSTEM_METRICS: 'system.metrics',\n\n  // Tool operations\n  TOOLS_LIST: 'tools.list',\n  TOOLS_INVOKE: 'tools.invoke',\n  TOOLS_DESCRIBE: 'tools.describe',\n\n  // Agent operations\n  AGENTS_LIST: 'agents.list',\n  AGENTS_SPAWN: 'agents.spawn',\n  AGENTS_TERMINATE: 'agents.terminate',\n  AGENTS_INFO: 'agents.info',\n\n  // Task operations\n  TASKS_LIST: 'tasks.list',\n  TASKS_CREATE: 'tasks.create',\n  TASKS_CANCEL: 'tasks.cancel',\n  TASKS_STATUS: 'tasks.status',\n\n  // Memory operations\n  MEMORY_READ: 'memory.read',\n  MEMORY_WRITE: 'memory.write',\n  MEMORY_QUERY: 'memory.query',\n  MEMORY_DELETE: 'memory.delete',\n\n  // Administrative operations\n  ADMIN_CONFIG: 'admin.config',\n  ADMIN_LOGS: 'admin.logs',\n  ADMIN_SESSIONS: 'admin.sessions',\n\n  // Wildcard permission\n  ALL: '*',\n} as const;\n\nexport type Permission = (typeof Permissions)[keyof typeof Permissions];\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,yBAA4C;AA6BrC,MAAM,YAAoC;AAAA,EAY/C,YACU,QACA,QACR;AAFQ;AACA;AAGR,QAAI,OAAO,SAAS;AAClB,kBAAY,MAAM;AAChB,aAAK,qBAAqB;AAAA,MAC5B,GAAG,GAAM;AAAA,IACX;AAAA,EACF;AAAA,EA1DF,OAoCiD;AAAA;AAAA;AAAA,EACvC,gBAAgB,oBAAI,IAAY;AAAA,EAChC,aAAa,oBAAI,IAQvB;AAAA,EAcF,MAAM,aAAa,aAA2C;AAC5D,QAAI,CAAC,KAAK,OAAO,SAAS;AACxB,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM;AAAA,QACN,aAAa,CAAC,GAAG;AAAA,MACnB;AAAA,IACF;AAEA,SAAK,OAAO,MAAM,8BAA8B;AAAA,MAC9C,QAAQ,KAAK,OAAO;AAAA,MACpB,gBAAgB,CAAC,CAAC;AAAA,IACpB,CAAC;AAED,QAAI;AACF,cAAQ,KAAK,OAAO,QAAQ;AAAA,QAC1B,KAAK;AACH,iBAAO,MAAM,KAAK,kBAAkB,WAAW;AAAA,QACjD,KAAK;AACH,iBAAO,MAAM,KAAK,kBAAkB,WAAW;AAAA,QACjD,KAAK;AACH,iBAAO,MAAM,KAAK,kBAAkB,WAAW;AAAA,QACjD;AACE,iBAAO;AAAA,YACL,SAAS;AAAA,YACT,OAAO,sCAAsC,KAAK,OAAO,MAAM;AAAA,UACjE;AAAA,MACJ;AAAA,IACF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,wBAAwB,KAAK;AAC/C,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OACE,iBAAiB,QACb,iBAAiB,QACf,MAAM,UACN,OAAO,KAAK,IACd;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAU,SAAqB,YAA6B;AAC1D,QAAI,CAAC,KAAK,OAAO,WAAW,CAAC,QAAQ,eAAe;AAClD,aAAO,CAAC,KAAK,OAAO;AAAA,IACtB;AAEA,UAAM,cAAc,QAAQ,UAAU,eAAe,CAAC;AAGtD,QAAI,YAAY,SAAS,GAAG,GAAG;AAC7B,aAAO;AAAA,IACT;AAGA,QAAI,YAAY,SAAS,UAAU,GAAG;AACpC,aAAO;AAAA,IACT;AAGA,eAAW,QAAQ,aAAa;AAC9B,UAAI,KAAK,SAAS,GAAG,KAAK,WAAW,WAAW,KAAK,MAAM,GAAG,EAAE,CAAC,GAAG;AAClE,eAAO;AAAA,MACT;AAAA,IACF;AAEA,SAAK,OAAO,KAAK,wBAAwB;AAAA,MACvC,WAAW,QAAQ;AAAA,MACnB,MAAM,QAAQ,UAAU;AAAA,MACxB;AAAA,MACA,iBAAiB;AAAA,IACnB,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,cAAc,OAAyC;AAC3D,QAAI,KAAK,cAAc,IAAI,KAAK,GAAG;AACjC,aAAO;AAAA,QACL,OAAO;AAAA,QACP,OAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,YAAY,KAAK,WAAW,IAAI,KAAK;AAC3C,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,QACL,OAAO;AAAA,QACP,OAAO;AAAA,MACT;AAAA,IACF;AAEA,QAAI,UAAU,YAAY,oBAAI,KAAK,GAAG;AACpC,WAAK,WAAW,OAAO,KAAK;AAC5B,aAAO;AAAA,QACL,OAAO;AAAA,QACP,OAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,MACL,OAAO;AAAA,MACP,MAAM,UAAU;AAAA,MAChB,aAAa,UAAU;AAAA,MACvB,WAAW,UAAU;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,MAAM,cAAc,QAAgB,aAAwC;AAC1E,UAAM,QAAQ,KAAK,kBAAkB;AACrC,UAAM,MAAM,oBAAI,KAAK;AACrB,UAAM,YAAY,IAAI,KAAK,IAAI,QAAQ,KAAK,KAAK,OAAO,kBAAkB,KAAQ;AAElF,SAAK,WAAW,IAAI,OAAO;AAAA,MACzB,MAAM;AAAA,MACN;AAAA,MACA,WAAW;AAAA,MACX;AAAA,IACF,CAAC;AAED,SAAK,OAAO,KAAK,mBAAmB;AAAA,MAClC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,YAAY,OAA8B;AAC9C,SAAK,cAAc,IAAI,KAAK;AAC5B,SAAK,WAAW,OAAO,KAAK;AAC5B,SAAK,OAAO,KAAK,iBAAiB,EAAE,OAAO,MAAM,UAAU,GAAG,CAAC,IAAI,MAAM,CAAC;AAAA,EAC5E;AAAA,EAEA,MAAc,kBAAkB,aAA2C;AACzE,UAAM,QAAQ,KAAK,aAAa,WAAW;AAC3C,QAAI,CAAC,OAAO;AACV,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,aAAa,MAAM,KAAK,cAAc,KAAK;AACjD,QAAI,WAAW,OAAO;AACpB,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM,WAAW;AAAA,QACjB,aAAa,WAAW;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,KAAK,OAAO,UAAU,KAAK,OAAO,OAAO,SAAS,GAAG;AACvD,YAAM,UAAU,KAAK,OAAO,OAAO,KAAK,CAAC,eAAe;AACtD,eAAO,KAAK,gBAAgB,OAAO,UAAU;AAAA,MAC/C,CAAC;AAED,UAAI,SAAS;AACX,eAAO;AAAA,UACL,SAAS;AAAA,UACT,MAAM;AAAA,UACN,aAAa,CAAC,GAAG;AAAA;AAAA,UACjB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAc,kBAAkB,aAA2C;AACzE,UAAM,EAAE,UAAU,SAAS,IAAI,KAAK,iBAAiB,WAAW;AAChE,QAAI,CAAC,YAAY,CAAC,UAAU;AAC1B,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,OAAO,SAAS,KAAK,OAAO,MAAM,WAAW,GAAG;AACxD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,OAAO,KAAK,OAAO,MAAM,KAAK,CAAC,MAAM,EAAE,aAAa,QAAQ;AAClE,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,kBAAkB,KAAK,eAAe,UAAU,KAAK,QAAQ;AACnE,QAAI,CAAC,iBAAiB;AACpB,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,QAAQ,MAAM,KAAK,cAAc,UAAU,KAAK,WAAW;AAEjE,WAAO;AAAA,MACL,SAAS;AAAA,MACT,MAAM;AAAA,MACN,aAAa,KAAK;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,kBAAkB,aAA2C;AAOzE,SAAK,OAAO,KAAK,0CAA0C;AAC3D,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEQ,aAAa,aAAqC;AACxD,QAAI,OAAO,gBAAgB,UAAU;AACnC,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,gBAAgB,YAAY,gBAAgB,MAAM;AAC3D,YAAM,QAAQ;AAEd,UAAI,OAAO,MAAM,UAAU,UAAU;AACnC,eAAO,MAAM;AAAA,MACf;AAEA,UAAI,OAAO,MAAM,kBAAkB,UAAU;AAC3C,cAAM,QAAQ,MAAM,cAAc,MAAM,kBAAkB;AAC1D,eAAO,QAAQ,MAAM,CAAC,IAAI;AAAA,MAC5B;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,iBAAiB,aAAgE;AACvF,QAAI,OAAO,gBAAgB,YAAY,gBAAgB,MAAM;AAC3D,YAAM,QAAQ;AAEd,UAAI,OAAO,MAAM,aAAa,YAAY,OAAO,MAAM,aAAa,UAAU;AAC5E,eAAO;AAAA,UACL,UAAU,MAAM;AAAA,UAChB,UAAU,MAAM;AAAA,QAClB;AAAA,MACF;AAEA,UAAI,OAAO,MAAM,kBAAkB,UAAU;AAC3C,cAAM,QAAQ,MAAM,cAAc,MAAM,iBAAiB;AACzD,YAAI,OAAO;AACT,cAAI;AACF,kBAAM,UAAU,KAAK,MAAM,CAAC,CAAC;AAC7B,kBAAM,aAAa,QAAQ,QAAQ,GAAG;AACtC,gBAAI,cAAc,GAAG;AACnB,qBAAO;AAAA,gBACL,UAAU,QAAQ,UAAU,GAAG,UAAU;AAAA,gBACzC,UAAU,QAAQ,UAAU,aAAa,CAAC;AAAA,cAC5C;AAAA,YACF;AAAA,UACF,QAAQ;AAAA,UAER;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,CAAC;AAAA,EACV;AAAA,EAEQ,eAAe,kBAA0B,gBAAiC;AAGhF,UAAM,iBAAiB,KAAK,aAAa,gBAAgB;AACzD,UAAM,eAAe,KAAK,aAAa,cAAc;AAErD,WAAO,KAAK,gBAAgB,gBAAgB,YAAY;AAAA,EAC1D;AAAA,EAEQ,aAAa,UAA0B;AAC7C,eAAO,+BAAW,QAAQ,EAAE,OAAO,QAAQ,EAAE,OAAO,KAAK;AAAA,EAC3D;AAAA,EAEQ,gBAAgB,GAAW,GAAoB;AACrD,UAAM,UAAU,IAAI,YAAY;AAChC,UAAM,UAAU,QAAQ,OAAO,CAAC;AAChC,UAAM,UAAU,QAAQ,OAAO,CAAC;AAEhC,QAAI,QAAQ,WAAW,QAAQ,QAAQ;AACrC,aAAO;AAAA,IACT;AAEA,eAAO,oCAAgB,SAAS,OAAO;AAAA,EACzC;AAAA,EAEQ,oBAA4B;AAElC,UAAM,YAAY,KAAK,IAAI,EAAE,SAAS,EAAE;AACxC,UAAM,UAAU,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AAC1D,UAAM,UAAU,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AAC1D,UAAM,WAAO,+BAAW,QAAQ,EAC7B,OAAO,GAAG,SAAS,GAAG,OAAO,GAAG,OAAO,EAAE,EACzC,OAAO,KAAK,EACZ,UAAU,GAAG,EAAE;AAElB,WAAO,OAAO,SAAS,IAAI,IAAI;AAAA,EACjC;AAAA,EAEQ,uBAA6B;AACnC,UAAM,MAAM,oBAAI,KAAK;AACrB,QAAI,UAAU;AAEd,eAAW,CAAC,OAAO,IAAI,KAAK,KAAK,WAAW,QAAQ,GAAG;AACrD,UAAI,KAAK,YAAY,KAAK;AACxB,aAAK,WAAW,OAAO,KAAK;AAC5B;AAAA,MACF;AAAA,IACF;AAEA,QAAI,UAAU,GAAG;AACf,WAAK,OAAO,MAAM,6BAA6B,EAAE,OAAO,QAAQ,CAAC;AAAA,IACnE;AAAA,EACF;AACF;AAKO,MAAM,cAAc;AAAA;AAAA,EAEzB,aAAa;AAAA,EACb,eAAe;AAAA,EACf,gBAAgB;AAAA;AAAA,EAGhB,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,gBAAgB;AAAA;AAAA,EAGhB,aAAa;AAAA,EACb,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,aAAa;AAAA;AAAA,EAGb,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,cAAc;AAAA,EACd,cAAc;AAAA;AAAA,EAGd,aAAa;AAAA,EACb,cAAc;AAAA,EACd,cAAc;AAAA,EACd,eAAe;AAAA;AAAA,EAGf,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,gBAAgB;AAAA;AAAA,EAGhB,KAAK;AACP;",
  "names": []
}
