{"version":3,"sources":["../../../../src/cli/simple-commands/train-and-stream.js"],"sourcesContent":["#!/usr/bin/env node\r\n/**\r\n * Integrated Training and Stream Chaining System\r\n * Combines real code training with stream-based agent chaining\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport { spawn } from 'child_process';\r\nimport { TrainingPipeline } from './training-pipeline.js';\r\n\r\nexport class TrainAndStreamSystem {\r\n  constructor() {\r\n    this.trainingPipeline = new TrainingPipeline();\r\n    this.streamConfig = '.claude-flow/stream-config.json';\r\n  }\r\n\r\n  /**\r\n   * Train agents and then use them in a stream chain\r\n   */\r\n  async trainAndExecute(task, options = {}) {\r\n    console.log('üéØ Integrated Training & Stream Execution');\r\n    console.log('‚îÅ'.repeat(50));\r\n\r\n    // Step 1: Run training to improve agent profiles\r\n    console.log('\\nüìö Phase 1: Training Agents with Real Code');\r\n    console.log('‚îÄ'.repeat(40));\r\n    \r\n    await this.trainingPipeline.initialize();\r\n    const trainingResult = await this.trainingPipeline.runFullPipeline({\r\n      complexity: options.complexity || 'medium',\r\n      iterations: options.iterations || 2,\r\n      validate: true\r\n    });\r\n\r\n    // Step 2: Load trained profiles\r\n    const profiles = JSON.parse(\r\n      await fs.readFile('.claude-flow/agents/profiles.json', 'utf8')\r\n    );\r\n\r\n    // Step 3: Select best strategy based on task requirements\r\n    const strategy = this.selectOptimalStrategy(profiles, options);\r\n    console.log(`\\nüéØ Selected Strategy: ${strategy.name}`);\r\n    console.log(`   Success Rate: ${(strategy.profile.successRate * 100).toFixed(1)}%`);\r\n    console.log(`   Avg Score: ${strategy.profile.avgScore.toFixed(2)}`);\r\n    console.log(`   Execution Time: ${strategy.profile.avgExecutionTime.toFixed(0)}ms`);\r\n\r\n    // Step 4: Execute stream chain with trained agents\r\n    console.log('\\nüîó Phase 2: Stream Chain Execution');\r\n    console.log('‚îÄ'.repeat(40));\r\n    \r\n    const result = await this.executeStreamChain(task, strategy, options);\r\n    \r\n    // Step 5: Learn from execution results\r\n    await this.updateProfilesFromExecution(strategy.name, result);\r\n\r\n    return {\r\n      training: trainingResult,\r\n      execution: result,\r\n      strategy: strategy.name,\r\n      performance: {\r\n        trainingImprovement: trainingResult.improvements,\r\n        executionTime: result.duration,\r\n        success: result.success\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Select optimal strategy based on task requirements\r\n   */\r\n  selectOptimalStrategy(profiles, options) {\r\n    const priorities = options.priorities || {\r\n      reliability: 0.4,\r\n      speed: 0.3,\r\n      score: 0.3\r\n    };\r\n\r\n    let bestScore = -1;\r\n    let bestStrategy = null;\r\n\r\n    for (const [name, profile] of Object.entries(profiles)) {\r\n      const score = \r\n        (profile.successRate * priorities.reliability) +\r\n        ((1 - profile.avgExecutionTime / 5000) * priorities.speed) +\r\n        (profile.avgScore / 100 * priorities.score);\r\n\r\n      if (score > bestScore) {\r\n        bestScore = score;\r\n        bestStrategy = { name, profile, score };\r\n      }\r\n    }\r\n\r\n    return bestStrategy;\r\n  }\r\n\r\n  /**\r\n   * Execute a stream chain with multiple agents\r\n   */\r\n  async executeStreamChain(task, strategy, options) {\r\n    const startTime = Date.now();\r\n    const steps = this.decomposeTask(task, strategy.name);\r\n    \r\n    console.log(`\\nüìù Task decomposed into ${steps.length} steps:`);\r\n    steps.forEach((step, i) => {\r\n      console.log(`   ${i + 1}. ${step.description}`);\r\n    });\r\n\r\n    let inputStream = null;\r\n    let lastOutput = null;\r\n    const results = [];\r\n\r\n    for (let i = 0; i < steps.length; i++) {\r\n      const step = steps[i];\r\n      console.log(`\\nüîÑ Executing Step ${i + 1}: ${step.description}`);\r\n      \r\n      const output = await this.executeStreamStep(\r\n        step,\r\n        inputStream,\r\n        i === steps.length - 1 // isLast\r\n      );\r\n      \r\n      results.push({\r\n        step: i + 1,\r\n        description: step.description,\r\n        output: output.summary,\r\n        duration: output.duration\r\n      });\r\n\r\n      inputStream = output.stream;\r\n      lastOutput = output;\r\n    }\r\n\r\n    const totalDuration = Date.now() - startTime;\r\n    \r\n    console.log('\\n‚úÖ Stream Chain Complete');\r\n    console.log(`   Total Duration: ${totalDuration}ms`);\r\n    console.log(`   Steps Completed: ${results.length}`);\r\n\r\n    return {\r\n      success: true,\r\n      duration: totalDuration,\r\n      steps: results,\r\n      finalOutput: lastOutput.summary\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Execute a single step in the stream chain\r\n   */\r\n  async executeStreamStep(step, inputStream, isLast) {\r\n    return new Promise((resolve) => {\r\n      const startTime = Date.now();\r\n      \r\n      // Build command arguments\r\n      const args = ['-p'];\r\n      if (inputStream) {\r\n        args.push('--input-format', 'stream-json');\r\n      }\r\n      if (!isLast) {\r\n        args.push('--output-format', 'stream-json');\r\n      }\r\n      args.push(step.prompt);\r\n\r\n      // Spawn Claude process\r\n      const claudeProcess = spawn('claude', args, {\r\n        stdio: inputStream ? ['pipe', 'pipe', 'pipe'] : ['inherit', 'pipe', 'pipe']\r\n      });\r\n\r\n      let output = '';\r\n      let streamOutput = '';\r\n\r\n      // Pipe input if available\r\n      if (inputStream && claudeProcess.stdin) {\r\n        inputStream.pipe(claudeProcess.stdin);\r\n      }\r\n\r\n      // Capture output\r\n      claudeProcess.stdout.on('data', (data) => {\r\n        const chunk = data.toString();\r\n        output += chunk;\r\n        if (!isLast) {\r\n          streamOutput += chunk;\r\n        }\r\n      });\r\n\r\n      claudeProcess.on('close', (code) => {\r\n        const duration = Date.now() - startTime;\r\n        \r\n        // Parse output for summary\r\n        let summary = 'Step completed';\r\n        try {\r\n          if (output.includes('\"type\":\"message\"')) {\r\n            const lines = output.split('\\n');\r\n            for (const line of lines) {\r\n              if (line.includes('\"type\":\"message\"')) {\r\n                const parsed = JSON.parse(line);\r\n                if (parsed.content && parsed.content[0]) {\r\n                  summary = parsed.content[0].text?.slice(0, 100) || summary;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            summary = output.slice(0, 100);\r\n          }\r\n        } catch (e) {\r\n          // Fallback to raw output\r\n          summary = output.slice(0, 100);\r\n        }\r\n\r\n        resolve({\r\n          success: code === 0,\r\n          duration,\r\n          summary,\r\n          stream: !isLast ? streamOutput : null\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompose task into stream chain steps\r\n   */\r\n  decomposeTask(task, strategy) {\r\n    // Different decomposition based on strategy\r\n    if (strategy === 'conservative') {\r\n      return [\r\n        {\r\n          description: 'Thorough analysis and validation',\r\n          prompt: `Analyze this task thoroughly and identify all requirements: ${task}`\r\n        },\r\n        {\r\n          description: 'Detailed planning with error handling',\r\n          prompt: 'Create a detailed implementation plan with comprehensive error handling'\r\n        },\r\n        {\r\n          description: 'Safe implementation with validation',\r\n          prompt: 'Implement the solution with extensive validation and safety checks'\r\n        }\r\n      ];\r\n    } else if (strategy === 'aggressive') {\r\n      return [\r\n        {\r\n          description: 'Quick analysis',\r\n          prompt: `Quickly analyze and implement: ${task}`\r\n        },\r\n        {\r\n          description: 'Optimization pass',\r\n          prompt: 'Optimize the implementation for maximum performance'\r\n        }\r\n      ];\r\n    } else {\r\n      // Balanced\r\n      return [\r\n        {\r\n          description: 'Analysis and design',\r\n          prompt: `Analyze and design a solution for: ${task}`\r\n        },\r\n        {\r\n          description: 'Implementation',\r\n          prompt: 'Implement the designed solution'\r\n        },\r\n        {\r\n          description: 'Review and refinement',\r\n          prompt: 'Review the implementation and make necessary refinements'\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update profiles based on execution results\r\n   */\r\n  async updateProfilesFromExecution(strategy, result) {\r\n    const profiles = JSON.parse(\r\n      await fs.readFile('.claude-flow/agents/profiles.json', 'utf8')\r\n    );\r\n\r\n    if (profiles[strategy]) {\r\n      const profile = profiles[strategy];\r\n      const executionScore = result.success ? 80 : 20;\r\n      const timeScore = Math.max(0, 100 - result.duration / 100);\r\n      const overallScore = (executionScore + timeScore) / 2;\r\n\r\n      // Update with learning\r\n      const learningRate = 0.2;\r\n      profile.avgScore = profile.avgScore * (1 - learningRate) + overallScore * learningRate;\r\n      profile.avgExecutionTime = profile.avgExecutionTime * (1 - learningRate) + result.duration * learningRate;\r\n      profile.uses++;\r\n\r\n      // Add to trend\r\n      if (!profile.trend) profile.trend = [];\r\n      profile.trend.push({\r\n        score: overallScore,\r\n        timestamp: new Date().toISOString(),\r\n        streamExecution: true\r\n      });\r\n\r\n      await fs.writeFile(\r\n        '.claude-flow/agents/profiles.json',\r\n        JSON.stringify(profiles, null, 2)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * CLI Command Handler\r\n */\r\nexport async function trainAndStreamCommand(args, flags) {\r\n  const system = new TrainAndStreamSystem();\r\n  const task = args.join(' ') || 'Create a function to validate email addresses';\r\n\r\n  console.log('üöÄ Train & Stream System');\r\n  console.log(`üìã Task: ${task}`);\r\n  console.log('');\r\n\r\n  const options = {\r\n    complexity: flags.complexity || 'medium',\r\n    iterations: parseInt(flags.iterations) || 2,\r\n    priorities: {\r\n      reliability: parseFloat(flags.reliability) || 0.4,\r\n      speed: parseFloat(flags.speed) || 0.3,\r\n      score: parseFloat(flags.score) || 0.3\r\n    }\r\n  };\r\n\r\n  try {\r\n    const result = await system.trainAndExecute(task, options);\r\n    \r\n    console.log('\\n' + '‚ïê'.repeat(50));\r\n    console.log('üìä Final Report');\r\n    console.log('‚ïê'.repeat(50));\r\n    \r\n    console.log('\\nüéØ Strategy Used:', result.strategy);\r\n    console.log('‚è±Ô∏è  Total Execution Time:', result.performance.executionTime + 'ms');\r\n    console.log('‚úÖ Success:', result.performance.success ? 'Yes' : 'No');\r\n    \r\n    if (result.performance.trainingImprovement) {\r\n      console.log('\\nüìà Training Improvements:');\r\n      console.log(`   Success Rate: ${result.performance.trainingImprovement.successRate > 0 ? '+' : ''}${result.performance.trainingImprovement.successRate.toFixed(1)}%`);\r\n      console.log(`   Score: ${result.performance.trainingImprovement.score > 0 ? '+' : ''}${result.performance.trainingImprovement.score.toFixed(1)}%`);\r\n    }\r\n\r\n    console.log('\\nüîó Stream Chain Steps:');\r\n    for (const step of result.execution.steps) {\r\n      console.log(`   ${step.step}. ${step.description} (${step.duration}ms)`);\r\n      console.log(`      Output: ${step.output.slice(0, 60)}...`);\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Error:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nexport default TrainAndStreamSystem;"],"names":["fs","spawn","TrainingPipeline","TrainAndStreamSystem","trainingPipeline","streamConfig","trainAndExecute","task","options","console","log","repeat","initialize","trainingResult","runFullPipeline","complexity","iterations","validate","profiles","JSON","parse","readFile","strategy","selectOptimalStrategy","name","profile","successRate","toFixed","avgScore","avgExecutionTime","result","executeStreamChain","updateProfilesFromExecution","training","execution","performance","trainingImprovement","improvements","executionTime","duration","success","priorities","reliability","speed","score","bestScore","bestStrategy","Object","entries","startTime","Date","now","steps","decomposeTask","length","forEach","step","i","description","inputStream","lastOutput","results","output","executeStreamStep","push","summary","stream","totalDuration","finalOutput","isLast","Promise","resolve","args","prompt","claudeProcess","stdio","streamOutput","stdin","pipe","stdout","on","data","chunk","toString","code","includes","lines","split","line","parsed","content","text","slice","e","executionScore","timeScore","Math","max","overallScore","learningRate","uses","trend","timestamp","toISOString","streamExecution","writeFile","stringify","trainAndStreamCommand","flags","system","join","parseInt","parseFloat","error","message","process","exit"],"mappings":";AAMA,OAAOA,QAAQ,cAAc;AAC7B,SAASC,KAAK,QAAQ,gBAAgB;AACtC,SAASC,gBAAgB,QAAQ,yBAAyB;AAE1D,OAAO,MAAMC;IACX,aAAc;QACZ,IAAI,CAACC,gBAAgB,GAAG,IAAIF;QAC5B,IAAI,CAACG,YAAY,GAAG;IACtB;IAKA,MAAMC,gBAAgBC,IAAI,EAAEC,UAAU,CAAC,CAAC,EAAE;QACxCC,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAGvBF,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAEvB,MAAM,IAAI,CAACP,gBAAgB,CAACQ,UAAU;QACtC,MAAMC,iBAAiB,MAAM,IAAI,CAACT,gBAAgB,CAACU,eAAe,CAAC;YACjEC,YAAYP,QAAQO,UAAU,IAAI;YAClCC,YAAYR,QAAQQ,UAAU,IAAI;YAClCC,UAAU;QACZ;QAGA,MAAMC,WAAWC,KAAKC,KAAK,CACzB,MAAMpB,GAAGqB,QAAQ,CAAC,qCAAqC;QAIzD,MAAMC,WAAW,IAAI,CAACC,qBAAqB,CAACL,UAAUV;QACtDC,QAAQC,GAAG,CAAC,CAAC,wBAAwB,EAAEY,SAASE,IAAI,EAAE;QACtDf,QAAQC,GAAG,CAAC,CAAC,iBAAiB,EAAE,AAACY,CAAAA,SAASG,OAAO,CAACC,WAAW,GAAG,GAAE,EAAGC,OAAO,CAAC,GAAG,CAAC,CAAC;QAClFlB,QAAQC,GAAG,CAAC,CAAC,cAAc,EAAEY,SAASG,OAAO,CAACG,QAAQ,CAACD,OAAO,CAAC,IAAI;QACnElB,QAAQC,GAAG,CAAC,CAAC,mBAAmB,EAAEY,SAASG,OAAO,CAACI,gBAAgB,CAACF,OAAO,CAAC,GAAG,EAAE,CAAC;QAGlFlB,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAEvB,MAAMmB,SAAS,MAAM,IAAI,CAACC,kBAAkB,CAACxB,MAAMe,UAAUd;QAG7D,MAAM,IAAI,CAACwB,2BAA2B,CAACV,SAASE,IAAI,EAAEM;QAEtD,OAAO;YACLG,UAAUpB;YACVqB,WAAWJ;YACXR,UAAUA,SAASE,IAAI;YACvBW,aAAa;gBACXC,qBAAqBvB,eAAewB,YAAY;gBAChDC,eAAeR,OAAOS,QAAQ;gBAC9BC,SAASV,OAAOU,OAAO;YACzB;QACF;IACF;IAKAjB,sBAAsBL,QAAQ,EAAEV,OAAO,EAAE;QACvC,MAAMiC,aAAajC,QAAQiC,UAAU,IAAI;YACvCC,aAAa;YACbC,OAAO;YACPC,OAAO;QACT;QAEA,IAAIC,YAAY,CAAC;QACjB,IAAIC,eAAe;QAEnB,KAAK,MAAM,CAACtB,MAAMC,QAAQ,IAAIsB,OAAOC,OAAO,CAAC9B,UAAW;YACtD,MAAM0B,QACJ,AAACnB,QAAQC,WAAW,GAAGe,WAAWC,WAAW,GAC5C,AAAC,CAAA,IAAIjB,QAAQI,gBAAgB,GAAG,IAAG,IAAKY,WAAWE,KAAK,GACxDlB,QAAQG,QAAQ,GAAG,MAAMa,WAAWG,KAAK;YAE5C,IAAIA,QAAQC,WAAW;gBACrBA,YAAYD;gBACZE,eAAe;oBAAEtB;oBAAMC;oBAASmB;gBAAM;YACxC;QACF;QAEA,OAAOE;IACT;IAKA,MAAMf,mBAAmBxB,IAAI,EAAEe,QAAQ,EAAEd,OAAO,EAAE;QAChD,MAAMyC,YAAYC,KAAKC,GAAG;QAC1B,MAAMC,QAAQ,IAAI,CAACC,aAAa,CAAC9C,MAAMe,SAASE,IAAI;QAEpDf,QAAQC,GAAG,CAAC,CAAC,0BAA0B,EAAE0C,MAAME,MAAM,CAAC,OAAO,CAAC;QAC9DF,MAAMG,OAAO,CAAC,CAACC,MAAMC;YACnBhD,QAAQC,GAAG,CAAC,CAAC,GAAG,EAAE+C,IAAI,EAAE,EAAE,EAAED,KAAKE,WAAW,EAAE;QAChD;QAEA,IAAIC,cAAc;QAClB,IAAIC,aAAa;QACjB,MAAMC,UAAU,EAAE;QAElB,IAAK,IAAIJ,IAAI,GAAGA,IAAIL,MAAME,MAAM,EAAEG,IAAK;YACrC,MAAMD,OAAOJ,KAAK,CAACK,EAAE;YACrBhD,QAAQC,GAAG,CAAC,CAAC,oBAAoB,EAAE+C,IAAI,EAAE,EAAE,EAAED,KAAKE,WAAW,EAAE;YAE/D,MAAMI,SAAS,MAAM,IAAI,CAACC,iBAAiB,CACzCP,MACAG,aACAF,MAAML,MAAME,MAAM,GAAG;YAGvBO,QAAQG,IAAI,CAAC;gBACXR,MAAMC,IAAI;gBACVC,aAAaF,KAAKE,WAAW;gBAC7BI,QAAQA,OAAOG,OAAO;gBACtB1B,UAAUuB,OAAOvB,QAAQ;YAC3B;YAEAoB,cAAcG,OAAOI,MAAM;YAC3BN,aAAaE;QACf;QAEA,MAAMK,gBAAgBjB,KAAKC,GAAG,KAAKF;QAEnCxC,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,CAAC,mBAAmB,EAAEyD,cAAc,EAAE,CAAC;QACnD1D,QAAQC,GAAG,CAAC,CAAC,oBAAoB,EAAEmD,QAAQP,MAAM,EAAE;QAEnD,OAAO;YACLd,SAAS;YACTD,UAAU4B;YACVf,OAAOS;YACPO,aAAaR,WAAWK,OAAO;QACjC;IACF;IAKA,MAAMF,kBAAkBP,IAAI,EAAEG,WAAW,EAAEU,MAAM,EAAE;QACjD,OAAO,IAAIC,QAAQ,CAACC;YAClB,MAAMtB,YAAYC,KAAKC,GAAG;YAG1B,MAAMqB,OAAO;gBAAC;aAAK;YACnB,IAAIb,aAAa;gBACfa,KAAKR,IAAI,CAAC,kBAAkB;YAC9B;YACA,IAAI,CAACK,QAAQ;gBACXG,KAAKR,IAAI,CAAC,mBAAmB;YAC/B;YACAQ,KAAKR,IAAI,CAACR,KAAKiB,MAAM;YAGrB,MAAMC,gBAAgBzE,MAAM,UAAUuE,MAAM;gBAC1CG,OAAOhB,cAAc;oBAAC;oBAAQ;oBAAQ;iBAAO,GAAG;oBAAC;oBAAW;oBAAQ;iBAAO;YAC7E;YAEA,IAAIG,SAAS;YACb,IAAIc,eAAe;YAGnB,IAAIjB,eAAee,cAAcG,KAAK,EAAE;gBACtClB,YAAYmB,IAAI,CAACJ,cAAcG,KAAK;YACtC;YAGAH,cAAcK,MAAM,CAACC,EAAE,CAAC,QAAQ,CAACC;gBAC/B,MAAMC,QAAQD,KAAKE,QAAQ;gBAC3BrB,UAAUoB;gBACV,IAAI,CAACb,QAAQ;oBACXO,gBAAgBM;gBAClB;YACF;YAEAR,cAAcM,EAAE,CAAC,SAAS,CAACI;gBACzB,MAAM7C,WAAWW,KAAKC,GAAG,KAAKF;gBAG9B,IAAIgB,UAAU;gBACd,IAAI;oBACF,IAAIH,OAAOuB,QAAQ,CAAC,qBAAqB;wBACvC,MAAMC,QAAQxB,OAAOyB,KAAK,CAAC;wBAC3B,KAAK,MAAMC,QAAQF,MAAO;4BACxB,IAAIE,KAAKH,QAAQ,CAAC,qBAAqB;gCACrC,MAAMI,SAAStE,KAAKC,KAAK,CAACoE;gCAC1B,IAAIC,OAAOC,OAAO,IAAID,OAAOC,OAAO,CAAC,EAAE,EAAE;oCACvCzB,UAAUwB,OAAOC,OAAO,CAAC,EAAE,CAACC,IAAI,EAAEC,MAAM,GAAG,QAAQ3B;oCACnD;gCACF;4BACF;wBACF;oBACF,OAAO;wBACLA,UAAUH,OAAO8B,KAAK,CAAC,GAAG;oBAC5B;gBACF,EAAE,OAAOC,GAAG;oBAEV5B,UAAUH,OAAO8B,KAAK,CAAC,GAAG;gBAC5B;gBAEArB,QAAQ;oBACN/B,SAAS4C,SAAS;oBAClB7C;oBACA0B;oBACAC,QAAQ,CAACG,SAASO,eAAe;gBACnC;YACF;QACF;IACF;IAKAvB,cAAc9C,IAAI,EAAEe,QAAQ,EAAE;QAE5B,IAAIA,aAAa,gBAAgB;YAC/B,OAAO;gBACL;oBACEoC,aAAa;oBACbe,QAAQ,CAAC,4DAA4D,EAAElE,MAAM;gBAC/E;gBACA;oBACEmD,aAAa;oBACbe,QAAQ;gBACV;gBACA;oBACEf,aAAa;oBACbe,QAAQ;gBACV;aACD;QACH,OAAO,IAAInD,aAAa,cAAc;YACpC,OAAO;gBACL;oBACEoC,aAAa;oBACbe,QAAQ,CAAC,+BAA+B,EAAElE,MAAM;gBAClD;gBACA;oBACEmD,aAAa;oBACbe,QAAQ;gBACV;aACD;QACH,OAAO;YAEL,OAAO;gBACL;oBACEf,aAAa;oBACbe,QAAQ,CAAC,mCAAmC,EAAElE,MAAM;gBACtD;gBACA;oBACEmD,aAAa;oBACbe,QAAQ;gBACV;gBACA;oBACEf,aAAa;oBACbe,QAAQ;gBACV;aACD;QACH;IACF;IAKA,MAAMzC,4BAA4BV,QAAQ,EAAEQ,MAAM,EAAE;QAClD,MAAMZ,WAAWC,KAAKC,KAAK,CACzB,MAAMpB,GAAGqB,QAAQ,CAAC,qCAAqC;QAGzD,IAAIH,QAAQ,CAACI,SAAS,EAAE;YACtB,MAAMG,UAAUP,QAAQ,CAACI,SAAS;YAClC,MAAMwE,iBAAiBhE,OAAOU,OAAO,GAAG,KAAK;YAC7C,MAAMuD,YAAYC,KAAKC,GAAG,CAAC,GAAG,MAAMnE,OAAOS,QAAQ,GAAG;YACtD,MAAM2D,eAAe,AAACJ,CAAAA,iBAAiBC,SAAQ,IAAK;YAGpD,MAAMI,eAAe;YACrB1E,QAAQG,QAAQ,GAAGH,QAAQG,QAAQ,GAAI,CAAA,IAAIuE,YAAW,IAAKD,eAAeC;YAC1E1E,QAAQI,gBAAgB,GAAGJ,QAAQI,gBAAgB,GAAI,CAAA,IAAIsE,YAAW,IAAKrE,OAAOS,QAAQ,GAAG4D;YAC7F1E,QAAQ2E,IAAI;YAGZ,IAAI,CAAC3E,QAAQ4E,KAAK,EAAE5E,QAAQ4E,KAAK,GAAG,EAAE;YACtC5E,QAAQ4E,KAAK,CAACrC,IAAI,CAAC;gBACjBpB,OAAOsD;gBACPI,WAAW,IAAIpD,OAAOqD,WAAW;gBACjCC,iBAAiB;YACnB;YAEA,MAAMxG,GAAGyG,SAAS,CAChB,qCACAtF,KAAKuF,SAAS,CAACxF,UAAU,MAAM;QAEnC;IACF;AACF;AAKA,OAAO,eAAeyF,sBAAsBnC,IAAI,EAAEoC,KAAK;IACrD,MAAMC,SAAS,IAAI1G;IACnB,MAAMI,OAAOiE,KAAKsC,IAAI,CAAC,QAAQ;IAE/BrG,QAAQC,GAAG,CAAC;IACZD,QAAQC,GAAG,CAAC,CAAC,SAAS,EAAEH,MAAM;IAC9BE,QAAQC,GAAG,CAAC;IAEZ,MAAMF,UAAU;QACdO,YAAY6F,MAAM7F,UAAU,IAAI;QAChCC,YAAY+F,SAASH,MAAM5F,UAAU,KAAK;QAC1CyB,YAAY;YACVC,aAAasE,WAAWJ,MAAMlE,WAAW,KAAK;YAC9CC,OAAOqE,WAAWJ,MAAMjE,KAAK,KAAK;YAClCC,OAAOoE,WAAWJ,MAAMhE,KAAK,KAAK;QACpC;IACF;IAEA,IAAI;QACF,MAAMd,SAAS,MAAM+E,OAAOvG,eAAe,CAACC,MAAMC;QAElDC,QAAQC,GAAG,CAAC,OAAO,IAAIC,MAAM,CAAC;QAC9BF,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAEvBF,QAAQC,GAAG,CAAC,uBAAuBoB,OAAOR,QAAQ;QAClDb,QAAQC,GAAG,CAAC,6BAA6BoB,OAAOK,WAAW,CAACG,aAAa,GAAG;QAC5E7B,QAAQC,GAAG,CAAC,cAAcoB,OAAOK,WAAW,CAACK,OAAO,GAAG,QAAQ;QAE/D,IAAIV,OAAOK,WAAW,CAACC,mBAAmB,EAAE;YAC1C3B,QAAQC,GAAG,CAAC;YACZD,QAAQC,GAAG,CAAC,CAAC,iBAAiB,EAAEoB,OAAOK,WAAW,CAACC,mBAAmB,CAACV,WAAW,GAAG,IAAI,MAAM,KAAKI,OAAOK,WAAW,CAACC,mBAAmB,CAACV,WAAW,CAACC,OAAO,CAAC,GAAG,CAAC,CAAC;YACpKlB,QAAQC,GAAG,CAAC,CAAC,UAAU,EAAEoB,OAAOK,WAAW,CAACC,mBAAmB,CAACQ,KAAK,GAAG,IAAI,MAAM,KAAKd,OAAOK,WAAW,CAACC,mBAAmB,CAACQ,KAAK,CAACjB,OAAO,CAAC,GAAG,CAAC,CAAC;QACnJ;QAEAlB,QAAQC,GAAG,CAAC;QACZ,KAAK,MAAM8C,QAAQ1B,OAAOI,SAAS,CAACkB,KAAK,CAAE;YACzC3C,QAAQC,GAAG,CAAC,CAAC,GAAG,EAAE8C,KAAKA,IAAI,CAAC,EAAE,EAAEA,KAAKE,WAAW,CAAC,EAAE,EAAEF,KAAKjB,QAAQ,CAAC,GAAG,CAAC;YACvE9B,QAAQC,GAAG,CAAC,CAAC,cAAc,EAAE8C,KAAKM,MAAM,CAAC8B,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC;QAC5D;IAEF,EAAE,OAAOqB,OAAO;QACdxG,QAAQwG,KAAK,CAAC,YAAYA,MAAMC,OAAO;QACvCC,QAAQC,IAAI,CAAC;IACf;AACF;AAEA,eAAejH,qBAAqB"}