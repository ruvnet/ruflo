{"version":3,"sources":["../../../src/core/TopologyManager.ts"],"sourcesContent":["/**\r\n * TopologyManager - Manages swarm topology (mesh, hierarchical, ring, star)\r\n * Implements network topology patterns for agent coordination\r\n */\r\n\r\nimport { IDatabaseProvider, ITopology, Agent, Network, Connection, Optimization, TopologyType, NetworkMetrics } from '../types/interfaces.js';\r\n\r\nexport class TopologyManager {\r\n  private currentTopology: ITopology | null = null;\r\n  private agents: Agent[] = [];\r\n  private connections: Connection[] = [];\r\n\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  /**\r\n   * Configure the swarm topology\r\n   */\r\n  async configure(topologyType: TopologyType, agents: Agent[] = []): Promise<Network> {\r\n    this.agents = agents;\r\n    this.currentTopology = this.createTopology(topologyType);\r\n\r\n    const network = await this.currentTopology.configure(agents);\r\n    this.connections = network.connections;\r\n\r\n    // Persist topology configuration\r\n    await this.database.store('topology', {\r\n      type: topologyType,\r\n      agentCount: agents.length,\r\n      connectionCount: network.connections.length,\r\n      timestamp: new Date().toISOString()\r\n    }, 'system');\r\n\r\n    return network;\r\n  }\r\n\r\n  /**\r\n   * Create specific topology implementation\r\n   */\r\n  private createTopology(type: TopologyType): ITopology {\r\n    switch (type) {\r\n      case 'mesh':\r\n        return new MeshTopology();\r\n      case 'hierarchical':\r\n        return new HierarchicalTopology();\r\n      case 'ring':\r\n        return new RingTopology();\r\n      case 'star':\r\n        return new StarTopology();\r\n      default:\r\n        throw new Error(`Unknown topology type: ${type}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add agent to topology\r\n   */\r\n  async addAgent(agent: Agent): Promise<void> {\r\n    if (!this.currentTopology) {\r\n      throw new Error('Topology not configured');\r\n    }\r\n\r\n    this.agents.push(agent);\r\n    const network = await this.currentTopology.configure(this.agents);\r\n    this.connections = network.connections;\r\n\r\n    await this.database.store(`agent:${agent.id}`, agent, 'agents');\r\n  }\r\n\r\n  /**\r\n   * Remove agent from topology\r\n   */\r\n  async removeAgent(agentId: string): Promise<void> {\r\n    if (!this.currentTopology) {\r\n      throw new Error('Topology not configured');\r\n    }\r\n\r\n    this.agents = this.agents.filter(agent => agent.id !== agentId);\r\n    const network = await this.currentTopology.configure(this.agents);\r\n    this.connections = network.connections;\r\n\r\n    await this.database.delete(`agent:${agentId}`, 'agents');\r\n  }\r\n\r\n  /**\r\n   * Optimize current topology\r\n   */\r\n  async optimize(): Promise<Optimization> {\r\n    if (!this.currentTopology) {\r\n      throw new Error('Topology not configured');\r\n    }\r\n\r\n    const optimization = await this.currentTopology.optimize();\r\n\r\n    // Apply optimization changes\r\n    for (const change of optimization.changes) {\r\n      switch (change.action) {\r\n        case 'add-connection':\r\n          this.connections.push(change.connection);\r\n          break;\r\n        case 'remove-connection':\r\n          this.connections = this.connections.filter(conn =>\r\n            !(conn.from === change.connection.from && conn.to === change.connection.to)\r\n          );\r\n          break;\r\n        case 'modify-weight':\r\n          const existing = this.connections.find(conn =>\r\n            conn.from === change.connection.from && conn.to === change.connection.to\r\n          );\r\n          if (existing) {\r\n            existing.weight = change.connection.weight;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    return optimization;\r\n  }\r\n\r\n  /**\r\n   * Get current topology information\r\n   */\r\n  async getTopologyInfo(): Promise<{\r\n    type: TopologyType;\r\n    agents: Agent[];\r\n    connections: Connection[];\r\n    metrics: NetworkMetrics;\r\n  }> {\r\n    if (!this.currentTopology) {\r\n      throw new Error('Topology not configured');\r\n    }\r\n\r\n    const metrics = this.calculateMetrics();\r\n\r\n    return {\r\n      type: this.currentTopology.getType(),\r\n      agents: this.agents,\r\n      connections: this.connections,\r\n      metrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate network metrics\r\n   */\r\n  private calculateMetrics(): NetworkMetrics {\r\n    const totalAgents = this.agents.length;\r\n    const totalConnections = this.connections.length;\r\n\r\n    // Calculate average latency\r\n    const latencies = this.connections\r\n      .map(conn => conn.latency || 0)\r\n      .filter(latency => latency > 0);\r\n    const averageLatency = latencies.length > 0\r\n      ? latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length\r\n      : 0;\r\n\r\n    // Estimate throughput based on connections\r\n    const throughput = totalConnections > 0 ? totalAgents / totalConnections : 0;\r\n\r\n    // Calculate reliability (percentage of active agents)\r\n    const activeAgents = this.agents.filter(agent => agent.status === 'active').length;\r\n    const reliability = totalAgents > 0 ? activeAgents / totalAgents : 0;\r\n\r\n    return {\r\n      totalAgents,\r\n      totalConnections,\r\n      averageLatency,\r\n      throughput,\r\n      reliability\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get agents connected to a specific agent\r\n   */\r\n  getConnectedAgents(agentId: string): Agent[] {\r\n    const connectedIds = new Set<string>();\r\n\r\n    this.connections.forEach(conn => {\r\n      if (conn.from === agentId) {\r\n        connectedIds.add(conn.to);\r\n      } else if (conn.to === agentId) {\r\n        connectedIds.add(conn.from);\r\n      }\r\n    });\r\n\r\n    return this.agents.filter(agent => connectedIds.has(agent.id));\r\n  }\r\n\r\n  /**\r\n   * Check if two agents are connected\r\n   */\r\n  areConnected(agentId1: string, agentId2: string): boolean {\r\n    return this.connections.some(conn =>\r\n      (conn.from === agentId1 && conn.to === agentId2) ||\r\n      (conn.from === agentId2 && conn.to === agentId1)\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Mesh Topology - All agents connected to all others\r\n */\r\nclass MeshTopology implements ITopology {\r\n  getType(): TopologyType {\r\n    return 'mesh';\r\n  }\r\n\r\n  async configure(agents: Agent[]): Promise<Network> {\r\n    const connections: Connection[] = [];\r\n\r\n    // Create connections between all pairs\r\n    for (let i = 0; i < agents.length; i++) {\r\n      for (let j = i + 1; j < agents.length; j++) {\r\n        connections.push({\r\n          from: agents[i].id,\r\n          to: agents[j].id,\r\n          type: 'direct',\r\n          weight: 1.0,\r\n          latency: Math.random() * 10 + 5 // 5-15ms simulated latency\r\n        });\r\n      }\r\n    }\r\n\r\n    return {\r\n      topology: 'mesh',\r\n      agents,\r\n      connections,\r\n      metrics: this.calculateMetrics(agents, connections)\r\n    };\r\n  }\r\n\r\n  async optimize(): Promise<Optimization> {\r\n    // For mesh topology, optimization might involve removing redundant connections\r\n    return {\r\n      type: 'latency',\r\n      changes: [],\r\n      expectedImprovement: 0\r\n    };\r\n  }\r\n\r\n  getConnections(): Connection[] {\r\n    return [];\r\n  }\r\n\r\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\r\n    return {\r\n      totalAgents: agents.length,\r\n      totalConnections: connections.length,\r\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\r\n      throughput: agents.length,\r\n      reliability: 0.95 // High reliability for mesh\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Hierarchical Topology - Tree-like structure with coordinators\r\n */\r\nclass HierarchicalTopology implements ITopology {\r\n  getType(): TopologyType {\r\n    return 'hierarchical';\r\n  }\r\n\r\n  async configure(agents: Agent[]): Promise<Network> {\r\n    const connections: Connection[] = [];\r\n\r\n    if (agents.length === 0) {\r\n      return { topology: 'hierarchical', agents, connections, metrics: this.calculateMetrics(agents, connections) };\r\n    }\r\n\r\n    // Select coordinators (every 3-4 agents)\r\n    const coordinators = agents.filter((_, index) => index % 4 === 0);\r\n    const workers = agents.filter((_, index) => index % 4 !== 0);\r\n\r\n    // Connect workers to nearest coordinator\r\n    workers.forEach((worker, index) => {\r\n      const coordinatorIndex = Math.floor(index / 3);\r\n      const coordinator = coordinators[coordinatorIndex] || coordinators[0];\r\n\r\n      connections.push({\r\n        from: worker.id,\r\n        to: coordinator.id,\r\n        type: 'direct',\r\n        weight: 1.0,\r\n        latency: Math.random() * 5 + 2\r\n      });\r\n    });\r\n\r\n    // Connect coordinators in a chain\r\n    for (let i = 0; i < coordinators.length - 1; i++) {\r\n      connections.push({\r\n        from: coordinators[i].id,\r\n        to: coordinators[i + 1].id,\r\n        type: 'relay',\r\n        weight: 2.0,\r\n        latency: Math.random() * 8 + 3\r\n      });\r\n    }\r\n\r\n    return {\r\n      topology: 'hierarchical',\r\n      agents,\r\n      connections,\r\n      metrics: this.calculateMetrics(agents, connections)\r\n    };\r\n  }\r\n\r\n  async optimize(): Promise<Optimization> {\r\n    return {\r\n      type: 'throughput',\r\n      changes: [],\r\n      expectedImprovement: 0\r\n    };\r\n  }\r\n\r\n  getConnections(): Connection[] {\r\n    return [];\r\n  }\r\n\r\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\r\n    return {\r\n      totalAgents: agents.length,\r\n      totalConnections: connections.length,\r\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\r\n      throughput: Math.sqrt(agents.length), // Logarithmic scaling\r\n      reliability: 0.85 // Good reliability\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Ring Topology - Agents connected in a circular pattern\r\n */\r\nclass RingTopology implements ITopology {\r\n  getType(): TopologyType {\r\n    return 'ring';\r\n  }\r\n\r\n  async configure(agents: Agent[]): Promise<Network> {\r\n    const connections: Connection[] = [];\r\n\r\n    if (agents.length < 2) {\r\n      return { topology: 'ring', agents, connections, metrics: this.calculateMetrics(agents, connections) };\r\n    }\r\n\r\n    // Connect each agent to the next (and last to first)\r\n    for (let i = 0; i < agents.length; i++) {\r\n      const nextIndex = (i + 1) % agents.length;\r\n      connections.push({\r\n        from: agents[i].id,\r\n        to: agents[nextIndex].id,\r\n        type: 'direct',\r\n        weight: 1.0,\r\n        latency: Math.random() * 6 + 3\r\n      });\r\n    }\r\n\r\n    return {\r\n      topology: 'ring',\r\n      agents,\r\n      connections,\r\n      metrics: this.calculateMetrics(agents, connections)\r\n    };\r\n  }\r\n\r\n  async optimize(): Promise<Optimization> {\r\n    return {\r\n      type: 'reliability',\r\n      changes: [],\r\n      expectedImprovement: 0\r\n    };\r\n  }\r\n\r\n  getConnections(): Connection[] {\r\n    return [];\r\n  }\r\n\r\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\r\n    return {\r\n      totalAgents: agents.length,\r\n      totalConnections: connections.length,\r\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\r\n      throughput: agents.length * 0.7, // Reduced due to ring bottlenecks\r\n      reliability: 0.75 // Lower reliability due to single points of failure\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Star Topology - All agents connected to a central hub\r\n */\r\nclass StarTopology implements ITopology {\r\n  getType(): TopologyType {\r\n    return 'star';\r\n  }\r\n\r\n  async configure(agents: Agent[]): Promise<Network> {\r\n    const connections: Connection[] = [];\r\n\r\n    if (agents.length === 0) {\r\n      return { topology: 'star', agents, connections, metrics: this.calculateMetrics(agents, connections) };\r\n    }\r\n\r\n    // First agent becomes the hub\r\n    const hub = agents[0];\r\n    const spokes = agents.slice(1);\r\n\r\n    // Connect all spokes to hub\r\n    spokes.forEach(spoke => {\r\n      connections.push({\r\n        from: spoke.id,\r\n        to: hub.id,\r\n        type: 'direct',\r\n        weight: 1.0,\r\n        latency: Math.random() * 4 + 2\r\n      });\r\n    });\r\n\r\n    return {\r\n      topology: 'star',\r\n      agents,\r\n      connections,\r\n      metrics: this.calculateMetrics(agents, connections)\r\n    };\r\n  }\r\n\r\n  async optimize(): Promise<Optimization> {\r\n    return {\r\n      type: 'latency',\r\n      changes: [],\r\n      expectedImprovement: 0\r\n    };\r\n  }\r\n\r\n  getConnections(): Connection[] {\r\n    return [];\r\n  }\r\n\r\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\r\n    return {\r\n      totalAgents: agents.length,\r\n      totalConnections: connections.length,\r\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\r\n      throughput: Math.min(agents.length, 10), // Limited by hub capacity\r\n      reliability: 0.70 // Lower due to single point of failure\r\n    };\r\n  }\r\n}"],"names":["TopologyManager","currentTopology","agents","connections","database","configure","topologyType","createTopology","network","store","type","agentCount","length","connectionCount","timestamp","Date","toISOString","MeshTopology","HierarchicalTopology","RingTopology","StarTopology","Error","addAgent","agent","push","id","removeAgent","agentId","filter","delete","optimize","optimization","change","changes","action","connection","conn","from","to","existing","find","weight","getTopologyInfo","metrics","calculateMetrics","getType","totalAgents","totalConnections","latencies","map","latency","averageLatency","reduce","sum","lat","throughput","activeAgents","status","reliability","getConnectedAgents","connectedIds","Set","forEach","add","has","areConnected","agentId1","agentId2","some","i","j","Math","random","topology","expectedImprovement","getConnections","coordinators","_","index","workers","worker","coordinatorIndex","floor","coordinator","sqrt","nextIndex","hub","spokes","slice","spoke","min"],"mappings":"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"}