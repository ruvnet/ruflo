{
  "version": 3,
  "sources": ["../../src/core/orchestrator.ts"],
  "sourcesContent": ["/**\n * Main orchestrator for Claude-Flow\n */\n\nimport {\n  Config,\n  SystemEvents,\n  AgentProfile,\n  AgentSession,\n  Task,\n  HealthStatus,\n  ComponentHealth,\n  TaskStatus,\n  OrchestratorMetrics,\n} from '../utils/types.js';\nimport { IEventBus } from './event-bus.js';\nimport type { ILogger } from './logger.js';\nimport type { ITerminalManager } from '../terminal/manager.js';\nimport type { IMemoryManager } from '../memory/manager.js';\nimport type { ICoordinationManager } from '../coordination/manager.js';\nimport type { IMCPServer } from '../mcp/server.js';\nimport { SystemError, InitializationError, ShutdownError } from '../utils/errors.js';\nimport { delay, retry, circuitBreaker, CircuitBreaker } from '../utils/helpers.js';\nimport { mkdir, writeFile, readFile } from 'fs/promises';\nimport { join, dirname } from 'path';\nimport { ClaudeAPIClient } from '../api/claude-client.js';\nimport { ConfigManager } from '../config/config-manager.js';\n\nexport interface ISessionManager {\n  createSession(profile: AgentProfile): Promise<AgentSession>;\n  getSession(sessionId: string): AgentSession | undefined;\n  getActiveSessions(): AgentSession[];\n  terminateSession(sessionId: string): Promise<void>;\n  terminateAllSessions(): Promise<void>;\n  persistSessions(): Promise<void>;\n  restoreSessions(): Promise<void>;\n  removeSession(sessionId: string): void;\n}\n\nexport interface IOrchestrator {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  spawnAgent(profile: AgentProfile): Promise<string>;\n  terminateAgent(agentId: string): Promise<void>;\n  assignTask(task: Task): Promise<void>;\n  getHealthStatus(): Promise<HealthStatus>;\n  getMetrics(): Promise<OrchestratorMetrics>;\n  performMaintenance(): Promise<void>;\n}\n\nexport interface SessionPersistence {\n  sessions: Array<AgentSession & { profile: AgentProfile }>;\n  taskQueue: Task[];\n  metrics: {\n    completedTasks: number;\n    failedTasks: number;\n    totalTaskDuration: number;\n  };\n  savedAt: Date;\n}\n\n/**\n * Session manager implementation with persistence\n */\nclass SessionManager implements ISessionManager {\n  private sessions = new Map<string, AgentSession>();\n  private sessionProfiles = new Map<string, AgentProfile>();\n  private persistencePath: string;\n  private persistenceCircuitBreaker: CircuitBreaker;\n\n  constructor(\n    private terminalManager: ITerminalManager,\n    private memoryManager: IMemoryManager,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n    private config: Config,\n  ) {\n    this.persistencePath = join(config.orchestrator.dataDir || './data', 'sessions.json');\n\n    // Circuit breaker for persistence operations\n    this.persistenceCircuitBreaker = circuitBreaker('SessionPersistence', {\n      threshold: 5,\n      timeout: 30000,\n      resetTimeout: 60000,\n    });\n  }\n\n  async createSession(profile: AgentProfile): Promise<AgentSession> {\n    try {\n      // Create terminal with retry logic\n      const terminalId = await retry(() => this.terminalManager.spawnTerminal(profile), {\n        maxAttempts: 3,\n        initialDelay: 1000,\n      });\n\n      // Create memory bank with retry logic\n      const memoryBankId = await retry(() => this.memoryManager.createBank(profile.id), {\n        maxAttempts: 3,\n        initialDelay: 1000,\n      });\n\n      // Create session\n      const session: AgentSession = {\n        id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        agentId: profile.id,\n        terminalId,\n        startTime: new Date(),\n        status: 'active',\n        lastActivity: new Date(),\n        memoryBankId,\n      };\n\n      this.sessions.set(session.id, session);\n      this.sessionProfiles.set(session.id, profile);\n\n      this.logger.info('Session created', {\n        sessionId: session.id,\n        agentId: profile.id,\n        terminalId,\n        memoryBankId,\n      });\n\n      // Persist sessions asynchronously\n      this.persistSessions().catch((error) =>\n        this.logger.error('Failed to persist sessions', error),\n      );\n\n      return session;\n    } catch (error) {\n      this.logger.error('Failed to create session', { agentId: profile.id, error });\n      throw new SystemError(`Failed to create session for agent ${profile.id}`, { error });\n    }\n  }\n\n  getSession(sessionId: string): AgentSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  getActiveSessions(): AgentSession[] {\n    return Array.from(this.sessions.values()).filter(\n      (session) => session.status === 'active' || session.status === 'idle',\n    );\n  }\n\n  async terminateSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    try {\n      // Update session status first\n      session.status = 'terminated';\n      session.endTime = new Date();\n\n      // Terminate terminal with timeout\n      await Promise.race([\n        this.terminalManager.terminateTerminal(session.terminalId),\n        delay(5000).then(() => {\n          throw new Error('Terminal termination timeout');\n        }),\n      ]).catch((error) => {\n        this.logger.error('Error terminating terminal', { sessionId, error });\n      });\n\n      // Close memory bank with timeout\n      await Promise.race([\n        this.memoryManager.closeBank(session.memoryBankId),\n        delay(5000).then(() => {\n          throw new Error('Memory bank close timeout');\n        }),\n      ]).catch((error) => {\n        this.logger.error('Error closing memory bank', { sessionId, error });\n      });\n\n      // Clean up\n      this.sessionProfiles.delete(sessionId);\n\n      this.logger.info('Session terminated', {\n        sessionId,\n        duration: session.endTime.getTime() - session.startTime.getTime(),\n      });\n\n      // Persist sessions asynchronously\n      this.persistSessions().catch((error) =>\n        this.logger.error('Failed to persist sessions', error),\n      );\n    } catch (error) {\n      this.logger.error('Error during session termination', { sessionId, error });\n      throw error;\n    }\n  }\n\n  async terminateAllSessions(): Promise<void> {\n    const sessions = this.getActiveSessions();\n\n    // Terminate sessions in batches to avoid overwhelming the system\n    const batchSize = 5;\n    for (let i = 0; i < sessions.length; i += batchSize) {\n      const batch = sessions.slice(i, i + batchSize);\n      await Promise.allSettled(batch.map((session) => this.terminateSession(session.id)));\n    }\n  }\n\n  removeSession(sessionId: string): void {\n    this.sessions.delete(sessionId);\n    this.sessionProfiles.delete(sessionId);\n  }\n\n  async persistSessions(): Promise<void> {\n    if (!this.config.orchestrator.persistSessions) {\n      return;\n    }\n\n    try {\n      await this.persistenceCircuitBreaker.execute(async () => {\n        const data: SessionPersistence = {\n          sessions: Array.from(this.sessions.values())\n            .map((session) => ({\n              ...session,\n              profile: this.sessionProfiles.get(session.id)!,\n            }))\n            .filter((s) => s.profile),\n          taskQueue: [],\n          metrics: {\n            completedTasks: 0,\n            failedTasks: 0,\n            totalTaskDuration: 0,\n          },\n          savedAt: new Date(),\n        };\n\n        await mkdir(dirname(this.persistencePath), { recursive: true });\n        await writeFile(this.persistencePath, JSON.stringify(data, null, 2), 'utf8');\n\n        this.logger.debug('Sessions persisted', { count: data.sessions.length });\n      });\n    } catch (error) {\n      this.logger.error('Failed to persist sessions', error);\n    }\n  }\n\n  async restoreSessions(): Promise<void> {\n    if (!this.config.orchestrator.persistSessions) {\n      return;\n    }\n\n    try {\n      const data = await readFile(this.persistencePath, 'utf8');\n      const persistence: SessionPersistence = JSON.parse(data);\n\n      // Restore only active/idle sessions\n      const sessionsToRestore = persistence.sessions.filter(\n        (s) => s.status === 'active' || s.status === 'idle',\n      );\n\n      for (const sessionData of sessionsToRestore) {\n        try {\n          // Recreate session\n          const session = await this.createSession(sessionData.profile);\n\n          // Update with persisted data\n          Object.assign(session, {\n            id: sessionData.id,\n            startTime: new Date(sessionData.startTime),\n            lastActivity: new Date(sessionData.lastActivity),\n          });\n\n          this.logger.info('Session restored', { sessionId: session.id });\n        } catch (error) {\n          this.logger.error('Failed to restore session', {\n            sessionId: sessionData.id,\n            error,\n          });\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n        this.logger.error('Failed to restore sessions', error);\n      }\n    }\n  }\n}\n\n/**\n * Main orchestrator implementation with enhanced features\n */\nexport class Orchestrator implements IOrchestrator {\n  private initialized = false;\n  private shutdownInProgress = false;\n  private sessionManager: ISessionManager;\n  private healthCheckInterval?: number;\n  private maintenanceInterval?: number;\n  private metricsInterval?: number;\n  private agents = new Map<string, AgentProfile>();\n  private taskQueue: Task[] = [];\n  private taskHistory = new Map<string, Task>();\n  private startTime = Date.now();\n  private claudeClient?: ClaudeAPIClient;\n  private configManager: ConfigManager;\n\n  // Metrics tracking\n  private metrics = {\n    completedTasks: 0,\n    failedTasks: 0,\n    totalTaskDuration: 0,\n  };\n\n  // Circuit breakers for critical operations\n  private healthCheckCircuitBreaker: CircuitBreaker;\n  private taskAssignmentCircuitBreaker: CircuitBreaker;\n\n  constructor(\n    private config: Config,\n    private terminalManager: ITerminalManager,\n    private memoryManager: IMemoryManager,\n    private coordinationManager: ICoordinationManager,\n    private mcpServer: IMCPServer,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    this.sessionManager = new SessionManager(\n      terminalManager,\n      memoryManager,\n      eventBus,\n      logger,\n      config,\n    );\n\n    this.configManager = ConfigManager.getInstance();\n\n    // Initialize circuit breakers\n    this.healthCheckCircuitBreaker = circuitBreaker('HealthCheck', {\n      threshold: 3,\n      timeout: 10000,\n      resetTimeout: 30000,\n    });\n\n    this.taskAssignmentCircuitBreaker = circuitBreaker('TaskAssignment', {\n      threshold: 5,\n      timeout: 5000,\n      resetTimeout: 20000,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      throw new InitializationError('Orchestrator already initialized');\n    }\n\n    this.logger.info('Initializing orchestrator...');\n    const startTime = Date.now();\n\n    try {\n      // Initialize components in parallel where possible\n      await Promise.all([\n        this.initializeComponent('Terminal Manager', () => this.terminalManager.initialize()),\n        this.initializeComponent('Memory Manager', () => this.memoryManager.initialize()),\n        this.initializeComponent('Coordination Manager', () =>\n          this.coordinationManager.initialize(),\n        ),\n      ]);\n\n      // MCP server needs to be started after other components\n      await this.initializeComponent('MCP Server', () => this.mcpServer.start());\n\n      // Initialize Claude API client if configured\n      if (this.configManager.isClaudeAPIConfigured()) {\n        try {\n          this.claudeClient = new ClaudeAPIClient(this.logger, this.configManager);\n          this.logger.info('Claude API client initialized', {\n            model: this.claudeClient.getConfig().model,\n            temperature: this.claudeClient.getConfig().temperature,\n          });\n        } catch (error) {\n          this.logger.warn('Failed to initialize Claude API client', error);\n        }\n      }\n\n      // Restore persisted sessions\n      await this.sessionManager.restoreSessions();\n\n      // Set up event handlers\n      this.setupEventHandlers();\n\n      // Start background tasks\n      this.startHealthChecks();\n      this.startMaintenanceTasks();\n      this.startMetricsCollection();\n\n      this.initialized = true;\n\n      const initDuration = Date.now() - startTime;\n      this.eventBus.emit(SystemEvents.SYSTEM_READY, { timestamp: new Date() });\n      this.logger.info('Orchestrator initialized successfully', { duration: initDuration });\n    } catch (error) {\n      this.logger.error('Failed to initialize orchestrator', error);\n\n      // Attempt cleanup on initialization failure\n      await this.emergencyShutdown();\n\n      throw new InitializationError('Orchestrator', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized || this.shutdownInProgress) {\n      return;\n    }\n\n    this.shutdownInProgress = true;\n    this.logger.info('Shutting down orchestrator...');\n    const shutdownStart = Date.now();\n\n    try {\n      // Stop background tasks\n      this.stopBackgroundTasks();\n\n      // Save current state\n      await this.sessionManager.persistSessions();\n\n      // Process any remaining critical tasks\n      await this.processShutdownTasks();\n\n      // Terminate all sessions\n      await this.sessionManager.terminateAllSessions();\n\n      // Shutdown components with timeout\n      await Promise.race([\n        this.shutdownComponents(),\n        delay(this.config.orchestrator.shutdownTimeout),\n      ]);\n\n      const shutdownDuration = Date.now() - shutdownStart;\n      this.eventBus.emit(SystemEvents.SYSTEM_SHUTDOWN, { reason: 'Graceful shutdown' });\n      this.logger.info('Orchestrator shutdown complete', { duration: shutdownDuration });\n    } catch (error) {\n      this.logger.error('Error during shutdown', error);\n\n      // Force shutdown if graceful shutdown fails\n      await this.emergencyShutdown();\n\n      throw new ShutdownError('Failed to shutdown gracefully', { error });\n    } finally {\n      this.initialized = false;\n      this.shutdownInProgress = false;\n    }\n  }\n\n  async spawnAgent(profile: AgentProfile): Promise<string> {\n    if (!this.initialized) {\n      throw new SystemError('Orchestrator not initialized');\n    }\n\n    // Check agent limit\n    if (this.agents.size >= this.config.orchestrator.maxConcurrentAgents) {\n      throw new SystemError('Maximum concurrent agents reached');\n    }\n\n    // Validate agent profile\n    this.validateAgentProfile(profile);\n\n    this.logger.info('Spawning agent', { agentId: profile.id, type: profile.type });\n\n    try {\n      // Create session with retry\n      const session = await retry(() => this.sessionManager.createSession(profile), {\n        maxAttempts: 3,\n        initialDelay: 2000,\n      });\n\n      // Store agent profile\n      this.agents.set(profile.id, profile);\n\n      // Emit event\n      this.eventBus.emit(SystemEvents.AGENT_SPAWNED, {\n        agentId: profile.id,\n        profile,\n        sessionId: session.id,\n      });\n\n      // Start agent health monitoring\n      this.startAgentHealthMonitoring(profile.id);\n\n      return session.id;\n    } catch (error) {\n      this.logger.error('Failed to spawn agent', { agentId: profile.id, error });\n      throw error;\n    }\n  }\n\n  async terminateAgent(agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new SystemError('Orchestrator not initialized');\n    }\n\n    const profile = this.agents.get(agentId);\n    if (!profile) {\n      throw new SystemError(`Agent not found: ${agentId}`);\n    }\n\n    this.logger.info('Terminating agent', { agentId });\n\n    try {\n      // Cancel any assigned tasks\n      await this.cancelAgentTasks(agentId);\n\n      // Find and terminate all sessions for this agent\n      const sessions = this.sessionManager\n        .getActiveSessions()\n        .filter((session) => session.agentId === agentId);\n\n      await Promise.allSettled(\n        sessions.map((session) => this.sessionManager.terminateSession(session.id)),\n      );\n\n      // Remove agent\n      this.agents.delete(agentId);\n\n      // Emit event\n      this.eventBus.emit(SystemEvents.AGENT_TERMINATED, {\n        agentId,\n        reason: 'User requested',\n      });\n    } catch (error) {\n      this.logger.error('Failed to terminate agent', { agentId, error });\n      throw error;\n    }\n  }\n\n  async assignTask(task: Task): Promise<void> {\n    if (!this.initialized) {\n      throw new SystemError('Orchestrator not initialized');\n    }\n\n    // Validate task\n    this.validateTask(task);\n\n    // Store task in history\n    this.taskHistory.set(task.id, task);\n\n    try {\n      await this.taskAssignmentCircuitBreaker.execute(async () => {\n        // Add to queue if no agent assigned\n        if (!task.assignedAgent) {\n          if (this.taskQueue.length >= this.config.orchestrator.taskQueueSize) {\n            throw new SystemError('Task queue is full');\n          }\n\n          this.taskQueue.push(task);\n          this.eventBus.emit(SystemEvents.TASK_CREATED, { task });\n\n          // Try to assign immediately\n          await this.processTaskQueue();\n          return;\n        }\n\n        // Assign to specific agent\n        const agent = this.agents.get(task.assignedAgent);\n        if (!agent) {\n          throw new SystemError(`Agent not found: ${task.assignedAgent}`);\n        }\n\n        await this.coordinationManager.assignTask(task, task.assignedAgent);\n\n        this.eventBus.emit(SystemEvents.TASK_ASSIGNED, {\n          taskId: task.id,\n          agentId: task.assignedAgent,\n        });\n      });\n    } catch (error) {\n      this.logger.error('Failed to assign task', { taskId: task.id, error });\n      throw error;\n    }\n  }\n\n  async getHealthStatus(): Promise<HealthStatus> {\n    try {\n      return await this.healthCheckCircuitBreaker.execute(async () => {\n        const components: Record<string, ComponentHealth> = {};\n\n        // Check all components in parallel\n        const [terminal, memory, coordination, mcp] = await Promise.allSettled([\n          this.getComponentHealth(\n            'Terminal Manager',\n            async () => await this.terminalManager.getHealthStatus(),\n          ),\n          this.getComponentHealth(\n            'Memory Manager',\n            async () => await this.memoryManager.getHealthStatus(),\n          ),\n          this.getComponentHealth(\n            'Coordination Manager',\n            async () => await this.coordinationManager.getHealthStatus(),\n          ),\n          this.getComponentHealth('MCP Server', async () => await this.mcpServer.getHealthStatus()),\n        ]);\n\n        // Process results\n        components.terminal = this.processHealthResult(terminal, 'Terminal Manager');\n        components.memory = this.processHealthResult(memory, 'Memory Manager');\n        components.coordination = this.processHealthResult(coordination, 'Coordination Manager');\n        components.mcp = this.processHealthResult(mcp, 'MCP Server');\n\n        // Add orchestrator self-check\n        components.orchestrator = {\n          name: 'Orchestrator',\n          status: 'healthy',\n          lastCheck: new Date(),\n          metrics: {\n            uptime: Date.now() - this.startTime,\n            activeAgents: this.agents.size,\n            queuedTasks: this.taskQueue.length,\n            memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024, // MB\n          },\n        };\n\n        // Determine overall status\n        const statuses = Object.values(components).map((c) => c.status);\n        let overallStatus: HealthStatus['status'] = 'healthy';\n\n        if (statuses.some((s) => s === 'unhealthy')) {\n          overallStatus = 'unhealthy';\n        } else if (statuses.some((s) => s === 'degraded')) {\n          overallStatus = 'degraded';\n        }\n\n        return {\n          status: overallStatus,\n          components,\n          timestamp: new Date(),\n        };\n      });\n    } catch (error) {\n      this.logger.error('Health check failed', error);\n\n      // Return degraded status if health check fails\n      return {\n        status: 'degraded',\n        components: {\n          orchestrator: {\n            name: 'Orchestrator',\n            status: 'degraded',\n            lastCheck: new Date(),\n            error: 'Health check circuit breaker open',\n          },\n        },\n        timestamp: new Date(),\n      };\n    }\n  }\n\n  async getMetrics(): Promise<OrchestratorMetrics> {\n    const memUsage = process.memoryUsage();\n    const cpuUsage = process.cpuUsage();\n\n    const avgTaskDuration =\n      this.metrics.completedTasks > 0\n        ? this.metrics.totalTaskDuration / this.metrics.completedTasks\n        : 0;\n\n    return {\n      uptime: Date.now() - this.startTime,\n      totalAgents: this.agents.size,\n      activeAgents: this.sessionManager.getActiveSessions().length,\n      totalTasks: this.taskHistory.size,\n      completedTasks: this.metrics.completedTasks,\n      failedTasks: this.metrics.failedTasks,\n      queuedTasks: this.taskQueue.length,\n      avgTaskDuration,\n      memoryUsage: memUsage,\n      cpuUsage: cpuUsage,\n      timestamp: new Date(),\n    };\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing maintenance tasks');\n\n    try {\n      // Clean up terminated sessions\n      await this.cleanupTerminatedSessions();\n\n      // Clean up old task history\n      await this.cleanupTaskHistory();\n\n      // Perform component maintenance\n      await Promise.allSettled([\n        this.terminalManager.performMaintenance(),\n        this.memoryManager.performMaintenance(),\n        this.coordinationManager.performMaintenance(),\n      ]);\n\n      // Persist current state\n      await this.sessionManager.persistSessions();\n\n      // Force garbage collection if available\n      if (global.gc) {\n        global.gc();\n      }\n\n      this.logger.debug('Maintenance tasks completed');\n    } catch (error) {\n      this.logger.error('Error during maintenance', error);\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Handle task lifecycle events\n    this.eventBus.on(SystemEvents.TASK_STARTED, (data: unknown) => {\n      const { taskId, agentId } = data as { taskId: string; agentId: string };\n      const task = this.taskHistory.get(taskId);\n      if (task) {\n        task.status = 'running';\n        task.startedAt = new Date();\n      }\n    });\n\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: unknown) => {\n      const { taskId, result } = data as { taskId: string; result: unknown };\n      const task = this.taskHistory.get(taskId);\n      if (task) {\n        task.status = 'completed';\n        task.completedAt = new Date();\n        if (result !== undefined) {\n          task.output = result as Record<string, unknown>;\n        }\n\n        // Update metrics\n        this.metrics.completedTasks++;\n        if (task.startedAt) {\n          this.metrics.totalTaskDuration += task.completedAt.getTime() - task.startedAt.getTime();\n        }\n      }\n\n      await this.processTaskQueue();\n    });\n\n    this.eventBus.on(SystemEvents.TASK_FAILED, async (data: unknown) => {\n      const { taskId, error } = data as { taskId: string; error: Error };\n      const task = this.taskHistory.get(taskId);\n      if (task) {\n        task.status = 'failed';\n        task.completedAt = new Date();\n        task.error = error;\n\n        // Update metrics\n        this.metrics.failedTasks++;\n      }\n\n      // Retry or requeue based on configuration\n      await this.handleTaskFailure(taskId, error);\n    });\n\n    // Handle agent events\n    this.eventBus.on(SystemEvents.AGENT_ERROR, async (data: unknown) => {\n      const { agentId, error } = data as { agentId: string; error: Error };\n      this.logger.error('Agent error', { agentId, error });\n\n      // Implement agent recovery\n      await this.handleAgentError(agentId, error);\n    });\n\n    this.eventBus.on(SystemEvents.AGENT_IDLE, async (data: unknown) => {\n      const { agentId } = data as { agentId: string };\n      // Update session status\n      const sessions = this.sessionManager.getActiveSessions().filter((s) => s.agentId === agentId);\n      sessions.forEach((s) => (s.status = 'idle'));\n\n      // Try to assign queued tasks\n      await this.processTaskQueue();\n    });\n\n    // Handle system events\n    this.eventBus.on(SystemEvents.SYSTEM_ERROR, (data: unknown) => {\n      const { error, component } = data as { error: Error; component: string };\n      this.logger.error('System error', { component, error });\n\n      // Implement system-level error recovery\n      this.handleSystemError(component, error);\n    });\n\n    // Handle resource events\n    this.eventBus.on(SystemEvents.DEADLOCK_DETECTED, (data: unknown) => {\n      const { agents, resources } = data as { agents: string[]; resources: string[] };\n      this.logger.error('Deadlock detected', { agents, resources });\n\n      // Implement deadlock resolution\n      this.resolveDeadlock(agents, resources);\n    });\n  }\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      try {\n        const health = await this.getHealthStatus();\n        this.eventBus.emit(SystemEvents.SYSTEM_HEALTHCHECK, { status: health });\n\n        if (health.status === 'unhealthy') {\n          this.logger.warn('System health check failed', health);\n\n          // Attempt recovery for unhealthy components\n          await this.recoverUnhealthyComponents(health);\n        }\n      } catch (error) {\n        this.logger.error('Health check error', error);\n      }\n    }, this.config.orchestrator.healthCheckInterval);\n  }\n\n  private startMaintenanceTasks(): void {\n    this.maintenanceInterval = setInterval(async () => {\n      await this.performMaintenance();\n    }, this.config.orchestrator.maintenanceInterval || 300000); // 5 minutes default\n  }\n\n  private startMetricsCollection(): void {\n    this.metricsInterval = setInterval(async () => {\n      try {\n        const metrics = await this.getMetrics();\n        this.logger.debug('Metrics collected', metrics);\n\n        // Emit metrics event for monitoring systems\n        this.eventBus.emit('metrics:collected', metrics);\n      } catch (error) {\n        this.logger.error('Metrics collection error', error);\n      }\n    }, this.config.orchestrator.metricsInterval || 60000); // 1 minute default\n  }\n\n  private stopBackgroundTasks(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n    if (this.maintenanceInterval) {\n      clearInterval(this.maintenanceInterval);\n    }\n    if (this.metricsInterval) {\n      clearInterval(this.metricsInterval);\n    }\n  }\n\n  private async shutdownComponents(): Promise<void> {\n    const shutdownTasks = [\n      this.shutdownComponent('Terminal Manager', () => this.terminalManager.shutdown()),\n      this.shutdownComponent('Memory Manager', () => this.memoryManager.shutdown()),\n      this.shutdownComponent('Coordination Manager', () => this.coordinationManager.shutdown()),\n      this.shutdownComponent('MCP Server', () => this.mcpServer.stop()),\n    ];\n\n    const results = await Promise.allSettled(shutdownTasks);\n\n    // Log any shutdown failures\n    results.forEach((result, index) => {\n      if (result.status === 'rejected') {\n        const componentName = [\n          'Terminal Manager',\n          'Memory Manager',\n          'Coordination Manager',\n          'MCP Server',\n        ][index];\n        this.logger.error(`Failed to shutdown ${componentName}`, result.reason);\n      }\n    });\n  }\n\n  private async emergencyShutdown(): Promise<void> {\n    this.logger.warn('Performing emergency shutdown');\n\n    try {\n      // Force stop all components\n      await Promise.allSettled([\n        this.terminalManager.shutdown().catch(() => {}),\n        this.memoryManager.shutdown().catch(() => {}),\n        this.coordinationManager.shutdown().catch(() => {}),\n        this.mcpServer.stop().catch(() => {}),\n      ]);\n    } catch (error) {\n      this.logger.error('Emergency shutdown error', error);\n    }\n  }\n\n  private async processTaskQueue(): Promise<void> {\n    if (this.taskQueue.length === 0) {\n      return;\n    }\n\n    const availableAgents = await this.getAvailableAgents();\n\n    while (this.taskQueue.length > 0 && availableAgents.length > 0) {\n      const task = this.taskQueue.shift()!;\n      const agent = this.selectAgentForTask(task, availableAgents);\n\n      if (agent) {\n        task.assignedAgent = agent.id;\n        task.status = 'assigned';\n\n        try {\n          await this.coordinationManager.assignTask(task, agent.id);\n\n          this.eventBus.emit(SystemEvents.TASK_ASSIGNED, {\n            taskId: task.id,\n            agentId: agent.id,\n          });\n\n          // Remove agent from available list\n          const index = availableAgents.indexOf(agent);\n          availableAgents.splice(index, 1);\n        } catch (error) {\n          // Put task back in queue\n          this.taskQueue.unshift(task);\n          this.logger.error('Failed to assign task', { taskId: task.id, error });\n          break;\n        }\n      } else {\n        // No suitable agent, put task back\n        this.taskQueue.unshift(task);\n        break;\n      }\n    }\n  }\n\n  private async getAvailableAgents(): Promise<AgentProfile[]> {\n    const sessions = this.sessionManager.getActiveSessions();\n    const available: AgentProfile[] = [];\n\n    for (const session of sessions) {\n      if (session.status === 'idle' || session.status === 'active') {\n        const profile = this.agents.get(session.agentId);\n        if (profile) {\n          try {\n            const taskCount = await this.coordinationManager.getAgentTaskCount(profile.id);\n            if (taskCount < profile.maxConcurrentTasks) {\n              available.push(profile);\n            }\n          } catch (error) {\n            this.logger.error('Failed to get agent task count', { agentId: profile.id, error });\n          }\n        }\n      }\n    }\n\n    return available.sort((a, b) => b.priority - a.priority);\n  }\n\n  private selectAgentForTask(task: Task, agents: AgentProfile[]): AgentProfile | undefined {\n    // Score agents based on capabilities, load, and priority\n    const scoredAgents = agents.map((agent) => {\n      let score = agent.priority * 10;\n\n      // Check capability match\n      const requiredCapabilities = (task.metadata?.requiredCapabilities as string[]) || [];\n      const matchedCapabilities = requiredCapabilities.filter((cap) =>\n        agent.capabilities.includes(cap),\n      ).length;\n\n      if (requiredCapabilities.length > 0 && matchedCapabilities === 0) {\n        return { agent, score: -1 }; // Can't handle task\n      }\n\n      score += matchedCapabilities * 5;\n\n      // Prefer agents with matching type\n      if (task.type === agent.type) {\n        score += 20;\n      }\n\n      return { agent, score };\n    });\n\n    // Filter out agents that can't handle the task\n    const eligibleAgents = scoredAgents.filter(({ score }) => score >= 0);\n\n    if (eligibleAgents.length === 0) {\n      return undefined;\n    }\n\n    // Select agent with highest score\n    eligibleAgents.sort((a, b) => b.score - a.score);\n    return eligibleAgents[0].agent;\n  }\n\n  private async getComponentHealth(\n    name: string,\n    check: () => Promise<{ healthy: boolean; error?: string; metrics?: Record<string, number> }>,\n  ): Promise<ComponentHealth> {\n    try {\n      const result = await Promise.race([\n        check(),\n        delay(5000).then(() => ({ healthy: false, error: 'Health check timeout' })),\n      ]);\n\n      const health: ComponentHealth = {\n        name,\n        status: result.healthy ? 'healthy' : 'unhealthy',\n        lastCheck: new Date(),\n      };\n      if (result.error !== undefined) {\n        health.error = result.error;\n      }\n      if ('metrics' in result && result.metrics !== undefined) {\n        health.metrics = result.metrics;\n      }\n      return health;\n    } catch (error) {\n      return {\n        name,\n        status: 'unhealthy',\n        lastCheck: new Date(),\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private processHealthResult(\n    result: PromiseSettledResult<ComponentHealth>,\n    componentName: string,\n  ): ComponentHealth {\n    if (result.status === 'fulfilled') {\n      return result.value;\n    } else {\n      return {\n        name: componentName,\n        status: 'unhealthy',\n        lastCheck: new Date(),\n        error: result.reason?.message || 'Health check failed',\n      };\n    }\n  }\n\n  private async initializeComponent(name: string, init: () => Promise<void>): Promise<void> {\n    try {\n      await retry(init, { maxAttempts: 3, initialDelay: 2000 });\n      this.logger.info(`${name} initialized`);\n    } catch (error) {\n      this.logger.error(`Failed to initialize ${name}`, error);\n      throw new InitializationError(name, { error });\n    }\n  }\n\n  private async shutdownComponent(name: string, shutdown: () => Promise<void>): Promise<void> {\n    try {\n      await Promise.race([\n        shutdown(),\n        delay(10000), // 10 second timeout per component\n      ]);\n      this.logger.info(`${name} shut down`);\n    } catch (error) {\n      this.logger.error(`Failed to shutdown ${name}`, error);\n      throw error;\n    }\n  }\n\n  private validateAgentProfile(profile: AgentProfile): void {\n    if (!profile.id || !profile.name || !profile.type) {\n      throw new Error('Invalid agent profile: missing required fields');\n    }\n\n    if (profile.maxConcurrentTasks < 1) {\n      throw new Error('Invalid agent profile: maxConcurrentTasks must be at least 1');\n    }\n\n    if (this.agents.has(profile.id)) {\n      throw new Error(`Agent with ID ${profile.id} already exists`);\n    }\n  }\n\n  private validateTask(task: Task): void {\n    if (!task.id || !task.type || !task.description) {\n      throw new Error('Invalid task: missing required fields');\n    }\n\n    if (task.priority < 0 || task.priority > 100) {\n      throw new Error('Invalid task: priority must be between 0 and 100');\n    }\n\n    if (this.taskHistory.has(task.id)) {\n      throw new Error(`Task with ID ${task.id} already exists`);\n    }\n  }\n\n  private async handleAgentError(agentId: string, error: Error): Promise<void> {\n    const profile = this.agents.get(agentId);\n    if (!profile) {\n      return;\n    }\n\n    // Log error details\n    this.logger.error('Handling agent error', { agentId, error });\n\n    // Check if agent should be restarted\n    const errorCount = (profile.metadata?.errorCount as number) || 0;\n    profile.metadata = { ...profile.metadata, errorCount: errorCount + 1 };\n\n    if (errorCount < 3) {\n      // Attempt to restart agent\n      try {\n        await this.terminateAgent(agentId);\n        await delay(2000); // Wait before restart\n        await this.spawnAgent({ ...profile, metadata: { ...profile.metadata, errorCount: 0 } });\n        this.logger.info('Agent restarted after error', { agentId });\n      } catch (restartError) {\n        this.logger.error('Failed to restart agent', { agentId, error: restartError });\n      }\n    } else {\n      // Too many errors, terminate agent\n      this.logger.error('Agent exceeded error threshold, terminating', { agentId, errorCount });\n      await this.terminateAgent(agentId);\n    }\n  }\n\n  private async handleTaskFailure(taskId: string, error: Error): Promise<void> {\n    const task = this.taskHistory.get(taskId);\n    if (!task) {\n      return;\n    }\n\n    const retryCount = (task.metadata?.retryCount as number) || 0;\n    const maxRetries = this.config.orchestrator.taskMaxRetries || 3;\n\n    if (retryCount < maxRetries) {\n      // Retry task\n      task.metadata = { ...task.metadata, retryCount: retryCount + 1 };\n      task.status = 'queued';\n      delete task.assignedAgent;\n\n      // Add back to queue with delay\n      setTimeout(\n        () => {\n          this.taskQueue.push(task);\n          this.processTaskQueue();\n        },\n        Math.pow(2, retryCount) * 1000,\n      ); // Exponential backoff\n\n      this.logger.info('Task queued for retry', { taskId, retryCount: retryCount + 1 });\n    } else {\n      this.logger.error('Task exceeded retry limit', { taskId, retryCount });\n    }\n  }\n\n  private handleSystemError(component: string, error: Error): void {\n    // Implement system-level error recovery strategies\n    this.logger.error('Handling system error', { component, error });\n\n    // TODO: Implement specific recovery strategies based on component and error type\n  }\n\n  private async resolveDeadlock(agents: string[], resources: string[]): Promise<void> {\n    this.logger.warn('Resolving deadlock', { agents, resources });\n\n    // Simple deadlock resolution: cancel lowest priority agent's tasks\n    const agentProfiles = agents.map((id) => this.agents.get(id)).filter(Boolean) as AgentProfile[];\n\n    if (agentProfiles.length === 0) {\n      return;\n    }\n\n    // Sort by priority (lowest first)\n    agentProfiles.sort((a, b) => a.priority - b.priority);\n\n    // Cancel tasks for lowest priority agent\n    const targetAgent = agentProfiles[0];\n    await this.cancelAgentTasks(targetAgent.id);\n\n    this.logger.info('Deadlock resolved by cancelling tasks', { agentId: targetAgent.id });\n  }\n\n  private async cancelAgentTasks(agentId: string): Promise<void> {\n    try {\n      const tasks = await this.coordinationManager.getAgentTasks(agentId);\n\n      for (const task of tasks) {\n        await this.coordinationManager.cancelTask(task.id);\n\n        // Update task status\n        const trackedTask = this.taskHistory.get(task.id);\n        if (trackedTask) {\n          trackedTask.status = 'cancelled';\n          trackedTask.completedAt = new Date();\n        }\n\n        this.eventBus.emit(SystemEvents.TASK_CANCELLED, {\n          taskId: task.id,\n          reason: 'Agent termination',\n        });\n      }\n    } catch (error) {\n      this.logger.error('Failed to cancel agent tasks', { agentId, error });\n    }\n  }\n\n  private startAgentHealthMonitoring(agentId: string): void {\n    // TODO: Implement periodic health checks for individual agents\n  }\n\n  private async recoverUnhealthyComponents(health: HealthStatus): Promise<void> {\n    for (const [name, component] of Object.entries(health.components)) {\n      if (component.status === 'unhealthy') {\n        this.logger.warn('Attempting to recover unhealthy component', { name });\n\n        // TODO: Implement component-specific recovery strategies\n        switch (name) {\n          case 'Terminal Manager':\n            // Restart terminal pools, etc.\n            break;\n          case 'Memory Manager':\n            // Clear cache, reconnect to backends, etc.\n            break;\n          case 'Coordination Manager':\n            // Reset locks, clear message queues, etc.\n            break;\n          case 'MCP Server':\n            // Restart server, reset connections, etc.\n            break;\n        }\n      }\n    }\n  }\n\n  private async cleanupTerminatedSessions(): Promise<void> {\n    const allSessions = this.sessionManager.getActiveSessions();\n    const terminatedSessions = allSessions.filter((s) => (s as any).status === 'terminated');\n\n    const cutoffTime = Date.now() - (this.config.orchestrator.sessionRetentionMs || 3600000); // 1 hour default\n\n    for (const session of terminatedSessions) {\n      const typedSession = session as any;\n      if (typedSession.endTime && typedSession.endTime.getTime() < cutoffTime) {\n        await this.sessionManager.terminateSession(typedSession.id);\n        this.logger.debug('Cleaned up old session', { sessionId: typedSession.id });\n      }\n    }\n  }\n\n  private async cleanupTaskHistory(): Promise<void> {\n    const cutoffTime = Date.now() - (this.config.orchestrator.taskHistoryRetentionMs || 86400000); // 24 hours default\n\n    for (const [taskId, task] of this.taskHistory.entries()) {\n      if (task.completedAt && task.completedAt.getTime() < cutoffTime) {\n        this.taskHistory.delete(taskId);\n        this.logger.debug('Cleaned up old task', { taskId });\n      }\n    }\n  }\n\n  private async processShutdownTasks(): Promise<void> {\n    // Process any critical tasks before shutdown\n    const criticalTasks = this.taskQueue.filter(\n      (t) => t.priority >= 90 || t.metadata?.critical === true,\n    );\n\n    if (criticalTasks.length > 0) {\n      this.logger.info('Processing critical tasks before shutdown', {\n        count: criticalTasks.length,\n      });\n\n      // TODO: Implement critical task processing\n    }\n  }\n\n  /**\n   * Get Claude API client instance\n   */\n  getClaudeClient(): ClaudeAPIClient | undefined {\n    return this.claudeClient;\n  }\n\n  /**\n   * Update Claude API configuration dynamically\n   */\n  updateClaudeConfig(config: Partial<Config['claude']>): void {\n    this.configManager.setClaudeConfig(config);\n\n    if (this.claudeClient) {\n      this.claudeClient.updateConfig(config);\n    } else if (this.configManager.isClaudeAPIConfigured()) {\n      // Initialize Claude client with new config\n      try {\n        this.claudeClient = new ClaudeAPIClient(this.logger, this.configManager);\n        this.logger.info('Claude API client initialized with new configuration');\n      } catch (error) {\n        this.logger.error('Failed to initialize Claude API client', error);\n      }\n    }\n  }\n\n  /**\n   * Execute a Claude API request\n   */\n  async executeClaudeRequest(\n    prompt: string,\n    options?: {\n      model?: string;\n      temperature?: number;\n      maxTokens?: number;\n      systemPrompt?: string;\n    },\n  ): Promise<string | null> {\n    if (!this.claudeClient) {\n      this.logger.error('Claude API client not initialized');\n      return null;\n    }\n\n    try {\n      const response = await this.claudeClient.complete(prompt, options as any);\n      return response;\n    } catch (error) {\n      this.logger.error('Claude API request failed', error);\n      return null;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
