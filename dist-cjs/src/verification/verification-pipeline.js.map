{"version":3,"sources":["../../../src/verification/verification-pipeline.ts"],"sourcesContent":["/**\r\n * VerificationPipeline - Orchestrates verification with mandatory checkpoints\r\n * Provides structured verification workflow with rollback capabilities\r\n */\r\n\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { logger } from '../core/logger.js';\r\nimport { AppError } from '../utils/error-handler.js';\r\nimport type { EventEmitter } from 'node:events';\r\nimport type {\r\n  VerificationPipelineConfig,\r\n  VerificationCheckpoint,\r\n  VerificationResult,\r\n  CheckpointResult,\r\n  VerificationStatus,\r\n  CheckpointValidator,\r\n  CheckpointCondition,\r\n  VerificationError,\r\n  VerificationWarning,\r\n  ResourceUsage,\r\n  VerificationEvidence,\r\n  VerificationCallback,\r\n  CheckpointCallback,\r\n} from './types.js';\r\nimport { VERIFICATION_CONSTANTS } from './types.js';\r\nimport { TruthScorer } from './truth-scorer.js';\r\nimport { AgentClaimValidator } from './agent-claim-validator.js';\r\nimport { IntegrationTestRunner } from './integration-test-runner.js';\r\nimport { StateSnapshotManager } from './state-snapshot.js';\r\n\r\nexport interface PipelineOptions {\r\n  config: VerificationPipelineConfig;\r\n  truthScorer?: TruthScorer;\r\n  claimValidator?: AgentClaimValidator;\r\n  testRunner?: IntegrationTestRunner;\r\n  snapshotManager?: StateSnapshotManager;\r\n  logger?: ILogger;\r\n  eventEmitter?: EventEmitter;\r\n}\r\n\r\nexport class VerificationPipeline {\r\n  private readonly config: VerificationPipelineConfig;\r\n  private readonly logger: ILogger;\r\n  private readonly truthScorer: TruthScorer;\r\n  private readonly claimValidator: AgentClaimValidator;\r\n  private readonly testRunner: IntegrationTestRunner;\r\n  private readonly snapshotManager: StateSnapshotManager;\r\n  private readonly eventEmitter?: EventEmitter;\r\n\r\n  private currentExecution?: PipelineExecution;\r\n  private readonly executionHistory: PipelineExecution[] = [];\r\n  private readonly checkpointCache: Map<string, CheckpointResult> = new Map();\r\n\r\n  constructor(options: PipelineOptions) {\r\n    this.config = options.config;\r\n    this.logger = options.logger || logger.child({ component: 'VerificationPipeline', pipelineId: options.config.id });\r\n    this.truthScorer = options.truthScorer || new TruthScorer();\r\n    this.claimValidator = options.claimValidator || new AgentClaimValidator();\r\n    this.testRunner = options.testRunner || new IntegrationTestRunner();\r\n    this.snapshotManager = options.snapshotManager || new StateSnapshotManager();\r\n    this.eventEmitter = options.eventEmitter;\r\n\r\n    this.logger.info('VerificationPipeline initialized', {\r\n      pipelineId: this.config.id,\r\n      checkpointCount: this.config.checkpoints.length,\r\n      level: this.config.level,\r\n      parallel: this.config.parallel,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute the verification pipeline\r\n   */\r\n  async execute(\r\n    context: VerificationContext,\r\n    callbacks?: PipelineCallbacks\r\n  ): Promise<VerificationResult> {\r\n    const startTime = Date.now();\r\n    const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n\r\n    this.logger.info('Starting verification pipeline execution', {\r\n      executionId,\r\n      pipelineId: this.config.id,\r\n      context: {\r\n        targetType: context.target?.type,\r\n        targetId: context.target?.id,\r\n        parametersCount: Object.keys(context.parameters || {}).length,\r\n      },\r\n    });\r\n\r\n    try {\r\n      // Initialize execution state\r\n      this.currentExecution = {\r\n        id: executionId,\r\n        pipelineId: this.config.id,\r\n        status: 'running',\r\n        startTime: new Date(),\r\n        context,\r\n        checkpointResults: [],\r\n        snapshots: [],\r\n        resourceUsage: this.initializeResourceUsage(),\r\n        callbacks,\r\n      };\r\n\r\n      // Create initial snapshot if enabled\r\n      if (this.config.enableRollback) {\r\n        await this.createSnapshot('initial', 'Pipeline execution start');\r\n      }\r\n\r\n      // Validate pipeline configuration\r\n      await this.validatePipelineConfig();\r\n\r\n      // Sort checkpoints by order\r\n      const sortedCheckpoints = [...this.config.checkpoints].sort((a, b) => a.order - b.order);\r\n\r\n      // Execute checkpoints\r\n      const checkpointResults = await this.executeCheckpoints(sortedCheckpoints, context, callbacks);\r\n\r\n      // Calculate overall result\r\n      const overallResult = this.calculateOverallResult(checkpointResults);\r\n\r\n      // Create final verification result\r\n      const result: VerificationResult = {\r\n        id: executionId,\r\n        pipelineId: this.config.id,\r\n        timestamp: new Date(),\r\n        status: overallResult.status,\r\n        score: overallResult.score,\r\n        passed: overallResult.passed,\r\n        checkpointResults,\r\n        truthScore: overallResult.truthScore,\r\n        duration: Date.now() - startTime,\r\n        resourceUsage: this.currentExecution.resourceUsage,\r\n        evidence: overallResult.evidence,\r\n        artifacts: overallResult.artifacts,\r\n        errors: overallResult.errors,\r\n        warnings: overallResult.warnings,\r\n        recommendations: overallResult.recommendations,\r\n        nextSteps: overallResult.nextSteps,\r\n      };\r\n\r\n      // Update execution state\r\n      this.currentExecution.status = result.status;\r\n      this.currentExecution.endTime = new Date();\r\n      this.currentExecution.result = result;\r\n\r\n      // Add to history\r\n      this.executionHistory.push(this.currentExecution);\r\n      this.currentExecution = undefined;\r\n\r\n      // Emit completion event\r\n      this.eventEmitter?.emit('pipeline:completed', result);\r\n\r\n      this.logger.info('Verification pipeline execution completed', {\r\n        executionId,\r\n        status: result.status,\r\n        passed: result.passed,\r\n        score: result.score,\r\n        duration: result.duration,\r\n        checkpointsPassed: checkpointResults.filter(r => r.passed).length,\r\n        checkpointsTotal: checkpointResults.length,\r\n      });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      const errorResult = await this.handleExecutionError(error, executionId, startTime);\r\n      \r\n      if (this.currentExecution) {\r\n        this.currentExecution.status = 'error';\r\n        this.currentExecution.endTime = new Date();\r\n        this.currentExecution.result = errorResult;\r\n        this.executionHistory.push(this.currentExecution);\r\n        this.currentExecution = undefined;\r\n      }\r\n\r\n      this.eventEmitter?.emit('pipeline:error', errorResult);\r\n      \r\n      return errorResult;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pipeline execution status\r\n   */\r\n  getStatus(): PipelineStatus {\r\n    return {\r\n      pipelineId: this.config.id,\r\n      isRunning: this.currentExecution !== undefined,\r\n      currentExecution: this.currentExecution ? {\r\n        id: this.currentExecution.id,\r\n        status: this.currentExecution.status,\r\n        progress: this.calculateProgress(),\r\n        startTime: this.currentExecution.startTime,\r\n        resourceUsage: this.currentExecution.resourceUsage,\r\n      } : undefined,\r\n      history: this.executionHistory.slice(-10).map(exec => ({\r\n        id: exec.id,\r\n        status: exec.status,\r\n        startTime: exec.startTime,\r\n        endTime: exec.endTime,\r\n        duration: exec.endTime ? exec.endTime.getTime() - exec.startTime.getTime() : undefined,\r\n        passed: exec.result?.passed,\r\n        score: exec.result?.score,\r\n      })),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Pause pipeline execution\r\n   */\r\n  async pause(): Promise<void> {\r\n    if (!this.currentExecution) {\r\n      throw new AppError('No active pipeline execution to pause', 'NO_ACTIVE_EXECUTION');\r\n    }\r\n\r\n    this.currentExecution.status = 'paused';\r\n    this.logger.info('Pipeline execution paused', { executionId: this.currentExecution.id });\r\n    this.eventEmitter?.emit('pipeline:paused', this.currentExecution.id);\r\n  }\r\n\r\n  /**\r\n   * Resume pipeline execution\r\n   */\r\n  async resume(): Promise<void> {\r\n    if (!this.currentExecution || this.currentExecution.status !== 'paused') {\r\n      throw new AppError('No paused pipeline execution to resume', 'NO_PAUSED_EXECUTION');\r\n    }\r\n\r\n    this.currentExecution.status = 'running';\r\n    this.logger.info('Pipeline execution resumed', { executionId: this.currentExecution.id });\r\n    this.eventEmitter?.emit('pipeline:resumed', this.currentExecution.id);\r\n  }\r\n\r\n  /**\r\n   * Cancel pipeline execution\r\n   */\r\n  async cancel(): Promise<void> {\r\n    if (!this.currentExecution) {\r\n      throw new AppError('No active pipeline execution to cancel', 'NO_ACTIVE_EXECUTION');\r\n    }\r\n\r\n    this.currentExecution.status = 'cancelled';\r\n    this.currentExecution.endTime = new Date();\r\n    \r\n    this.logger.info('Pipeline execution cancelled', { executionId: this.currentExecution.id });\r\n    this.eventEmitter?.emit('pipeline:cancelled', this.currentExecution.id);\r\n\r\n    // Create cancellation result\r\n    const result: VerificationResult = {\r\n      id: this.currentExecution.id,\r\n      pipelineId: this.config.id,\r\n      timestamp: new Date(),\r\n      status: 'cancelled',\r\n      score: 0,\r\n      passed: false,\r\n      checkpointResults: this.currentExecution.checkpointResults,\r\n      truthScore: {\r\n        score: 0,\r\n        components: {\r\n          agentReliability: 0,\r\n          crossValidation: 0,\r\n          externalVerification: 0,\r\n          factualConsistency: 0,\r\n          logicalCoherence: 0,\r\n          overall: 0,\r\n        },\r\n        confidence: { lower: 0, upper: 0, level: 0 },\r\n        evidence: [],\r\n        timestamp: new Date(),\r\n        metadata: { reason: 'cancelled' },\r\n      },\r\n      duration: this.currentExecution.endTime.getTime() - this.currentExecution.startTime.getTime(),\r\n      resourceUsage: this.currentExecution.resourceUsage,\r\n      evidence: [],\r\n      artifacts: {},\r\n      errors: [{\r\n        code: 'PIPELINE_CANCELLED',\r\n        message: 'Pipeline execution was cancelled',\r\n        severity: 'medium',\r\n        context: { executionId: this.currentExecution.id },\r\n        recoverable: true,\r\n        timestamp: new Date(),\r\n      }],\r\n      warnings: [],\r\n      recommendations: ['Consider reviewing cancellation reason', 'Check for incomplete state'],\r\n      nextSteps: ['Restart pipeline if needed', 'Clean up any partial state'],\r\n    };\r\n\r\n    this.currentExecution.result = result;\r\n    this.executionHistory.push(this.currentExecution);\r\n    this.currentExecution = undefined;\r\n  }\r\n\r\n  /**\r\n   * Clear execution history\r\n   */\r\n  clearHistory(): void {\r\n    this.executionHistory.length = 0;\r\n    this.checkpointCache.clear();\r\n    this.logger.debug('Pipeline execution history cleared');\r\n  }\r\n\r\n  private async validatePipelineConfig(): Promise<void> {\r\n    const errors: string[] = [];\r\n\r\n    if (this.config.checkpoints.length === 0) {\r\n      errors.push('Pipeline must have at least one checkpoint');\r\n    }\r\n\r\n    // Check for mandatory checkpoints\r\n    const mandatoryCheckpoints = this.config.checkpoints.filter(cp => cp.mandatory);\r\n    if (mandatoryCheckpoints.length === 0) {\r\n      errors.push('Pipeline must have at least one mandatory checkpoint');\r\n    }\r\n\r\n    // Validate checkpoint dependencies\r\n    for (const checkpoint of this.config.checkpoints) {\r\n      for (const depId of checkpoint.dependencies) {\r\n        if (!this.config.checkpoints.find(cp => cp.id === depId)) {\r\n          errors.push(`Checkpoint ${checkpoint.id} depends on non-existent checkpoint ${depId}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for circular dependencies\r\n    if (this.hasCircularDependencies()) {\r\n      errors.push('Circular dependencies detected in checkpoint configuration');\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      throw new AppError(`Pipeline configuration validation failed: ${errors.join(', ')}`, 'INVALID_PIPELINE_CONFIG');\r\n    }\r\n  }\r\n\r\n  private async executeCheckpoints(\r\n    checkpoints: VerificationCheckpoint[],\r\n    context: VerificationContext,\r\n    callbacks?: PipelineCallbacks\r\n  ): Promise<CheckpointResult[]> {\r\n    const results: CheckpointResult[] = [];\r\n    const completed = new Set<string>();\r\n    const pending = new Set(checkpoints.map(cp => cp.id));\r\n\r\n    while (pending.size > 0) {\r\n      // Find checkpoints that can be executed (dependencies satisfied)\r\n      const ready = checkpoints.filter(cp => \r\n        pending.has(cp.id) && \r\n        cp.dependencies.every(depId => completed.has(depId))\r\n      );\r\n\r\n      if (ready.length === 0) {\r\n        throw new AppError('Dependency deadlock in checkpoint execution', 'CHECKPOINT_DEADLOCK');\r\n      }\r\n\r\n      // Execute ready checkpoints\r\n      if (this.config.parallel && ready.length > 1) {\r\n        const batchResults = await Promise.all(\r\n          ready.map(checkpoint => this.executeCheckpoint(checkpoint, context, callbacks))\r\n        );\r\n        results.push(...batchResults);\r\n      } else {\r\n        for (const checkpoint of ready) {\r\n          const result = await this.executeCheckpoint(checkpoint, context, callbacks);\r\n          results.push(result);\r\n          \r\n          // Check if we should stop on failure\r\n          if (!result.passed && checkpoint.mandatory) {\r\n            throw new AppError(\r\n              `Mandatory checkpoint ${checkpoint.id} failed`,\r\n              'MANDATORY_CHECKPOINT_FAILED'\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Update completion status\r\n      ready.forEach(cp => {\r\n        completed.add(cp.id);\r\n        pending.delete(cp.id);\r\n      });\r\n    }\r\n\r\n    return results.sort((a, b) => {\r\n      const aCheckpoint = checkpoints.find(cp => cp.id === a.checkpointId)!;\r\n      const bCheckpoint = checkpoints.find(cp => cp.id === b.checkpointId)!;\r\n      return aCheckpoint.order - bCheckpoint.order;\r\n    });\r\n  }\r\n\r\n  private async executeCheckpoint(\r\n    checkpoint: VerificationCheckpoint,\r\n    context: VerificationContext,\r\n    callbacks?: PipelineCallbacks\r\n  ): Promise<CheckpointResult> {\r\n    const startTime = Date.now();\r\n    \r\n    this.logger.info('Executing checkpoint', {\r\n      checkpointId: checkpoint.id,\r\n      type: checkpoint.type,\r\n      mandatory: checkpoint.mandatory,\r\n      validatorCount: checkpoint.validators.length,\r\n    });\r\n\r\n    try {\r\n      // Check if paused\r\n      while (this.currentExecution?.status === 'paused') {\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n      }\r\n\r\n      // Check if cancelled\r\n      if (this.currentExecution?.status === 'cancelled') {\r\n        throw new AppError('Execution cancelled', 'EXECUTION_CANCELLED');\r\n      }\r\n\r\n      // Create snapshot if required\r\n      if (checkpoint.createSnapshot && this.config.enableRollback) {\r\n        await this.createSnapshot(checkpoint.id, `Before checkpoint ${checkpoint.name}`);\r\n      }\r\n\r\n      // Execute validators\r\n      const validatorResults = await this.executeValidators(checkpoint.validators, context);\r\n\r\n      // Evaluate conditions\r\n      const conditionResults = this.evaluateConditions(checkpoint.conditions, context, validatorResults);\r\n\r\n      // Calculate checkpoint result\r\n      const passed = validatorResults.every(vr => vr.passed) && conditionResults.every(cr => cr.passed);\r\n      const score = validatorResults.reduce((sum, vr) => sum + vr.score, 0) / validatorResults.length;\r\n\r\n      const result: CheckpointResult = {\r\n        checkpointId: checkpoint.id,\r\n        status: passed ? 'passed' : 'failed',\r\n        score,\r\n        passed,\r\n        duration: Date.now() - startTime,\r\n        validatorResults,\r\n        evidence: validatorResults.flatMap(vr => vr.evidence),\r\n        errors: validatorResults.flatMap(vr => vr.errors || []),\r\n        warnings: validatorResults.flatMap(vr => vr.warnings || []),\r\n      };\r\n\r\n      // Handle rollback on failure\r\n      if (!passed && checkpoint.rollbackOnFailure && this.config.enableRollback) {\r\n        await this.handleCheckpointRollback(checkpoint);\r\n      }\r\n\r\n      // Update execution state\r\n      if (this.currentExecution) {\r\n        this.currentExecution.checkpointResults.push(result);\r\n      }\r\n\r\n      // Cache result\r\n      this.checkpointCache.set(checkpoint.id, result);\r\n\r\n      // Call checkpoint callback\r\n      if (callbacks?.onCheckpointComplete) {\r\n        await callbacks.onCheckpointComplete(result);\r\n      }\r\n\r\n      this.eventEmitter?.emit('checkpoint:completed', result);\r\n\r\n      this.logger.info('Checkpoint execution completed', {\r\n        checkpointId: checkpoint.id,\r\n        passed,\r\n        score,\r\n        duration: result.duration,\r\n      });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      const errorResult: CheckpointResult = {\r\n        checkpointId: checkpoint.id,\r\n        status: 'error',\r\n        score: 0,\r\n        passed: false,\r\n        duration: Date.now() - startTime,\r\n        validatorResults: [],\r\n        evidence: [],\r\n        errors: [{\r\n          code: 'CHECKPOINT_EXECUTION_ERROR',\r\n          message: `Checkpoint execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n          severity: 'high',\r\n          context: { checkpointId: checkpoint.id },\r\n          recoverable: !checkpoint.mandatory,\r\n          timestamp: new Date(),\r\n        }],\r\n        warnings: [],\r\n      };\r\n\r\n      this.logger.error('Checkpoint execution failed', {\r\n        checkpointId: checkpoint.id,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      });\r\n\r\n      return errorResult;\r\n    }\r\n  }\r\n\r\n  private async executeValidators(\r\n    validators: CheckpointValidator[],\r\n    context: VerificationContext\r\n  ): Promise<ValidatorResult[]> {\r\n    const results: ValidatorResult[] = [];\r\n\r\n    for (const validator of validators) {\r\n      try {\r\n        let result: ValidatorResult;\r\n\r\n        switch (validator.type) {\r\n          case 'truth_score':\r\n            result = await this.executeTruthScoreValidator(validator, context);\r\n            break;\r\n          case 'agent_claim':\r\n            result = await this.executeAgentClaimValidator(validator, context);\r\n            break;\r\n          case 'integration_test':\r\n            result = await this.executeIntegrationTestValidator(validator, context);\r\n            break;\r\n          case 'state_validation':\r\n            result = await this.executeStateValidationValidator(validator, context);\r\n            break;\r\n          case 'custom':\r\n            result = await this.executeCustomValidator(validator, context);\r\n            break;\r\n          default:\r\n            throw new AppError(`Unknown validator type: ${validator.type}`, 'UNKNOWN_VALIDATOR_TYPE');\r\n        }\r\n\r\n        results.push(result);\r\n      } catch (error) {\r\n        if (validator.required) {\r\n          throw error;\r\n        }\r\n\r\n        // Create error result for non-required validators\r\n        results.push({\r\n          validatorId: validator.id,\r\n          status: 'error',\r\n          score: 0,\r\n          passed: false,\r\n          details: { error: error instanceof Error ? error.message : 'Unknown error' },\r\n          evidence: [],\r\n          errors: [{\r\n            code: 'VALIDATOR_EXECUTION_ERROR',\r\n            message: `Validator execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n            severity: 'medium',\r\n            context: { validatorId: validator.id },\r\n            recoverable: true,\r\n            timestamp: new Date(),\r\n          }],\r\n        });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  private async executeTruthScoreValidator(\r\n    validator: CheckpointValidator,\r\n    context: VerificationContext\r\n  ): Promise<ValidatorResult> {\r\n    if (!context.claims || context.claims.length === 0) {\r\n      return {\r\n        validatorId: validator.id,\r\n        status: 'failed',\r\n        score: 0,\r\n        passed: false,\r\n        details: { reason: 'No claims to validate' },\r\n        evidence: [],\r\n      };\r\n    }\r\n\r\n    const scores = await Promise.all(\r\n      context.claims.map(claim => this.truthScorer.scoreClaim(claim, context.scoringContext))\r\n    );\r\n\r\n    const averageScore = scores.reduce((sum, score) => sum + score.score, 0) / scores.length;\r\n    const passed = averageScore >= (validator.config.threshold as number || VERIFICATION_CONSTANTS.DEFAULT_TRUTH_THRESHOLD);\r\n\r\n    return {\r\n      validatorId: validator.id,\r\n      status: passed ? 'passed' : 'failed',\r\n      score: averageScore,\r\n      passed,\r\n      details: {\r\n        claimCount: context.claims.length,\r\n        averageScore,\r\n        threshold: validator.config.threshold,\r\n        scores: scores.map(s => s.score),\r\n      },\r\n      evidence: scores.flatMap(s => s.evidence),\r\n    };\r\n  }\r\n\r\n  private async executeAgentClaimValidator(\r\n    validator: CheckpointValidator,\r\n    context: VerificationContext\r\n  ): Promise<ValidatorResult> {\r\n    if (!context.claims || context.claims.length === 0) {\r\n      return {\r\n        validatorId: validator.id,\r\n        status: 'failed',\r\n        score: 0,\r\n        passed: false,\r\n        details: { reason: 'No claims to validate' },\r\n        evidence: [],\r\n      };\r\n    }\r\n\r\n    const validationResults = await Promise.all(\r\n      context.claims.map(claim => this.claimValidator.validateClaim(claim, validator.config))\r\n    );\r\n\r\n    const passedCount = validationResults.filter(r => r.passed).length;\r\n    const successRate = passedCount / validationResults.length;\r\n    const averageScore = validationResults.reduce((sum, r) => sum + r.score, 0) / validationResults.length;\r\n    const passed = successRate >= (validator.config.minSuccessRate as number || 0.8);\r\n\r\n    return {\r\n      validatorId: validator.id,\r\n      status: passed ? 'passed' : 'failed',\r\n      score: averageScore,\r\n      passed,\r\n      details: {\r\n        claimCount: context.claims.length,\r\n        passedCount,\r\n        successRate,\r\n        averageScore,\r\n        results: validationResults,\r\n      },\r\n      evidence: validationResults.flatMap(r => r.evidence),\r\n    };\r\n  }\r\n\r\n  private async executeIntegrationTestValidator(\r\n    validator: CheckpointValidator,\r\n    context: VerificationContext\r\n  ): Promise<ValidatorResult> {\r\n    if (!context.testConfig) {\r\n      return {\r\n        validatorId: validator.id,\r\n        status: 'failed',\r\n        score: 0,\r\n        passed: false,\r\n        details: { reason: 'No test configuration provided' },\r\n        evidence: [],\r\n      };\r\n    }\r\n\r\n    const testResult = await this.testRunner.runTests(context.testConfig);\r\n    \r\n    return {\r\n      validatorId: validator.id,\r\n      status: testResult.passed ? 'passed' : 'failed',\r\n      score: testResult.score,\r\n      passed: testResult.passed,\r\n      details: {\r\n        testId: testResult.testId,\r\n        scenarioCount: testResult.scenarioResults.length,\r\n        passedScenarios: testResult.scenarioResults.filter(sr => sr.passed).length,\r\n        duration: testResult.duration,\r\n        coverage: testResult.coverage,\r\n      },\r\n      evidence: testResult.evidence,\r\n    };\r\n  }\r\n\r\n  private async executeStateValidationValidator(\r\n    validator: CheckpointValidator,\r\n    context: VerificationContext\r\n  ): Promise<ValidatorResult> {\r\n    // Validate current system state\r\n    const validationScore = 0.85; // Simplified - implement actual state validation\r\n    const passed = validationScore >= (validator.config.threshold as number || 0.8);\r\n\r\n    return {\r\n      validatorId: validator.id,\r\n      status: passed ? 'passed' : 'failed',\r\n      score: validationScore,\r\n      passed,\r\n      details: {\r\n        validationType: 'state_validation',\r\n        validationScore,\r\n        threshold: validator.config.threshold,\r\n      },\r\n      evidence: [{\r\n        type: 'state_validation',\r\n        source: 'system_state',\r\n        timestamp: new Date(),\r\n        data: { score: validationScore },\r\n        reliability: 0.9,\r\n        weight: 1.0,\r\n      }],\r\n    };\r\n  }\r\n\r\n  private async executeCustomValidator(\r\n    validator: CheckpointValidator,\r\n    context: VerificationContext\r\n  ): Promise<ValidatorResult> {\r\n    // Implement custom validator logic based on config\r\n    const customScore = 0.8; // Simplified - implement actual custom validation\r\n    const passed = customScore >= (validator.config.threshold as number || 0.8);\r\n\r\n    return {\r\n      validatorId: validator.id,\r\n      status: passed ? 'passed' : 'failed',\r\n      score: customScore,\r\n      passed,\r\n      details: {\r\n        validationType: 'custom',\r\n        config: validator.config,\r\n        customScore,\r\n      },\r\n      evidence: [{\r\n        type: 'custom',\r\n        source: 'custom_validator',\r\n        timestamp: new Date(),\r\n        data: validator.config,\r\n        reliability: 0.8,\r\n        weight: 1.0,\r\n      }],\r\n    };\r\n  }\r\n\r\n  private evaluateConditions(\r\n    conditions: CheckpointCondition[],\r\n    context: VerificationContext,\r\n    validatorResults: ValidatorResult[]\r\n  ): ConditionResult[] {\r\n    return conditions.map(condition => {\r\n      try {\r\n        const value = this.extractConditionValue(condition.field, context, validatorResults);\r\n        const passed = this.evaluateCondition(condition, value);\r\n\r\n        return {\r\n          condition,\r\n          passed,\r\n          value,\r\n          reason: passed ? 'Condition satisfied' : 'Condition not satisfied',\r\n        };\r\n      } catch (error) {\r\n        return {\r\n          condition,\r\n          passed: false,\r\n          value: undefined,\r\n          reason: `Condition evaluation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  private extractConditionValue(\r\n    field: string,\r\n    context: VerificationContext,\r\n    validatorResults: ValidatorResult[]\r\n  ): unknown {\r\n    // Extract value from context or validator results based on field path\r\n    if (field.startsWith('validator.')) {\r\n      const validatorId = field.split('.')[1];\r\n      const validatorField = field.split('.').slice(2).join('.');\r\n      const validator = validatorResults.find(vr => vr.validatorId === validatorId);\r\n      \r\n      if (validatorField === 'score') return validator?.score;\r\n      if (validatorField === 'passed') return validator?.passed;\r\n      \r\n      return this.getNestedValue(validator?.details, validatorField);\r\n    }\r\n\r\n    if (field.startsWith('context.')) {\r\n      const contextField = field.split('.').slice(1).join('.');\r\n      return this.getNestedValue(context, contextField);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private getNestedValue(obj: any, path: string): unknown {\r\n    return path.split('.').reduce((current, key) => current?.[key], obj);\r\n  }\r\n\r\n  private evaluateCondition(condition: CheckpointCondition, value: unknown): boolean {\r\n    switch (condition.operator) {\r\n      case 'eq':\r\n        return value === condition.value;\r\n      case 'ne':\r\n        return value !== condition.value;\r\n      case 'gt':\r\n        return typeof value === 'number' && value > (condition.value as number);\r\n      case 'gte':\r\n        return typeof value === 'number' && value >= (condition.value as number);\r\n      case 'lt':\r\n        return typeof value === 'number' && value < (condition.value as number);\r\n      case 'lte':\r\n        return typeof value === 'number' && value <= (condition.value as number);\r\n      case 'in':\r\n        return Array.isArray(condition.value) && condition.value.includes(value);\r\n      case 'nin':\r\n        return Array.isArray(condition.value) && !condition.value.includes(value);\r\n      case 'regex':\r\n        return typeof value === 'string' && new RegExp(condition.value as string).test(value);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private calculateOverallResult(checkpointResults: CheckpointResult[]): OverallResult {\r\n    const mandatoryResults = checkpointResults.filter(r => {\r\n      const checkpoint = this.config.checkpoints.find(cp => cp.id === r.checkpointId);\r\n      return checkpoint?.mandatory;\r\n    });\r\n\r\n    const mandatoryPassed = mandatoryResults.every(r => r.passed);\r\n    const overallPassed = mandatoryPassed && checkpointResults.every(r => r.passed);\r\n    \r\n    const totalScore = checkpointResults.reduce((sum, r) => sum + r.score, 0) / checkpointResults.length;\r\n    const status: VerificationStatus = overallPassed ? 'passed' : 'failed';\r\n\r\n    // Aggregate truth score (simplified)\r\n    const truthScore = {\r\n      score: totalScore,\r\n      components: {\r\n        agentReliability: totalScore,\r\n        crossValidation: totalScore,\r\n        externalVerification: totalScore,\r\n        factualConsistency: totalScore,\r\n        logicalCoherence: totalScore,\r\n        overall: totalScore,\r\n      },\r\n      confidence: { lower: totalScore - 0.1, upper: totalScore + 0.1, level: 0.95 },\r\n      evidence: checkpointResults.flatMap(r => r.evidence),\r\n      timestamp: new Date(),\r\n      metadata: { pipelineId: this.config.id },\r\n    };\r\n\r\n    return {\r\n      status,\r\n      passed: overallPassed,\r\n      score: totalScore,\r\n      truthScore,\r\n      evidence: checkpointResults.flatMap(r => r.evidence),\r\n      artifacts: {},\r\n      errors: checkpointResults.flatMap(r => r.errors),\r\n      warnings: checkpointResults.flatMap(r => r.warnings),\r\n      recommendations: [\r\n        ...(overallPassed ? ['Pipeline verification successful'] : ['Review failed checkpoints']),\r\n        'Monitor ongoing performance',\r\n      ],\r\n      nextSteps: [\r\n        ...(overallPassed ? ['Proceed with deployment'] : ['Address verification failures']),\r\n        'Schedule next verification cycle',\r\n      ],\r\n    };\r\n  }\r\n\r\n  private async createSnapshot(checkpointId: string, description: string): Promise<void> {\r\n    if (this.currentExecution) {\r\n      const snapshot = await this.snapshotManager.createSnapshot({\r\n        name: `${this.config.id}_${checkpointId}`,\r\n        description,\r\n        context: { pipelineId: this.config.id, checkpointId },\r\n      });\r\n      \r\n      this.currentExecution.snapshots.push(snapshot.id);\r\n      \r\n      this.logger.debug('Snapshot created', {\r\n        snapshotId: snapshot.id,\r\n        checkpointId,\r\n        description,\r\n      });\r\n    }\r\n  }\r\n\r\n  private async handleCheckpointRollback(checkpoint: VerificationCheckpoint): Promise<void> {\r\n    if (!this.currentExecution || this.currentExecution.snapshots.length === 0) {\r\n      this.logger.warn('Cannot rollback: no snapshots available', { checkpointId: checkpoint.id });\r\n      return;\r\n    }\r\n\r\n    const latestSnapshotId = this.currentExecution.snapshots[this.currentExecution.snapshots.length - 1];\r\n    \r\n    try {\r\n      await this.snapshotManager.rollback({\r\n        snapshotId: latestSnapshotId,\r\n        reason: `Checkpoint ${checkpoint.id} failed`,\r\n        scope: { includeAgents: true, includeTasks: true, includeSwarms: true },\r\n      });\r\n      \r\n      this.logger.info('Rollback completed', {\r\n        checkpointId: checkpoint.id,\r\n        snapshotId: latestSnapshotId,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Rollback failed', {\r\n        checkpointId: checkpoint.id,\r\n        snapshotId: latestSnapshotId,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      });\r\n    }\r\n  }\r\n\r\n  private async handleExecutionError(error: unknown, executionId: string, startTime: number): Promise<VerificationResult> {\r\n    this.logger.error('Pipeline execution error', {\r\n      executionId,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    });\r\n\r\n    return {\r\n      id: executionId,\r\n      pipelineId: this.config.id,\r\n      timestamp: new Date(),\r\n      status: 'error',\r\n      score: 0,\r\n      passed: false,\r\n      checkpointResults: this.currentExecution?.checkpointResults || [],\r\n      truthScore: {\r\n        score: 0,\r\n        components: {\r\n          agentReliability: 0,\r\n          crossValidation: 0,\r\n          externalVerification: 0,\r\n          factualConsistency: 0,\r\n          logicalCoherence: 0,\r\n          overall: 0,\r\n        },\r\n        confidence: { lower: 0, upper: 0, level: 0 },\r\n        evidence: [],\r\n        timestamp: new Date(),\r\n        metadata: { error: error instanceof Error ? error.message : 'Unknown error' },\r\n      },\r\n      duration: Date.now() - startTime,\r\n      resourceUsage: this.currentExecution?.resourceUsage || this.initializeResourceUsage(),\r\n      evidence: [],\r\n      artifacts: {},\r\n      errors: [{\r\n        code: 'PIPELINE_EXECUTION_ERROR',\r\n        message: `Pipeline execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        severity: 'critical',\r\n        context: { executionId, pipelineId: this.config.id },\r\n        recoverable: false,\r\n        timestamp: new Date(),\r\n      }],\r\n      warnings: [],\r\n      recommendations: ['Review pipeline configuration', 'Check system logs for details'],\r\n      nextSteps: ['Fix identified issues', 'Restart pipeline execution'],\r\n    };\r\n  }\r\n\r\n  private calculateProgress(): number {\r\n    if (!this.currentExecution) return 0;\r\n    \r\n    const totalCheckpoints = this.config.checkpoints.length;\r\n    const completedCheckpoints = this.currentExecution.checkpointResults.length;\r\n    \r\n    return totalCheckpoints > 0 ? (completedCheckpoints / totalCheckpoints) * 100 : 0;\r\n  }\r\n\r\n  private hasCircularDependencies(): boolean {\r\n    const visited = new Set<string>();\r\n    const recursionStack = new Set<string>();\r\n\r\n    const hasCircle = (checkpointId: string): boolean => {\r\n      if (recursionStack.has(checkpointId)) return true;\r\n      if (visited.has(checkpointId)) return false;\r\n\r\n      visited.add(checkpointId);\r\n      recursionStack.add(checkpointId);\r\n\r\n      const checkpoint = this.config.checkpoints.find(cp => cp.id === checkpointId);\r\n      if (checkpoint) {\r\n        for (const depId of checkpoint.dependencies) {\r\n          if (hasCircle(depId)) return true;\r\n        }\r\n      }\r\n\r\n      recursionStack.delete(checkpointId);\r\n      return false;\r\n    };\r\n\r\n    return this.config.checkpoints.some(cp => hasCircle(cp.id));\r\n  }\r\n\r\n  private initializeResourceUsage(): ResourceUsage {\r\n    return {\r\n      cpu: 0,\r\n      memory: 0,\r\n      disk: 0,\r\n      network: 0,\r\n      tokens: 0,\r\n      apiCalls: 0,\r\n    };\r\n  }\r\n}\r\n\r\n// Supporting interfaces\r\ninterface PipelineExecution {\r\n  id: string;\r\n  pipelineId: string;\r\n  status: VerificationStatus;\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  context: VerificationContext;\r\n  checkpointResults: CheckpointResult[];\r\n  snapshots: string[];\r\n  resourceUsage: ResourceUsage;\r\n  result?: VerificationResult;\r\n  callbacks?: PipelineCallbacks;\r\n}\r\n\r\ninterface VerificationContext {\r\n  target?: {\r\n    type: string;\r\n    id: string;\r\n    data: Record<string, unknown>;\r\n  };\r\n  parameters?: Record<string, unknown>;\r\n  claims?: any[];\r\n  testConfig?: any;\r\n  scoringContext?: any;\r\n}\r\n\r\ninterface PipelineCallbacks {\r\n  onCheckpointComplete?: CheckpointCallback;\r\n  onVerificationComplete?: VerificationCallback;\r\n  onError?: (error: Error) => void | Promise<void>;\r\n}\r\n\r\ninterface ValidatorResult {\r\n  validatorId: string;\r\n  status: VerificationStatus;\r\n  score: number;\r\n  passed: boolean;\r\n  details: Record<string, unknown>;\r\n  evidence: VerificationEvidence[];\r\n  errors?: VerificationError[];\r\n  warnings?: VerificationWarning[];\r\n}\r\n\r\ninterface ConditionResult {\r\n  condition: CheckpointCondition;\r\n  passed: boolean;\r\n  value: unknown;\r\n  reason: string;\r\n}\r\n\r\ninterface OverallResult {\r\n  status: VerificationStatus;\r\n  passed: boolean;\r\n  score: number;\r\n  truthScore: any;\r\n  evidence: VerificationEvidence[];\r\n  artifacts: Record<string, unknown>;\r\n  errors: VerificationError[];\r\n  warnings: VerificationWarning[];\r\n  recommendations: string[];\r\n  nextSteps: string[];\r\n}\r\n\r\ninterface PipelineStatus {\r\n  pipelineId: string;\r\n  isRunning: boolean;\r\n  currentExecution?: {\r\n    id: string;\r\n    status: VerificationStatus;\r\n    progress: number;\r\n    startTime: Date;\r\n    resourceUsage: ResourceUsage;\r\n  };\r\n  history: {\r\n    id: string;\r\n    status: VerificationStatus;\r\n    startTime: Date;\r\n    endTime?: Date;\r\n    duration?: number;\r\n    passed?: boolean;\r\n    score?: number;\r\n  }[];\r\n}\r\n\r\nexport default VerificationPipeline;"],"names":["logger","AppError","VERIFICATION_CONSTANTS","TruthScorer","AgentClaimValidator","IntegrationTestRunner","StateSnapshotManager","VerificationPipeline","config","truthScorer","claimValidator","testRunner","snapshotManager","eventEmitter","currentExecution","executionHistory","checkpointCache","Map","options","child","component","pipelineId","id","info","checkpointCount","checkpoints","length","level","parallel","execute","context","callbacks","startTime","Date","now","executionId","Math","random","toString","substr","targetType","target","type","targetId","parametersCount","Object","keys","parameters","status","checkpointResults","snapshots","resourceUsage","initializeResourceUsage","enableRollback","createSnapshot","validatePipelineConfig","sortedCheckpoints","sort","a","b","order","executeCheckpoints","overallResult","calculateOverallResult","result","timestamp","score","passed","truthScore","duration","evidence","artifacts","errors","warnings","recommendations","nextSteps","endTime","push","undefined","emit","checkpointsPassed","filter","r","checkpointsTotal","error","errorResult","handleExecutionError","getStatus","isRunning","progress","calculateProgress","history","slice","map","exec","getTime","pause","resume","cancel","components","agentReliability","crossValidation","externalVerification","factualConsistency","logicalCoherence","overall","confidence","lower","upper","metadata","reason","code","message","severity","recoverable","clearHistory","clear","debug","mandatoryCheckpoints","cp","mandatory","checkpoint","depId","dependencies","find","hasCircularDependencies","join","results","completed","Set","pending","size","ready","has","every","batchResults","Promise","all","executeCheckpoint","forEach","add","delete","aCheckpoint","checkpointId","bCheckpoint","validatorCount","validators","resolve","setTimeout","name","validatorResults","executeValidators","conditionResults","evaluateConditions","conditions","vr","cr","reduce","sum","flatMap","rollbackOnFailure","handleCheckpointRollback","set","onCheckpointComplete","Error","validator","executeTruthScoreValidator","executeAgentClaimValidator","executeIntegrationTestValidator","executeStateValidationValidator","executeCustomValidator","required","validatorId","details","claims","scores","claim","scoreClaim","scoringContext","averageScore","threshold","DEFAULT_TRUTH_THRESHOLD","claimCount","s","validationResults","validateClaim","passedCount","successRate","minSuccessRate","testConfig","testResult","runTests","testId","scenarioCount","scenarioResults","passedScenarios","sr","coverage","validationScore","validationType","source","data","reliability","weight","customScore","condition","value","extractConditionValue","field","evaluateCondition","startsWith","split","validatorField","getNestedValue","contextField","obj","path","current","key","operator","Array","isArray","includes","RegExp","test","mandatoryResults","mandatoryPassed","overallPassed","totalScore","description","snapshot","snapshotId","warn","latestSnapshotId","rollback","scope","includeAgents","includeTasks","includeSwarms","totalCheckpoints","completedCheckpoints","visited","recursionStack","hasCircle","some","cpu","memory","disk","network","tokens","apiCalls"],"mappings":"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"}