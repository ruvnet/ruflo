{
  "version": 3,
  "sources": ["../../src/coordination/advanced-scheduler.ts"],
  "sourcesContent": ["/**\n * Advanced task scheduler with intelligent agent selection and priority handling\n */\n\nimport {\n  Task,\n  TaskStatus,\n  CoordinationConfig,\n  SystemEvents,\n  AgentProfile,\n} from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TaskScheduler } from './scheduler.js';\nimport { WorkStealingCoordinator } from './work-stealing.js';\nimport { DependencyGraph } from './dependency-graph.js';\nimport { CircuitBreakerManager, CircuitBreakerConfig } from './circuit-breaker.js';\n\nexport interface SchedulingStrategy {\n  name: string;\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null;\n}\n\nexport interface SchedulingContext {\n  taskLoads: Map<string, number>;\n  agentCapabilities: Map<string, string[]>;\n  agentPriorities: Map<string, number>;\n  taskHistory: Map<string, TaskStats>;\n  currentTime: Date;\n}\n\nexport interface TaskStats {\n  totalExecutions: number;\n  avgDuration: number;\n  successRate: number;\n  lastAgent?: string;\n}\n\n/**\n * Capability-based scheduling strategy\n */\nexport class CapabilitySchedulingStrategy implements SchedulingStrategy {\n  name = 'capability';\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    // Filter agents by capability match\n    const capableAgents = agents.filter((agent) => {\n      const capabilities = context.agentCapabilities.get(agent.id) || agent.capabilities;\n      return task.type === 'any' || capabilities.includes(task.type) || capabilities.includes('*');\n    });\n\n    if (capableAgents.length === 0) {\n      return null;\n    }\n\n    // Sort by load (ascending) and priority (descending)\n    capableAgents.sort((a, b) => {\n      const loadA = context.taskLoads.get(a.id) || 0;\n      const loadB = context.taskLoads.get(b.id) || 0;\n\n      if (loadA !== loadB) {\n        return loadA - loadB;\n      }\n\n      const priorityA = context.agentPriorities.get(a.id) || a.priority;\n      const priorityB = context.agentPriorities.get(b.id) || b.priority;\n\n      return priorityB - priorityA;\n    });\n\n    return capableAgents[0].id;\n  }\n}\n\n/**\n * Round-robin scheduling strategy\n */\nexport class RoundRobinSchedulingStrategy implements SchedulingStrategy {\n  name = 'round-robin';\n  private lastIndex = 0;\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    if (agents.length === 0) {\n      return null;\n    }\n\n    this.lastIndex = (this.lastIndex + 1) % agents.length;\n    return agents[this.lastIndex].id;\n  }\n}\n\n/**\n * Least-loaded scheduling strategy\n */\nexport class LeastLoadedSchedulingStrategy implements SchedulingStrategy {\n  name = 'least-loaded';\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    if (agents.length === 0) {\n      return null;\n    }\n\n    let minLoad = Infinity;\n    let selectedAgent: string | null = null;\n\n    for (const agent of agents) {\n      const load = context.taskLoads.get(agent.id) || 0;\n      if (load < minLoad) {\n        minLoad = load;\n        selectedAgent = agent.id;\n      }\n    }\n\n    return selectedAgent;\n  }\n}\n\n/**\n * Affinity-based scheduling strategy (prefers agents that previously executed similar tasks)\n */\nexport class AffinitySchedulingStrategy implements SchedulingStrategy {\n  name = 'affinity';\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    const taskStats = context.taskHistory.get(task.type);\n\n    if (taskStats?.lastAgent) {\n      // Check if the last agent is available\n      const lastAgent = agents.find((a) => a.id === taskStats.lastAgent);\n      if (lastAgent) {\n        const load = context.taskLoads.get(lastAgent.id) || 0;\n        // Use last agent if not overloaded\n        if (load < lastAgent.maxConcurrentTasks * 0.8) {\n          return lastAgent.id;\n        }\n      }\n    }\n\n    // Fall back to capability-based selection\n    return new CapabilitySchedulingStrategy().selectAgent(task, agents, context);\n  }\n}\n\n/**\n * Advanced task scheduler with multiple strategies\n */\nexport class AdvancedTaskScheduler extends TaskScheduler {\n  private strategies = new Map<string, SchedulingStrategy>();\n  private activeAgents = new Map<string, AgentProfile>();\n  private taskStats = new Map<string, TaskStats>();\n  private workStealing: WorkStealingCoordinator;\n  private dependencyGraph: DependencyGraph;\n  private circuitBreakers: CircuitBreakerManager;\n  private defaultStrategy = 'capability';\n\n  constructor(config: CoordinationConfig, eventBus: IEventBus, logger: ILogger) {\n    super(config, eventBus, logger);\n\n    // Initialize components\n    this.workStealing = new WorkStealingCoordinator(\n      {\n        enabled: true,\n        stealThreshold: 3,\n        maxStealBatch: 2,\n        stealInterval: 5000,\n      },\n      eventBus,\n      logger,\n    );\n\n    this.dependencyGraph = new DependencyGraph(logger);\n\n    const cbConfig: CircuitBreakerConfig = {\n      failureThreshold: 3,\n      successThreshold: 2,\n      timeout: 30000,\n      halfOpenLimit: 1,\n    };\n    this.circuitBreakers = new CircuitBreakerManager(cbConfig, logger, eventBus);\n\n    // Register default strategies\n    this.registerStrategy(new CapabilitySchedulingStrategy());\n    this.registerStrategy(new RoundRobinSchedulingStrategy());\n    this.registerStrategy(new LeastLoadedSchedulingStrategy());\n    this.registerStrategy(new AffinitySchedulingStrategy());\n\n    // Set up event handlers\n    this.setupAdvancedEventHandlers();\n  }\n\n  override async initialize(): Promise<void> {\n    await super.initialize();\n    await this.workStealing.initialize();\n\n    this.logger.info('Advanced task scheduler initialized');\n  }\n\n  override async shutdown(): Promise<void> {\n    await this.workStealing.shutdown();\n    await super.shutdown();\n  }\n\n  /**\n   * Register a scheduling strategy\n   */\n  registerStrategy(strategy: SchedulingStrategy): void {\n    this.strategies.set(strategy.name, strategy);\n    this.logger.info('Registered scheduling strategy', { name: strategy.name });\n  }\n\n  /**\n   * Set the default scheduling strategy\n   */\n  setDefaultStrategy(name: string): void {\n    if (!this.strategies.has(name)) {\n      throw new Error(`Strategy not found: ${name}`);\n    }\n    this.defaultStrategy = name;\n  }\n\n  /**\n   * Register an agent\n   */\n  registerAgent(profile: AgentProfile): void {\n    this.activeAgents.set(profile.id, profile);\n    this.workStealing.updateAgentWorkload(profile.id, {\n      agentId: profile.id,\n      taskCount: 0,\n      avgTaskDuration: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      priority: profile.priority,\n      capabilities: profile.capabilities,\n    });\n  }\n\n  /**\n   * Unregister an agent\n   */\n  unregisterAgent(agentId: string): void {\n    this.activeAgents.delete(agentId);\n  }\n\n  /**\n   * Override assignTask to use advanced scheduling\n   */\n  override async assignTask(task: Task, agentId?: string): Promise<void> {\n    // Add to dependency graph\n    this.dependencyGraph.addTask(task);\n\n    // If no agent specified, select one\n    if (!agentId) {\n      const selectedAgent = await this.selectAgentForTask(task);\n      if (!selectedAgent) {\n        throw new Error('No suitable agent found for task');\n      }\n      agentId = selectedAgent;\n    }\n\n    // Use circuit breaker for assignment\n    await this.circuitBreakers.execute(`assign-${agentId}`, async () => {\n      await super.assignTask(task, agentId!);\n    });\n\n    // Update work stealing metrics\n    const taskCount = await this.getAgentTaskCount(agentId);\n    this.workStealing.updateAgentWorkload(agentId, { taskCount });\n  }\n\n  /**\n   * Select the best agent for a task\n   */\n  private async selectAgentForTask(task: Task): Promise<string | null> {\n    const availableAgents = Array.from(this.activeAgents.values());\n    if (availableAgents.length === 0) {\n      return null;\n    }\n\n    // Build scheduling context\n    const context: SchedulingContext = {\n      taskLoads: new Map(),\n      agentCapabilities: new Map(),\n      agentPriorities: new Map(),\n      taskHistory: this.taskStats,\n      currentTime: new Date(),\n    };\n\n    // Populate context\n    for (const agent of availableAgents) {\n      const taskCount = await this.getAgentTaskCount(agent.id);\n      context.taskLoads.set(agent.id, taskCount);\n      context.agentCapabilities.set(agent.id, agent.capabilities);\n      context.agentPriorities.set(agent.id, agent.priority);\n    }\n\n    // Try work stealing first\n    const workStealingAgent = this.workStealing.findBestAgent(task, availableAgents);\n    if (workStealingAgent) {\n      return workStealingAgent;\n    }\n\n    // Use configured strategy\n    const strategy = this.strategies.get(this.defaultStrategy);\n    if (!strategy) {\n      throw new Error(`Strategy not found: ${this.defaultStrategy}`);\n    }\n\n    return strategy.selectAgent(task, availableAgents, context);\n  }\n\n  /**\n   * Override completeTask to update stats and dependency graph\n   */\n  override async completeTask(taskId: string, result: unknown): Promise<void> {\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task not found: ${taskId}`);\n    }\n\n    // Calculate duration\n    const duration = task.startedAt ? new Date().getTime() - task.startedAt.getTime() : 0;\n\n    // Update task stats\n    this.updateTaskStats(task.type, true, duration);\n\n    // Update work stealing metrics\n    if (task.assignedAgent) {\n      this.workStealing.recordTaskDuration(task.assignedAgent, duration);\n    }\n\n    // Mark as completed in dependency graph\n    const readyTasks = this.dependencyGraph.markCompleted(taskId);\n\n    // Complete the task\n    await super.completeTask(taskId, result);\n\n    // Start ready tasks\n    for (const readyTaskId of readyTasks) {\n      const readyTask = await this.getTask(readyTaskId);\n      if (readyTask) {\n        this.eventBus.emit(SystemEvents.TASK_CREATED, { task: readyTask });\n      }\n    }\n  }\n\n  /**\n   * Override failTask to update stats and dependency graph\n   */\n  override async failTask(taskId: string, error: Error): Promise<void> {\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task not found: ${taskId}`);\n    }\n\n    // Update task stats\n    this.updateTaskStats(task.type, false, 0);\n\n    // Mark as failed in dependency graph\n    const toCancelIds = this.dependencyGraph.markFailed(taskId);\n\n    // Fail the task\n    await super.failTask(taskId, error);\n\n    // Cancel dependent tasks\n    for (const cancelId of toCancelIds) {\n      await this.cancelTask(cancelId, 'Parent task failed');\n    }\n  }\n\n  /**\n   * Get a task by ID (helper method)\n   */\n  private async getTask(taskId: string): Promise<Task | null> {\n    // This would need to be implemented based on how tasks are stored\n    // For now, return null\n    return null;\n  }\n\n  /**\n   * Update task statistics\n   */\n  private updateTaskStats(taskType: string, success: boolean, duration: number): void {\n    const stats = this.taskStats.get(taskType) || {\n      totalExecutions: 0,\n      avgDuration: 0,\n      successRate: 0,\n    };\n\n    stats.totalExecutions++;\n\n    if (success) {\n      const successCount = Math.round(stats.successRate * (stats.totalExecutions - 1));\n      stats.successRate = (successCount + 1) / stats.totalExecutions;\n\n      if (duration > 0) {\n        const totalDuration = stats.avgDuration * (stats.totalExecutions - 1);\n        stats.avgDuration = (totalDuration + duration) / stats.totalExecutions;\n      }\n    } else {\n      const successCount = Math.round(stats.successRate * (stats.totalExecutions - 1));\n      stats.successRate = successCount / stats.totalExecutions;\n    }\n\n    this.taskStats.set(taskType, stats);\n  }\n\n  /**\n   * Set up advanced event handlers\n   */\n  private setupAdvancedEventHandlers(): void {\n    // Handle work stealing requests\n    this.eventBus.on('workstealing:request', async (data: any) => {\n      const { sourceAgent, targetAgent, taskCount } = data;\n\n      try {\n        const tasks = await this.getAgentTasks(sourceAgent);\n        const tasksToSteal = tasks\n          .filter((t) => t.status === 'queued' || t.status === 'assigned')\n          .slice(0, taskCount);\n\n        for (const task of tasksToSteal) {\n          await this.reassignTask(task.id, targetAgent);\n        }\n\n        this.logger.info('Work stealing completed', {\n          from: sourceAgent,\n          to: targetAgent,\n          stolenCount: tasksToSteal.length,\n        });\n      } catch (error) {\n        this.logger.error('Work stealing failed', { error });\n      }\n    });\n\n    // Update workload on task events\n    this.eventBus.on(SystemEvents.TASK_ASSIGNED, async (data: any) => {\n      const { agentId } = data;\n      const taskCount = await this.getAgentTaskCount(agentId);\n      this.workStealing.updateAgentWorkload(agentId, { taskCount });\n    });\n\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: any) => {\n      const { taskId } = data;\n      // Update workload after task completion\n      // This would need the agent ID from the task\n    });\n  }\n\n  /**\n   * Reassign a task to a different agent\n   */\n  private async reassignTask(taskId: string, newAgentId: string): Promise<void> {\n    // Cancel the current assignment\n    await this.cancelTask(taskId, 'Reassigning to different agent');\n\n    // Get the task\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task not found: ${taskId}`);\n    }\n\n    // Assign to new agent\n    await this.assignTask(task, newAgentId);\n  }\n\n  /**\n   * Get advanced scheduling metrics\n   */\n  async getSchedulingMetrics(): Promise<Record<string, unknown>> {\n    const baseMetrics = await this.getHealthStatus();\n    const workloadStats = this.workStealing.getWorkloadStats();\n    const depGraphStats = this.dependencyGraph.getStats();\n    const cbMetrics = this.circuitBreakers.getAllMetrics();\n\n    return {\n      ...baseMetrics.metrics,\n      workStealing: workloadStats,\n      dependencies: depGraphStats,\n      circuitBreakers: cbMetrics,\n      taskStats: Object.fromEntries(this.taskStats),\n      activeStrategies: Array.from(this.strategies.keys()),\n      defaultStrategy: this.defaultStrategy,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
