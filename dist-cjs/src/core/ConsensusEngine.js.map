{"version":3,"sources":["../../../src/core/ConsensusEngine.ts"],"sourcesContent":["/**\r\n * ConsensusEngine - Implements consensus algorithms for distributed decision making\r\n * Supports multiple consensus algorithms: Raft, Byzantine, Gossip, and Proof-of-Learning\r\n */\r\n\r\nimport { IDatabaseProvider, IConsensusAlgorithm, Decision, Vote, Consensus, Result, ConsensusType } from '../types/interfaces.js';\r\nimport { nanoid } from 'nanoid';\r\n\r\nexport class ConsensusEngine {\r\n  private algorithms: Map<ConsensusType, IConsensusAlgorithm> = new Map();\r\n  private currentAlgorithm: IConsensusAlgorithm | null = null;\r\n  private pendingDecisions: Map<string, Decision> = new Map();\r\n  private consensusHistory: Map<string, Consensus> = new Map();\r\n\r\n  constructor(private database: IDatabaseProvider) {\r\n    this.initializeAlgorithms();\r\n  }\r\n\r\n  /**\r\n   * Initialize available consensus algorithms\r\n   */\r\n  private initializeAlgorithms(): void {\r\n    this.algorithms.set('raft', new RaftConsensus(this.database));\r\n    this.algorithms.set('byzantine', new ByzantineConsensus(this.database));\r\n    this.algorithms.set('gossip', new GossipConsensus(this.database));\r\n    this.algorithms.set('proof-of-learning', new ProofOfLearningConsensus(this.database));\r\n  }\r\n\r\n  /**\r\n   * Set the active consensus algorithm\r\n   */\r\n  async setAlgorithm(type: ConsensusType): Promise<void> {\r\n    const algorithm = this.algorithms.get(type);\r\n    if (!algorithm) {\r\n      throw new Error(`Unknown consensus algorithm: ${type}`);\r\n    }\r\n\r\n    this.currentAlgorithm = algorithm;\r\n    await algorithm.initialize();\r\n\r\n    await this.database.store('consensus-algorithm', type, 'system');\r\n  }\r\n\r\n  /**\r\n   * Propose a decision for consensus\r\n   */\r\n  async propose(decision: Omit<Decision, 'id' | 'timestamp'>): Promise<string> {\r\n    if (!this.currentAlgorithm) {\r\n      throw new Error('No consensus algorithm selected');\r\n    }\r\n\r\n    const fullDecision: Decision = {\r\n      ...decision,\r\n      id: nanoid(),\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.pendingDecisions.set(fullDecision.id, fullDecision);\r\n    await this.database.store(`decision:${fullDecision.id}`, fullDecision, 'consensus');\r\n\r\n    // Start consensus process\r\n    const votes = await this.currentAlgorithm.propose(fullDecision);\r\n\r\n    // Process votes and determine consensus\r\n    const consensus = await this.processVotes(fullDecision, votes);\r\n\r\n    return fullDecision.id;\r\n  }\r\n\r\n  /**\r\n   * Process votes and determine consensus\r\n   */\r\n  private async processVotes(decision: Decision, votes: Vote[]): Promise<Consensus> {\r\n    // Calculate consensus based on votes\r\n    const positiveVotes = votes.filter(vote => vote.decision);\r\n    const totalConfidence = votes.reduce((sum, vote) => sum + vote.confidence, 0);\r\n    const averageConfidence = totalConfidence / votes.length;\r\n\r\n    // Simple majority rule with confidence weighting\r\n    const weightedPositive = positiveVotes.reduce((sum, vote) => sum + vote.confidence, 0);\r\n    const totalWeight = votes.reduce((sum, vote) => sum + vote.confidence, 0);\r\n\r\n    const outcome = weightedPositive > (totalWeight / 2) && averageConfidence > 0.6;\r\n\r\n    const consensus: Consensus = {\r\n      decisionId: decision.id,\r\n      outcome,\r\n      votes,\r\n      confidence: averageConfidence,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.consensusHistory.set(decision.id, consensus);\r\n    await this.database.store(`consensus:${decision.id}`, consensus, 'consensus');\r\n\r\n    // Execute if consensus reached\r\n    if (outcome) {\r\n      await this.executeConsensus(consensus);\r\n    }\r\n\r\n    return consensus;\r\n  }\r\n\r\n  /**\r\n   * Execute a consensus decision\r\n   */\r\n  private async executeConsensus(consensus: Consensus): Promise<Result> {\r\n    if (!this.currentAlgorithm) {\r\n      throw new Error('No consensus algorithm available for execution');\r\n    }\r\n\r\n    const result = await this.currentAlgorithm.execute(consensus);\r\n    await this.database.store(`result:${consensus.decisionId}`, result, 'consensus');\r\n\r\n    // Clean up pending decision\r\n    this.pendingDecisions.delete(consensus.decisionId);\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get consensus status for a decision\r\n   */\r\n  async getConsensusStatus(decisionId: string): Promise<{\r\n    decision: Decision | null;\r\n    consensus: Consensus | null;\r\n    status: 'pending' | 'reached' | 'failed';\r\n  }> {\r\n    const decision = this.pendingDecisions.get(decisionId) ||\r\n      await this.database.retrieve(`decision:${decisionId}`, 'consensus');\r\n\r\n    const consensus = this.consensusHistory.get(decisionId) ||\r\n      await this.database.retrieve(`consensus:${decisionId}`, 'consensus');\r\n\r\n    let status: 'pending' | 'reached' | 'failed' = 'pending';\r\n    if (consensus) {\r\n      status = consensus.outcome ? 'reached' : 'failed';\r\n    }\r\n\r\n    return { decision, consensus, status };\r\n  }\r\n\r\n  /**\r\n   * Get all pending decisions\r\n   */\r\n  getPendingDecisions(): Decision[] {\r\n    return Array.from(this.pendingDecisions.values());\r\n  }\r\n\r\n  /**\r\n   * Get consensus history\r\n   */\r\n  getConsensusHistory(): Consensus[] {\r\n    return Array.from(this.consensusHistory.values());\r\n  }\r\n\r\n  /**\r\n   * Get current algorithm type\r\n   */\r\n  getCurrentAlgorithm(): ConsensusType | null {\r\n    return this.currentAlgorithm?.getType() || null;\r\n  }\r\n\r\n  /**\r\n   * Get available algorithms\r\n   */\r\n  getAvailableAlgorithms(): ConsensusType[] {\r\n    return Array.from(this.algorithms.keys());\r\n  }\r\n}\r\n\r\n/**\r\n * Raft Consensus Algorithm\r\n * Leader-based consensus with strong consistency\r\n */\r\nclass RaftConsensus implements IConsensusAlgorithm {\r\n  private leaderId: string | null = null;\r\n  private term: number = 0;\r\n  private votedFor: string | null = null;\r\n\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  getType(): ConsensusType {\r\n    return 'raft';\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    // Load state from database\r\n    const state = await this.database.retrieve('raft-state', 'consensus');\r\n    if (state) {\r\n      this.term = state.term || 0;\r\n      this.leaderId = state.leaderId || null;\r\n      this.votedFor = state.votedFor || null;\r\n    }\r\n  }\r\n\r\n  async propose(decision: Decision): Promise<Vote[]> {\r\n    // In Raft, only the leader can propose\r\n    if (!this.leaderId) {\r\n      await this.electLeader();\r\n    }\r\n\r\n    // Simulate distributed voting\r\n    const votes: Vote[] = [];\r\n    const agentIds = await this.getAgentIds();\r\n\r\n    for (const agentId of agentIds) {\r\n      const vote: Vote = {\r\n        agentId,\r\n        decision: Math.random() > 0.2, // 80% approval rate\r\n        confidence: 0.8 + Math.random() * 0.2, // High confidence in Raft\r\n        reasoning: `Raft consensus vote for decision ${decision.id}`\r\n      };\r\n      votes.push(vote);\r\n    }\r\n\r\n    return votes;\r\n  }\r\n\r\n  async execute(consensus: Consensus): Promise<Result> {\r\n    if (!consensus.outcome) {\r\n      return {\r\n        success: false,\r\n        error: 'Consensus was not reached'\r\n      };\r\n    }\r\n\r\n    // Execute the decision through the leader\r\n    return {\r\n      success: true,\r\n      data: {\r\n        algorithm: 'raft',\r\n        leader: this.leaderId,\r\n        term: this.term,\r\n        executedAt: new Date().toISOString()\r\n      },\r\n      metadata: {\r\n        consensusId: consensus.decisionId,\r\n        votes: consensus.votes.length\r\n      }\r\n    };\r\n  }\r\n\r\n  private async electLeader(): Promise<void> {\r\n    this.term++;\r\n    const agentIds = await this.getAgentIds();\r\n    this.leaderId = agentIds[0] || 'default-leader';\r\n    this.votedFor = this.leaderId;\r\n\r\n    await this.database.store('raft-state', {\r\n      term: this.term,\r\n      leaderId: this.leaderId,\r\n      votedFor: this.votedFor\r\n    }, 'consensus');\r\n  }\r\n\r\n  private async getAgentIds(): Promise<string[]> {\r\n    try {\r\n      const agentKeys = await this.database.list('agents');\r\n      return agentKeys.map(key => key.replace('agent:', ''));\r\n    } catch {\r\n      return ['agent-1', 'agent-2', 'agent-3']; // Default agents\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Byzantine Fault Tolerant Consensus\r\n * Handles up to 1/3 malicious agents\r\n */\r\nclass ByzantineConsensus implements IConsensusAlgorithm {\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  getType(): ConsensusType {\r\n    return 'byzantine';\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    // Byzantine consensus initialization\r\n  }\r\n\r\n  async propose(decision: Decision): Promise<Vote[]> {\r\n    const votes: Vote[] = [];\r\n    const agentIds = await this.getAgentIds();\r\n\r\n    // Simulate Byzantine environment with some malicious agents\r\n    for (const agentId of agentIds) {\r\n      const isMalicious = Math.random() < 0.2; // 20% malicious agents\r\n      const vote: Vote = {\r\n        agentId,\r\n        decision: isMalicious ? Math.random() < 0.3 : Math.random() > 0.3, // Malicious agents vote randomly\r\n        confidence: isMalicious ? Math.random() * 0.5 : 0.7 + Math.random() * 0.3,\r\n        reasoning: `Byzantine consensus vote (${isMalicious ? 'malicious' : 'honest'})`\r\n      };\r\n      votes.push(vote);\r\n    }\r\n\r\n    return votes;\r\n  }\r\n\r\n  async execute(consensus: Consensus): Promise<Result> {\r\n    // Byzantine consensus requires 2/3 + 1 majority\r\n    const honestVotes = consensus.votes.filter(vote => vote.confidence > 0.6);\r\n    const required = Math.floor(consensus.votes.length * 2 / 3) + 1;\r\n\r\n    if (honestVotes.length >= required && consensus.outcome) {\r\n      return {\r\n        success: true,\r\n        data: {\r\n          algorithm: 'byzantine',\r\n          honestVotes: honestVotes.length,\r\n          totalVotes: consensus.votes.length,\r\n          executedAt: new Date().toISOString()\r\n        }\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Byzantine consensus failed - insufficient honest votes'\r\n    };\r\n  }\r\n\r\n  private async getAgentIds(): Promise<string[]> {\r\n    try {\r\n      const agentKeys = await this.database.list('agents');\r\n      return agentKeys.map(key => key.replace('agent:', ''));\r\n    } catch {\r\n      return ['agent-1', 'agent-2', 'agent-3', 'agent-4', 'agent-5'];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gossip Protocol Consensus\r\n * Eventually consistent through peer-to-peer communication\r\n */\r\nclass GossipConsensus implements IConsensusAlgorithm {\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  getType(): ConsensusType {\r\n    return 'gossip';\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    // Gossip protocol initialization\r\n  }\r\n\r\n  async propose(decision: Decision): Promise<Vote[]> {\r\n    const votes: Vote[] = [];\r\n    const agentIds = await this.getAgentIds();\r\n\r\n    // Simulate gossip propagation delays and eventual consistency\r\n    for (const agentId of agentIds) {\r\n      const delay = Math.random() * 1000; // Random delay\r\n      const informed = Math.random() > 0.1; // 90% eventually receive the message\r\n\r\n      if (informed) {\r\n        const vote: Vote = {\r\n          agentId,\r\n          decision: Math.random() > 0.25, // 75% approval\r\n          confidence: 0.6 + Math.random() * 0.3,\r\n          reasoning: `Gossip consensus vote (delay: ${Math.round(delay)}ms)`\r\n        };\r\n        votes.push(vote);\r\n      }\r\n    }\r\n\r\n    return votes;\r\n  }\r\n\r\n  async execute(consensus: Consensus): Promise<Result> {\r\n    // Gossip consensus is eventually consistent\r\n    const participation = consensus.votes.length / (await this.getAgentIds()).length;\r\n\r\n    if (consensus.outcome && participation > 0.7) {\r\n      return {\r\n        success: true,\r\n        data: {\r\n          algorithm: 'gossip',\r\n          participation: participation,\r\n          convergenceTime: Math.random() * 5000 + 1000,\r\n          executedAt: new Date().toISOString()\r\n        }\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Gossip consensus failed - insufficient participation or negative outcome'\r\n    };\r\n  }\r\n\r\n  private async getAgentIds(): Promise<string[]> {\r\n    try {\r\n      const agentKeys = await this.database.list('agents');\r\n      return agentKeys.map(key => key.replace('agent:', ''));\r\n    } catch {\r\n      return Array.from({ length: 8 }, (_, i) => `agent-${i + 1}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Proof of Learning Consensus\r\n * Consensus based on agent learning and performance\r\n */\r\nclass ProofOfLearningConsensus implements IConsensusAlgorithm {\r\n  constructor(private database: IDatabaseProvider) {}\r\n\r\n  getType(): ConsensusType {\r\n    return 'proof-of-learning';\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    // Proof of Learning initialization\r\n  }\r\n\r\n  async propose(decision: Decision): Promise<Vote[]> {\r\n    const votes: Vote[] = [];\r\n    const agentIds = await this.getAgentIds();\r\n\r\n    for (const agentId of agentIds) {\r\n      // Get agent performance for voting weight\r\n      const performance = await this.getAgentPerformance(agentId);\r\n      const learningScore = this.calculateLearningScore(performance);\r\n\r\n      const vote: Vote = {\r\n        agentId,\r\n        decision: learningScore > 0.5 ? Math.random() > 0.2 : Math.random() > 0.6,\r\n        confidence: learningScore,\r\n        reasoning: `Proof of Learning vote (learning score: ${learningScore.toFixed(2)})`\r\n      };\r\n      votes.push(vote);\r\n    }\r\n\r\n    return votes;\r\n  }\r\n\r\n  async execute(consensus: Consensus): Promise<Result> {\r\n    // Weight votes by learning scores\r\n    const weightedVotes = consensus.votes.reduce((sum, vote) => {\r\n      return sum + (vote.decision ? vote.confidence : -vote.confidence);\r\n    }, 0);\r\n\r\n    const totalWeight = consensus.votes.reduce((sum, vote) => sum + vote.confidence, 0);\r\n    const weightedOutcome = weightedVotes > 0 && (weightedVotes / totalWeight) > 0.6;\r\n\r\n    if (weightedOutcome) {\r\n      return {\r\n        success: true,\r\n        data: {\r\n          algorithm: 'proof-of-learning',\r\n          weightedScore: weightedVotes / totalWeight,\r\n          highPerformers: consensus.votes.filter(v => v.confidence > 0.8).length,\r\n          executedAt: new Date().toISOString()\r\n        }\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: 'Proof of Learning consensus failed - insufficient weighted support'\r\n    };\r\n  }\r\n\r\n  private async getAgentPerformance(agentId: string): Promise<any> {\r\n    try {\r\n      const agent = await this.database.retrieve(agentId, 'agents');\r\n      return agent?.performance || { successRate: 0.5, tasksCompleted: 0 };\r\n    } catch {\r\n      return { successRate: 0.5, tasksCompleted: 0 };\r\n    }\r\n  }\r\n\r\n  private calculateLearningScore(performance: any): number {\r\n    // Combine success rate and experience\r\n    const successWeight = 0.7;\r\n    const experienceWeight = 0.3;\r\n\r\n    const successScore = performance.successRate || 0.5;\r\n    const experienceScore = Math.min(1.0, (performance.tasksCompleted || 0) / 100);\r\n\r\n    return successScore * successWeight + experienceScore * experienceWeight;\r\n  }\r\n\r\n  private async getAgentIds(): Promise<string[]> {\r\n    try {\r\n      const agentKeys = await this.database.list('agents');\r\n      return agentKeys.map(key => key.replace('agent:', ''));\r\n    } catch {\r\n      return Array.from({ length: 6 }, (_, i) => `agent-${i + 1}`);\r\n    }\r\n  }\r\n}"],"names":["nanoid","ConsensusEngine","algorithms","Map","currentAlgorithm","pendingDecisions","consensusHistory","database","initializeAlgorithms","set","RaftConsensus","ByzantineConsensus","GossipConsensus","ProofOfLearningConsensus","setAlgorithm","type","algorithm","get","Error","initialize","store","propose","decision","fullDecision","id","timestamp","Date","votes","consensus","processVotes","positiveVotes","filter","vote","totalConfidence","reduce","sum","confidence","averageConfidence","length","weightedPositive","totalWeight","outcome","decisionId","executeConsensus","result","execute","delete","getConsensusStatus","retrieve","status","getPendingDecisions","Array","from","values","getConsensusHistory","getCurrentAlgorithm","getType","getAvailableAlgorithms","keys","leaderId","term","votedFor","state","electLeader","agentIds","getAgentIds","agentId","Math","random","reasoning","push","success","error","data","leader","executedAt","toISOString","metadata","consensusId","agentKeys","list","map","key","replace","isMalicious","honestVotes","required","floor","totalVotes","delay","informed","round","participation","convergenceTime","_","i","performance","getAgentPerformance","learningScore","calculateLearningScore","toFixed","weightedVotes","weightedOutcome","weightedScore","highPerformers","v","agent","successRate","tasksCompleted","successWeight","experienceWeight","successScore","experienceScore","min"],"mappings":"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"}