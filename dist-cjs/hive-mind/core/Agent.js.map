{
  "version": 3,
  "sources": ["../../../src/hive-mind/core/Agent.ts"],
  "sourcesContent": ["/**\n * Base Agent Class\n *\n * Foundation for all agent types in the Hive Mind swarm.\n * Provides core functionality for task execution, communication, and coordination.\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\nimport {\n  AgentType,\n  AgentStatus,\n  AgentCapability,\n  Task,\n  Message,\n  AgentConfig,\n  ExecutionResult,\n} from '../types.js';\n\nexport class Agent extends EventEmitter {\n  public readonly id: string;\n  public readonly name: string;\n  public readonly type: AgentType;\n  public readonly swarmId: string;\n  public readonly capabilities: AgentCapability[];\n  public readonly createdAt: Date;\n\n  public status: AgentStatus = 'idle';\n  public currentTask: string | null = null;\n  public messageCount: number = 0;\n\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private memory: Map<string, any>;\n  private communicationBuffer: Message[];\n  private lastHeartbeat: number;\n  private isActive: boolean = false;\n\n  constructor(config: AgentConfig) {\n    super();\n    this.id = config.id || uuidv4();\n    this.name = config.name;\n    this.type = config.type;\n    this.swarmId = config.swarmId;\n    this.capabilities = config.capabilities || [];\n    this.createdAt = new Date();\n\n    this.memory = new Map();\n    this.communicationBuffer = [];\n    this.lastHeartbeat = Date.now();\n  }\n\n  /**\n   * Initialize the agent\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n\n    // Load agent state from database if exists\n    const existingAgent = await this.db.getAgent(this.id);\n    if (existingAgent) {\n      this.status = existingAgent.status as AgentStatus;\n      this.currentTask = existingAgent.current_task_id;\n      this.messageCount = existingAgent.message_count;\n    }\n\n    // Start agent loops\n    this.startHeartbeatLoop();\n    this.startCommunicationLoop();\n    this.startLearningLoop();\n\n    this.isActive = true;\n    this.emit('initialized');\n  }\n\n  /**\n   * Assign a task to this agent\n   */\n  async assignTask(taskId: string, executionPlan: any): Promise<void> {\n    if (this.currentTask) {\n      throw new Error('Agent already has an active task');\n    }\n\n    this.currentTask = taskId;\n    this.status = 'busy';\n\n    // Update database\n    await this.db.updateAgent(this.id, {\n      status: 'busy',\n      current_task_id: taskId,\n    });\n\n    // Store task in memory\n    this.memory.set('current_task', { taskId, executionPlan, startTime: Date.now() });\n\n    // Start task execution\n    this.executeTask(taskId, executionPlan).catch((error) => {\n      this.emit('taskError', { taskId, error });\n    });\n\n    this.emit('taskAssigned', { taskId });\n  }\n\n  /**\n   * Execute assigned task\n   */\n  private async executeTask(taskId: string, executionPlan: any): Promise<void> {\n    try {\n      // Load task details\n      const task = await this.db.getTask(taskId);\n      if (!task) {\n        throw new Error('Task not found');\n      }\n\n      // Update task status\n      await this.db.updateTaskStatus(taskId, 'in_progress');\n\n      // Execute based on agent type\n      const result = await this.executeByType(task, executionPlan);\n\n      // Store result\n      await this.db.updateTask(taskId, {\n        status: 'completed',\n        result: JSON.stringify(result),\n        progress: 100,\n        completed_at: new Date(),\n      });\n\n      // Learn from execution\n      await this.learnFromExecution(task, result);\n\n      // Clear task\n      this.currentTask = null;\n      this.status = 'idle';\n\n      await this.db.updateAgent(this.id, {\n        status: 'idle',\n        current_task_id: null,\n        success_count: this.db.raw('success_count + 1'),\n      });\n\n      this.emit('taskCompleted', { taskId, result });\n    } catch (error) {\n      // Handle task failure\n      await this.handleTaskFailure(taskId, error);\n    }\n  }\n\n  /**\n   * Execute task based on agent type\n   */\n  protected async executeByType(task: any, executionPlan: any): Promise<ExecutionResult> {\n    // Base implementation - override in specialized agents\n    const startTime = Date.now();\n\n    // Simulate task execution phases\n    const phases = executionPlan.phases || ['analysis', 'execution', 'validation'];\n    const results: any[] = [];\n\n    for (const phase of phases) {\n      const phaseResult = await this.executePhase(phase, task, executionPlan);\n      results.push(phaseResult);\n\n      // Update progress\n      const progress = Math.round(((phases.indexOf(phase) + 1) / phases.length) * 100);\n      await this.updateTaskProgress(task.id, progress);\n\n      // Communicate progress\n      await this.communicateProgress(task.id, phase, progress);\n    }\n\n    return {\n      success: true,\n      data: results,\n      executionTime: Date.now() - startTime,\n      agentId: this.id,\n      metadata: {\n        phases: phases,\n        plan: executionPlan,\n      },\n    };\n  }\n\n  /**\n   * Execute a specific phase of the task\n   */\n  protected async executePhase(phase: string, task: any, plan: any): Promise<any> {\n    // Use MCP tools based on phase and agent capabilities\n    switch (phase) {\n      case 'analysis':\n        return this.performAnalysis(task);\n\n      case 'execution':\n        return this.performExecution(task, plan);\n\n      case 'validation':\n        return this.performValidation(task);\n\n      default:\n        return { phase, status: 'completed' };\n    }\n  }\n\n  /**\n   * Perform analysis phase\n   */\n  protected async performAnalysis(task: any): Promise<any> {\n    // Use neural analysis for task understanding\n    const analysis = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: `${this.type}_analysis`,\n      metadata: {\n        task: task.description,\n        agentType: this.type,\n        capabilities: this.capabilities,\n      },\n    });\n\n    // Store analysis in memory\n    await this.storeInMemory('task_analysis', analysis);\n\n    return {\n      phase: 'analysis',\n      complexity: analysis.complexity || 'medium',\n      estimatedTime: analysis.estimatedTime || 3600000,\n      requirements: analysis.requirements || [],\n    };\n  }\n\n  /**\n   * Perform execution phase\n   */\n  protected async performExecution(task: any, plan: any): Promise<any> {\n    // Base execution - specialized agents override this\n    const actions =\n      plan.agentAssignments?.find((a: any) => a.agentId === this.id)?.responsibilities || [];\n    const results = [];\n\n    for (const action of actions) {\n      const actionResult = await this.executeAction(action, task);\n      results.push(actionResult);\n    }\n\n    return {\n      phase: 'execution',\n      actions: actions,\n      results: results,\n    };\n  }\n\n  /**\n   * Perform validation phase\n   */\n  protected async performValidation(task: any): Promise<any> {\n    // Validate execution results\n    const validation = {\n      phase: 'validation',\n      checks: [],\n      passed: true,\n    };\n\n    // Basic validation checks\n    const checks = [\n      { name: 'completeness', passed: true },\n      { name: 'quality', passed: true },\n      { name: 'performance', passed: true },\n    ];\n\n    validation.checks = checks;\n    validation.passed = checks.every((c) => c.passed);\n\n    return validation;\n  }\n\n  /**\n   * Execute a specific action\n   */\n  protected async executeAction(action: string, task: any): Promise<any> {\n    // Base action execution\n    return {\n      action: action,\n      status: 'completed',\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Send a message to another agent or broadcast\n   */\n  async sendMessage(toAgentId: string | null, messageType: string, content: any): Promise<void> {\n    const message: Message = {\n      id: uuidv4(),\n      fromAgentId: this.id,\n      toAgentId,\n      swarmId: this.swarmId,\n      type: messageType,\n      content,\n      timestamp: new Date(),\n      requiresResponse: false,\n    };\n\n    // Store in database\n    await this.db.createCommunication({\n      from_agent_id: this.id,\n      to_agent_id: toAgentId,\n      swarm_id: this.swarmId,\n      message_type: messageType,\n      content: JSON.stringify(content),\n      priority: 'normal',\n    });\n\n    this.messageCount++;\n    this.emit('messageSent', message);\n  }\n\n  /**\n   * Receive and process a message\n   */\n  async receiveMessage(message: Message): Promise<void> {\n    this.communicationBuffer.push(message);\n    this.emit('messageReceived', message);\n  }\n\n  /**\n   * Vote on a consensus proposal\n   */\n  async voteOnProposal(proposalId: string, vote: boolean, reason?: string): Promise<void> {\n    await this.db.submitConsensusVote(proposalId, this.id, vote, reason);\n    this.emit('voteCast', { proposalId, vote, reason });\n  }\n\n  /**\n   * Update task progress\n   */\n  protected async updateTaskProgress(taskId: string, progress: number): Promise<void> {\n    await this.db.updateTask(taskId, {\n      progress,\n      last_progress_update: new Date(),\n    });\n  }\n\n  /**\n   * Communicate progress to other agents\n   */\n  protected async communicateProgress(\n    taskId: string,\n    phase: string,\n    progress: number,\n  ): Promise<void> {\n    await this.sendMessage(null, 'progress_update', {\n      taskId,\n      agentId: this.id,\n      phase,\n      progress,\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Store data in agent memory\n   */\n  protected async storeInMemory(key: string, value: any): Promise<void> {\n    this.memory.set(key, value);\n\n    // Also store in persistent memory\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `agent/${this.id}/${key}`,\n      value: JSON.stringify(value),\n      namespace: 'agent-memory',\n      ttl: 3600, // 1 hour\n    });\n  }\n\n  /**\n   * Retrieve from agent memory\n   */\n  protected async retrieveFromMemory(key: string): Promise<any> {\n    // Check local memory first\n    if (this.memory.has(key)) {\n      return this.memory.get(key);\n    }\n\n    // Check persistent memory\n    const result = await this.mcpWrapper.retrieveMemory({\n      action: 'retrieve',\n      key: `agent/${this.id}/${key}`,\n      namespace: 'agent-memory',\n    });\n\n    return result ? JSON.parse(result) : null;\n  }\n\n  /**\n   * Learn from task execution\n   */\n  protected async learnFromExecution(task: any, result: ExecutionResult): Promise<void> {\n    const learningData = {\n      taskType: this.detectTaskType(task.description),\n      agentType: this.type,\n      success: result.success,\n      executionTime: result.executionTime,\n      patterns: this.extractPatterns(task, result),\n    };\n\n    // Train neural patterns\n    await this.mcpWrapper.trainNeural({\n      pattern_type: 'optimization',\n      training_data: JSON.stringify(learningData),\n      epochs: 10,\n    });\n  }\n\n  /**\n   * Handle task failure\n   */\n  protected async handleTaskFailure(taskId: string, error: any): Promise<void> {\n    // Update task status\n    await this.db.updateTask(taskId, {\n      status: 'failed',\n      error: error.message,\n      completed_at: new Date(),\n    });\n\n    // Update agent stats\n    await this.db.updateAgent(this.id, {\n      status: 'idle',\n      current_task_id: null,\n      error_count: this.db.raw('error_count + 1'),\n    });\n\n    // Clear current task\n    this.currentTask = null;\n    this.status = 'idle';\n\n    // Notify swarm of failure\n    await this.sendMessage(null, 'task_failed', {\n      taskId,\n      agentId: this.id,\n      error: error.message,\n      timestamp: new Date(),\n    });\n\n    this.emit('taskFailed', { taskId, error });\n  }\n\n  /**\n   * Start heartbeat loop\n   */\n  private startHeartbeatLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      this.lastHeartbeat = Date.now();\n\n      // Update last active timestamp\n      await this.db.updateAgent(this.id, {\n        last_active_at: new Date(),\n      });\n\n      this.emit('heartbeat');\n    }, 30000); // Every 30 seconds\n  }\n\n  /**\n   * Start communication processing loop\n   */\n  private startCommunicationLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive || this.communicationBuffer.length === 0) return;\n\n      // Process buffered messages\n      const messages = [...this.communicationBuffer];\n      this.communicationBuffer = [];\n\n      for (const message of messages) {\n        await this.processMessage(message);\n      }\n    }, 1000); // Every second\n  }\n\n  /**\n   * Start learning loop\n   */\n  private startLearningLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Analyze recent patterns\n        const patterns = await this.analyzeRecentPatterns();\n\n        // Update capabilities if needed\n        await this.updateCapabilities(patterns);\n      } catch (error) {\n        this.emit('learningError', error);\n      }\n    }, 300000); // Every 5 minutes\n  }\n\n  /**\n   * Process incoming message\n   */\n  protected async processMessage(message: Message): Promise<void> {\n    switch (message.type) {\n      case 'task_assignment':\n        await this.handleTaskAssignment(message.content);\n        break;\n\n      case 'consensus':\n        await this.handleConsensusRequest(message.content);\n        break;\n\n      case 'query':\n        await this.handleQuery(message);\n        break;\n\n      case 'coordination':\n        await this.handleCoordination(message.content);\n        break;\n\n      default:\n        this.emit('unknownMessage', message);\n    }\n  }\n\n  /**\n   * Check if agent is responsive\n   */\n  isResponsive(): boolean {\n    const timeout = 60000; // 1 minute\n    return Date.now() - this.lastHeartbeat < timeout;\n  }\n\n  /**\n   * Get agent state\n   */\n  getState(): any {\n    return {\n      id: this.id,\n      name: this.name,\n      type: this.type,\n      status: this.status,\n      currentTask: this.currentTask,\n      capabilities: this.capabilities,\n      messageCount: this.messageCount,\n      isResponsive: this.isResponsive(),\n      memory: Object.fromEntries(this.memory),\n    };\n  }\n\n  /**\n   * Shutdown the agent\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Update status in database\n    await this.db.updateAgent(this.id, {\n      status: 'offline',\n    });\n\n    // Clear memory\n    this.memory.clear();\n    this.communicationBuffer = [];\n\n    this.emit('shutdown');\n  }\n\n  // Helper methods\n\n  private detectTaskType(description: string): string {\n    const lower = description.toLowerCase();\n\n    if (lower.includes('research') || lower.includes('investigate')) return 'research';\n    if (lower.includes('develop') || lower.includes('implement')) return 'development';\n    if (lower.includes('analyze') || lower.includes('review')) return 'analysis';\n    if (lower.includes('test') || lower.includes('validate')) return 'testing';\n    if (lower.includes('optimize') || lower.includes('improve')) return 'optimization';\n\n    return 'general';\n  }\n\n  private extractPatterns(task: any, result: ExecutionResult): any {\n    return {\n      taskComplexity: task.priority,\n      executionStrategy: task.strategy,\n      phasesCompleted: result.metadata?.phases?.length || 0,\n      timePerPhase: result.executionTime / (result.metadata?.phases?.length || 1),\n    };\n  }\n\n  private async analyzeRecentPatterns(): Promise<any> {\n    return this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'agent_patterns',\n      metadata: {\n        agentId: this.id,\n        agentType: this.type,\n        timeframe: '1h',\n      },\n    });\n  }\n\n  private async updateCapabilities(patterns: any): Promise<void> {\n    if (patterns.suggestedCapabilities) {\n      // Update capabilities based on learning\n      const newCapabilities = patterns.suggestedCapabilities.filter(\n        (cap: string) => !this.capabilities.includes(cap),\n      );\n\n      if (newCapabilities.length > 0) {\n        this.capabilities.push(...newCapabilities);\n\n        await this.db.updateAgent(this.id, {\n          capabilities: JSON.stringify(this.capabilities),\n        });\n\n        this.emit('capabilitiesUpdated', newCapabilities);\n      }\n    }\n  }\n\n  private async handleTaskAssignment(content: any): Promise<void> {\n    // Handle incoming task assignment\n    if (!this.currentTask && content.taskId) {\n      await this.assignTask(content.taskId, content.executionPlan || {});\n    }\n  }\n\n  private async handleConsensusRequest(content: any): Promise<void> {\n    // Analyze proposal and vote\n    const analysis = await this.analyzeProposal(content);\n    await this.voteOnProposal(content.proposalId, analysis.vote, analysis.reason);\n  }\n\n  private async handleQuery(message: Message): Promise<void> {\n    // Respond to query\n    const response = await this.processQuery(message.content);\n\n    if (message.fromAgentId) {\n      await this.sendMessage(message.fromAgentId, 'response', {\n        queryId: message.id,\n        response,\n      });\n    }\n  }\n\n  private async handleCoordination(content: any): Promise<void> {\n    // Handle coordination messages\n    this.emit('coordinationReceived', content);\n  }\n\n  private async analyzeProposal(proposal: any): Promise<any> {\n    // Simple analysis - can be overridden by specialized agents\n    return {\n      vote: Math.random() > 0.3, // 70% approval rate\n      reason: 'Based on agent analysis',\n    };\n  }\n\n  private async processQuery(query: any): Promise<any> {\n    // Process and respond to queries\n    return {\n      agentId: this.id,\n      agentType: this.type,\n      status: this.status,\n      response: 'Query processed',\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["uuidv4"]
}
