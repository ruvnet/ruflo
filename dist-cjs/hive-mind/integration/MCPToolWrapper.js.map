{
  "version": 3,
  "sources": ["../../../src/hive-mind/integration/MCPToolWrapper.ts"],
  "sourcesContent": ["/**\n * MCPToolWrapper Class\n *\n * Wraps all MCP tools for use within the Hive Mind system,\n * providing a unified interface for swarm coordination, neural processing,\n * and memory management.\n */\n\nimport { EventEmitter } from 'events';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { getErrorMessage } from '../../utils/type-guards.js';\n\nconst execAsync = promisify(exec);\n\ninterface MCPToolResponse {\n  success: boolean;\n  data?: any;\n  error?: string;\n}\n\nexport class MCPToolWrapper extends EventEmitter {\n  private toolPrefix = 'mcp__ruv-swarm__';\n  private isInitialized = false;\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Initialize MCP tools\n   */\n  async initialize(): Promise<void> {\n    try {\n      // Check if MCP tools are available\n      await this.checkToolAvailability();\n      this.isInitialized = true;\n      this.emit('initialized');\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if MCP tools are available\n   */\n  private async checkToolAvailability(): Promise<void> {\n    try {\n      const { stdout } = await execAsync('npx ruv-swarm --version');\n      if (!stdout) {\n        throw new Error('ruv-swarm MCP tools not found');\n      }\n    } catch (error) {\n      throw new Error('MCP tools not available. Please ensure ruv-swarm is installed.');\n    }\n  }\n\n  /**\n   * Execute MCP tool via CLI\n   */\n  private async executeTool(toolName: string, params: any): Promise<MCPToolResponse> {\n    try {\n      const command = `npx ruv-swarm mcp-execute ${toolName} '${JSON.stringify(params)}'`;\n      const { stdout, stderr } = await execAsync(command);\n\n      if (stderr) {\n        return { success: false, error: stderr };\n      }\n\n      const result = JSON.parse(stdout);\n      return { success: true, data: result };\n    } catch (error) {\n      return { success: false, error: getErrorMessage(error) };\n    }\n  }\n\n  // Swarm coordination tools\n\n  async initSwarm(params: {\n    topology: string;\n    maxAgents?: number;\n    strategy?: string;\n  }): Promise<any> {\n    return this.executeTool('swarm_init', params);\n  }\n\n  async spawnAgent(params: {\n    type: string;\n    name?: string;\n    swarmId?: string;\n    capabilities?: string[];\n  }): Promise<any> {\n    return this.executeTool('agent_spawn', params);\n  }\n\n  async orchestrateTask(params: {\n    task: string;\n    priority?: string;\n    strategy?: string;\n    dependencies?: string[];\n  }): Promise<any> {\n    return this.executeTool('task_orchestrate', params);\n  }\n\n  async getSwarmStatus(swarmId?: string): Promise<any> {\n    return this.executeTool('swarm_status', { swarmId });\n  }\n\n  async monitorSwarm(params: { swarmId?: string; interval?: number }): Promise<any> {\n    return this.executeTool('swarm_monitor', params);\n  }\n\n  // Neural and pattern tools\n\n  async analyzePattern(params: {\n    action: string;\n    operation?: string;\n    metadata?: any;\n  }): Promise<any> {\n    return this.executeTool('neural_patterns', params);\n  }\n\n  async trainNeural(params: {\n    pattern_type: string;\n    training_data: string;\n    epochs?: number;\n  }): Promise<any> {\n    return this.executeTool('neural_train', params);\n  }\n\n  async predict(params: { modelId: string; input: string }): Promise<any> {\n    return this.executeTool('neural_predict', params);\n  }\n\n  async getNeuralStatus(modelId?: string): Promise<any> {\n    return this.executeTool('neural_status', { modelId });\n  }\n\n  // Memory management tools\n\n  async storeMemory(params: {\n    action: 'store';\n    key: string;\n    value: string;\n    namespace?: string;\n    ttl?: number;\n  }): Promise<any> {\n    return this.executeTool('memory_usage', params);\n  }\n\n  async retrieveMemory(params: {\n    action: 'retrieve';\n    key: string;\n    namespace?: string;\n  }): Promise<any> {\n    const result = await this.executeTool('memory_usage', params);\n    return result.success ? result.data : null;\n  }\n\n  async searchMemory(params: {\n    pattern: string;\n    namespace?: string;\n    limit?: number;\n  }): Promise<any> {\n    return this.executeTool('memory_search', params);\n  }\n\n  async deleteMemory(params: { action: 'delete'; key: string; namespace?: string }): Promise<any> {\n    return this.executeTool('memory_usage', params);\n  }\n\n  async listMemory(params: { action: 'list'; namespace?: string }): Promise<any> {\n    return this.executeTool('memory_usage', params);\n  }\n\n  // Performance and monitoring tools\n\n  async getPerformanceReport(params?: { format?: string; timeframe?: string }): Promise<any> {\n    return this.executeTool('performance_report', params || {});\n  }\n\n  async analyzeBottlenecks(params?: { component?: string; metrics?: string[] }): Promise<any> {\n    return this.executeTool('bottleneck_analyze', params || {});\n  }\n\n  async getTokenUsage(params?: { operation?: string; timeframe?: string }): Promise<any> {\n    return this.executeTool('token_usage', params || {});\n  }\n\n  // Agent management tools\n\n  async listAgents(swarmId?: string): Promise<any> {\n    return this.executeTool('agent_list', { swarmId });\n  }\n\n  async getAgentMetrics(agentId: string): Promise<any> {\n    return this.executeTool('agent_metrics', { agentId });\n  }\n\n  // Task management tools\n\n  async getTaskStatus(taskId: string): Promise<any> {\n    return this.executeTool('task_status', { taskId });\n  }\n\n  async getTaskResults(taskId: string): Promise<any> {\n    return this.executeTool('task_results', { taskId });\n  }\n\n  // Advanced coordination tools\n\n  async optimizeTopology(swarmId?: string): Promise<any> {\n    return this.executeTool('topology_optimize', { swarmId });\n  }\n\n  async loadBalance(params: { swarmId?: string; tasks: any[] }): Promise<any> {\n    return this.executeTool('load_balance', params);\n  }\n\n  async syncCoordination(swarmId?: string): Promise<any> {\n    return this.executeTool('coordination_sync', { swarmId });\n  }\n\n  async scaleSwarm(params: { swarmId?: string; targetSize: number }): Promise<any> {\n    return this.executeTool('swarm_scale', params);\n  }\n\n  // SPARC mode integration\n\n  async runSparcMode(params: {\n    mode: string;\n    task_description: string;\n    options?: any;\n  }): Promise<any> {\n    return this.executeTool('sparc_mode', params);\n  }\n\n  // Workflow tools\n\n  async createWorkflow(params: { name: string; steps: any[]; triggers?: any[] }): Promise<any> {\n    return this.executeTool('workflow_create', params);\n  }\n\n  async executeWorkflow(params: { workflowId: string; params?: any }): Promise<any> {\n    return this.executeTool('workflow_execute', params);\n  }\n\n  // GitHub integration tools\n\n  async analyzeRepository(params: { repo: string; analysis_type?: string }): Promise<any> {\n    return this.executeTool('github_repo_analyze', params);\n  }\n\n  async manageGitHubPR(params: { repo: string; action: string; pr_number?: number }): Promise<any> {\n    return this.executeTool('github_pr_manage', params);\n  }\n\n  // Dynamic Agent Architecture tools\n\n  async createDynamicAgent(params: {\n    agent_type: string;\n    capabilities?: string[];\n    resources?: any;\n  }): Promise<any> {\n    return this.executeTool('daa_agent_create', params);\n  }\n\n  async matchCapabilities(params: {\n    task_requirements: string[];\n    available_agents?: any[];\n  }): Promise<any> {\n    return this.executeTool('daa_capability_match', params);\n  }\n\n  // System tools\n\n  async runBenchmark(suite?: string): Promise<any> {\n    return this.executeTool('benchmark_run', { suite });\n  }\n\n  async collectMetrics(components?: string[]): Promise<any> {\n    return this.executeTool('metrics_collect', { components });\n  }\n\n  async analyzeTrends(params: { metric: string; period?: string }): Promise<any> {\n    return this.executeTool('trend_analysis', params);\n  }\n\n  async analyzeCost(timeframe?: string): Promise<any> {\n    return this.executeTool('cost_analysis', { timeframe });\n  }\n\n  async assessQuality(params: { target: string; criteria?: string[] }): Promise<any> {\n    return this.executeTool('quality_assess', params);\n  }\n\n  async healthCheck(components?: string[]): Promise<any> {\n    return this.executeTool('health_check', { components });\n  }\n\n  // Batch operations\n\n  async batchProcess(params: { items: any[]; operation: string }): Promise<any> {\n    return this.executeTool('batch_process', params);\n  }\n\n  async parallelExecute(tasks: any[]): Promise<any> {\n    return this.executeTool('parallel_execute', { tasks });\n  }\n\n  /**\n   * Generic tool execution for custom tools\n   */\n  async executeMCPTool(toolName: string, params: any): Promise<any> {\n    return this.executeTool(toolName, params);\n  }\n\n  /**\n   * Helper to format tool responses\n   */\n  private formatResponse(response: MCPToolResponse): any {\n    if (response.success) {\n      return response.data;\n    } else {\n      throw new Error(`MCP Tool Error: ${response.error}`);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
