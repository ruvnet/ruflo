{"version":3,"sources":["../../../src/api/auth-service.ts"],"sourcesContent":["/**\r\n * Authentication and authorization service for swarm coordination system\r\n * Provides secure access control with JWT tokens, API keys, and role-based permissions\r\n */\r\n\r\nimport { ILogger } from '../core/logger.js';\r\nimport { AuthenticationError } from '../utils/errors.js';\r\nimport { nanoid } from 'nanoid';\r\nimport { createHash, createHmac, timingSafeEqual } from 'crypto';\r\n\r\nexport interface AuthConfig {\r\n  jwtSecret: string;\r\n  jwtExpiresIn?: string; // Default: '24h'\r\n  apiKeyLength?: number; // Default: 32\r\n  bcryptRounds?: number; // Default: 12\r\n  sessionTimeout?: number; // Default: 3600000 (1 hour)\r\n  maxLoginAttempts?: number; // Default: 5\r\n  lockoutDuration?: number; // Default: 900000 (15 minutes)\r\n  requireMFA?: boolean; // Default: false\r\n}\r\n\r\nexport interface User {\r\n  id: string;\r\n  email: string;\r\n  passwordHash: string;\r\n  role: UserRole;\r\n  permissions: Permission[];\r\n  apiKeys: ApiKey[];\r\n  isActive: boolean;\r\n  lastLogin?: Date;\r\n  loginAttempts: number;\r\n  lockedUntil?: Date;\r\n  mfaSecret?: string;\r\n  mfaEnabled: boolean;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface ApiKey {\r\n  id: string;\r\n  key: string;\r\n  keyHash: string;\r\n  name: string;\r\n  permissions: Permission[];\r\n  expiresAt?: Date;\r\n  lastUsed?: Date;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n}\r\n\r\nexport interface AuthToken {\r\n  token: string;\r\n  type: 'jwt' | 'api_key';\r\n  userId?: string;\r\n  apiKeyId?: string;\r\n  permissions: Permission[];\r\n  expiresAt: Date;\r\n  createdAt: Date;\r\n}\r\n\r\nexport interface AuthSession {\r\n  id: string;\r\n  userId: string;\r\n  token: string;\r\n  clientInfo?: {\r\n    userAgent?: string;\r\n    ip?: string;\r\n    device?: string;\r\n  };\r\n  isActive: boolean;\r\n  expiresAt: Date;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport type UserRole = \r\n  | 'admin'       // Full system access\r\n  | 'operator'    // Can manage swarms and agents\r\n  | 'developer'   // Can create and monitor tasks\r\n  | 'viewer'      // Read-only access\r\n  | 'service';    // Service-to-service authentication\r\n\r\nexport type Permission = \r\n  | 'swarm.create'\r\n  | 'swarm.read'\r\n  | 'swarm.update'\r\n  | 'swarm.delete'\r\n  | 'swarm.scale'\r\n  | 'agent.spawn'\r\n  | 'agent.read'\r\n  | 'agent.terminate'\r\n  | 'task.create'\r\n  | 'task.read'\r\n  | 'task.cancel'\r\n  | 'metrics.read'\r\n  | 'system.admin'\r\n  | 'api.access';\r\n\r\nconst ROLE_PERMISSIONS: Record<UserRole, Permission[]> = {\r\n  admin: [\r\n    'swarm.create', 'swarm.read', 'swarm.update', 'swarm.delete', 'swarm.scale',\r\n    'agent.spawn', 'agent.read', 'agent.terminate',\r\n    'task.create', 'task.read', 'task.cancel',\r\n    'metrics.read', 'system.admin', 'api.access'\r\n  ],\r\n  operator: [\r\n    'swarm.create', 'swarm.read', 'swarm.update', 'swarm.scale',\r\n    'agent.spawn', 'agent.read', 'agent.terminate',\r\n    'task.create', 'task.read', 'task.cancel',\r\n    'metrics.read', 'api.access'\r\n  ],\r\n  developer: [\r\n    'swarm.read', 'agent.read',\r\n    'task.create', 'task.read', 'task.cancel',\r\n    'metrics.read', 'api.access'\r\n  ],\r\n  viewer: [\r\n    'swarm.read', 'agent.read', 'task.read', 'metrics.read', 'api.access'\r\n  ],\r\n  service: [\r\n    'api.access'\r\n  ]\r\n};\r\n\r\n/**\r\n * Authentication service implementation\r\n */\r\nexport class AuthService {\r\n  private users = new Map<string, User>();\r\n  private sessions = new Map<string, AuthSession>();\r\n  private apiKeys = new Map<string, ApiKey>();\r\n  private loginAttempts = new Map<string, { count: number; lastAttempt: Date }>();\r\n\r\n  constructor(\r\n    private config: AuthConfig,\r\n    private logger: ILogger,\r\n  ) {\r\n    this.initializeDefaultUsers();\r\n  }\r\n\r\n  /**\r\n   * Authenticate user with email and password\r\n   */\r\n  async authenticateUser(email: string, password: string, clientInfo?: {\r\n    userAgent?: string;\r\n    ip?: string;\r\n    device?: string;\r\n  }): Promise<{ user: User; token: string; session: AuthSession }> {\r\n    try {\r\n      // Check for rate limiting\r\n      await this.checkRateLimit(email);\r\n\r\n      // Find user\r\n      const user = Array.from(this.users.values()).find(u => u.email === email);\r\n      if (!user) {\r\n        await this.recordFailedLogin(email);\r\n        throw new AuthenticationError('Invalid credentials');\r\n      }\r\n\r\n      // Check if account is locked\r\n      if (user.lockedUntil && user.lockedUntil > new Date()) {\r\n        throw new AuthenticationError('Account locked due to too many failed attempts');\r\n      }\r\n\r\n      // Check if account is active\r\n      if (!user.isActive) {\r\n        throw new AuthenticationError('Account is disabled');\r\n      }\r\n\r\n      // Verify password\r\n      const isValid = await this.verifyPassword(password, user.passwordHash);\r\n      if (!isValid) {\r\n        await this.recordFailedLogin(email);\r\n        throw new AuthenticationError('Invalid credentials');\r\n      }\r\n\r\n      // Reset login attempts on successful authentication\r\n      this.loginAttempts.delete(email);\r\n      user.loginAttempts = 0;\r\n      user.lockedUntil = undefined;\r\n      user.lastLogin = new Date();\r\n\r\n      // Create session\r\n      const session = await this.createSession(user.id, clientInfo);\r\n\r\n      // Generate JWT token\r\n      const token = await this.generateJWT(user, session.id);\r\n\r\n      this.logger.info('User authenticated successfully', {\r\n        userId: user.id,\r\n        email: user.email,\r\n        sessionId: session.id,\r\n      });\r\n\r\n      return { user, token, session };\r\n    } catch (error) {\r\n      this.logger.error('Authentication failed', {\r\n        email,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Authenticate API key\r\n   */\r\n  async authenticateApiKey(apiKey: string): Promise<{ key: ApiKey; user?: User }> {\r\n    try {\r\n      // Hash the provided key to compare with stored hash\r\n      const keyHash = this.hashApiKey(apiKey);\r\n      \r\n      // Find matching API key\r\n      const storedKey = Array.from(this.apiKeys.values()).find(k => \r\n        this.constantTimeCompare(k.keyHash, keyHash)\r\n      );\r\n\r\n      if (!storedKey) {\r\n        throw new AuthenticationError('Invalid API key');\r\n      }\r\n\r\n      // Check if key is active\r\n      if (!storedKey.isActive) {\r\n        throw new AuthenticationError('API key is disabled');\r\n      }\r\n\r\n      // Check if key is expired\r\n      if (storedKey.expiresAt && storedKey.expiresAt < new Date()) {\r\n        throw new AuthenticationError('API key has expired');\r\n      }\r\n\r\n      // Update last used timestamp\r\n      storedKey.lastUsed = new Date();\r\n\r\n      // Find associated user (if any)\r\n      const user = Array.from(this.users.values()).find(u => \r\n        u.apiKeys.some(k => k.id === storedKey.id)\r\n      );\r\n\r\n      this.logger.info('API key authenticated successfully', {\r\n        keyId: storedKey.id,\r\n        keyName: storedKey.name,\r\n        userId: user?.id,\r\n      });\r\n\r\n      return { key: storedKey, user };\r\n    } catch (error) {\r\n      this.logger.error('API key authentication failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify JWT token\r\n   */\r\n  async verifyJWT(token: string): Promise<{ user: User; session: AuthSession }> {\r\n    try {\r\n      const payload = this.decodeJWT(token);\r\n      \r\n      if (!payload.userId || !payload.sessionId) {\r\n        throw new AuthenticationError('Invalid token payload');\r\n      }\r\n\r\n      // Check if session exists and is active\r\n      const session = this.sessions.get(payload.sessionId);\r\n      if (!session || !session.isActive) {\r\n        throw new AuthenticationError('Invalid or expired session');\r\n      }\r\n\r\n      // Check if session is expired\r\n      if (session.expiresAt < new Date()) {\r\n        session.isActive = false;\r\n        throw new AuthenticationError('Session expired');\r\n      }\r\n\r\n      // Get user\r\n      const user = this.users.get(payload.userId);\r\n      if (!user || !user.isActive) {\r\n        throw new AuthenticationError('User not found or inactive');\r\n      }\r\n\r\n      // Update session activity\r\n      session.updatedAt = new Date();\r\n\r\n      return { user, session };\r\n    } catch (error) {\r\n      this.logger.error('JWT verification failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if user has required permission\r\n   */\r\n  hasPermission(userOrPermissions: User | Permission[], requiredPermission: Permission): boolean {\r\n    const permissions = Array.isArray(userOrPermissions) \r\n      ? userOrPermissions \r\n      : userOrPermissions.permissions;\r\n    \r\n    return permissions.includes(requiredPermission) || permissions.includes('system.admin');\r\n  }\r\n\r\n  /**\r\n   * Create new user\r\n   */\r\n  async createUser(userData: {\r\n    email: string;\r\n    password: string;\r\n    role: UserRole;\r\n    isActive?: boolean;\r\n  }): Promise<User> {\r\n    // Check if email already exists\r\n    const existingUser = Array.from(this.users.values()).find(u => u.email === userData.email);\r\n    if (existingUser) {\r\n      throw new AuthenticationError('Email already exists');\r\n    }\r\n\r\n    const userId = `user_${Date.now()}_${nanoid(8)}`;\r\n    const passwordHash = await this.hashPassword(userData.password);\r\n    const permissions = ROLE_PERMISSIONS[userData.role] || [];\r\n\r\n    const user: User = {\r\n      id: userId,\r\n      email: userData.email,\r\n      passwordHash,\r\n      role: userData.role,\r\n      permissions,\r\n      apiKeys: [],\r\n      isActive: userData.isActive ?? true,\r\n      loginAttempts: 0,\r\n      mfaEnabled: false,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    this.users.set(userId, user);\r\n\r\n    this.logger.info('User created', {\r\n      userId,\r\n      email: userData.email,\r\n      role: userData.role,\r\n    });\r\n\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Create API key for user\r\n   */\r\n  async createApiKey(userId: string, keyData: {\r\n    name: string;\r\n    permissions?: Permission[];\r\n    expiresAt?: Date;\r\n  }): Promise<{ apiKey: ApiKey; key: string }> {\r\n    const user = this.users.get(userId);\r\n    if (!user) {\r\n      throw new AuthenticationError('User not found');\r\n    }\r\n\r\n    const key = this.generateApiKey();\r\n    const keyHash = this.hashApiKey(key);\r\n    const keyId = `key_${Date.now()}_${nanoid(8)}`;\r\n\r\n    const permissions = keyData.permissions || user.permissions;\r\n\r\n    const apiKey: ApiKey = {\r\n      id: keyId,\r\n      key: key.substring(0, 8) + '...',  // Store only prefix for display\r\n      keyHash,\r\n      name: keyData.name,\r\n      permissions,\r\n      expiresAt: keyData.expiresAt,\r\n      isActive: true,\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    // Add to user's API keys\r\n    user.apiKeys.push(apiKey);\r\n    \r\n    // Store in global API keys map\r\n    this.apiKeys.set(keyId, apiKey);\r\n\r\n    this.logger.info('API key created', {\r\n      userId,\r\n      keyId,\r\n      keyName: keyData.name,\r\n    });\r\n\r\n    return { apiKey, key };\r\n  }\r\n\r\n  /**\r\n   * Revoke API key\r\n   */\r\n  async revokeApiKey(keyId: string): Promise<void> {\r\n    const apiKey = this.apiKeys.get(keyId);\r\n    if (!apiKey) {\r\n      throw new AuthenticationError('API key not found');\r\n    }\r\n\r\n    apiKey.isActive = false;\r\n    \r\n    // Remove from user's keys\r\n    const user = Array.from(this.users.values()).find(u => \r\n      u.apiKeys.some(k => k.id === keyId)\r\n    );\r\n    if (user) {\r\n      user.apiKeys = user.apiKeys.filter(k => k.id !== keyId);\r\n    }\r\n\r\n    this.logger.info('API key revoked', {\r\n      keyId,\r\n      keyName: apiKey.name,\r\n      userId: user?.id,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Invalidate session\r\n   */\r\n  async invalidateSession(sessionId: string): Promise<void> {\r\n    const session = this.sessions.get(sessionId);\r\n    if (session) {\r\n      session.isActive = false;\r\n      this.logger.info('Session invalidated', {\r\n        sessionId,\r\n        userId: session.userId,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  async cleanupSessions(): Promise<void> {\r\n    const now = new Date();\r\n    let cleaned = 0;\r\n\r\n    for (const [sessionId, session] of this.sessions) {\r\n      if (!session.isActive || session.expiresAt < now) {\r\n        this.sessions.delete(sessionId);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      this.logger.info('Cleaned up expired sessions', { count: cleaned });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user by ID\r\n   */\r\n  getUser(userId: string): User | undefined {\r\n    return this.users.get(userId);\r\n  }\r\n\r\n  /**\r\n   * List all users (admin only)\r\n   */\r\n  listUsers(): User[] {\r\n    return Array.from(this.users.values());\r\n  }\r\n\r\n  // Private helper methods\r\n  private async checkRateLimit(email: string): Promise<void> {\r\n    const attempts = this.loginAttempts.get(email);\r\n    const maxAttempts = this.config.maxLoginAttempts || 5;\r\n    const lockoutDuration = this.config.lockoutDuration || 900000; // 15 minutes\r\n\r\n    if (attempts && attempts.count >= maxAttempts) {\r\n      const timeSinceLastAttempt = Date.now() - attempts.lastAttempt.getTime();\r\n      if (timeSinceLastAttempt < lockoutDuration) {\r\n        throw new AuthenticationError('Too many failed login attempts. Please try again later.');\r\n      } else {\r\n        // Reset attempts after lockout period\r\n        this.loginAttempts.delete(email);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async recordFailedLogin(email: string): Promise<void> {\r\n    const attempts = this.loginAttempts.get(email) || { count: 0, lastAttempt: new Date() };\r\n    attempts.count++;\r\n    attempts.lastAttempt = new Date();\r\n    this.loginAttempts.set(email, attempts);\r\n  }\r\n\r\n  private async createSession(userId: string, clientInfo?: {\r\n    userAgent?: string;\r\n    ip?: string;\r\n    device?: string;\r\n  }): Promise<AuthSession> {\r\n    const sessionId = `session_${Date.now()}_${nanoid(16)}`;\r\n    const sessionTimeout = this.config.sessionTimeout || 3600000; // 1 hour\r\n    const expiresAt = new Date(Date.now() + sessionTimeout);\r\n\r\n    const session: AuthSession = {\r\n      id: sessionId,\r\n      userId,\r\n      token: nanoid(32),\r\n      clientInfo,\r\n      isActive: true,\r\n      expiresAt,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    this.sessions.set(sessionId, session);\r\n    return session;\r\n  }\r\n\r\n  private async generateJWT(user: User, sessionId: string): Promise<string> {\r\n    const payload = {\r\n      userId: user.id,\r\n      email: user.email,\r\n      role: user.role,\r\n      permissions: user.permissions,\r\n      sessionId,\r\n      iat: Math.floor(Date.now() / 1000),\r\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours\r\n    };\r\n\r\n    const header = {\r\n      alg: 'HS256',\r\n      typ: 'JWT',\r\n    };\r\n\r\n    const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');\r\n    const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64url');\r\n    \r\n    const signature = createHmac('sha256', this.config.jwtSecret)\r\n      .update(`${encodedHeader}.${encodedPayload}`)\r\n      .digest('base64url');\r\n\r\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\r\n  }\r\n\r\n  private decodeJWT(token: string): any {\r\n    const parts = token.split('.');\r\n    if (parts.length !== 3) {\r\n      throw new AuthenticationError('Invalid token format');\r\n    }\r\n\r\n    const [encodedHeader, encodedPayload, signature] = parts;\r\n    \r\n    // Verify signature\r\n    const expectedSignature = createHmac('sha256', this.config.jwtSecret)\r\n      .update(`${encodedHeader}.${encodedPayload}`)\r\n      .digest('base64url');\r\n    \r\n    if (!this.constantTimeCompare(signature, expectedSignature)) {\r\n      throw new AuthenticationError('Invalid token signature');\r\n    }\r\n\r\n    // Decode payload\r\n    const payload = JSON.parse(Buffer.from(encodedPayload, 'base64url').toString());\r\n    \r\n    // Check expiration\r\n    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\r\n      throw new AuthenticationError('Token expired');\r\n    }\r\n\r\n    return payload;\r\n  }\r\n\r\n  private generateApiKey(): string {\r\n    const length = this.config.apiKeyLength || 32;\r\n    return nanoid(length);\r\n  }\r\n\r\n  private hashApiKey(key: string): string {\r\n    return createHash('sha256').update(key).digest('hex');\r\n  }\r\n\r\n  private async hashPassword(password: string): Promise<string> {\r\n    // In a real implementation, use bcrypt\r\n    return createHash('sha256').update(password + 'salt').digest('hex');\r\n  }\r\n\r\n  private async verifyPassword(password: string, hash: string): Promise<boolean> {\r\n    // In a real implementation, use bcrypt.compare\r\n    const passwordHash = createHash('sha256').update(password + 'salt').digest('hex');\r\n    return this.constantTimeCompare(passwordHash, hash);\r\n  }\r\n\r\n  private constantTimeCompare(a: string, b: string): boolean {\r\n    if (a.length !== b.length) {\r\n      return false;\r\n    }\r\n    \r\n    const bufferA = Buffer.from(a, 'hex');\r\n    const bufferB = Buffer.from(b, 'hex');\r\n    \r\n    return timingSafeEqual(bufferA, bufferB);\r\n  }\r\n\r\n  private initializeDefaultUsers(): void {\r\n    // Create default admin user\r\n    const adminId = 'admin_default';\r\n    const adminUser: User = {\r\n      id: adminId,\r\n      email: 'admin@claude-flow.local',\r\n      passwordHash: createHash('sha256').update('admin123' + 'salt').digest('hex'),\r\n      role: 'admin',\r\n      permissions: ROLE_PERMISSIONS.admin,\r\n      apiKeys: [],\r\n      isActive: true,\r\n      loginAttempts: 0,\r\n      mfaEnabled: false,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    this.users.set(adminId, adminUser);\r\n\r\n    // Create default service user\r\n    const serviceId = 'service_default';\r\n    const serviceUser: User = {\r\n      id: serviceId,\r\n      email: 'service@claude-flow.local',\r\n      passwordHash: createHash('sha256').update('service123' + 'salt').digest('hex'),\r\n      role: 'service',\r\n      permissions: ROLE_PERMISSIONS.service,\r\n      apiKeys: [],\r\n      isActive: true,\r\n      loginAttempts: 0,\r\n      mfaEnabled: false,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    this.users.set(serviceId, serviceUser);\r\n\r\n    this.logger.info('Default users initialized', {\r\n      admin: adminUser.email,\r\n      service: serviceUser.email,\r\n    });\r\n  }\r\n}"],"names":["AuthenticationError","nanoid","createHash","createHmac","timingSafeEqual","ROLE_PERMISSIONS","admin","operator","developer","viewer","service","AuthService","users","Map","sessions","apiKeys","loginAttempts","config","logger","initializeDefaultUsers","authenticateUser","email","password","clientInfo","checkRateLimit","user","Array","from","values","find","u","recordFailedLogin","lockedUntil","Date","isActive","isValid","verifyPassword","passwordHash","delete","undefined","lastLogin","session","createSession","id","token","generateJWT","info","userId","sessionId","error","Error","message","authenticateApiKey","apiKey","keyHash","hashApiKey","storedKey","k","constantTimeCompare","expiresAt","lastUsed","some","keyId","keyName","name","key","verifyJWT","payload","decodeJWT","get","updatedAt","hasPermission","userOrPermissions","requiredPermission","permissions","isArray","includes","createUser","userData","existingUser","now","hashPassword","role","mfaEnabled","createdAt","set","createApiKey","keyData","generateApiKey","substring","push","revokeApiKey","filter","invalidateSession","cleanupSessions","cleaned","count","getUser","listUsers","attempts","maxAttempts","maxLoginAttempts","lockoutDuration","timeSinceLastAttempt","lastAttempt","getTime","sessionTimeout","iat","Math","floor","exp","header","alg","typ","encodedHeader","Buffer","JSON","stringify","toString","encodedPayload","signature","jwtSecret","update","digest","parts","split","length","expectedSignature","parse","apiKeyLength","hash","a","b","bufferA","bufferB","adminId","adminUser","serviceId","serviceUser"],"mappings":"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"}