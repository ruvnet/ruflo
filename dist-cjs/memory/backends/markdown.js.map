{
  "version": 3,
  "sources": ["../../../src/memory/backends/markdown.ts"],
  "sourcesContent": ["/**\n * Markdown backend implementation for human-readable memory storage\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport type { IMemoryBackend } from './base.js';\nimport type { MemoryEntry, MemoryQuery } from '../../utils/types.js';\nimport type { ILogger } from '../../core/logger.js';\nimport { MemoryBackendError } from '../../utils/errors.js';\n\n/**\n * Markdown-based memory backend\n */\nexport class MarkdownBackend implements IMemoryBackend {\n  private entries = new Map<string, MemoryEntry>();\n  private indexPath: string;\n\n  constructor(\n    private baseDir: string,\n    private logger: ILogger,\n  ) {\n    this.indexPath = path.join(this.baseDir, 'index.json');\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Markdown backend', { baseDir: this.baseDir });\n\n    try {\n      // Ensure directories exist\n      await fs.mkdir(this.baseDir, { recursive: true });\n      await fs.mkdir(path.join(this.baseDir, 'agents'), { recursive: true });\n      await fs.mkdir(path.join(this.baseDir, 'sessions'), { recursive: true });\n\n      // Load index\n      await this.loadIndex();\n\n      this.logger.info('Markdown backend initialized');\n    } catch (error) {\n      throw new MemoryBackendError('Failed to initialize Markdown backend', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Markdown backend');\n\n    // Save index before shutdown\n    await this.saveIndex();\n    this.entries.clear();\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    try {\n      // Store in memory\n      this.entries.set(entry.id, entry);\n\n      // Write to markdown file\n      await this.writeEntryToFile(entry);\n\n      // Update index\n      await this.saveIndex();\n    } catch (error) {\n      throw new MemoryBackendError('Failed to store entry', { error });\n    }\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    return this.entries.get(id);\n  }\n\n  async update(id: string, entry: MemoryEntry): Promise<void> {\n    if (!this.entries.has(id)) {\n      throw new MemoryBackendError(`Entry not found: ${id}`);\n    }\n\n    await this.store(entry);\n  }\n\n  async delete(id: string): Promise<void> {\n    const entry = this.entries.get(id);\n    if (!entry) {\n      return;\n    }\n\n    try {\n      // Delete from memory\n      this.entries.delete(id);\n\n      // Delete file\n      const filePath = this.getEntryFilePath(entry);\n      await fs.unlink(filePath);\n\n      // Update index\n      await this.saveIndex();\n    } catch (error) {\n      throw new MemoryBackendError('Failed to delete entry', { error });\n    }\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    let results = Array.from(this.entries.values());\n\n    // Apply filters\n    if (query.agentId) {\n      results = results.filter((e) => e.agentId === query.agentId);\n    }\n\n    if (query.sessionId) {\n      results = results.filter((e) => e.sessionId === query.sessionId);\n    }\n\n    if (query.type) {\n      results = results.filter((e) => e.type === query.type);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter((e) => query.tags!.some((tag) => e.tags.includes(tag)));\n    }\n\n    if (query.startTime) {\n      results = results.filter((e) => e.timestamp.getTime() >= query.startTime!.getTime());\n    }\n\n    if (query.endTime) {\n      results = results.filter((e) => e.timestamp.getTime() <= query.endTime!.getTime());\n    }\n\n    if (query.search) {\n      const searchLower = query.search.toLowerCase();\n      results = results.filter(\n        (e) =>\n          e.content.toLowerCase().includes(searchLower) ||\n          e.tags.some((tag) => tag.toLowerCase().includes(searchLower)),\n      );\n    }\n\n    // Sort by timestamp (newest first)\n    results.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    // Apply pagination\n    const start = query.offset || 0;\n    const limit = query.limit || results.length;\n    results = results.slice(start, start + limit);\n\n    return results;\n  }\n\n  async getAllEntries(): Promise<MemoryEntry[]> {\n    return Array.from(this.entries.values());\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      // Check if directory is accessible\n      await fs.stat(this.baseDir);\n\n      const entryCount = this.entries.size;\n      let totalSizeBytes = 0;\n\n      // Calculate total size\n      for (const entry of this.entries.values()) {\n        const filePath = this.getEntryFilePath(entry);\n        try {\n          const stat = await fs.stat(filePath);\n          totalSizeBytes += stat.size;\n        } catch {\n          // File might not exist yet\n        }\n      }\n\n      return {\n        healthy: true,\n        metrics: {\n          entryCount,\n          totalSizeBytes,\n        },\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private async loadIndex(): Promise<void> {\n    try {\n      const content = await fs.readFile(this.indexPath, 'utf-8');\n      const index = JSON.parse(content) as Record<string, MemoryEntry>;\n\n      // Convert and validate entries\n      for (const [id, entry] of Object.entries(index)) {\n        // Reconstruct dates\n        entry.timestamp = new Date(entry.timestamp);\n        this.entries.set(id, entry);\n      }\n\n      this.logger.info('Loaded memory index', { entries: this.entries.size });\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load index', { error });\n      }\n      // Start with empty index if file doesn't exist\n    }\n  }\n\n  private async saveIndex(): Promise<void> {\n    const index: Record<string, MemoryEntry> = {};\n\n    for (const [id, entry] of this.entries) {\n      index[id] = entry;\n    }\n\n    const content = JSON.stringify(index, null, 2);\n    await fs.writeFile(this.indexPath, content, 'utf-8');\n  }\n\n  private async writeEntryToFile(entry: MemoryEntry): Promise<void> {\n    const filePath = this.getEntryFilePath(entry);\n    const dirPath = path.dirname(filePath);\n\n    // Ensure directory exists\n    await fs.mkdir(dirPath, { recursive: true });\n\n    // Generate markdown content\n    const content = this.entryToMarkdown(entry);\n\n    // Write file\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  private getEntryFilePath(entry: MemoryEntry): string {\n    const date = entry.timestamp.toISOString().split('T')[0];\n    const time = entry.timestamp.toISOString().split('T')[1].replace(/:/g, '-').split('.')[0];\n\n    return path.join(this.baseDir, 'agents', entry.agentId, date, `${time}_${entry.id}.md`);\n  }\n\n  private entryToMarkdown(entry: MemoryEntry): string {\n    const lines: string[] = [\n      `# Memory Entry: ${entry.id}`,\n      '',\n      `**Agent**: ${entry.agentId}`,\n      `**Session**: ${entry.sessionId}`,\n      `**Type**: ${entry.type}`,\n      `**Timestamp**: ${entry.timestamp.toISOString()}`,\n      `**Version**: ${entry.version}`,\n      '',\n    ];\n\n    if (entry.parentId) {\n      lines.push(`**Parent**: ${entry.parentId}`, '');\n    }\n\n    if (entry.tags.length > 0) {\n      lines.push(`**Tags**: ${entry.tags.join(', ')}`, '');\n    }\n\n    lines.push('## Content', '', entry.content, '');\n\n    if (Object.keys(entry.context).length > 0) {\n      lines.push('## Context', '', '```json');\n      lines.push(JSON.stringify(entry.context, null, 2));\n      lines.push('```', '');\n    }\n\n    if (entry.metadata && Object.keys(entry.metadata).length > 0) {\n      lines.push('## Metadata', '', '```json');\n      lines.push(JSON.stringify(entry.metadata, null, 2));\n      lines.push('```', '');\n    }\n\n    return lines.join('\\n');\n  }\n}\n"],
  "mappings": "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",
  "names": ["path", "fs"]
}
