{
  "version": 3,
  "sources": ["../../src/swarm/prompt-copier-enhanced.ts"],
  "sourcesContent": ["import { dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { Worker } from 'worker_threads';\nimport { PromptCopier } from './prompt-copier.js';\nimport type { CopyOptions, CopyResult, FileInfo } from './prompt-copier.js';\nimport { logger } from '../core/logger.js';\n\ninterface WorkerPool {\n  workers: Worker[];\n  busy: Set<number>;\n  queue: Array<() => void>;\n}\n\nexport class EnhancedPromptCopier extends PromptCopier {\n  private workerPool?: WorkerPool;\n  private workerResults: Map<string, any> = new Map();\n\n  constructor(options: CopyOptions) {\n    super(options);\n  }\n\n  public async copyFilesParallel(): Promise<void> {\n    const workerCount = Math.min((this as any).options.maxWorkers, (this as any).fileQueue.length);\n\n    // Initialize worker pool\n    this.workerPool = await this.initializeWorkerPool(workerCount);\n\n    try {\n      // Process files using worker pool\n      await this.processWithWorkerPool();\n    } finally {\n      // Cleanup workers\n      await this.terminateWorkers();\n    }\n  }\n\n  private async initializeWorkerPool(workerCount: number): Promise<WorkerPool> {\n    const workers: Worker[] = [];\n    const pool: WorkerPool = {\n      workers,\n      busy: new Set(),\n      queue: [],\n    };\n\n    // Create workers\n    for (let i = 0; i < workerCount; i++) {\n      const worker = new Worker(path.join(__dirname, 'workers', 'copy-worker.js'), {\n        workerData: { workerId: i },\n      });\n\n      // Setup worker message handler\n      worker.on('message', (result) => {\n        this.handleWorkerResult(result, i, pool);\n      });\n\n      worker.on('error', (error) => {\n        logger.error(`Worker ${i} error:`, error);\n        (this as any).errors.push({\n          file: 'worker',\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'write',\n        });\n      });\n\n      workers.push(worker);\n    }\n\n    return pool;\n  }\n\n  private async processWithWorkerPool(): Promise<void> {\n    const chunkSize = Math.max(\n      1,\n      Math.floor((this as any).fileQueue.length / this.workerPool!.workers.length / 2),\n    );\n    const chunks: FileInfo[][] = [];\n\n    // Create chunks for better distribution\n    for (let i = 0; i < (this as any).fileQueue.length; i += chunkSize) {\n      chunks.push((this as any).fileQueue.slice(i, i + chunkSize));\n    }\n\n    // Process chunks\n    const promises: Promise<void>[] = [];\n\n    for (const chunk of chunks) {\n      promises.push(this.processChunkWithWorker(chunk));\n    }\n\n    await Promise.all(promises);\n  }\n\n  private async processChunkWithWorker(chunk: FileInfo[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const pool = this.workerPool!;\n\n      const tryAssignWork = () => {\n        // Find available worker\n        const availableWorkerIndex = pool.workers.findIndex((_, index) => !pool.busy.has(index));\n\n        if (availableWorkerIndex === -1) {\n          // No workers available, queue the work\n          pool.queue.push(tryAssignWork);\n          return;\n        }\n\n        // Mark worker as busy\n        pool.busy.add(availableWorkerIndex);\n\n        // Prepare worker data\n        const workerData = {\n          files: chunk.map((file) => ({\n            sourcePath: file.path,\n            destPath: path.join((this as any).options.destination, file.relativePath),\n            permissions: (this as any).options.preservePermissions ? file.permissions : undefined,\n            verify: (this as any).options.verify,\n          })),\n          workerId: availableWorkerIndex,\n        };\n\n        let remainingFiles = chunk.length;\n        const chunkResults: any[] = [];\n\n        // Setup temporary message handler for this chunk\n        const messageHandler = (result: any) => {\n          chunkResults.push(result);\n          remainingFiles--;\n\n          if (remainingFiles === 0) {\n            // Chunk complete\n            pool.workers[availableWorkerIndex].off('message', messageHandler);\n            pool.busy.delete(availableWorkerIndex);\n\n            // Process next queued work\n            if (pool.queue.length > 0) {\n              const nextWork = pool.queue.shift()!;\n              nextWork();\n            }\n\n            // Process results\n            this.processChunkResults(chunk, chunkResults);\n            resolve();\n          }\n        };\n\n        pool.workers[availableWorkerIndex].on('message', messageHandler);\n        pool.workers[availableWorkerIndex].postMessage(workerData);\n      };\n\n      tryAssignWork();\n    });\n  }\n\n  private processChunkResults(chunk: FileInfo[], results: any[]): void {\n    for (const result of results) {\n      if (result.success) {\n        (this as any).copiedFiles.add(result.file);\n        if (result.hash) {\n          this.workerResults.set(result.file, { hash: result.hash });\n        }\n      } else {\n        (this as any).errors.push({\n          file: result.file,\n          error: result.error,\n          phase: 'write',\n        });\n      }\n    }\n\n    // Report progress through the callback if available\n    if ((this as any).options.progressCallback) {\n      (this as any).options.progressCallback(\n        (this as any).copiedFiles.size,\n        (this as any).totalFiles,\n      );\n    }\n  }\n\n  private handleWorkerResult(result: any, workerId: number, pool: WorkerPool): void {\n    // This is a fallback handler, actual handling happens in processChunkWithWorker\n    logger.debug(`Worker ${workerId} result:`, result);\n  }\n\n  private async terminateWorkers(): Promise<void> {\n    if (!this.workerPool) return;\n\n    const terminationPromises = this.workerPool.workers.map((worker) => worker.terminate());\n\n    await Promise.all(terminationPromises);\n    this.workerPool = undefined;\n  }\n\n  // Override verification to use worker results\n  protected override async verifyFiles(): Promise<void> {\n    logger.info('Verifying copied files...');\n\n    for (const file of (this as any).fileQueue) {\n      if (!(this as any).copiedFiles.has(file.path)) continue;\n\n      try {\n        const destPath = path.join((this as any).options.destination, file.relativePath);\n\n        // Verify file exists\n        if (!(await (this as any).fileExists(destPath))) {\n          throw new Error('Destination file not found');\n        }\n\n        // Verify size\n        const destStats = await fs.stat(destPath);\n        const sourceStats = await fs.stat(file.path);\n\n        if (destStats.size !== sourceStats.size) {\n          throw new Error(`Size mismatch: ${destStats.size} != ${sourceStats.size}`);\n        }\n\n        // Use hash from worker if available\n        const workerResult = this.workerResults.get(file.path);\n        if (workerResult?.hash) {\n          const sourceHash = await (this as any).calculateFileHash(file.path);\n          if (sourceHash !== workerResult.hash) {\n            throw new Error(`Hash mismatch: ${sourceHash} != ${workerResult.hash}`);\n          }\n        }\n      } catch (error) {\n        (this as any).errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'verify',\n        });\n      }\n    }\n  }\n}\n\n// Export enhanced copy function\nexport async function copyPromptsEnhanced(options: CopyOptions): Promise<CopyResult> {\n  const copier = new EnhancedPromptCopier(options);\n  return copier.copy();\n}\n"],
  "mappings": "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",
  "names": []
}
