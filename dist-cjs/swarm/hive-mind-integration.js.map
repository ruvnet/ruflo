{
  "version": 3,
  "sources": ["../../src/swarm/hive-mind-integration.ts"],
  "sourcesContent": ["/**\n * Hive-Mind System Integration Interface\n * \n * This module provides seamless integration with the existing hive-mind system,\n * enabling swarms to leverage collective intelligence, shared memory, and\n * distributed coordination capabilities while maintaining compatibility\n * with the current claude-flow architecture.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { MemoryManager } from '../memory/manager.js';\nimport type { AdvancedSwarmOrchestrator } from './advanced-orchestrator.js';\nimport {\n  SwarmExecutionContext,\n  SwarmAgent,\n  SwarmTask,\n  TaskResult,\n  SwarmObjective,\n  AgentState,\n  SwarmMetrics,\n} from './types.js';\n\nexport interface HiveMindConfig {\n  enableSharedIntelligence: boolean;\n  enableCollectiveMemory: boolean;\n  enableDistributedLearning: boolean;\n  enableKnowledgeSharing: boolean;\n  hiveMindEndpoint?: string;\n  syncInterval: number;\n  maxSharedMemorySize: number;\n  intelligencePoolSize: number;\n  learningRate: number;\n  knowledgeRetentionPeriod: number;\n}\n\nexport interface HiveMindSession {\n  id: string;\n  swarmId: string;\n  participants: string[];\n  sharedMemory: Map<string, any>;\n  collectiveIntelligence: CollectiveIntelligence;\n  knowledgeBase: KnowledgeBase;\n  distributedLearning: DistributedLearning;\n  status: 'active' | 'paused' | 'terminated';\n  startTime: Date;\n  lastSync: Date;\n}\n\nexport interface CollectiveIntelligence {\n  patterns: Map<string, Pattern>;\n  insights: Map<string, Insight>;\n  decisions: Map<string, CollectiveDecision>;\n  predictions: Map<string, Prediction>;\n}\n\nexport interface Pattern {\n  id: string;\n  type: 'behavioral' | 'performance' | 'error' | 'success';\n  description: string;\n  frequency: number;\n  confidence: number;\n  contexts: string[];\n  impact: 'low' | 'medium' | 'high';\n  discoveredBy: string[];\n  lastSeen: Date;\n}\n\nexport interface Insight {\n  id: string;\n  category: 'optimization' | 'coordination' | 'quality' | 'efficiency';\n  title: string;\n  description: string;\n  evidence: any[];\n  confidence: number;\n  applicability: string[];\n  contributingAgents: string[];\n  timestamp: Date;\n}\n\nexport interface CollectiveDecision {\n  id: string;\n  question: string;\n  options: DecisionOption[];\n  votingResults: Map<string, string>;\n  consensus: string;\n  confidence: number;\n  reasoning: string;\n  participants: string[];\n  timestamp: Date;\n}\n\nexport interface DecisionOption {\n  id: string;\n  description: string;\n  pros: string[];\n  cons: string[];\n  risk: 'low' | 'medium' | 'high';\n  effort: 'low' | 'medium' | 'high';\n  expectedOutcome: string;\n}\n\nexport interface Prediction {\n  id: string;\n  target: string;\n  predicted_value: any;\n  confidence: number;\n  timeframe: string;\n  methodology: string;\n  factors: string[];\n  accuracy?: number;\n  createdBy: string[];\n  timestamp: Date;\n}\n\nexport interface KnowledgeBase {\n  facts: Map<string, Fact>;\n  procedures: Map<string, Procedure>;\n  bestPractices: Map<string, BestPractice>;\n  lessons: Map<string, Lesson>;\n}\n\nexport interface Fact {\n  id: string;\n  statement: string;\n  category: string;\n  confidence: number;\n  sources: string[];\n  validatedBy: string[];\n  contexts: string[];\n  timestamp: Date;\n}\n\nexport interface Procedure {\n  id: string;\n  name: string;\n  description: string;\n  steps: ProcedureStep[];\n  preconditions: string[];\n  postconditions: string[];\n  successRate: number;\n  contexts: string[];\n  lastUsed: Date;\n}\n\nexport interface ProcedureStep {\n  order: number;\n  action: string;\n  parameters: Record<string, any>;\n  expectedResult: string;\n  alternatives: string[];\n}\n\nexport interface BestPractice {\n  id: string;\n  domain: string;\n  practice: string;\n  rationale: string;\n  benefits: string[];\n  applicableContexts: string[];\n  effectiveness: number;\n  adoptionRate: number;\n  validatedBy: string[];\n  timestamp: Date;\n}\n\nexport interface Lesson {\n  id: string;\n  title: string;\n  situation: string;\n  actions: string[];\n  outcome: string;\n  learning: string;\n  applicability: string[];\n  importance: 'low' | 'medium' | 'high' | 'critical';\n  learnedBy: string[];\n  timestamp: Date;\n}\n\nexport interface DistributedLearning {\n  models: Map<string, LearningModel>;\n  experiences: Map<string, Experience>;\n  adaptations: Map<string, Adaptation>;\n  performance: PerformanceTrends;\n}\n\nexport interface LearningModel {\n  id: string;\n  type: 'neural' | 'statistical' | 'heuristic' | 'ensemble';\n  purpose: string;\n  parameters: Record<string, any>;\n  performance: ModelPerformance;\n  trainingData: string[];\n  lastUpdated: Date;\n  version: string;\n}\n\nexport interface ModelPerformance {\n  accuracy: number;\n  precision: number;\n  recall: number;\n  f1Score: number;\n  validationResults: any[];\n  benchmarkResults: any[];\n}\n\nexport interface Experience {\n  id: string;\n  context: string;\n  situation: string;\n  actions: string[];\n  results: any[];\n  feedback: number;\n  tags: string[];\n  agentId: string;\n  timestamp: Date;\n}\n\nexport interface Adaptation {\n  id: string;\n  trigger: string;\n  change: string;\n  reason: string;\n  effectiveness: number;\n  rollbackPlan: string;\n  approvedBy: string[];\n  implementedAt: Date;\n}\n\nexport interface PerformanceTrends {\n  metrics: Map<string, number[]>;\n  improvements: string[];\n  degradations: string[];\n  stability: number;\n  trends: TrendAnalysis[];\n}\n\nexport interface TrendAnalysis {\n  metric: string;\n  direction: 'increasing' | 'decreasing' | 'stable' | 'volatile';\n  magnitude: number;\n  confidence: number;\n  timeframe: string;\n  factors: string[];\n}\n\nexport class HiveMindIntegration extends EventEmitter {\n  private logger: Logger;\n  private config: HiveMindConfig;\n  private memoryManager: MemoryManager;\n  private activeSessions: Map<string, HiveMindSession> = new Map();\n  private globalKnowledgeBase: KnowledgeBase;\n  private globalIntelligence: CollectiveIntelligence;\n  private syncInterval?: NodeJS.Timeout;\n  private isInitialized: boolean = false;\n\n  constructor(\n    config: Partial<HiveMindConfig> = {},\n    memoryManager: MemoryManager\n  ) {\n    super();\n    \n    this.logger = new Logger('HiveMindIntegration');\n    this.config = this.createDefaultConfig(config);\n    this.memoryManager = memoryManager;\n    this.globalKnowledgeBase = this.initializeKnowledgeBase();\n    this.globalIntelligence = this.initializeCollectiveIntelligence();\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the hive-mind integration\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      this.logger.warn('Hive-mind integration already initialized');\n      return;\n    }\n\n    this.logger.info('Initializing hive-mind integration...');\n\n    try {\n      // Load existing knowledge base from memory\n      await this.loadKnowledgeBase();\n\n      // Load collective intelligence data\n      await this.loadCollectiveIntelligence();\n\n      // Start synchronization if enabled\n      if (this.config.syncInterval > 0) {\n        this.startPeriodicSync();\n      }\n\n      this.isInitialized = true;\n      this.logger.info('Hive-mind integration initialized successfully');\n      this.emit('initialized');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize hive-mind integration', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the integration gracefully\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n\n    this.logger.info('Shutting down hive-mind integration...');\n\n    try {\n      // Stop synchronization\n      if (this.syncInterval) {\n        clearInterval(this.syncInterval);\n      }\n\n      // Save current state\n      await this.saveKnowledgeBase();\n      await this.saveCollectiveIntelligence();\n\n      // Terminate active sessions\n      const terminationPromises = Array.from(this.activeSessions.keys())\n        .map(sessionId => this.terminateSession(sessionId));\n      \n      await Promise.allSettled(terminationPromises);\n\n      this.isInitialized = false;\n      this.logger.info('Hive-mind integration shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during hive-mind integration shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new hive-mind session for a swarm\n   */\n  async createSession(\n    swarmId: string,\n    orchestrator: AdvancedSwarmOrchestrator\n  ): Promise<string> {\n    const sessionId = generateId('hive-session');\n    \n    this.logger.info('Creating hive-mind session', {\n      sessionId,\n      swarmId,\n    });\n\n    const session: HiveMindSession = {\n      id: sessionId,\n      swarmId,\n      participants: [],\n      sharedMemory: new Map(),\n      collectiveIntelligence: this.initializeCollectiveIntelligence(),\n      knowledgeBase: this.initializeKnowledgeBase(),\n      distributedLearning: this.initializeDistributedLearning(),\n      status: 'active',\n      startTime: new Date(),\n      lastSync: new Date(),\n    };\n\n    this.activeSessions.set(sessionId, session);\n\n    // Initialize session with global knowledge\n    await this.initializeSessionWithGlobalKnowledge(session);\n\n    this.emit('session:created', {\n      sessionId,\n      swarmId,\n    });\n\n    return sessionId;\n  }\n\n  /**\n   * Add an agent to a hive-mind session\n   */\n  async addAgentToSession(\n    sessionId: string,\n    agentId: string,\n    agent: SwarmAgent\n  ): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    if (!session.participants.includes(agentId)) {\n      session.participants.push(agentId);\n      \n      this.logger.info('Agent added to hive-mind session', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n\n      // Share relevant knowledge with the agent\n      await this.shareKnowledgeWithAgent(session, agentId, agent);\n\n      this.emit('agent:joined', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n    }\n  }\n\n  /**\n   * Remove an agent from a hive-mind session\n   */\n  async removeAgentFromSession(\n    sessionId: string,\n    agentId: string\n  ): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    const index = session.participants.indexOf(agentId);\n    if (index !== -1) {\n      session.participants.splice(index, 1);\n      \n      this.logger.info('Agent removed from hive-mind session', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n\n      this.emit('agent:left', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n    }\n  }\n\n  /**\n   * Share knowledge or experience with the hive-mind\n   */\n  async shareWithHive(\n    sessionId: string,\n    agentId: string,\n    type: 'knowledge' | 'experience' | 'insight' | 'pattern',\n    data: any\n  ): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    this.logger.debug('Sharing with hive-mind', {\n      sessionId,\n      agentId,\n      type,\n    });\n\n    switch (type) {\n      case 'knowledge':\n        await this.addKnowledge(session, agentId, data);\n        break;\n      case 'experience':\n        await this.addExperience(session, agentId, data);\n        break;\n      case 'insight':\n        await this.addInsight(session, agentId, data);\n        break;\n      case 'pattern':\n        await this.addPattern(session, agentId, data);\n        break;\n    }\n\n    this.emit('knowledge:shared', {\n      sessionId,\n      agentId,\n      type,\n    });\n  }\n\n  /**\n   * Request collective decision making\n   */\n  async requestCollectiveDecision(\n    sessionId: string,\n    question: string,\n    options: DecisionOption[],\n    requesterAgentId: string\n  ): Promise<string> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    const decisionId = generateId('decision');\n    \n    this.logger.info('Requesting collective decision', {\n      sessionId,\n      decisionId,\n      question,\n      optionCount: options.length,\n      requesterAgentId,\n    });\n\n    const decision: CollectiveDecision = {\n      id: decisionId,\n      question,\n      options,\n      votingResults: new Map(),\n      consensus: '',\n      confidence: 0,\n      reasoning: '',\n      participants: [...session.participants],\n      timestamp: new Date(),\n    };\n\n    session.collectiveIntelligence.decisions.set(decisionId, decision);\n\n    // Initiate voting process\n    await this.initiateVoting(session, decision);\n\n    this.emit('decision:requested', {\n      sessionId,\n      decisionId,\n      question,\n    });\n\n    return decisionId;\n  }\n\n  /**\n   * Get collective decision result\n   */\n  getCollectiveDecision(sessionId: string, decisionId: string): CollectiveDecision | null {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return null;\n\n    return session.collectiveIntelligence.decisions.get(decisionId) || null;\n  }\n\n  /**\n   * Query the hive-mind knowledge base\n   */\n  async queryKnowledge(\n    sessionId: string,\n    query: {\n      type: 'fact' | 'procedure' | 'bestPractice' | 'lesson';\n      keywords?: string[];\n      context?: string;\n      category?: string;\n    }\n  ): Promise<any[]> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    this.logger.debug('Querying hive-mind knowledge', {\n      sessionId,\n      query,\n    });\n\n    let results: any[] = [];\n\n    switch (query.type) {\n      case 'fact':\n        results = this.queryFacts(session, query);\n        break;\n      case 'procedure':\n        results = this.queryProcedures(session, query);\n        break;\n      case 'bestPractice':\n        results = this.queryBestPractices(session, query);\n        break;\n      case 'lesson':\n        results = this.queryLessons(session, query);\n        break;\n    }\n\n    this.emit('knowledge:queried', {\n      sessionId,\n      query,\n      resultCount: results.length,\n    });\n\n    return results;\n  }\n\n  /**\n   * Get collective insights for a swarm\n   */\n  getCollectiveInsights(sessionId: string): Insight[] {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return [];\n\n    return Array.from(session.collectiveIntelligence.insights.values());\n  }\n\n  /**\n   * Get identified patterns\n   */\n  getIdentifiedPatterns(sessionId: string): Pattern[] {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return [];\n\n    return Array.from(session.collectiveIntelligence.patterns.values());\n  }\n\n  /**\n   * Get performance predictions\n   */\n  getPerformancePredictions(sessionId: string): Prediction[] {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return [];\n\n    return Array.from(session.collectiveIntelligence.predictions.values());\n  }\n\n  /**\n   * Terminate a hive-mind session\n   */\n  async terminateSession(sessionId: string): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return;\n\n    this.logger.info('Terminating hive-mind session', {\n      sessionId,\n      participantCount: session.participants.length,\n      duration: Date.now() - session.startTime.getTime(),\n    });\n\n    // Save session knowledge to global knowledge base\n    await this.consolidateSessionKnowledge(session);\n\n    // Update status and cleanup\n    session.status = 'terminated';\n    this.activeSessions.delete(sessionId);\n\n    this.emit('session:terminated', {\n      sessionId,\n      duration: Date.now() - session.startTime.getTime(),\n    });\n  }\n\n  /**\n   * Get hive-mind session status\n   */\n  getSessionStatus(sessionId: string): HiveMindSession | null {\n    return this.activeSessions.get(sessionId) || null;\n  }\n\n  /**\n   * Get integration metrics\n   */\n  getIntegrationMetrics(): {\n    activeSessions: number;\n    totalParticipants: number;\n    knowledgeItems: number;\n    insights: number;\n    patterns: number;\n    decisions: number;\n    predictions: number;\n    learningModels: number;\n  } {\n    const sessions = Array.from(this.activeSessions.values());\n    \n    return {\n      activeSessions: sessions.length,\n      totalParticipants: sessions.reduce((sum, s) => sum + s.participants.length, 0),\n      knowledgeItems: this.countKnowledgeItems(),\n      insights: this.globalIntelligence.insights.size,\n      patterns: this.globalIntelligence.patterns.size,\n      decisions: this.globalIntelligence.decisions.size,\n      predictions: this.globalIntelligence.predictions.size,\n      learningModels: sessions.reduce((sum, s) => sum + s.distributedLearning.models.size, 0),\n    };\n  }\n\n  // Private methods\n\n  private async loadKnowledgeBase(): Promise<void> {\n    try {\n      const knowledgeEntries = await this.memoryManager.retrieve({\n        namespace: 'hive-mind-knowledge',\n        type: 'knowledge-base',\n      });\n\n      for (const entry of knowledgeEntries) {\n        const data = JSON.parse(entry.content);\n        // Load facts, procedures, best practices, and lessons\n        this.loadKnowledgeData(data);\n      }\n\n      this.logger.debug('Knowledge base loaded', {\n        factsCount: this.globalKnowledgeBase.facts.size,\n        proceduresCount: this.globalKnowledgeBase.procedures.size,\n        bestPracticesCount: this.globalKnowledgeBase.bestPractices.size,\n        lessonsCount: this.globalKnowledgeBase.lessons.size,\n      });\n\n    } catch (error) {\n      this.logger.warn('Failed to load knowledge base, starting fresh', error);\n    }\n  }\n\n  private async loadCollectiveIntelligence(): Promise<void> {\n    try {\n      const intelligenceEntries = await this.memoryManager.retrieve({\n        namespace: 'hive-mind-intelligence',\n        type: 'collective-intelligence',\n      });\n\n      for (const entry of intelligenceEntries) {\n        const data = JSON.parse(entry.content);\n        this.loadIntelligenceData(data);\n      }\n\n      this.logger.debug('Collective intelligence loaded', {\n        patternsCount: this.globalIntelligence.patterns.size,\n        insightsCount: this.globalIntelligence.insights.size,\n        decisionsCount: this.globalIntelligence.decisions.size,\n        predictionsCount: this.globalIntelligence.predictions.size,\n      });\n\n    } catch (error) {\n      this.logger.warn('Failed to load collective intelligence, starting fresh', error);\n    }\n  }\n\n  private async saveKnowledgeBase(): Promise<void> {\n    try {\n      const knowledgeData = {\n        facts: Array.from(this.globalKnowledgeBase.facts.entries()),\n        procedures: Array.from(this.globalKnowledgeBase.procedures.entries()),\n        bestPractices: Array.from(this.globalKnowledgeBase.bestPractices.entries()),\n        lessons: Array.from(this.globalKnowledgeBase.lessons.entries()),\n      };\n\n      await this.memoryManager.store({\n        id: `knowledge-base-${Date.now()}`,\n        agentId: 'hive-mind-integration',\n        type: 'knowledge-base',\n        content: JSON.stringify(knowledgeData),\n        namespace: 'hive-mind-knowledge',\n        timestamp: new Date(),\n        metadata: {\n          type: 'knowledge-base-snapshot',\n          itemCount: this.countKnowledgeItems(),\n        },\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to save knowledge base', error);\n    }\n  }\n\n  private async saveCollectiveIntelligence(): Promise<void> {\n    try {\n      const intelligenceData = {\n        patterns: Array.from(this.globalIntelligence.patterns.entries()),\n        insights: Array.from(this.globalIntelligence.insights.entries()),\n        decisions: Array.from(this.globalIntelligence.decisions.entries()),\n        predictions: Array.from(this.globalIntelligence.predictions.entries()),\n      };\n\n      await this.memoryManager.store({\n        id: `collective-intelligence-${Date.now()}`,\n        agentId: 'hive-mind-integration',\n        type: 'collective-intelligence',\n        content: JSON.stringify(intelligenceData),\n        namespace: 'hive-mind-intelligence',\n        timestamp: new Date(),\n        metadata: {\n          type: 'intelligence-snapshot',\n          itemCount: this.globalIntelligence.patterns.size + \n                     this.globalIntelligence.insights.size +\n                     this.globalIntelligence.decisions.size +\n                     this.globalIntelligence.predictions.size,\n        },\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to save collective intelligence', error);\n    }\n  }\n\n  private startPeriodicSync(): void {\n    this.syncInterval = setInterval(async () => {\n      try {\n        await this.performPeriodicSync();\n      } catch (error) {\n        this.logger.error('Error during periodic sync', error);\n      }\n    }, this.config.syncInterval);\n  }\n\n  private async performPeriodicSync(): Promise<void> {\n    // Sync with external hive-mind endpoint if configured\n    if (this.config.hiveMindEndpoint) {\n      // Implementation would sync with external system\n      this.logger.debug('Performing external hive-mind sync');\n    }\n\n    // Update session knowledge bases\n    for (const session of this.activeSessions.values()) {\n      await this.syncSessionKnowledge(session);\n      session.lastSync = new Date();\n    }\n\n    this.emit('sync:completed', {\n      sessionsSynced: this.activeSessions.size,\n      timestamp: new Date(),\n    });\n  }\n\n  private async initializeSessionWithGlobalKnowledge(session: HiveMindSession): Promise<void> {\n    // Copy relevant global knowledge to session\n    for (const [id, fact] of this.globalKnowledgeBase.facts) {\n      session.knowledgeBase.facts.set(id, fact);\n    }\n\n    for (const [id, insight] of this.globalIntelligence.insights) {\n      session.collectiveIntelligence.insights.set(id, insight);\n    }\n\n    for (const [id, pattern] of this.globalIntelligence.patterns) {\n      session.collectiveIntelligence.patterns.set(id, pattern);\n    }\n  }\n\n  private async shareKnowledgeWithAgent(\n    session: HiveMindSession,\n    agentId: string,\n    agent: SwarmAgent\n  ): Promise<void> {\n    // Share relevant knowledge based on agent capabilities\n    const relevantKnowledge = this.getRelevantKnowledge(session, agent.capabilities);\n    \n    this.logger.debug('Sharing knowledge with agent', {\n      sessionId: session.id,\n      agentId,\n      knowledgeItems: relevantKnowledge.length,\n    });\n\n    // Implementation would send knowledge to agent through MCP tools\n  }\n\n  private getRelevantKnowledge(session: HiveMindSession, capabilities: string[]): any[] {\n    const relevantItems: any[] = [];\n\n    // Filter facts by capabilities\n    for (const fact of session.knowledgeBase.facts.values()) {\n      if (capabilities.some(cap => fact.category.includes(cap))) {\n        relevantItems.push(fact);\n      }\n    }\n\n    // Filter procedures by capabilities\n    for (const procedure of session.knowledgeBase.procedures.values()) {\n      if (capabilities.some(cap => procedure.contexts.includes(cap))) {\n        relevantItems.push(procedure);\n      }\n    }\n\n    return relevantItems;\n  }\n\n  private async addKnowledge(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    // Add new knowledge item to session\n    if (data.type === 'fact') {\n      const fact: Fact = {\n        id: generateId('fact'),\n        statement: data.statement,\n        category: data.category || 'general',\n        confidence: data.confidence || 0.8,\n        sources: [agentId],\n        validatedBy: [agentId],\n        contexts: data.contexts || [],\n        timestamp: new Date(),\n      };\n      \n      session.knowledgeBase.facts.set(fact.id, fact);\n    }\n    // Similar implementations for procedures, best practices, and lessons\n  }\n\n  private async addExperience(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    const experience: Experience = {\n      id: generateId('experience'),\n      context: data.context || 'general',\n      situation: data.situation,\n      actions: data.actions || [],\n      results: data.results || [],\n      feedback: data.feedback || 0,\n      tags: data.tags || [],\n      agentId,\n      timestamp: new Date(),\n    };\n\n    session.distributedLearning.experiences.set(experience.id, experience);\n  }\n\n  private async addInsight(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    const insight: Insight = {\n      id: generateId('insight'),\n      category: data.category || 'optimization',\n      title: data.title,\n      description: data.description,\n      evidence: data.evidence || [],\n      confidence: data.confidence || 0.7,\n      applicability: data.applicability || [],\n      contributingAgents: [agentId],\n      timestamp: new Date(),\n    };\n\n    session.collectiveIntelligence.insights.set(insight.id, insight);\n  }\n\n  private async addPattern(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    const pattern: Pattern = {\n      id: generateId('pattern'),\n      type: data.type || 'behavioral',\n      description: data.description,\n      frequency: data.frequency || 1,\n      confidence: data.confidence || 0.7,\n      contexts: data.contexts || [],\n      impact: data.impact || 'medium',\n      discoveredBy: [agentId],\n      lastSeen: new Date(),\n    };\n\n    session.collectiveIntelligence.patterns.set(pattern.id, pattern);\n  }\n\n  private async initiateVoting(session: HiveMindSession, decision: CollectiveDecision): Promise<void> {\n    // Implementation would send voting request to all participants\n    // For now, simulate consensus building\n    this.logger.debug('Initiating collective voting', {\n      sessionId: session.id,\n      decisionId: decision.id,\n      participantCount: decision.participants.length,\n    });\n\n    // Placeholder implementation - in reality, this would involve\n    // sophisticated consensus algorithms\n    setTimeout(() => {\n      this.processVotingResults(session, decision);\n    }, 5000);\n  }\n\n  private processVotingResults(session: HiveMindSession, decision: CollectiveDecision): void {\n    // Placeholder implementation\n    decision.consensus = decision.options[0].id;\n    decision.confidence = 0.8;\n    decision.reasoning = 'Consensus reached through collective voting';\n\n    this.emit('decision:completed', {\n      sessionId: session.id,\n      decisionId: decision.id,\n      consensus: decision.consensus,\n      confidence: decision.confidence,\n    });\n  }\n\n  private queryFacts(session: HiveMindSession, query: any): Fact[] {\n    const results: Fact[] = [];\n    \n    for (const fact of session.knowledgeBase.facts.values()) {\n      let matches = true;\n      \n      if (query.category && !fact.category.includes(query.category)) {\n        matches = false;\n      }\n      \n      if (query.keywords && !query.keywords.some(keyword => \n        fact.statement.toLowerCase().includes(keyword.toLowerCase()))) {\n        matches = false;\n      }\n      \n      if (query.context && !fact.contexts.includes(query.context)) {\n        matches = false;\n      }\n      \n      if (matches) {\n        results.push(fact);\n      }\n    }\n    \n    return results;\n  }\n\n  private queryProcedures(session: HiveMindSession, query: any): Procedure[] {\n    // Similar implementation to queryFacts but for procedures\n    return Array.from(session.knowledgeBase.procedures.values());\n  }\n\n  private queryBestPractices(session: HiveMindSession, query: any): BestPractice[] {\n    // Similar implementation to queryFacts but for best practices\n    return Array.from(session.knowledgeBase.bestPractices.values());\n  }\n\n  private queryLessons(session: HiveMindSession, query: any): Lesson[] {\n    // Similar implementation to queryFacts but for lessons\n    return Array.from(session.knowledgeBase.lessons.values());\n  }\n\n  private async consolidateSessionKnowledge(session: HiveMindSession): Promise<void> {\n    // Merge session knowledge into global knowledge base\n    for (const [id, fact] of session.knowledgeBase.facts) {\n      if (!this.globalKnowledgeBase.facts.has(id)) {\n        this.globalKnowledgeBase.facts.set(id, fact);\n      }\n    }\n\n    for (const [id, insight] of session.collectiveIntelligence.insights) {\n      if (!this.globalIntelligence.insights.has(id)) {\n        this.globalIntelligence.insights.set(id, insight);\n      }\n    }\n\n    // Similar consolidation for other knowledge types\n  }\n\n  private async syncSessionKnowledge(session: HiveMindSession): Promise<void> {\n    // Sync session with global knowledge base\n    // Implementation would handle bidirectional sync\n  }\n\n  private loadKnowledgeData(data: any): void {\n    // Load knowledge data from stored format\n    if (data.facts) {\n      for (const [id, fact] of data.facts) {\n        this.globalKnowledgeBase.facts.set(id, fact);\n      }\n    }\n    // Similar loading for other knowledge types\n  }\n\n  private loadIntelligenceData(data: any): void {\n    // Load intelligence data from stored format\n    if (data.patterns) {\n      for (const [id, pattern] of data.patterns) {\n        this.globalIntelligence.patterns.set(id, pattern);\n      }\n    }\n    // Similar loading for other intelligence types\n  }\n\n  private countKnowledgeItems(): number {\n    return this.globalKnowledgeBase.facts.size +\n           this.globalKnowledgeBase.procedures.size +\n           this.globalKnowledgeBase.bestPractices.size +\n           this.globalKnowledgeBase.lessons.size;\n  }\n\n  private initializeKnowledgeBase(): KnowledgeBase {\n    return {\n      facts: new Map(),\n      procedures: new Map(),\n      bestPractices: new Map(),\n      lessons: new Map(),\n    };\n  }\n\n  private initializeCollectiveIntelligence(): CollectiveIntelligence {\n    return {\n      patterns: new Map(),\n      insights: new Map(),\n      decisions: new Map(),\n      predictions: new Map(),\n    };\n  }\n\n  private initializeDistributedLearning(): DistributedLearning {\n    return {\n      models: new Map(),\n      experiences: new Map(),\n      adaptations: new Map(),\n      performance: {\n        metrics: new Map(),\n        improvements: [],\n        degradations: [],\n        stability: 1.0,\n        trends: [],\n      },\n    };\n  }\n\n  private createDefaultConfig(config: Partial<HiveMindConfig>): HiveMindConfig {\n    return {\n      enableSharedIntelligence: true,\n      enableCollectiveMemory: true,\n      enableDistributedLearning: true,\n      enableKnowledgeSharing: true,\n      syncInterval: 30000, // 30 seconds\n      maxSharedMemorySize: 100 * 1024 * 1024, // 100MB\n      intelligencePoolSize: 1000,\n      learningRate: 0.1,\n      knowledgeRetentionPeriod: 7 * 24 * 60 * 60 * 1000, // 7 days\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('session:created', (data) => {\n      this.logger.info('Hive-mind session created', data);\n    });\n\n    this.on('agent:joined', (data) => {\n      this.logger.info('Agent joined hive-mind', data);\n    });\n\n    this.on('knowledge:shared', (data) => {\n      this.logger.debug('Knowledge shared with hive-mind', data);\n    });\n\n    this.on('decision:completed', (data) => {\n      this.logger.info('Collective decision completed', data);\n    });\n  }\n}\n\nexport default HiveMindIntegration;"],
  "mappings": "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",
  "names": []
}
