{
  "version": 3,
  "sources": ["../../src/mcp/router.ts"],
  "sourcesContent": ["/**\n * Request router for MCP\n */\n\nimport type { MCPRequest } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPMethodNotFoundError } from '../utils/errors.js';\nimport type { ToolRegistry } from './tools.js';\n\n/**\n * Request router implementation\n */\nexport class RequestRouter {\n  private totalRequests = 0;\n  private successfulRequests = 0;\n  private failedRequests = 0;\n\n  constructor(\n    private toolRegistry: ToolRegistry,\n    private logger: ILogger,\n  ) {}\n\n  /**\n   * Routes a request to the appropriate handler\n   */\n  async route(request: MCPRequest): Promise<unknown> {\n    this.totalRequests++;\n\n    try {\n      // Parse method to determine handler\n      const { method, params } = request;\n\n      // Handle built-in methods\n      if (method.startsWith('rpc.')) {\n        return await this.handleRPCMethod(method, params);\n      }\n\n      // Handle tool invocations\n      if (method.startsWith('tools.')) {\n        return await this.handleToolMethod(method, params);\n      }\n\n      // Try to execute as a tool directly\n      const tool = this.toolRegistry.getTool(method);\n      if (tool) {\n        const result = await this.toolRegistry.executeTool(method, params);\n        this.successfulRequests++;\n        return result;\n      }\n\n      // Method not found\n      throw new MCPMethodNotFoundError(method);\n    } catch (error) {\n      this.failedRequests++;\n      throw error;\n    }\n  }\n\n  /**\n   * Gets router metrics\n   */\n  getMetrics(): {\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n  } {\n    return {\n      totalRequests: this.totalRequests,\n      successfulRequests: this.successfulRequests,\n      failedRequests: this.failedRequests,\n    };\n  }\n\n  /**\n   * Handles built-in RPC methods\n   */\n  private async handleRPCMethod(method: string, params: unknown): Promise<unknown> {\n    switch (method) {\n      case 'rpc.discover':\n        return this.discoverMethods();\n\n      case 'rpc.ping':\n        return { pong: true };\n\n      case 'rpc.describe':\n        return this.describeMethod(params);\n\n      default:\n        throw new MCPMethodNotFoundError(method);\n    }\n  }\n\n  /**\n   * Handles tool-related methods\n   */\n  private async handleToolMethod(method: string, params: unknown): Promise<unknown> {\n    switch (method) {\n      case 'tools.list':\n        return this.toolRegistry.listTools();\n\n      case 'tools.invoke':\n        return await this.invokeTool(params);\n\n      case 'tools.describe':\n        return this.describeTool(params);\n\n      default:\n        throw new MCPMethodNotFoundError(method);\n    }\n  }\n\n  /**\n   * Discovers all available methods\n   */\n  private discoverMethods(): Record<string, string> {\n    const methods: Record<string, string> = {\n      'rpc.discover': 'Discover all available methods',\n      'rpc.ping': 'Ping the server',\n      'rpc.describe': 'Describe a specific method',\n      'tools.list': 'List all available tools',\n      'tools.invoke': 'Invoke a specific tool',\n      'tools.describe': 'Describe a specific tool',\n    };\n\n    // Add all registered tools\n    for (const tool of this.toolRegistry.listTools()) {\n      methods[tool.name] = tool.description;\n    }\n\n    return methods;\n  }\n\n  /**\n   * Describes a specific method\n   */\n  private describeMethod(params: unknown): unknown {\n    if (!params || typeof params !== 'object' || !('method' in params)) {\n      throw new Error('Invalid params: method required');\n    }\n\n    const { method } = params as { method: string };\n\n    // Check if it's a tool\n    const tool = this.toolRegistry.getTool(method);\n    if (tool) {\n      return {\n        name: tool.name,\n        description: tool.description,\n        inputSchema: tool.inputSchema,\n      };\n    }\n\n    // Check built-in methods\n    const builtInMethods: Record<string, unknown> = {\n      'rpc.discover': {\n        description: 'Discover all available methods',\n        inputSchema: { type: 'object', properties: {} },\n      },\n      'rpc.ping': {\n        description: 'Ping the server',\n        inputSchema: { type: 'object', properties: {} },\n      },\n      'rpc.describe': {\n        description: 'Describe a specific method',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            method: { type: 'string' },\n          },\n          required: ['method'],\n        },\n      },\n      'tools.list': {\n        description: 'List all available tools',\n        inputSchema: { type: 'object', properties: {} },\n      },\n      'tools.invoke': {\n        description: 'Invoke a specific tool',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tool: { type: 'string' },\n            input: { type: 'object' },\n          },\n          required: ['tool', 'input'],\n        },\n      },\n      'tools.describe': {\n        description: 'Describe a specific tool',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tool: { type: 'string' },\n          },\n          required: ['tool'],\n        },\n      },\n    };\n\n    if (method in builtInMethods) {\n      return builtInMethods[method];\n    }\n\n    throw new MCPMethodNotFoundError(method);\n  }\n\n  /**\n   * Invokes a tool\n   */\n  private async invokeTool(params: unknown): Promise<unknown> {\n    if (!params || typeof params !== 'object' || !('tool' in params)) {\n      throw new Error('Invalid params: tool required');\n    }\n\n    const { tool, input } = params as { tool: string; input?: unknown };\n    return await this.toolRegistry.executeTool(tool, input || {});\n  }\n\n  /**\n   * Describes a specific tool\n   */\n  private describeTool(params: unknown): unknown {\n    if (!params || typeof params !== 'object' || !('tool' in params)) {\n      throw new Error('Invalid params: tool required');\n    }\n\n    const { tool: toolName } = params as { tool: string };\n    const tool = this.toolRegistry.getTool(toolName);\n\n    if (!tool) {\n      throw new Error(`Tool not found: ${toolName}`);\n    }\n\n    return {\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.inputSchema,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
