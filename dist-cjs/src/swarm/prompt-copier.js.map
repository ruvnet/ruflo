{"version":3,"sources":["../../../src/swarm/prompt-copier.ts"],"sourcesContent":["import * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport { createHash } from 'crypto';\r\nimport type { Worker } from 'worker_threads';\r\nimport { EventEmitter } from 'events';\r\nimport { logger } from '../core/logger.js';\r\n\r\nexport interface CopyOptions {\r\n  source: string;\r\n  destination: string;\r\n  backup?: boolean;\r\n  overwrite?: boolean;\r\n  verify?: boolean;\r\n  preservePermissions?: boolean;\r\n  excludePatterns?: string[];\r\n  includePatterns?: string[];\r\n  parallel?: boolean;\r\n  maxWorkers?: number;\r\n  dryRun?: boolean;\r\n  conflictResolution?: 'skip' | 'overwrite' | 'backup' | 'merge';\r\n  progressCallback?: (progress: CopyProgress) => void;\r\n}\r\n\r\nexport interface CopyProgress {\r\n  total: number;\r\n  completed: number;\r\n  failed: number;\r\n  skipped: number;\r\n  currentFile?: string;\r\n  percentage: number;\r\n}\r\n\r\nexport interface CopyResult {\r\n  success: boolean;\r\n  totalFiles: number;\r\n  copiedFiles: number;\r\n  failedFiles: number;\r\n  skippedFiles: number;\r\n  backupLocation?: string;\r\n  errors: CopyError[];\r\n  duration: number;\r\n}\r\n\r\nexport interface CopyError {\r\n  file: string;\r\n  error: string;\r\n  phase: 'read' | 'write' | 'verify' | 'backup';\r\n}\r\n\r\nexport interface FileInfo {\r\n  path: string;\r\n  relativePath: string;\r\n  size: number;\r\n  hash?: string;\r\n  permissions?: number;\r\n}\r\n\r\nexport class PromptCopier extends EventEmitter {\r\n  private options: Required<CopyOptions>;\r\n  private fileQueue: FileInfo[] = [];\r\n  private copiedFiles: Set<string> = new Set();\r\n  private errors: CopyError[] = [];\r\n  private backupMap: Map<string, string> = new Map();\r\n  private rollbackStack: Array<() => Promise<void>> = [];\r\n\r\n  constructor(options: CopyOptions) {\r\n    super();\r\n    this.options = {\r\n      ...options,\r\n      backup: options.backup ?? true,\r\n      overwrite: options.overwrite ?? false,\r\n      verify: options.verify ?? true,\r\n      preservePermissions: options.preservePermissions ?? true,\r\n      excludePatterns: options.excludePatterns ?? [],\r\n      includePatterns: options.includePatterns ?? ['*.md', '*.txt', '*.prompt', '*.prompts'],\r\n      parallel: options.parallel ?? true,\r\n      maxWorkers: options.maxWorkers ?? 4,\r\n      dryRun: options.dryRun ?? false,\r\n      conflictResolution: options.conflictResolution ?? 'backup',\r\n      progressCallback: options.progressCallback ?? (() => {}),\r\n    };\r\n  }\r\n\r\n  async copy(): Promise<CopyResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Phase 1: Discovery\r\n      logger.info('Starting prompt discovery phase...');\r\n      await this.discoverFiles();\r\n\r\n      if (this.fileQueue.length === 0) {\r\n        return {\r\n          success: true,\r\n          totalFiles: 0,\r\n          copiedFiles: 0,\r\n          failedFiles: 0,\r\n          skippedFiles: 0,\r\n          duration: Date.now() - startTime,\r\n          errors: [],\r\n        };\r\n      }\r\n\r\n      // Phase 2: Pre-flight checks\r\n      if (!this.options.dryRun) {\r\n        await this.ensureDestinationDirectories();\r\n      }\r\n\r\n      // Phase 3: Copy files\r\n      logger.info(`Copying ${this.fileQueue.length} files...`);\r\n      if (this.options.parallel) {\r\n        await this.copyFilesParallel();\r\n      } else {\r\n        await this.copyFilesSequential();\r\n      }\r\n\r\n      // Phase 4: Verification\r\n      if (this.options.verify && !this.options.dryRun) {\r\n        await this.verifyFiles();\r\n      }\r\n\r\n      const duration = Date.now() - startTime;\r\n      const result: CopyResult = {\r\n        success: this.errors.length === 0,\r\n        totalFiles: this.fileQueue.length,\r\n        copiedFiles: this.copiedFiles.size,\r\n        failedFiles: this.errors.length,\r\n        skippedFiles: this.fileQueue.length - this.copiedFiles.size - this.errors.length,\r\n        errors: this.errors,\r\n        duration,\r\n      };\r\n\r\n      if (this.backupMap.size > 0) {\r\n        result.backupLocation = await this.createBackupManifest();\r\n      }\r\n\r\n      logger.info(`Copy completed in ${duration}ms`, result);\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('Copy operation failed', error);\r\n\r\n      if (!this.options.dryRun) {\r\n        await this.rollback();\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async discoverFiles(): Promise<void> {\r\n    const sourceStats = await fs.stat(this.options.source);\r\n\r\n    if (!sourceStats.isDirectory()) {\r\n      throw new Error(`Source path ${this.options.source} is not a directory`);\r\n    }\r\n\r\n    await this.scanDirectory(this.options.source, '');\r\n\r\n    // Sort by size for better parallel distribution\r\n    this.fileQueue.sort((a, b) => b.size - a.size);\r\n  }\r\n\r\n  private async scanDirectory(dirPath: string, relativePath: string): Promise<void> {\r\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = path.join(dirPath, entry.name);\r\n      const relPath = path.join(relativePath, entry.name);\r\n\r\n      if (entry.isDirectory()) {\r\n        await this.scanDirectory(fullPath, relPath);\r\n      } else if (entry.isFile() && this.shouldIncludeFile(relPath)) {\r\n        const stats = await fs.stat(fullPath);\r\n        this.fileQueue.push({\r\n          path: fullPath,\r\n          relativePath: relPath,\r\n          size: stats.size,\r\n          permissions: stats.mode,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private shouldIncludeFile(filePath: string): boolean {\r\n    // Check exclude patterns first\r\n    for (const pattern of this.options.excludePatterns) {\r\n      if (this.matchPattern(filePath, pattern)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Check include patterns\r\n    if (this.options.includePatterns.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    for (const pattern of this.options.includePatterns) {\r\n      if (this.matchPattern(filePath, pattern)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private matchPattern(filePath: string, pattern: string): boolean {\r\n    // Simple glob pattern matching\r\n    const regex = pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*').replace(/\\?/g, '.');\r\n\r\n    return new RegExp(regex).test(filePath);\r\n  }\r\n\r\n  private async ensureDestinationDirectories(): Promise<void> {\r\n    const directories = new Set<string>();\r\n\r\n    for (const file of this.fileQueue) {\r\n      const destDir = path.dirname(path.join(this.options.destination, file.relativePath));\r\n      directories.add(destDir);\r\n    }\r\n\r\n    // Create directories in order (parent first)\r\n    const sortedDirs = Array.from(directories).sort((a, b) => a.length - b.length);\r\n\r\n    for (const dir of sortedDirs) {\r\n      await fs.mkdir(dir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  private async copyFilesSequential(): Promise<void> {\r\n    let completed = 0;\r\n\r\n    for (const file of this.fileQueue) {\r\n      try {\r\n        await this.copyFile(file);\r\n        completed++;\r\n        this.reportProgress(completed);\r\n      } catch (error) {\r\n        this.errors.push({\r\n          file: file.path,\r\n          error: error instanceof Error ? error.message : String(error),\r\n          phase: 'write',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async copyFilesParallel(): Promise<void> {\r\n    const workerCount = Math.min(this.options.maxWorkers, this.fileQueue.length);\r\n    const chunkSize = Math.ceil(this.fileQueue.length / workerCount);\r\n    const workers: Promise<void>[] = [];\r\n\r\n    for (let i = 0; i < workerCount; i++) {\r\n      const start = i * chunkSize;\r\n      const end = Math.min(start + chunkSize, this.fileQueue.length);\r\n      const chunk = this.fileQueue.slice(start, end);\r\n\r\n      if (chunk.length > 0) {\r\n        workers.push(this.processChunk(chunk, i));\r\n      }\r\n    }\r\n\r\n    await Promise.all(workers);\r\n  }\r\n\r\n  private async processChunk(files: FileInfo[], workerId: number): Promise<void> {\r\n    for (const file of files) {\r\n      try {\r\n        await this.copyFile(file);\r\n        this.copiedFiles.add(file.path);\r\n        this.reportProgress(this.copiedFiles.size);\r\n      } catch (error) {\r\n        this.errors.push({\r\n          file: file.path,\r\n          error: error instanceof Error ? error.message : String(error),\r\n          phase: 'write',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async copyFile(file: FileInfo): Promise<void> {\r\n    const destPath = path.join(this.options.destination, file.relativePath);\r\n\r\n    if (this.options.dryRun) {\r\n      logger.info(`[DRY RUN] Would copy ${file.path} to ${destPath}`);\r\n      return;\r\n    }\r\n\r\n    // Check for conflicts\r\n    const destExists = await this.fileExists(destPath);\r\n\r\n    if (destExists) {\r\n      switch (this.options.conflictResolution) {\r\n        case 'skip':\r\n          logger.info(`Skipping existing file: ${destPath}`);\r\n          return;\r\n\r\n        case 'backup':\r\n          await this.backupFile(destPath);\r\n          break;\r\n\r\n        case 'merge':\r\n          await this.mergeFiles(file.path, destPath);\r\n          return;\r\n\r\n        case 'overwrite':\r\n          // Continue with copy\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Calculate source hash if verification is enabled\r\n    if (this.options.verify) {\r\n      file.hash = await this.calculateFileHash(file.path);\r\n    }\r\n\r\n    // Copy the file\r\n    await fs.copyFile(file.path, destPath);\r\n\r\n    // Preserve permissions if requested\r\n    if (this.options.preservePermissions && file.permissions) {\r\n      await fs.chmod(destPath, file.permissions);\r\n    }\r\n\r\n    // Add to rollback stack\r\n    this.rollbackStack.push(async () => {\r\n      if (destExists && this.backupMap.has(destPath)) {\r\n        // Restore from backup\r\n        const backupPath = this.backupMap.get(destPath)!;\r\n        await fs.copyFile(backupPath, destPath);\r\n      } else {\r\n        // Remove the copied file\r\n        await fs.unlink(destPath);\r\n      }\r\n    });\r\n\r\n    this.copiedFiles.add(file.path);\r\n  }\r\n\r\n  private async backupFile(filePath: string): Promise<void> {\r\n    const backupDir = path.join(this.options.destination, '.prompt-backups');\r\n    await fs.mkdir(backupDir, { recursive: true });\r\n\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n    const backupName = `${path.basename(filePath)}.${timestamp}.bak`;\r\n    const backupPath = path.join(backupDir, backupName);\r\n\r\n    await fs.copyFile(filePath, backupPath);\r\n    this.backupMap.set(filePath, backupPath);\r\n  }\r\n\r\n  private async mergeFiles(sourcePath: string, destPath: string): Promise<void> {\r\n    // Simple merge strategy: append source to destination with separator\r\n    const sourceContent = await fs.readFile(sourcePath, 'utf-8');\r\n    const destContent = await fs.readFile(destPath, 'utf-8');\r\n\r\n    const separator = '\\n\\n--- MERGED CONTENT ---\\n\\n';\r\n    const mergedContent = destContent + separator + sourceContent;\r\n\r\n    await this.backupFile(destPath);\r\n    await fs.writeFile(destPath, mergedContent, 'utf-8');\r\n  }\r\n\r\n  private async verifyFiles(): Promise<void> {\r\n    logger.info('Verifying copied files...');\r\n\r\n    for (const file of this.fileQueue) {\r\n      if (!this.copiedFiles.has(file.path)) continue;\r\n\r\n      try {\r\n        const destPath = path.join(this.options.destination, file.relativePath);\r\n\r\n        // Verify file exists\r\n        if (!(await this.fileExists(destPath))) {\r\n          throw new Error('Destination file not found');\r\n        }\r\n\r\n        // Verify size\r\n        const destStats = await fs.stat(destPath);\r\n        const sourceStats = await fs.stat(file.path);\r\n\r\n        if (destStats.size !== sourceStats.size) {\r\n          throw new Error(`Size mismatch: ${destStats.size} != ${sourceStats.size}`);\r\n        }\r\n\r\n        // Verify hash if available\r\n        if (file.hash) {\r\n          const destHash = await this.calculateFileHash(destPath);\r\n          if (destHash !== file.hash) {\r\n            throw new Error(`Hash mismatch: ${destHash} != ${file.hash}`);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        this.errors.push({\r\n          file: file.path,\r\n          error: error instanceof Error ? error.message : String(error),\r\n          phase: 'verify',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async calculateFileHash(filePath: string): Promise<string> {\r\n    const content = await fs.readFile(filePath);\r\n    return createHash('sha256').update(content).digest('hex');\r\n  }\r\n\r\n  private async fileExists(filePath: string): Promise<boolean> {\r\n    try {\r\n      await fs.access(filePath);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async createBackupManifest(): Promise<string> {\r\n    const manifestPath = path.join(\r\n      this.options.destination,\r\n      '.prompt-backups',\r\n      `manifest-${Date.now()}.json`,\r\n    );\r\n\r\n    const manifest = {\r\n      timestamp: new Date().toISOString(),\r\n      source: this.options.source,\r\n      destination: this.options.destination,\r\n      backups: Array.from(this.backupMap.entries()).map(([original, backup]) => ({\r\n        original,\r\n        backup,\r\n      })),\r\n    };\r\n\r\n    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));\r\n    return manifestPath;\r\n  }\r\n\r\n  private async rollback(): Promise<void> {\r\n    logger.warn('Rolling back changes...');\r\n\r\n    // Execute rollback operations in reverse order\r\n    for (let i = this.rollbackStack.length - 1; i >= 0; i--) {\r\n      try {\r\n        await this.rollbackStack[i]();\r\n      } catch (error) {\r\n        logger.error(`Rollback operation ${i} failed:`, error);\r\n      }\r\n    }\r\n\r\n    // Clean up backup directory if empty\r\n    try {\r\n      const backupDir = path.join(this.options.destination, '.prompt-backups');\r\n      const entries = await fs.readdir(backupDir);\r\n      if (entries.length === 0) {\r\n        await fs.rmdir(backupDir);\r\n      }\r\n    } catch {\r\n      // Ignore cleanup errors\r\n    }\r\n  }\r\n\r\n  private reportProgress(completed: number): void {\r\n    const progress: CopyProgress = {\r\n      total: this.fileQueue.length,\r\n      completed,\r\n      failed: this.errors.length,\r\n      skipped: this.fileQueue.length - completed - this.errors.length,\r\n      percentage: Math.round((completed / this.fileQueue.length) * 100),\r\n    };\r\n\r\n    this.emit('progress', progress);\r\n    this.options.progressCallback(progress);\r\n  }\r\n\r\n  // Utility method to restore from backup\r\n  async restoreFromBackup(manifestPath: string): Promise<void> {\r\n    const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));\r\n\r\n    for (const { original, backup } of manifest.backups) {\r\n      try {\r\n        await fs.copyFile(backup, original);\r\n        logger.info(`Restored ${original} from ${backup}`);\r\n      } catch (error) {\r\n        logger.error(`Failed to restore ${original}:`, error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Export convenience function\r\nexport async function copyPrompts(options: CopyOptions): Promise<CopyResult> {\r\n  const copier = new PromptCopier(options);\r\n  return copier.copy();\r\n}\r\n"],"names":["fs","path","createHash","EventEmitter","logger","PromptCopier","options","fileQueue","copiedFiles","Set","errors","backupMap","Map","rollbackStack","backup","overwrite","verify","preservePermissions","excludePatterns","includePatterns","parallel","maxWorkers","dryRun","conflictResolution","progressCallback","copy","startTime","Date","now","info","discoverFiles","length","success","totalFiles","failedFiles","skippedFiles","duration","ensureDestinationDirectories","copyFilesParallel","copyFilesSequential","verifyFiles","result","size","backupLocation","createBackupManifest","error","rollback","sourceStats","stat","source","isDirectory","Error","scanDirectory","sort","a","b","dirPath","relativePath","entries","readdir","withFileTypes","entry","fullPath","join","name","relPath","isFile","shouldIncludeFile","stats","push","permissions","mode","filePath","pattern","matchPattern","regex","replace","RegExp","test","directories","file","destDir","dirname","destination","add","sortedDirs","Array","from","dir","mkdir","recursive","completed","copyFile","reportProgress","message","String","phase","workerCount","Math","min","chunkSize","ceil","workers","i","start","end","chunk","slice","processChunk","Promise","all","files","workerId","destPath","destExists","fileExists","backupFile","mergeFiles","hash","calculateFileHash","chmod","has","backupPath","get","unlink","backupDir","timestamp","toISOString","backupName","basename","set","sourcePath","sourceContent","readFile","destContent","separator","mergedContent","writeFile","destStats","destHash","content","update","digest","access","manifestPath","manifest","backups","map","original","JSON","stringify","warn","rmdir","progress","total","failed","skipped","percentage","round","emit","restoreFromBackup","parse","copyPrompts","copier"],"mappings":"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"}