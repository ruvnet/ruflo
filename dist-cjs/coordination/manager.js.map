{
  "version": 3,
  "sources": ["../../src/coordination/manager.ts"],
  "sourcesContent": ["/**\n * Coordination manager for task scheduling and resource management\n */\n\nimport { Task, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { CoordinationError, DeadlockError } from '../utils/errors.js';\nimport { TaskScheduler } from './scheduler.js';\nimport { ResourceManager } from './resources.js';\nimport { MessageRouter } from './messaging.js';\nimport { AdvancedTaskScheduler } from './advanced-scheduler.js';\nimport { ConflictResolver } from './conflict-resolution.js';\nimport { CoordinationMetricsCollector } from './metrics.js';\n\nexport interface ICoordinationManager {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  assignTask(task: Task, agentId: string): Promise<void>;\n  getAgentTaskCount(agentId: string): Promise<number>;\n  getAgentTasks(agentId: string): Promise<Task[]>;\n  cancelTask(taskId: string, reason?: string): Promise<void>;\n  acquireResource(resourceId: string, agentId: string): Promise<void>;\n  releaseResource(resourceId: string, agentId: string): Promise<void>;\n  sendMessage(from: string, to: string, message: unknown): Promise<void>;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  performMaintenance(): Promise<void>;\n  getCoordinationMetrics(): Promise<Record<string, unknown>>;\n  enableAdvancedScheduling(): void;\n  reportConflict(type: 'resource' | 'task', id: string, agents: string[]): Promise<void>;\n}\n\n/**\n * Coordination manager implementation\n */\nexport class CoordinationManager implements ICoordinationManager {\n  private scheduler: TaskScheduler;\n  private resourceManager: ResourceManager;\n  private messageRouter: MessageRouter;\n  private conflictResolver: ConflictResolver;\n  private metricsCollector: CoordinationMetricsCollector;\n  private initialized = false;\n  private deadlockCheckInterval?: ReturnType<typeof setInterval>;\n  private advancedSchedulingEnabled = false;\n\n  constructor(\n    private config: CoordinationConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    this.scheduler = new TaskScheduler(config, eventBus, logger);\n    this.resourceManager = new ResourceManager(config, eventBus, logger);\n    this.messageRouter = new MessageRouter(config, eventBus, logger);\n    this.conflictResolver = new ConflictResolver(logger, eventBus);\n    this.metricsCollector = new CoordinationMetricsCollector(logger, eventBus);\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    this.logger.info('Initializing coordination manager...');\n\n    try {\n      // Initialize components\n      await this.scheduler.initialize();\n      await this.resourceManager.initialize();\n      await this.messageRouter.initialize();\n\n      // Start metrics collection\n      this.metricsCollector.start();\n\n      // Start deadlock detection if enabled\n      if (this.config.deadlockDetection) {\n        this.startDeadlockDetection();\n      }\n\n      // Set up event handlers\n      this.setupEventHandlers();\n\n      this.initialized = true;\n      this.logger.info('Coordination manager initialized');\n    } catch (error) {\n      this.logger.error('Failed to initialize coordination manager', error);\n      throw new CoordinationError('Coordination manager initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down coordination manager...');\n\n    try {\n      // Stop deadlock detection\n      if (this.deadlockCheckInterval) {\n        clearInterval(this.deadlockCheckInterval);\n      }\n\n      // Stop metrics collection\n      this.metricsCollector.stop();\n\n      // Shutdown components\n      await Promise.all([\n        this.scheduler.shutdown(),\n        this.resourceManager.shutdown(),\n        this.messageRouter.shutdown(),\n      ]);\n\n      this.initialized = false;\n      this.logger.info('Coordination manager shutdown complete');\n    } catch (error) {\n      this.logger.error('Error during coordination manager shutdown', error);\n      throw error;\n    }\n  }\n\n  async assignTask(task: Task, agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.scheduler.assignTask(task, agentId);\n  }\n\n  async getAgentTaskCount(agentId: string): Promise<number> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    return this.scheduler.getAgentTaskCount(agentId);\n  }\n\n  async acquireResource(resourceId: string, agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.resourceManager.acquire(resourceId, agentId);\n  }\n\n  async releaseResource(resourceId: string, agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.resourceManager.release(resourceId, agentId);\n  }\n\n  async sendMessage(from: string, to: string, message: unknown): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.messageRouter.send(from, to, message);\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const [schedulerHealth, resourceHealth, messageHealth] = await Promise.all([\n        this.scheduler.getHealthStatus(),\n        this.resourceManager.getHealthStatus(),\n        this.messageRouter.getHealthStatus(),\n      ]);\n\n      const metrics = {\n        ...schedulerHealth.metrics,\n        ...resourceHealth.metrics,\n        ...messageHealth.metrics,\n      };\n\n      const healthy = schedulerHealth.healthy && resourceHealth.healthy && messageHealth.healthy;\n\n      const errors = [schedulerHealth.error, resourceHealth.error, messageHealth.error].filter(\n        Boolean,\n      );\n\n      const status: { healthy: boolean; error?: string; metrics?: Record<string, number> } = {\n        healthy,\n        metrics,\n      };\n      if (errors.length > 0) {\n        status.error = errors.join('; ');\n      }\n      return status;\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Handle task events\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: unknown) => {\n      const { taskId, result } = data as { taskId: string; result: unknown };\n      try {\n        await this.scheduler.completeTask(taskId, result);\n      } catch (error) {\n        this.logger.error('Error handling task completion', { taskId, error });\n      }\n    });\n\n    this.eventBus.on(SystemEvents.TASK_FAILED, async (data: unknown) => {\n      const { taskId, error } = data as { taskId: string; error: Error };\n      try {\n        await this.scheduler.failTask(taskId, error);\n      } catch (err) {\n        this.logger.error('Error handling task failure', { taskId, error: err });\n      }\n    });\n\n    // Handle agent termination\n    this.eventBus.on(SystemEvents.AGENT_TERMINATED, async (data: unknown) => {\n      const { agentId } = data as { agentId: string };\n      try {\n        // Release all resources held by the agent\n        await this.resourceManager.releaseAllForAgent(agentId);\n\n        // Cancel all tasks assigned to the agent\n        await this.scheduler.cancelAgentTasks(agentId);\n      } catch (error) {\n        this.logger.error('Error handling agent termination', { agentId, error });\n      }\n    });\n  }\n\n  private startDeadlockDetection(): void {\n    this.deadlockCheckInterval = setInterval(async () => {\n      try {\n        const deadlock = await this.detectDeadlock();\n\n        if (deadlock) {\n          this.logger.error('Deadlock detected', deadlock);\n\n          // Emit deadlock event\n          this.eventBus.emit(SystemEvents.DEADLOCK_DETECTED, deadlock);\n\n          // Attempt to resolve deadlock\n          await this.resolveDeadlock(deadlock);\n        }\n      } catch (error) {\n        this.logger.error('Error during deadlock detection', error);\n      }\n    }, 10000); // Check every 10 seconds\n  }\n\n  private async detectDeadlock(): Promise<{\n    agents: string[];\n    resources: string[];\n  } | null> {\n    // Get resource allocation graph\n    const allocations = await this.resourceManager.getAllocations();\n    const waitingFor = await this.resourceManager.getWaitingRequests();\n\n    // Build dependency graph\n    const graph = new Map<string, Set<string>>();\n\n    // Add edges for resources agents are waiting for\n    for (const [agentId, resources] of waitingFor) {\n      if (!graph.has(agentId)) {\n        graph.set(agentId, new Set());\n      }\n\n      // Find who owns these resources\n      for (const resource of resources) {\n        const owner = allocations.get(resource);\n        if (owner && owner !== agentId) {\n          graph.get(agentId)!.add(owner);\n        }\n      }\n    }\n\n    // Detect cycles using DFS\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const cycle: string[] = [];\n\n    const hasCycle = (node: string): boolean => {\n      visited.add(node);\n      recursionStack.add(node);\n\n      const neighbors = graph.get(node) || new Set();\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          if (hasCycle(neighbor)) {\n            cycle.unshift(node);\n            return true;\n          }\n        } else if (recursionStack.has(neighbor)) {\n          cycle.unshift(node);\n          cycle.unshift(neighbor);\n          return true;\n        }\n      }\n\n      recursionStack.delete(node);\n      return false;\n    };\n\n    // Check for cycles\n    for (const node of graph.keys()) {\n      if (!visited.has(node) && hasCycle(node)) {\n        // Extract unique agents in cycle\n        const agents = Array.from(new Set(cycle));\n\n        // Find resources involved\n        const resources: string[] = [];\n        for (const agent of agents) {\n          const waiting = waitingFor.get(agent) || [];\n          resources.push(...waiting);\n        }\n\n        return {\n          agents,\n          resources: Array.from(new Set(resources)),\n        };\n      }\n    }\n\n    return null;\n  }\n\n  private async resolveDeadlock(deadlock: {\n    agents: string[];\n    resources: string[];\n  }): Promise<void> {\n    this.logger.warn('Attempting to resolve deadlock', deadlock);\n\n    // Simple resolution: release resources from the lowest priority agent\n    // In a real implementation, use more sophisticated strategies\n\n    try {\n      // Find the agent with the lowest priority or least work done\n      const agentToPreempt = deadlock.agents[0]; // Simplified\n\n      // Release all resources held by this agent\n      await this.resourceManager.releaseAllForAgent(agentToPreempt);\n\n      // Reschedule the agent's tasks\n      await this.scheduler.rescheduleAgentTasks(agentToPreempt);\n\n      this.logger.info('Deadlock resolved by preempting agent', {\n        agentId: agentToPreempt,\n      });\n    } catch (error) {\n      throw new DeadlockError('Failed to resolve deadlock', deadlock.agents, deadlock.resources);\n    }\n  }\n\n  async getAgentTasks(agentId: string): Promise<Task[]> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    return this.scheduler.getAgentTasks(agentId);\n  }\n\n  async cancelTask(taskId: string, reason?: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.scheduler.cancelTask(taskId, reason || 'User requested cancellation');\n  }\n\n  async performMaintenance(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.debug('Performing coordination manager maintenance');\n\n    try {\n      await Promise.all([\n        this.scheduler.performMaintenance(),\n        this.resourceManager.performMaintenance(),\n        this.messageRouter.performMaintenance(),\n      ]);\n\n      // Clean up old conflicts\n      this.conflictResolver.cleanupOldConflicts(24 * 60 * 60 * 1000); // 24 hours\n    } catch (error) {\n      this.logger.error('Error during coordination manager maintenance', error);\n    }\n  }\n\n  async getCoordinationMetrics(): Promise<Record<string, unknown>> {\n    const baseMetrics = await this.getHealthStatus();\n    const coordinationMetrics = this.metricsCollector.getCurrentMetrics();\n    const conflictStats = this.conflictResolver.getStats();\n\n    return {\n      ...baseMetrics.metrics,\n      coordination: coordinationMetrics,\n      conflicts: conflictStats,\n      advancedScheduling: this.advancedSchedulingEnabled,\n    };\n  }\n\n  enableAdvancedScheduling(): void {\n    if (this.advancedSchedulingEnabled) {\n      return;\n    }\n\n    this.logger.info('Enabling advanced scheduling features');\n\n    // Replace basic scheduler with advanced one\n    const advancedScheduler = new AdvancedTaskScheduler(this.config, this.eventBus, this.logger);\n\n    // Transfer state if needed (in a real implementation)\n    this.scheduler = advancedScheduler;\n    this.advancedSchedulingEnabled = true;\n  }\n\n  async reportConflict(type: 'resource' | 'task', id: string, agents: string[]): Promise<void> {\n    this.logger.warn('Conflict reported', { type, id, agents });\n\n    let conflict;\n    if (type === 'resource') {\n      conflict = await this.conflictResolver.reportResourceConflict(id, agents);\n    } else {\n      conflict = await this.conflictResolver.reportTaskConflict(id, agents, 'assignment');\n    }\n\n    // Auto-resolve using default strategy\n    try {\n      await this.conflictResolver.autoResolve(conflict.id);\n    } catch (error) {\n      this.logger.error('Failed to auto-resolve conflict', {\n        conflictId: conflict.id,\n        error,\n      });\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
