{
  "version": 3,
  "sources": ["../../../src/swarm/strategies/base.ts"],
  "sourcesContent": ["/**\n * Base Strategy Interface for Swarm Task Execution\n * Provides the foundation for different task execution strategies\n */\n\nimport type { TaskDefinition, SwarmObjective, AgentState, SwarmConfig } from '../types.js';\n\nexport interface StrategyMetrics {\n  tasksCompleted: number;\n  averageExecutionTime: number;\n  successRate: number;\n  resourceUtilization: number;\n  parallelismEfficiency: number;\n  cacheHitRate: number;\n  predictionAccuracy: number;\n  // Additional metrics\n  queriesExecuted?: number;\n  averageResponseTime?: number;\n  cacheHits?: number;\n  cacheMisses?: number;\n  credibilityScores?: Record<string, number>;\n}\n\nexport interface TaskPattern {\n  pattern: RegExp;\n  type: string;\n  complexity: number;\n  estimatedDuration: number;\n  requiredAgents: number;\n  priority: number;\n}\n\nexport interface DecompositionResult {\n  tasks: TaskDefinition[];\n  dependencies: Map<string, string[]>;\n  estimatedDuration: number;\n  recommendedStrategy: string;\n  complexity: number;\n  batchGroups: TaskBatch[];\n  // Additional properties for caching and memory\n  timestamp: Date;\n  ttl: number;\n  accessCount: number;\n  lastAccessed: Date;\n  data: any;\n  // Resource requirements\n  resourceRequirements?: {\n    memory?: number;\n    cpu?: number;\n    network?: string;\n    storage?: string;\n  };\n}\n\nexport interface TaskBatch {\n  id: string;\n  tasks: TaskDefinition[];\n  canRunInParallel: boolean;\n  estimatedDuration: number;\n  requiredResources: Record<string, number>;\n}\n\nexport interface AgentAllocation {\n  agentId: string;\n  tasks: string[];\n  estimatedWorkload: number;\n  capabilities: string[];\n}\n\nexport abstract class BaseStrategy {\n  protected metrics: StrategyMetrics;\n  protected taskPatterns: TaskPattern[];\n  protected cache: Map<string, DecompositionResult>;\n  protected config: SwarmConfig;\n\n  constructor(config: SwarmConfig) {\n    this.config = config;\n    this.metrics = this.initializeMetrics();\n    this.taskPatterns = this.initializeTaskPatterns();\n    this.cache = new Map();\n  }\n\n  // Abstract methods that must be implemented by concrete strategies\n  abstract decomposeObjective(objective: SwarmObjective): Promise<DecompositionResult>;\n  abstract selectAgentForTask(\n    task: TaskDefinition,\n    availableAgents: AgentState[],\n  ): Promise<string | null>;\n  abstract optimizeTaskSchedule(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n  ): Promise<AgentAllocation[]>;\n\n  // Common utility methods\n  protected initializeMetrics(): StrategyMetrics {\n    return {\n      tasksCompleted: 0,\n      averageExecutionTime: 0,\n      successRate: 0,\n      resourceUtilization: 0,\n      parallelismEfficiency: 0,\n      cacheHitRate: 0,\n      predictionAccuracy: 0,\n    };\n  }\n\n  protected initializeTaskPatterns(): TaskPattern[] {\n    return [\n      {\n        pattern: /create|build|implement|develop/i,\n        type: 'development',\n        complexity: 3,\n        estimatedDuration: 15 * 60 * 1000,\n        requiredAgents: 2,\n        priority: 2,\n      },\n      {\n        pattern: /test|verify|validate/i,\n        type: 'testing',\n        complexity: 2,\n        estimatedDuration: 8 * 60 * 1000,\n        requiredAgents: 1,\n        priority: 1,\n      },\n      {\n        pattern: /analyze|research|investigate/i,\n        type: 'analysis',\n        complexity: 2,\n        estimatedDuration: 10 * 60 * 1000,\n        requiredAgents: 1,\n        priority: 1,\n      },\n      {\n        pattern: /document|write|explain/i,\n        type: 'documentation',\n        complexity: 1,\n        estimatedDuration: 5 * 60 * 1000,\n        requiredAgents: 1,\n        priority: 0,\n      },\n      {\n        pattern: /optimize|improve|refactor/i,\n        type: 'optimization',\n        complexity: 3,\n        estimatedDuration: 12 * 60 * 1000,\n        requiredAgents: 2,\n        priority: 1,\n      },\n    ];\n  }\n\n  protected detectTaskType(description: string): string {\n    for (const pattern of this.taskPatterns) {\n      if (pattern.pattern.test(description)) {\n        return pattern.type;\n      }\n    }\n    return 'generic';\n  }\n\n  protected estimateComplexity(description: string): number {\n    const pattern = this.taskPatterns.find((p) => p.pattern.test(description));\n    if (pattern) {\n      return pattern.complexity;\n    }\n\n    // Fallback complexity estimation based on description length and keywords\n    let complexity = 1;\n    const words = description.split(' ').length;\n\n    if (words > 50) complexity += 1;\n    if (words > 100) complexity += 1;\n\n    const complexKeywords = ['integrate', 'complex', 'advanced', 'multiple', 'system'];\n    const foundKeywords = complexKeywords.filter((keyword) =>\n      description.toLowerCase().includes(keyword),\n    ).length;\n\n    complexity += foundKeywords;\n\n    return Math.min(complexity, 5); // Cap at 5\n  }\n\n  protected getCacheKey(objective: SwarmObjective): string {\n    return `${objective.strategy}-${objective.description.slice(0, 100)}`;\n  }\n\n  protected updateMetrics(result: DecompositionResult, executionTime: number): void {\n    this.metrics.tasksCompleted += result.tasks.length;\n    this.metrics.averageExecutionTime = (this.metrics.averageExecutionTime + executionTime) / 2;\n  }\n\n  public getMetrics(): StrategyMetrics {\n    return { ...this.metrics };\n  }\n\n  public clearCache(): void {\n    this.cache.clear();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAqEO,MAAe,aAAa;AAAA,EArEnC,OAqEmC;AAAA;AAAA;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEV,YAAY,QAAqB;AAC/B,SAAK,SAAS;AACd,SAAK,UAAU,KAAK,kBAAkB;AACtC,SAAK,eAAe,KAAK,uBAAuB;AAChD,SAAK,QAAQ,oBAAI,IAAI;AAAA,EACvB;AAAA;AAAA,EAcU,oBAAqC;AAC7C,WAAO;AAAA,MACL,gBAAgB;AAAA,MAChB,sBAAsB;AAAA,MACtB,aAAa;AAAA,MACb,qBAAqB;AAAA,MACrB,uBAAuB;AAAA,MACvB,cAAc;AAAA,MACd,oBAAoB;AAAA,IACtB;AAAA,EACF;AAAA,EAEU,yBAAwC;AAChD,WAAO;AAAA,MACL;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,mBAAmB,KAAK,KAAK;AAAA,QAC7B,gBAAgB;AAAA,QAChB,UAAU;AAAA,MACZ;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,mBAAmB,IAAI,KAAK;AAAA,QAC5B,gBAAgB;AAAA,QAChB,UAAU;AAAA,MACZ;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,mBAAmB,KAAK,KAAK;AAAA,QAC7B,gBAAgB;AAAA,QAChB,UAAU;AAAA,MACZ;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,mBAAmB,IAAI,KAAK;AAAA,QAC5B,gBAAgB;AAAA,QAChB,UAAU;AAAA,MACZ;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,mBAAmB,KAAK,KAAK;AAAA,QAC7B,gBAAgB;AAAA,QAChB,UAAU;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AAAA,EAEU,eAAe,aAA6B;AACpD,eAAW,WAAW,KAAK,cAAc;AACvC,UAAI,QAAQ,QAAQ,KAAK,WAAW,GAAG;AACrC,eAAO,QAAQ;AAAA,MACjB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEU,mBAAmB,aAA6B;AACxD,UAAM,UAAU,KAAK,aAAa,KAAK,CAAC,MAAM,EAAE,QAAQ,KAAK,WAAW,CAAC;AACzE,QAAI,SAAS;AACX,aAAO,QAAQ;AAAA,IACjB;AAGA,QAAI,aAAa;AACjB,UAAM,QAAQ,YAAY,MAAM,GAAG,EAAE;AAErC,QAAI,QAAQ;AAAI,oBAAc;AAC9B,QAAI,QAAQ;AAAK,oBAAc;AAE/B,UAAM,kBAAkB,CAAC,aAAa,WAAW,YAAY,YAAY,QAAQ;AACjF,UAAM,gBAAgB,gBAAgB;AAAA,MAAO,CAAC,YAC5C,YAAY,YAAY,EAAE,SAAS,OAAO;AAAA,IAC5C,EAAE;AAEF,kBAAc;AAEd,WAAO,KAAK,IAAI,YAAY,CAAC;AAAA,EAC/B;AAAA,EAEU,YAAY,WAAmC;AACvD,WAAO,GAAG,UAAU,QAAQ,IAAI,UAAU,YAAY,MAAM,GAAG,GAAG,CAAC;AAAA,EACrE;AAAA,EAEU,cAAc,QAA6B,eAA6B;AAChF,SAAK,QAAQ,kBAAkB,OAAO,MAAM;AAC5C,SAAK,QAAQ,wBAAwB,KAAK,QAAQ,uBAAuB,iBAAiB;AAAA,EAC5F;AAAA,EAEO,aAA8B;AACnC,WAAO,EAAE,GAAG,KAAK,QAAQ;AAAA,EAC3B;AAAA,EAEO,aAAmB;AACxB,SAAK,MAAM,MAAM;AAAA,EACnB;AACF;",
  "names": []
}
