{
  "version": 3,
  "sources": ["../../../src/hive-mind/core/Communication.ts"],
  "sourcesContent": ["/**\n * Communication Class\n *\n * Manages inter-agent messaging, broadcasts, and communication protocols\n * within the Hive Mind swarm.\n */\n\nimport { EventEmitter } from 'events';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { Agent } from './Agent.js';\nimport {\n  Message,\n  MessageType,\n  MessagePriority,\n  CommunicationStats,\n  CommunicationChannel,\n} from '../types.js';\n\nexport class Communication extends EventEmitter {\n  private swarmId: string;\n  private db: DatabaseManager;\n  private agents: Map<string, Agent>;\n  private channels: Map<string, CommunicationChannel>;\n  private messageQueue: Map<MessagePriority, Message[]>;\n  private stats: CommunicationStats;\n  private isActive: boolean = false;\n\n  constructor(swarmId: string) {\n    super();\n    this.swarmId = swarmId;\n    this.agents = new Map();\n    this.channels = new Map();\n    this.messageQueue = new Map([\n      ['urgent', []],\n      ['high', []],\n      ['normal', []],\n      ['low', []],\n    ]);\n\n    this.stats = {\n      totalMessages: 0,\n      avgLatency: 0,\n      activeChannels: 0,\n      messagesByType: {},\n      throughput: 0,\n    };\n  }\n\n  /**\n   * Initialize communication system\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n\n    // Set up default channels\n    this.setupDefaultChannels();\n\n    // Start message processing\n    this.startMessageProcessor();\n    this.startLatencyMonitor();\n    this.startStatsCollector();\n\n    this.isActive = true;\n    this.emit('initialized');\n  }\n\n  /**\n   * Add an agent to the communication network\n   */\n  addAgent(agent: Agent): void {\n    this.agents.set(agent.id, agent);\n\n    // Create agent-specific channels\n    this.createAgentChannels(agent);\n\n    // Subscribe agent to relevant channels\n    this.subscribeAgentToChannels(agent);\n\n    this.emit('agentAdded', { agentId: agent.id });\n  }\n\n  /**\n   * Remove an agent from the communication network\n   */\n  removeAgent(agentId: string): void {\n    this.agents.delete(agentId);\n\n    // Remove agent from channels\n    this.channels.forEach((channel) => {\n      channel.subscribers = channel.subscribers.filter((id) => id !== agentId);\n    });\n\n    this.emit('agentRemoved', { agentId });\n  }\n\n  /**\n   * Send a message\n   */\n  async sendMessage(message: Message): Promise<void> {\n    // Store in database\n    await this.db.createCommunication({\n      from_agent_id: message.fromAgentId,\n      to_agent_id: message.toAgentId,\n      swarm_id: this.swarmId,\n      message_type: message.type,\n      content: JSON.stringify(message.content),\n      priority: message.priority || 'normal',\n      requires_response: message.requiresResponse || false,\n    });\n\n    // Add to queue\n    const priority = message.priority || 'normal';\n    this.messageQueue.get(priority)!.push(message);\n\n    // Update stats\n    this.stats.totalMessages++;\n    this.stats.messagesByType[message.type] = (this.stats.messagesByType[message.type] || 0) + 1;\n\n    this.emit('messageSent', message);\n  }\n\n  /**\n   * Broadcast a message to all agents\n   */\n  async broadcast(\n    fromAgentId: string,\n    type: MessageType,\n    content: any,\n    priority: MessagePriority = 'normal',\n  ): Promise<void> {\n    const message: Message = {\n      id: this.generateMessageId(),\n      fromAgentId,\n      toAgentId: null, // null indicates broadcast\n      swarmId: this.swarmId,\n      type,\n      content,\n      priority,\n      timestamp: new Date(),\n      requiresResponse: false,\n    };\n\n    await this.sendMessage(message);\n  }\n\n  /**\n   * Send a message to a specific channel\n   */\n  async sendToChannel(\n    channelName: string,\n    fromAgentId: string,\n    content: any,\n    priority: MessagePriority = 'normal',\n  ): Promise<void> {\n    const channel = this.channels.get(channelName);\n    if (!channel) {\n      throw new Error(`Channel ${channelName} not found`);\n    }\n\n    // Send to all subscribers\n    for (const subscriberId of channel.subscribers) {\n      if (subscriberId !== fromAgentId) {\n        const message: Message = {\n          id: this.generateMessageId(),\n          fromAgentId,\n          toAgentId: subscriberId,\n          swarmId: this.swarmId,\n          type: 'channel',\n          content: {\n            channel: channelName,\n            data: content,\n          },\n          priority,\n          timestamp: new Date(),\n          requiresResponse: false,\n        };\n\n        await this.sendMessage(message);\n      }\n    }\n  }\n\n  /**\n   * Request response from an agent\n   */\n  async requestResponse(\n    fromAgentId: string,\n    toAgentId: string,\n    query: any,\n    timeout: number = 5000,\n  ): Promise<any> {\n    const message: Message = {\n      id: this.generateMessageId(),\n      fromAgentId,\n      toAgentId,\n      swarmId: this.swarmId,\n      type: 'query',\n      content: query,\n      priority: 'high',\n      timestamp: new Date(),\n      requiresResponse: true,\n    };\n\n    await this.sendMessage(message);\n\n    // Wait for response\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error('Response timeout'));\n      }, timeout);\n\n      const responseHandler = (response: Message) => {\n        if (response.content.queryId === message.id) {\n          clearTimeout(timer);\n          this.off('messageReceived', responseHandler);\n          resolve(response.content.response);\n        }\n      };\n\n      this.on('messageReceived', responseHandler);\n    });\n  }\n\n  /**\n   * Create a new communication channel\n   */\n  createChannel(name: string, description: string, type: 'public' | 'private' = 'public'): void {\n    if (this.channels.has(name)) {\n      throw new Error(`Channel ${name} already exists`);\n    }\n\n    const channel: CommunicationChannel = {\n      name,\n      description,\n      type,\n      subscribers: [],\n      createdAt: new Date(),\n    };\n\n    this.channels.set(name, channel);\n    this.stats.activeChannels++;\n\n    this.emit('channelCreated', { channel });\n  }\n\n  /**\n   * Subscribe an agent to a channel\n   */\n  subscribeToChannel(agentId: string, channelName: string): void {\n    const channel = this.channels.get(channelName);\n    if (!channel) {\n      throw new Error(`Channel ${channelName} not found`);\n    }\n\n    if (!channel.subscribers.includes(agentId)) {\n      channel.subscribers.push(agentId);\n      this.emit('channelSubscribed', { agentId, channelName });\n    }\n  }\n\n  /**\n   * Unsubscribe an agent from a channel\n   */\n  unsubscribeFromChannel(agentId: string, channelName: string): void {\n    const channel = this.channels.get(channelName);\n    if (!channel) {\n      return;\n    }\n\n    channel.subscribers = channel.subscribers.filter((id) => id !== agentId);\n    this.emit('channelUnsubscribed', { agentId, channelName });\n  }\n\n  /**\n   * Get communication statistics\n   */\n  async getStats(): Promise<CommunicationStats> {\n    // Calculate throughput\n    const recentMessages = await this.db.getRecentMessages(this.swarmId, 60000); // Last minute\n    this.stats.throughput = recentMessages.length;\n\n    return { ...this.stats };\n  }\n\n  /**\n   * Get pending messages for an agent\n   */\n  async getPendingMessages(agentId: string): Promise<Message[]> {\n    const messages = await this.db.getPendingMessages(agentId);\n\n    return messages.map((msg) => ({\n      id: msg.id.toString(),\n      fromAgentId: msg.from_agent_id,\n      toAgentId: msg.to_agent_id,\n      swarmId: msg.swarm_id,\n      type: msg.message_type as MessageType,\n      content: JSON.parse(msg.content),\n      priority: msg.priority as MessagePriority,\n      timestamp: new Date(msg.timestamp),\n      requiresResponse: msg.requires_response,\n    }));\n  }\n\n  /**\n   * Mark message as delivered\n   */\n  async markDelivered(messageId: string): Promise<void> {\n    await this.db.markMessageDelivered(messageId);\n  }\n\n  /**\n   * Mark message as read\n   */\n  async markRead(messageId: string): Promise<void> {\n    await this.db.markMessageRead(messageId);\n  }\n\n  /**\n   * Setup default communication channels\n   */\n  private setupDefaultChannels(): void {\n    // System channels\n    this.createChannel('system', 'System-wide notifications and alerts');\n    this.createChannel('coordination', 'Task coordination messages');\n    this.createChannel('consensus', 'Consensus voting and decisions');\n    this.createChannel('monitoring', 'Performance and health monitoring');\n\n    // Agent type channels\n    this.createChannel('coordinators', 'Coordinator agent communications');\n    this.createChannel('researchers', 'Researcher agent communications');\n    this.createChannel('coders', 'Coder agent communications');\n    this.createChannel('analysts', 'Analyst agent communications');\n  }\n\n  /**\n   * Create channels for a specific agent\n   */\n  private createAgentChannels(agent: Agent): void {\n    // Direct message channel\n    this.createChannel(`agent-${agent.id}`, `Direct messages for ${agent.name}`, 'private');\n\n    // Team channel if agent is coordinator\n    if (agent.type === 'coordinator') {\n      this.createChannel(`team-${agent.id}`, `Team channel led by ${agent.name}`);\n    }\n  }\n\n  /**\n   * Subscribe agent to relevant channels\n   */\n  private subscribeAgentToChannels(agent: Agent): void {\n    // Subscribe to system channels\n    this.subscribeToChannel(agent.id, 'system');\n    this.subscribeToChannel(agent.id, 'coordination');\n\n    // Subscribe to type-specific channel\n    const typeChannel = `${agent.type}s`;\n    if (this.channels.has(typeChannel)) {\n      this.subscribeToChannel(agent.id, typeChannel);\n    }\n\n    // Subscribe to own direct channel\n    this.subscribeToChannel(agent.id, `agent-${agent.id}`);\n\n    // Special subscriptions based on capabilities\n    if (agent.capabilities.includes('consensus_building')) {\n      this.subscribeToChannel(agent.id, 'consensus');\n    }\n\n    if (agent.capabilities.includes('system_monitoring')) {\n      this.subscribeToChannel(agent.id, 'monitoring');\n    }\n  }\n\n  /**\n   * Start message processor\n   */\n  private startMessageProcessor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Process messages by priority\n      for (const [priority, messages] of this.messageQueue) {\n        if (messages.length === 0) continue;\n\n        // Process batch of messages\n        const batch = messages.splice(0, 10); // Process up to 10 messages\n\n        for (const message of batch) {\n          await this.processMessage(message);\n        }\n      }\n    }, 100); // Every 100ms\n  }\n\n  /**\n   * Process a single message\n   */\n  private async processMessage(message: Message): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      if (message.toAgentId) {\n        // Direct message\n        const agent = this.agents.get(message.toAgentId);\n        if (agent) {\n          await agent.receiveMessage(message);\n          await this.markDelivered(message.id);\n        }\n      } else {\n        // Broadcast message\n        for (const agent of this.agents.values()) {\n          if (agent.id !== message.fromAgentId) {\n            await agent.receiveMessage(message);\n          }\n        }\n      }\n\n      // Update latency stats\n      const latency = Date.now() - startTime;\n      this.updateLatencyStats(latency);\n\n      this.emit('messageProcessed', { message, latency });\n    } catch (error) {\n      this.emit('messageError', { message, error });\n    }\n  }\n\n  /**\n   * Update latency statistics\n   */\n  private updateLatencyStats(latency: number): void {\n    // Simple moving average\n    this.stats.avgLatency = this.stats.avgLatency * 0.9 + latency * 0.1;\n  }\n\n  /**\n   * Start latency monitor\n   */\n  private startLatencyMonitor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Check for high latency\n      if (this.stats.avgLatency > 1000) {\n        this.emit('highLatency', { avgLatency: this.stats.avgLatency });\n      }\n    }, 5000); // Every 5 seconds\n  }\n\n  /**\n   * Start statistics collector\n   */\n  private startStatsCollector(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Store stats in database\n      await this.db.storePerformanceMetric({\n        swarm_id: this.swarmId,\n        metric_type: 'communication_throughput',\n        metric_value: this.stats.throughput,\n      });\n\n      await this.db.storePerformanceMetric({\n        swarm_id: this.swarmId,\n        metric_type: 'communication_latency',\n        metric_value: this.stats.avgLatency,\n      });\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Generate unique message ID\n   */\n  private generateMessageId(): string {\n    return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Shutdown communication system\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Clear queues\n    this.messageQueue.forEach((queue) => (queue.length = 0));\n\n    // Clear channels\n    this.channels.clear();\n\n    this.emit('shutdown');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
