{
  "version": 3,
  "sources": ["../../src/memory/advanced-memory-manager.ts"],
  "sourcesContent": ["/**\n * Advanced Memory Management System with comprehensive capabilities\n * Includes indexing, compression, cross-agent sharing, and intelligent cleanup\n */\n\nimport { EventEmitter } from 'node:events';\nimport { promises as fs } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { join, dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport type { ILogger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\n\n// === INTERFACES ===\n\nexport interface MemoryEntry {\n  id: string;\n  key: string;\n  value: any;\n  type: string;\n  namespace: string;\n  tags: string[];\n  metadata: Record<string, any>;\n  owner: string;\n  accessLevel: 'private' | 'shared' | 'public';\n  createdAt: Date;\n  updatedAt: Date;\n  lastAccessedAt: Date;\n  expiresAt?: Date;\n  version: number;\n  size: number;\n  compressed: boolean;\n  checksum: string;\n  references: string[];\n  dependencies: string[];\n}\n\nexport interface MemoryIndex {\n  keys: Map<string, string[]>; // key -> entryIds\n  tags: Map<string, string[]>; // tag -> entryIds\n  types: Map<string, string[]>; // type -> entryIds\n  namespaces: Map<string, string[]>; // namespace -> entryIds\n  owners: Map<string, string[]>; // owner -> entryIds\n  fullText: Map<string, string[]>; // word -> entryIds\n}\n\nexport interface QueryOptions {\n  namespace?: string;\n  type?: string;\n  tags?: string[];\n  owner?: string;\n  accessLevel?: 'private' | 'shared' | 'public';\n  keyPattern?: string;\n  valueSearch?: string;\n  fullTextSearch?: string;\n  createdAfter?: Date;\n  createdBefore?: Date;\n  updatedAfter?: Date;\n  updatedBefore?: Date;\n  lastAccessedAfter?: Date;\n  lastAccessedBefore?: Date;\n  sizeGreaterThan?: number;\n  sizeLessThan?: number;\n  includeExpired?: boolean;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'key' | 'createdAt' | 'updatedAt' | 'lastAccessedAt' | 'size' | 'type';\n  sortOrder?: 'asc' | 'desc';\n  aggregateBy?: 'namespace' | 'type' | 'owner' | 'tags';\n  includeMetadata?: boolean;\n}\n\nexport interface ExportOptions {\n  format: 'json' | 'csv' | 'xml' | 'yaml';\n  namespace?: string;\n  type?: string;\n  includeMetadata?: boolean;\n  compression?: boolean;\n  encryption?: {\n    enabled: boolean;\n    algorithm?: string;\n    key?: string;\n  };\n  filtering?: QueryOptions;\n}\n\nexport interface ImportOptions {\n  format: 'json' | 'csv' | 'xml' | 'yaml';\n  namespace?: string;\n  conflictResolution: 'overwrite' | 'skip' | 'merge' | 'rename';\n  validation?: boolean;\n  transformation?: {\n    keyMapping?: Record<string, string>;\n    valueTransformation?: (value: any) => any;\n    metadataExtraction?: (entry: any) => Record<string, any>;\n  };\n  dryRun?: boolean;\n}\n\nexport interface MemoryStatistics {\n  overview: {\n    totalEntries: number;\n    totalSize: number;\n    compressedEntries: number;\n    compressionRatio: number;\n    indexSize: number;\n    memoryUsage: number;\n    diskUsage: number;\n  };\n  distribution: {\n    byNamespace: Record<string, { count: number; size: number }>;\n    byType: Record<string, { count: number; size: number }>;\n    byOwner: Record<string, { count: number; size: number }>;\n    byAccessLevel: Record<string, { count: number; size: number }>;\n  };\n  temporal: {\n    entriesCreatedLast24h: number;\n    entriesUpdatedLast24h: number;\n    entriesAccessedLast24h: number;\n    oldestEntry?: Date;\n    newestEntry?: Date;\n  };\n  performance: {\n    averageQueryTime: number;\n    averageWriteTime: number;\n    cacheHitRatio: number;\n    indexEfficiency: number;\n  };\n  health: {\n    expiredEntries: number;\n    orphanedReferences: number;\n    duplicateKeys: number;\n    corruptedEntries: number;\n    recommendedCleanup: boolean;\n  };\n  optimization: {\n    suggestions: string[];\n    potentialSavings: {\n      compression: number;\n      cleanup: number;\n      deduplication: number;\n    };\n    indexOptimization: string[];\n  };\n}\n\nexport interface CleanupOptions {\n  dryRun?: boolean;\n  removeExpired?: boolean;\n  removeOlderThan?: number; // days\n  removeUnaccessed?: number; // days since last access\n  removeOrphaned?: boolean;\n  removeDuplicates?: boolean;\n  compressEligible?: boolean;\n  archiveOld?: {\n    enabled: boolean;\n    olderThan: number; // days\n    archivePath: string;\n  };\n  retentionPolicies?: {\n    namespace: string;\n    maxAge?: number; // days\n    maxCount?: number;\n    sizeLimit?: number; // bytes\n  }[];\n}\n\nexport interface RetentionPolicy {\n  id: string;\n  name: string;\n  namespace?: string;\n  type?: string;\n  tags?: string[];\n  maxAge?: number; // days\n  maxCount?: number;\n  sizeLimit?: number; // bytes\n  priority: number;\n  enabled: boolean;\n}\n\n// === MAIN CLASS ===\n\nexport class AdvancedMemoryManager extends EventEmitter {\n  private readonly dataPath: string;\n  private readonly indexPath: string;\n  private readonly backupPath: string;\n  private readonly archivePath: string;\n\n  private entries = new Map<string, MemoryEntry>();\n  private index: MemoryIndex;\n  private cache = new Map<string, { entry: MemoryEntry; expiry: number }>();\n  private retentionPolicies = new Map<string, RetentionPolicy>();\n\n  private logger: ILogger;\n  private config: {\n    maxMemorySize: number;\n    cacheSize: number;\n    cacheTtl: number;\n    autoCompress: boolean;\n    autoCleanup: boolean;\n    cleanupInterval: number;\n    indexingEnabled: boolean;\n    persistenceEnabled: boolean;\n    compressionThreshold: number;\n    backupRetention: number;\n  };\n\n  private statistics: MemoryStatistics;\n  private operationMetrics = new Map<string, { count: number; totalTime: number }>();\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(\n    config: Partial<typeof AdvancedMemoryManager.prototype.config> = {},\n    logger: ILogger,\n  ) {\n    super();\n\n    this.logger = logger;\n    this.config = {\n      maxMemorySize: 1024 * 1024 * 1024, // 1GB\n      cacheSize: 10000,\n      cacheTtl: 300000, // 5 minutes\n      autoCompress: true,\n      autoCleanup: true,\n      cleanupInterval: 3600000, // 1 hour\n      indexingEnabled: true,\n      persistenceEnabled: true,\n      compressionThreshold: 1024, // 1KB\n      backupRetention: 7, // days\n      ...config,\n    };\n\n    // Setup file paths\n    const __dirname = dirname(fileURLToPath(import.meta.url));\n    this.dataPath = join(process.cwd(), 'memory', 'data');\n    this.indexPath = join(process.cwd(), 'memory', 'index');\n    this.backupPath = join(process.cwd(), 'memory', 'backups');\n    this.archivePath = join(process.cwd(), 'memory', 'archive');\n\n    this.index = this.createEmptyIndex();\n    this.statistics = this.initializeStatistics();\n  }\n\n  // === INITIALIZATION ===\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Advanced Memory Manager');\n\n    // Create directories\n    await Promise.all([\n      fs.mkdir(this.dataPath, { recursive: true }),\n      fs.mkdir(this.indexPath, { recursive: true }),\n      fs.mkdir(this.backupPath, { recursive: true }),\n      fs.mkdir(this.archivePath, { recursive: true }),\n    ]);\n\n    // Load persisted data\n    if (this.config.persistenceEnabled) {\n      await this.loadPersistedData();\n    }\n\n    // Start automatic cleanup if enabled\n    if (this.config.autoCleanup) {\n      this.startAutoCleanup();\n    }\n\n    this.emit('memory:initialized');\n    this.logger.info('Advanced Memory Manager initialized successfully');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Advanced Memory Manager');\n\n    // Stop cleanup interval\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    // Persist data\n    if (this.config.persistenceEnabled) {\n      await this.persistData();\n    }\n\n    // Create backup\n    await this.createBackup();\n\n    this.emit('memory:shutdown');\n  }\n\n  // === CORE OPERATIONS ===\n\n  async store(\n    key: string,\n    value: any,\n    options: {\n      namespace?: string;\n      type?: string;\n      tags?: string[];\n      metadata?: Record<string, any>;\n      owner?: string;\n      accessLevel?: 'private' | 'shared' | 'public';\n      ttl?: number;\n      compress?: boolean;\n    } = {},\n  ): Promise<string> {\n    const startTime = Date.now();\n\n    try {\n      const entryId = generateId('entry');\n      const now = new Date();\n\n      // Process value (compression, serialization)\n      const processedValue = await this.processValue(value, options.compress);\n      const size = this.calculateSize(processedValue);\n\n      // Create entry\n      const entry: MemoryEntry = {\n        id: entryId,\n        key,\n        value: processedValue.value,\n        type: options.type || this.inferType(value),\n        namespace: options.namespace || 'default',\n        tags: options.tags || [],\n        metadata: options.metadata || {},\n        owner: options.owner || 'system',\n        accessLevel: options.accessLevel || 'shared',\n        createdAt: now,\n        updatedAt: now,\n        lastAccessedAt: now,\n        expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n        version: 1,\n        size,\n        compressed: processedValue.compressed,\n        checksum: this.calculateChecksum(processedValue.value),\n        references: [],\n        dependencies: [],\n      };\n\n      // Store entry\n      this.entries.set(entryId, entry);\n\n      // Update index\n      if (this.config.indexingEnabled) {\n        this.updateIndex(entry, 'create');\n      }\n\n      // Update cache\n      this.updateCache(key, entry);\n\n      // Apply retention policies\n      await this.applyRetentionPolicies(entry);\n\n      this.logger.debug('Memory entry stored', { entryId, key, namespace: entry.namespace });\n      this.emit('memory:entry-stored', { entry });\n\n      this.recordMetric('store', Date.now() - startTime);\n      return entryId;\n    } catch (error) {\n      this.recordMetric('store-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async retrieve(\n    key: string,\n    options: {\n      namespace?: string;\n      updateLastAccessed?: boolean;\n    } = {},\n  ): Promise<MemoryEntry | null> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const cached = this.cache.get(key);\n      if (cached && cached.expiry > Date.now()) {\n        this.recordMetric('retrieve-cache', Date.now() - startTime);\n        return cached.entry;\n      }\n\n      // Search in entries\n      const entry = this.findEntryByKey(key, options.namespace);\n      if (!entry) {\n        this.recordMetric('retrieve-miss', Date.now() - startTime);\n        return null;\n      }\n\n      // Check if expired\n      if (entry.expiresAt && entry.expiresAt < new Date()) {\n        await this.deleteEntry(entry.id);\n        this.recordMetric('retrieve-expired', Date.now() - startTime);\n        return null;\n      }\n\n      // Update last accessed\n      if (options.updateLastAccessed !== false) {\n        entry.lastAccessedAt = new Date();\n      }\n\n      // Decompress if needed\n      if (entry.compressed) {\n        entry.value = await this.decompressValue(entry.value);\n      }\n\n      // Update cache\n      this.updateCache(key, entry);\n\n      this.recordMetric('retrieve', Date.now() - startTime);\n      return entry;\n    } catch (error) {\n      this.recordMetric('retrieve-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async update(\n    key: string,\n    value: any,\n    options: {\n      namespace?: string;\n      merge?: boolean;\n      updateMetadata?: Record<string, any>;\n    } = {},\n  ): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = await this.retrieve(key, { namespace: options.namespace });\n      if (!entry) {\n        this.recordMetric('update-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Process new value\n      const processedValue = await this.processValue(value, entry.compressed);\n\n      // Update entry\n      if (options.merge && typeof entry.value === 'object' && typeof value === 'object') {\n        entry.value = { ...entry.value, ...processedValue.value };\n      } else {\n        entry.value = processedValue.value;\n      }\n\n      entry.updatedAt = new Date();\n      entry.lastAccessedAt = new Date();\n      entry.version++;\n      entry.size = this.calculateSize(entry.value);\n      entry.checksum = this.calculateChecksum(entry.value);\n\n      if (options.updateMetadata) {\n        entry.metadata = { ...entry.metadata, ...options.updateMetadata };\n      }\n\n      // Update index\n      if (this.config.indexingEnabled) {\n        this.updateIndex(entry, 'update');\n      }\n\n      // Update cache\n      this.updateCache(key, entry);\n\n      this.logger.debug('Memory entry updated', { entryId: entry.id, key });\n      this.emit('memory:entry-updated', { entry });\n\n      this.recordMetric('update', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('update-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async deleteEntry(entryId: string): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = this.entries.get(entryId);\n      if (!entry) {\n        this.recordMetric('delete-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Remove from storage\n      this.entries.delete(entryId);\n\n      // Update index\n      if (this.config.indexingEnabled) {\n        this.updateIndex(entry, 'delete');\n      }\n\n      // Remove from cache\n      this.cache.delete(entry.key);\n\n      this.logger.debug('Memory entry deleted', { entryId, key: entry.key });\n      this.emit('memory:entry-deleted', { entryId });\n\n      this.recordMetric('delete', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('delete-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === ADVANCED QUERY OPERATIONS ===\n\n  async query(options: QueryOptions = {}): Promise<{\n    entries: MemoryEntry[];\n    total: number;\n    aggregations?: Record<string, any>;\n  }> {\n    const startTime = Date.now();\n\n    try {\n      let candidateEntries: MemoryEntry[] = [];\n\n      // Use index for efficient querying if enabled\n      if (this.config.indexingEnabled) {\n        candidateEntries = this.queryWithIndex(options);\n      } else {\n        candidateEntries = Array.from(this.entries.values());\n      }\n\n      // Apply filters\n      let filteredEntries = candidateEntries.filter((entry) => {\n        return this.matchesQuery(entry, options);\n      });\n\n      // Remove expired entries\n      if (!options.includeExpired) {\n        filteredEntries = filteredEntries.filter((entry) => {\n          if (entry.expiresAt && entry.expiresAt < new Date()) {\n            // Schedule for deletion\n            setTimeout(() => this.deleteEntry(entry.id), 0);\n            return false;\n          }\n          return true;\n        });\n      }\n\n      const total = filteredEntries.length;\n\n      // Apply sorting\n      if (options.sortBy) {\n        filteredEntries.sort((a, b) => {\n          const aVal = this.getPropertyValue(a, options.sortBy!);\n          const bVal = this.getPropertyValue(b, options.sortBy!);\n          const multiplier = options.sortOrder === 'desc' ? -1 : 1;\n\n          if (aVal < bVal) return -1 * multiplier;\n          if (aVal > bVal) return 1 * multiplier;\n          return 0;\n        });\n      }\n\n      // Apply pagination\n      const offset = options.offset || 0;\n      const limit = options.limit || filteredEntries.length;\n      const paginatedEntries = filteredEntries.slice(offset, offset + limit);\n\n      // Update last accessed times\n      paginatedEntries.forEach((entry) => {\n        entry.lastAccessedAt = new Date();\n      });\n\n      // Generate aggregations if requested\n      let aggregations: Record<string, any> | undefined;\n      if (options.aggregateBy) {\n        aggregations = this.generateAggregations(filteredEntries, options.aggregateBy);\n      }\n\n      this.recordMetric('query', Date.now() - startTime);\n\n      return {\n        entries: paginatedEntries,\n        total,\n        aggregations,\n      };\n    } catch (error) {\n      this.recordMetric('query-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === EXPORT OPERATIONS ===\n\n  async export(\n    filePath: string,\n    options: ExportOptions,\n  ): Promise<{\n    entriesExported: number;\n    fileSize: number;\n    checksum: string;\n  }> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Starting memory export', { filePath, format: options.format });\n\n      // Query entries to export\n      const queryResult = await this.query(options.filtering || {});\n      const entries = queryResult.entries;\n\n      if (entries.length === 0) {\n        throw new Error('No entries found matching export criteria');\n      }\n\n      // Prepare export data\n      let exportData: any;\n\n      switch (options.format) {\n        case 'json':\n          exportData = this.prepareJsonExport(entries, options);\n          break;\n        case 'csv':\n          exportData = this.prepareCsvExport(entries, options);\n          break;\n        case 'xml':\n          exportData = this.prepareXmlExport(entries, options);\n          break;\n        case 'yaml':\n          exportData = this.prepareYamlExport(entries, options);\n          break;\n        default:\n          throw new Error(`Unsupported export format: ${options.format}`);\n      }\n\n      // Apply compression if requested\n      if (options.compression) {\n        exportData = await this.compressData(exportData);\n      }\n\n      // Apply encryption if requested\n      if (options.encryption?.enabled) {\n        exportData = await this.encryptData(exportData, options.encryption);\n      }\n\n      // Write to file\n      await fs.mkdir(dirname(filePath), { recursive: true });\n      await fs.writeFile(filePath, exportData);\n\n      // Calculate file stats\n      const stats = await fs.stat(filePath);\n      const checksum = this.calculateChecksum(exportData);\n\n      this.logger.info('Memory export completed', {\n        entriesExported: entries.length,\n        fileSize: stats.size,\n        checksum,\n      });\n\n      this.emit('memory:exported', {\n        filePath,\n        entriesExported: entries.length,\n        fileSize: stats.size,\n      });\n\n      this.recordMetric('export', Date.now() - startTime);\n\n      return {\n        entriesExported: entries.length,\n        fileSize: stats.size,\n        checksum,\n      };\n    } catch (error) {\n      this.recordMetric('export-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === IMPORT OPERATIONS ===\n\n  async import(\n    filePath: string,\n    options: ImportOptions,\n  ): Promise<{\n    entriesImported: number;\n    entriesSkipped: number;\n    entriesUpdated: number;\n    conflicts: string[];\n  }> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Starting memory import', { filePath, format: options.format });\n\n      // Read and parse file\n      const fileContent = await fs.readFile(filePath, 'utf-8');\n      let importData: any[];\n\n      switch (options.format) {\n        case 'json':\n          importData = this.parseJsonImport(fileContent);\n          break;\n        case 'csv':\n          importData = this.parseCsvImport(fileContent);\n          break;\n        case 'xml':\n          importData = this.parseXmlImport(fileContent);\n          break;\n        case 'yaml':\n          importData = this.parseYamlImport(fileContent);\n          break;\n        default:\n          throw new Error(`Unsupported import format: ${options.format}`);\n      }\n\n      // Validate data if requested\n      if (options.validation) {\n        importData = this.validateImportData(importData);\n      }\n\n      // Apply transformations if provided\n      if (options.transformation) {\n        importData = this.transformImportData(importData, options.transformation);\n      }\n\n      // Process imports\n      const results = {\n        entriesImported: 0,\n        entriesSkipped: 0,\n        entriesUpdated: 0,\n        conflicts: [] as string[],\n      };\n\n      for (const item of importData) {\n        if (options.dryRun) {\n          // Dry run - just check for conflicts\n          const existing = this.findEntryByKey(item.key, item.namespace);\n          if (existing) {\n            results.conflicts.push(\n              `Key '${item.key}' already exists in namespace '${item.namespace}'`,\n            );\n          }\n          continue;\n        }\n\n        try {\n          const result = await this.importSingleEntry(item, options);\n\n          switch (result.action) {\n            case 'imported':\n              results.entriesImported++;\n              break;\n            case 'updated':\n              results.entriesUpdated++;\n              break;\n            case 'skipped':\n              results.entriesSkipped++;\n              break;\n            case 'conflict':\n              results.conflicts.push(result.message || 'Unknown conflict');\n              break;\n          }\n        } catch (error) {\n          results.conflicts.push(\n            `Error importing '${item.key}': ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n\n      this.logger.info('Memory import completed', results);\n      this.emit('memory:imported', results);\n\n      this.recordMetric('import', Date.now() - startTime);\n      return results;\n    } catch (error) {\n      this.recordMetric('import-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === STATISTICS AND ANALYTICS ===\n\n  async getStatistics(): Promise<MemoryStatistics> {\n    const startTime = Date.now();\n\n    try {\n      const stats = this.calculateStatistics();\n      this.recordMetric('stats', Date.now() - startTime);\n      return stats;\n    } catch (error) {\n      this.recordMetric('stats-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === CLEANUP OPERATIONS ===\n\n  async cleanup(options: CleanupOptions = {}): Promise<{\n    entriesRemoved: number;\n    entriesArchived: number;\n    entriesCompressed: number;\n    spaceSaved: number;\n    actions: string[];\n  }> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Starting memory cleanup', options);\n\n      const results = {\n        entriesRemoved: 0,\n        entriesArchived: 0,\n        entriesCompressed: 0,\n        spaceSaved: 0,\n        actions: [] as string[],\n      };\n\n      // Get all entries for processing\n      const allEntries = Array.from(this.entries.values());\n      const now = new Date();\n\n      // Phase 1: Remove expired entries\n      if (options.removeExpired !== false) {\n        const expiredEntries = allEntries.filter(\n          (entry) => entry.expiresAt && entry.expiresAt < now,\n        );\n\n        for (const entry of expiredEntries) {\n          if (!options.dryRun) {\n            await this.deleteEntry(entry.id);\n          }\n          results.entriesRemoved++;\n          results.spaceSaved += entry.size;\n        }\n\n        if (expiredEntries.length > 0) {\n          results.actions.push(`Removed ${expiredEntries.length} expired entries`);\n        }\n      }\n\n      // Phase 2: Remove old entries\n      if (options.removeOlderThan) {\n        const cutoffDate = new Date(now.getTime() - options.removeOlderThan * 24 * 60 * 60 * 1000);\n        const oldEntries = allEntries.filter((entry) => entry.createdAt < cutoffDate);\n\n        for (const entry of oldEntries) {\n          if (!options.dryRun) {\n            await this.deleteEntry(entry.id);\n          }\n          results.entriesRemoved++;\n          results.spaceSaved += entry.size;\n        }\n\n        if (oldEntries.length > 0) {\n          results.actions.push(\n            `Removed ${oldEntries.length} entries older than ${options.removeOlderThan} days`,\n          );\n        }\n      }\n\n      // Phase 3: Remove unaccessed entries\n      if (options.removeUnaccessed) {\n        const cutoffDate = new Date(now.getTime() - options.removeUnaccessed * 24 * 60 * 60 * 1000);\n        const unaccessedEntries = allEntries.filter((entry) => entry.lastAccessedAt < cutoffDate);\n\n        for (const entry of unaccessedEntries) {\n          if (!options.dryRun) {\n            await this.deleteEntry(entry.id);\n          }\n          results.entriesRemoved++;\n          results.spaceSaved += entry.size;\n        }\n\n        if (unaccessedEntries.length > 0) {\n          results.actions.push(\n            `Removed ${unaccessedEntries.length} entries not accessed in ${options.removeUnaccessed} days`,\n          );\n        }\n      }\n\n      // Phase 4: Archive old entries\n      if (options.archiveOld?.enabled) {\n        const cutoffDate = new Date(\n          now.getTime() - options.archiveOld.olderThan * 24 * 60 * 60 * 1000,\n        );\n        const archiveEntries = allEntries.filter(\n          (entry) => entry.createdAt < cutoffDate && !entry.expiresAt, // Don't archive entries that will expire\n        );\n\n        if (archiveEntries.length > 0 && !options.dryRun) {\n          await this.archiveEntries(archiveEntries, options.archiveOld.archivePath);\n        }\n\n        results.entriesArchived = archiveEntries.length;\n        if (archiveEntries.length > 0) {\n          results.actions.push(`Archived ${archiveEntries.length} old entries`);\n        }\n      }\n\n      // Phase 5: Compress eligible entries\n      if (options.compressEligible !== false && this.config.autoCompress) {\n        const uncompressedEntries = allEntries.filter(\n          (entry) => !entry.compressed && entry.size > this.config.compressionThreshold,\n        );\n\n        for (const entry of uncompressedEntries) {\n          if (!options.dryRun) {\n            const originalSize = entry.size;\n            const compressedValue = await this.compressValue(entry.value);\n            entry.value = compressedValue;\n            entry.compressed = true;\n            entry.size = this.calculateSize(compressedValue);\n            results.spaceSaved += originalSize - entry.size;\n          }\n          results.entriesCompressed++;\n        }\n\n        if (uncompressedEntries.length > 0) {\n          results.actions.push(`Compressed ${uncompressedEntries.length} entries`);\n        }\n      }\n\n      // Phase 6: Apply retention policies\n      if (options.retentionPolicies) {\n        for (const policy of options.retentionPolicies) {\n          const policyResults = await this.applyRetentionPolicy(policy, options.dryRun);\n          results.entriesRemoved += policyResults.removed;\n          results.spaceSaved += policyResults.spaceSaved;\n          if (policyResults.removed > 0) {\n            results.actions.push(\n              `Retention policy '${policy.namespace}': removed ${policyResults.removed} entries`,\n            );\n          }\n        }\n      }\n\n      // Phase 7: Remove orphaned references\n      if (options.removeOrphaned !== false) {\n        const orphanedCount = await this.cleanupOrphanedReferences(options.dryRun);\n        if (orphanedCount > 0) {\n          results.actions.push(`Cleaned up ${orphanedCount} orphaned references`);\n        }\n      }\n\n      // Phase 8: Remove duplicates\n      if (options.removeDuplicates) {\n        const duplicatesResults = await this.removeDuplicateEntries(options.dryRun);\n        results.entriesRemoved += duplicatesResults.removed;\n        results.spaceSaved += duplicatesResults.spaceSaved;\n        if (duplicatesResults.removed > 0) {\n          results.actions.push(`Removed ${duplicatesResults.removed} duplicate entries`);\n        }\n      }\n\n      // Rebuild index if significant changes\n      if (results.entriesRemoved + results.entriesArchived > 100 && !options.dryRun) {\n        await this.rebuildIndex();\n        results.actions.push('Rebuilt search index');\n      }\n\n      this.logger.info('Memory cleanup completed', results);\n      this.emit('memory:cleanup-completed', results);\n\n      this.recordMetric('cleanup', Date.now() - startTime);\n      return results;\n    } catch (error) {\n      this.recordMetric('cleanup-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private createEmptyIndex(): MemoryIndex {\n    return {\n      keys: new Map(),\n      tags: new Map(),\n      types: new Map(),\n      namespaces: new Map(),\n      owners: new Map(),\n      fullText: new Map(),\n    };\n  }\n\n  private async processValue(\n    value: any,\n    compress?: boolean,\n  ): Promise<{ value: any; compressed: boolean }> {\n    let processedValue = value;\n    let isCompressed = false;\n\n    // Auto-compress if enabled and value is large enough\n    if (\n      (compress || this.config.autoCompress) &&\n      this.calculateSize(value) > this.config.compressionThreshold\n    ) {\n      processedValue = await this.compressValue(value);\n      isCompressed = true;\n    }\n\n    return { value: processedValue, compressed: isCompressed };\n  }\n\n  private async compressValue(value: any): Promise<any> {\n    // Placeholder for compression implementation\n    // In a real implementation, you would use a compression library like zlib\n    return JSON.stringify(value);\n  }\n\n  private async decompressValue(value: any): Promise<any> {\n    // Placeholder for decompression implementation\n    try {\n      return JSON.parse(value);\n    } catch {\n      return value;\n    }\n  }\n\n  private calculateSize(value: any): number {\n    return JSON.stringify(value).length;\n  }\n\n  private calculateChecksum(value: any): string {\n    return createHash('sha256').update(JSON.stringify(value)).digest('hex');\n  }\n\n  private inferType(value: any): string {\n    if (Array.isArray(value)) return 'array';\n    if (value === null) return 'null';\n    return typeof value;\n  }\n\n  private findEntryByKey(key: string, namespace?: string): MemoryEntry | undefined {\n    for (const entry of this.entries.values()) {\n      if (entry.key === key && (!namespace || entry.namespace === namespace)) {\n        return entry;\n      }\n    }\n    return undefined;\n  }\n\n  private updateIndex(entry: MemoryEntry, operation: 'create' | 'update' | 'delete'): void {\n    if (!this.config.indexingEnabled) return;\n\n    const { id, key, tags, type, namespace, owner, value } = entry;\n\n    if (operation === 'delete') {\n      // Remove from all indices\n      this.removeFromIndex(this.index.keys, key, id);\n      tags.forEach((tag) => this.removeFromIndex(this.index.tags, tag, id));\n      this.removeFromIndex(this.index.types, type, id);\n      this.removeFromIndex(this.index.namespaces, namespace, id);\n      this.removeFromIndex(this.index.owners, owner, id);\n\n      // Remove from full-text index\n      const words = this.extractWords(value);\n      words.forEach((word) => this.removeFromIndex(this.index.fullText, word, id));\n    } else {\n      // Add to indices\n      this.addToIndex(this.index.keys, key, id);\n      tags.forEach((tag) => this.addToIndex(this.index.tags, tag, id));\n      this.addToIndex(this.index.types, type, id);\n      this.addToIndex(this.index.namespaces, namespace, id);\n      this.addToIndex(this.index.owners, owner, id);\n\n      // Add to full-text index\n      const words = this.extractWords(value);\n      words.forEach((word) => this.addToIndex(this.index.fullText, word, id));\n    }\n  }\n\n  private addToIndex(indexMap: Map<string, string[]>, key: string, entryId: string): void {\n    if (!indexMap.has(key)) {\n      indexMap.set(key, []);\n    }\n    const entries = indexMap.get(key)!;\n    if (!entries.includes(entryId)) {\n      entries.push(entryId);\n    }\n  }\n\n  private removeFromIndex(indexMap: Map<string, string[]>, key: string, entryId: string): void {\n    const entries = indexMap.get(key);\n    if (entries) {\n      const index = entries.indexOf(entryId);\n      if (index > -1) {\n        entries.splice(index, 1);\n      }\n      if (entries.length === 0) {\n        indexMap.delete(key);\n      }\n    }\n  }\n\n  private extractWords(value: any): string[] {\n    const text = typeof value === 'string' ? value : JSON.stringify(value);\n    return text\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter((word) => word.length > 2);\n  }\n\n  private updateCache(key: string, entry: MemoryEntry): void {\n    if (this.cache.size >= this.config.cacheSize) {\n      this.evictCache();\n    }\n\n    this.cache.set(key, {\n      entry: { ...entry },\n      expiry: Date.now() + this.config.cacheTtl,\n    });\n  }\n\n  private evictCache(): void {\n    const entries = Array.from(this.cache.entries());\n    entries.sort((a, b) => a[1].expiry - b[1].expiry);\n\n    const toRemove = entries.slice(0, Math.floor(this.config.cacheSize * 0.1));\n    toRemove.forEach(([key]) => this.cache.delete(key));\n  }\n\n  private recordMetric(operation: string, duration: number): void {\n    const current = this.operationMetrics.get(operation) || { count: 0, totalTime: 0 };\n    current.count++;\n    current.totalTime += duration;\n    this.operationMetrics.set(operation, current);\n  }\n\n  private initializeStatistics(): MemoryStatistics {\n    return {\n      overview: {\n        totalEntries: 0,\n        totalSize: 0,\n        compressedEntries: 0,\n        compressionRatio: 0,\n        indexSize: 0,\n        memoryUsage: 0,\n        diskUsage: 0,\n      },\n      distribution: {\n        byNamespace: {},\n        byType: {},\n        byOwner: {},\n        byAccessLevel: {},\n      },\n      temporal: {\n        entriesCreatedLast24h: 0,\n        entriesUpdatedLast24h: 0,\n        entriesAccessedLast24h: 0,\n      },\n      performance: {\n        averageQueryTime: 0,\n        averageWriteTime: 0,\n        cacheHitRatio: 0,\n        indexEfficiency: 0,\n      },\n      health: {\n        expiredEntries: 0,\n        orphanedReferences: 0,\n        duplicateKeys: 0,\n        corruptedEntries: 0,\n        recommendedCleanup: false,\n      },\n      optimization: {\n        suggestions: [],\n        potentialSavings: {\n          compression: 0,\n          cleanup: 0,\n          deduplication: 0,\n        },\n        indexOptimization: [],\n      },\n    };\n  }\n\n  // === COMPLEX IMPLEMENTATION METHODS ===\n  // These would be fully implemented in a production system\n\n  private queryWithIndex(options: QueryOptions): MemoryEntry[] {\n    // Implementation would use the index for efficient querying\n    return Array.from(this.entries.values());\n  }\n\n  private matchesQuery(entry: MemoryEntry, options: QueryOptions): boolean {\n    // Comprehensive query matching logic\n    if (options.namespace && entry.namespace !== options.namespace) return false;\n    if (options.type && entry.type !== options.type) return false;\n    if (options.owner && entry.owner !== options.owner) return false;\n    if (options.accessLevel && entry.accessLevel !== options.accessLevel) return false;\n\n    if (options.tags && options.tags.length > 0) {\n      const hasAllTags = options.tags.every((tag) => entry.tags.includes(tag));\n      if (!hasAllTags) return false;\n    }\n\n    if (options.keyPattern) {\n      const regex = new RegExp(options.keyPattern, 'i');\n      if (!regex.test(entry.key)) return false;\n    }\n\n    if (options.valueSearch) {\n      const valueStr = JSON.stringify(entry.value).toLowerCase();\n      if (!valueStr.includes(options.valueSearch.toLowerCase())) return false;\n    }\n\n    // Date range checks\n    if (options.createdAfter && entry.createdAt < options.createdAfter) return false;\n    if (options.createdBefore && entry.createdAt > options.createdBefore) return false;\n    if (options.updatedAfter && entry.updatedAt < options.updatedAfter) return false;\n    if (options.updatedBefore && entry.updatedAt > options.updatedBefore) return false;\n\n    // Size checks\n    if (options.sizeGreaterThan && entry.size <= options.sizeGreaterThan) return false;\n    if (options.sizeLessThan && entry.size >= options.sizeLessThan) return false;\n\n    return true;\n  }\n\n  private getPropertyValue(entry: MemoryEntry, property: string): any {\n    switch (property) {\n      case 'key':\n        return entry.key;\n      case 'createdAt':\n        return entry.createdAt.getTime();\n      case 'updatedAt':\n        return entry.updatedAt.getTime();\n      case 'lastAccessedAt':\n        return entry.lastAccessedAt.getTime();\n      case 'size':\n        return entry.size;\n      case 'type':\n        return entry.type;\n      default:\n        return entry.key;\n    }\n  }\n\n  private generateAggregations(entries: MemoryEntry[], aggregateBy: string): Record<string, any> {\n    const aggregations: Record<string, any> = {};\n\n    switch (aggregateBy) {\n      case 'namespace':\n        aggregations.namespaces = this.aggregateByProperty(entries, 'namespace');\n        break;\n      case 'type':\n        aggregations.types = this.aggregateByProperty(entries, 'type');\n        break;\n      case 'owner':\n        aggregations.owners = this.aggregateByProperty(entries, 'owner');\n        break;\n      case 'tags':\n        aggregations.tags = this.aggregateByTags(entries);\n        break;\n    }\n\n    return aggregations;\n  }\n\n  private aggregateByProperty(\n    entries: MemoryEntry[],\n    property: keyof MemoryEntry,\n  ): Record<string, { count: number; totalSize: number }> {\n    const result: Record<string, { count: number; totalSize: number }> = {};\n\n    for (const entry of entries) {\n      const value = String(entry[property]);\n      if (!result[value]) {\n        result[value] = { count: 0, totalSize: 0 };\n      }\n      result[value].count++;\n      result[value].totalSize += entry.size;\n    }\n\n    return result;\n  }\n\n  private aggregateByTags(\n    entries: MemoryEntry[],\n  ): Record<string, { count: number; totalSize: number }> {\n    const result: Record<string, { count: number; totalSize: number }> = {};\n\n    for (const entry of entries) {\n      for (const tag of entry.tags) {\n        if (!result[tag]) {\n          result[tag] = { count: 0, totalSize: 0 };\n        }\n        result[tag].count++;\n        result[tag].totalSize += entry.size;\n      }\n    }\n\n    return result;\n  }\n\n  // === EXPORT/IMPORT HELPERS ===\n\n  private prepareJsonExport(entries: MemoryEntry[], options: ExportOptions): string {\n    const exportData = {\n      metadata: {\n        exportedAt: new Date().toISOString(),\n        version: '1.0',\n        totalEntries: entries.length,\n        format: 'json',\n      },\n      entries: options.includeMetadata\n        ? entries\n        : entries.map((entry) => ({\n            key: entry.key,\n            value: entry.value,\n            type: entry.type,\n            namespace: entry.namespace,\n            tags: entry.tags,\n          })),\n    };\n\n    return JSON.stringify(exportData, null, 2);\n  }\n\n  private prepareCsvExport(entries: MemoryEntry[], options: ExportOptions): string {\n    // CSV export implementation\n    const headers = ['key', 'value', 'type', 'namespace', 'tags'];\n    const rows = entries.map((entry) => [\n      entry.key,\n      JSON.stringify(entry.value),\n      entry.type,\n      entry.namespace,\n      entry.tags.join(';'),\n    ]);\n\n    return [headers, ...rows].map((row) => row.join(',')).join('\\n');\n  }\n\n  private prepareXmlExport(entries: MemoryEntry[], options: ExportOptions): string {\n    // XML export implementation\n    let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<memory>\\n';\n\n    for (const entry of entries) {\n      xml += `  <entry>\\n`;\n      xml += `    <key>${this.escapeXml(entry.key)}</key>\\n`;\n      xml += `    <value>${this.escapeXml(JSON.stringify(entry.value))}</value>\\n`;\n      xml += `    <type>${this.escapeXml(entry.type)}</type>\\n`;\n      xml += `    <namespace>${this.escapeXml(entry.namespace)}</namespace>\\n`;\n      xml += `    <tags>${this.escapeXml(entry.tags.join(','))}</tags>\\n`;\n      xml += `  </entry>\\n`;\n    }\n\n    xml += '</memory>';\n    return xml;\n  }\n\n  private prepareYamlExport(entries: MemoryEntry[], options: ExportOptions): string {\n    // YAML export implementation - simplified\n    let yaml = 'memory:\\n';\n\n    for (const entry of entries) {\n      yaml += `  - key: \"${entry.key}\"\\n`;\n      yaml += `    value: ${JSON.stringify(entry.value)}\\n`;\n      yaml += `    type: \"${entry.type}\"\\n`;\n      yaml += `    namespace: \"${entry.namespace}\"\\n`;\n      yaml += `    tags: [${entry.tags.map((t) => `\"${t}\"`).join(', ')}]\\n`;\n    }\n\n    return yaml;\n  }\n\n  private escapeXml(str: string): string {\n    return str\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;');\n  }\n\n  private parseJsonImport(content: string): any[] {\n    const data = JSON.parse(content);\n    return data.entries || data;\n  }\n\n  private parseCsvImport(content: string): any[] {\n    // Simple CSV parsing\n    const lines = content.split('\\n');\n    const headers = lines[0].split(',');\n    const entries = [];\n\n    for (let i = 1; i < lines.length; i++) {\n      const values = lines[i].split(',');\n      const entry: any = {};\n\n      for (let j = 0; j < headers.length; j++) {\n        entry[headers[j]] = values[j];\n      }\n\n      entries.push(entry);\n    }\n\n    return entries;\n  }\n\n  private parseXmlImport(content: string): any[] {\n    // XML parsing would require a proper XML parser\n    throw new Error('XML import not implemented in this example');\n  }\n\n  private parseYamlImport(content: string): any[] {\n    // YAML parsing would require a YAML parser\n    throw new Error('YAML import not implemented in this example');\n  }\n\n  private validateImportData(data: any[]): any[] {\n    return data.filter((item) => {\n      return item.key && item.value !== undefined;\n    });\n  }\n\n  private transformImportData(\n    data: any[],\n    transformation: NonNullable<ImportOptions['transformation']>,\n  ): any[] {\n    return data.map((item) => {\n      const transformed = { ...item };\n\n      // Apply key mapping\n      if (transformation.keyMapping) {\n        for (const [oldKey, newKey] of Object.entries(transformation.keyMapping)) {\n          if (transformed[oldKey] !== undefined) {\n            transformed[newKey] = transformed[oldKey];\n            delete transformed[oldKey];\n          }\n        }\n      }\n\n      // Apply value transformation\n      if (transformation.valueTransformation) {\n        transformed.value = transformation.valueTransformation(transformed.value);\n      }\n\n      // Extract metadata\n      if (transformation.metadataExtraction) {\n        transformed.metadata = transformation.metadataExtraction(transformed);\n      }\n\n      return transformed;\n    });\n  }\n\n  private async importSingleEntry(\n    item: any,\n    options: ImportOptions,\n  ): Promise<{\n    action: 'imported' | 'updated' | 'skipped' | 'conflict';\n    message?: string;\n  }> {\n    const existing = this.findEntryByKey(item.key, item.namespace || options.namespace);\n\n    if (existing) {\n      switch (options.conflictResolution) {\n        case 'skip':\n          return { action: 'skipped' };\n        case 'overwrite':\n          await this.update(item.key, item.value, { namespace: item.namespace });\n          return { action: 'updated' };\n        case 'merge':\n          await this.update(item.key, item.value, {\n            namespace: item.namespace,\n            merge: true,\n          });\n          return { action: 'updated' };\n        case 'rename':\n          const newKey = `${item.key}_imported_${Date.now()}`;\n          await this.store(newKey, item.value, {\n            namespace: item.namespace,\n            type: item.type,\n            tags: item.tags,\n            metadata: item.metadata,\n          });\n          return { action: 'imported' };\n        default:\n          return {\n            action: 'conflict',\n            message: `Key '${item.key}' already exists`,\n          };\n      }\n    } else {\n      await this.store(item.key, item.value, {\n        namespace: item.namespace || options.namespace,\n        type: item.type,\n        tags: item.tags,\n        metadata: item.metadata,\n      });\n      return { action: 'imported' };\n    }\n  }\n\n  // === STATISTICS CALCULATION ===\n\n  private calculateStatistics(): MemoryStatistics {\n    const entries = Array.from(this.entries.values());\n    const now = new Date();\n    const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    const stats: MemoryStatistics = {\n      overview: {\n        totalEntries: entries.length,\n        totalSize: entries.reduce((sum, entry) => sum + entry.size, 0),\n        compressedEntries: entries.filter((entry) => entry.compressed).length,\n        compressionRatio: 0,\n        indexSize: this.calculateIndexSize(),\n        memoryUsage: process.memoryUsage().heapUsed,\n        diskUsage: 0, // Would be calculated from actual file system\n      },\n      distribution: {\n        byNamespace: this.calculateDistribution(entries, 'namespace'),\n        byType: this.calculateDistribution(entries, 'type'),\n        byOwner: this.calculateDistribution(entries, 'owner'),\n        byAccessLevel: this.calculateDistribution(entries, 'accessLevel'),\n      },\n      temporal: {\n        entriesCreatedLast24h: entries.filter((e) => e.createdAt >= last24h).length,\n        entriesUpdatedLast24h: entries.filter((e) => e.updatedAt >= last24h).length,\n        entriesAccessedLast24h: entries.filter((e) => e.lastAccessedAt >= last24h).length,\n        oldestEntry:\n          entries.length > 0\n            ? entries.reduce((oldest, entry) =>\n                entry.createdAt < oldest.createdAt ? entry : oldest,\n              ).createdAt\n            : undefined,\n        newestEntry:\n          entries.length > 0\n            ? entries.reduce((newest, entry) =>\n                entry.createdAt > newest.createdAt ? entry : newest,\n              ).createdAt\n            : undefined,\n      },\n      performance: this.calculatePerformanceMetrics(),\n      health: this.calculateHealthMetrics(entries, now),\n      optimization: this.generateOptimizationSuggestions(entries),\n    };\n\n    // Calculate compression ratio\n    const uncompressedSize = entries\n      .filter((e) => !e.compressed)\n      .reduce((sum, e) => sum + e.size, 0);\n    const compressedSize = entries.filter((e) => e.compressed).reduce((sum, e) => sum + e.size, 0);\n    stats.overview.compressionRatio =\n      uncompressedSize > 0 ? (uncompressedSize - compressedSize) / uncompressedSize : 0;\n\n    return stats;\n  }\n\n  private calculateDistribution(\n    entries: MemoryEntry[],\n    property: keyof MemoryEntry,\n  ): Record<string, { count: number; size: number }> {\n    const distribution: Record<string, { count: number; size: number }> = {};\n\n    for (const entry of entries) {\n      const value = String(entry[property]);\n      if (!distribution[value]) {\n        distribution[value] = { count: 0, size: 0 };\n      }\n      distribution[value].count++;\n      distribution[value].size += entry.size;\n    }\n\n    return distribution;\n  }\n\n  private calculateIndexSize(): number {\n    let size = 0;\n    for (const [, entries] of this.index.keys) {\n      size += entries.length * 50; // Rough estimate\n    }\n    return size;\n  }\n\n  private calculatePerformanceMetrics(): MemoryStatistics['performance'] {\n    const queryMetrics = this.operationMetrics.get('query') || { count: 0, totalTime: 0 };\n    const writeMetrics = this.operationMetrics.get('store') || { count: 0, totalTime: 0 };\n    const cacheMetrics = this.operationMetrics.get('retrieve-cache') || { count: 0, totalTime: 0 };\n    const totalRetrieves =\n      (this.operationMetrics.get('retrieve') || { count: 0 }).count + cacheMetrics.count;\n\n    return {\n      averageQueryTime: queryMetrics.count > 0 ? queryMetrics.totalTime / queryMetrics.count : 0,\n      averageWriteTime: writeMetrics.count > 0 ? writeMetrics.totalTime / writeMetrics.count : 0,\n      cacheHitRatio: totalRetrieves > 0 ? cacheMetrics.count / totalRetrieves : 0,\n      indexEfficiency: this.config.indexingEnabled ? 0.95 : 0, // Placeholder\n    };\n  }\n\n  private calculateHealthMetrics(entries: MemoryEntry[], now: Date): MemoryStatistics['health'] {\n    const expiredEntries = entries.filter((e) => e.expiresAt && e.expiresAt < now).length;\n    const duplicateKeys = this.findDuplicateKeys(entries);\n\n    return {\n      expiredEntries,\n      orphanedReferences: 0, // Would be calculated by checking references\n      duplicateKeys: duplicateKeys.length,\n      corruptedEntries: 0, // Would be calculated by validating checksums\n      recommendedCleanup: expiredEntries > 10 || duplicateKeys.length > 5,\n    };\n  }\n\n  private generateOptimizationSuggestions(\n    entries: MemoryEntry[],\n  ): MemoryStatistics['optimization'] {\n    const suggestions: string[] = [];\n    const potentialSavings = { compression: 0, cleanup: 0, deduplication: 0 };\n\n    // Compression suggestions\n    const uncompressedLarge = entries.filter(\n      (e) => !e.compressed && e.size > this.config.compressionThreshold,\n    );\n    if (uncompressedLarge.length > 0) {\n      suggestions.push(`${uncompressedLarge.length} entries could benefit from compression`);\n      potentialSavings.compression = uncompressedLarge.reduce((sum, e) => sum + e.size * 0.6, 0);\n    }\n\n    // Cleanup suggestions\n    const now = new Date();\n    const oldEntries = entries.filter(\n      (e) => now.getTime() - e.lastAccessedAt.getTime() > 30 * 24 * 60 * 60 * 1000,\n    );\n    if (oldEntries.length > 0) {\n      suggestions.push(`${oldEntries.length} entries haven't been accessed in 30+ days`);\n      potentialSavings.cleanup = oldEntries.reduce((sum, e) => sum + e.size, 0);\n    }\n\n    // Deduplication suggestions\n    const duplicates = this.findDuplicateKeys(entries);\n    if (duplicates.length > 0) {\n      suggestions.push(`${duplicates.length} duplicate keys found`);\n      potentialSavings.deduplication = duplicates.reduce(\n        (sum, group) => sum + group.entries.slice(1).reduce((s, e) => s + e.size, 0),\n        0,\n      );\n    }\n\n    return {\n      suggestions,\n      potentialSavings,\n      indexOptimization: this.config.indexingEnabled\n        ? ['Consider periodic index rebuilding for optimal performance']\n        : ['Enable indexing for better query performance'],\n    };\n  }\n\n  private findDuplicateKeys(\n    entries: MemoryEntry[],\n  ): Array<{ key: string; namespace: string; entries: MemoryEntry[] }> {\n    const keyMap = new Map<string, MemoryEntry[]>();\n\n    for (const entry of entries) {\n      const compositeKey = `${entry.namespace}:${entry.key}`;\n      if (!keyMap.has(compositeKey)) {\n        keyMap.set(compositeKey, []);\n      }\n      keyMap.get(compositeKey)!.push(entry);\n    }\n\n    const duplicates: Array<{ key: string; namespace: string; entries: MemoryEntry[] }> = [];\n    for (const [compositeKey, entryList] of keyMap) {\n      if (entryList.length > 1) {\n        const [namespace, key] = compositeKey.split(':', 2);\n        duplicates.push({ key, namespace, entries: entryList });\n      }\n    }\n\n    return duplicates;\n  }\n\n  // === CLEANUP IMPLEMENTATION ===\n\n  private async applyRetentionPolicies(entry: MemoryEntry): Promise<void> {\n    // Apply matching retention policies to the entry\n    for (const policy of this.retentionPolicies.values()) {\n      if (this.policyMatches(policy, entry)) {\n        await this.enforceRetentionPolicy(policy, entry);\n      }\n    }\n  }\n\n  private policyMatches(policy: RetentionPolicy, entry: MemoryEntry): boolean {\n    if (policy.namespace && entry.namespace !== policy.namespace) return false;\n    if (policy.type && entry.type !== policy.type) return false;\n    if (policy.tags && !policy.tags.every((tag) => entry.tags.includes(tag))) return false;\n    return true;\n  }\n\n  private async enforceRetentionPolicy(policy: RetentionPolicy, entry: MemoryEntry): Promise<void> {\n    const now = new Date();\n\n    // Check age limit\n    if (policy.maxAge) {\n      const ageInDays = (now.getTime() - entry.createdAt.getTime()) / (24 * 60 * 60 * 1000);\n      if (ageInDays > policy.maxAge) {\n        await this.deleteEntry(entry.id);\n        return;\n      }\n    }\n\n    // Count and size limits would require more complex logic\n    // This is a simplified implementation\n  }\n\n  private async applyRetentionPolicy(\n    policy: CleanupOptions['retentionPolicies'][0],\n    dryRun?: boolean,\n  ): Promise<{ removed: number; spaceSaved: number }> {\n    const matchingEntries = Array.from(this.entries.values()).filter((entry) => {\n      if (policy.namespace && entry.namespace !== policy.namespace) return false;\n      return true;\n    });\n\n    let toRemove: MemoryEntry[] = [];\n    const now = new Date();\n\n    // Apply age limit\n    if (policy.maxAge) {\n      const cutoffDate = new Date(now.getTime() - policy.maxAge * 24 * 60 * 60 * 1000);\n      toRemove = matchingEntries.filter((entry) => entry.createdAt < cutoffDate);\n    }\n\n    // Apply count limit\n    if (policy.maxCount && matchingEntries.length > policy.maxCount) {\n      const sorted = matchingEntries.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n      toRemove = sorted.slice(0, matchingEntries.length - policy.maxCount);\n    }\n\n    // Apply size limit\n    if (policy.sizeLimit) {\n      const totalSize = matchingEntries.reduce((sum, entry) => sum + entry.size, 0);\n      if (totalSize > policy.sizeLimit) {\n        const sorted = matchingEntries.sort(\n          (a, b) => a.lastAccessedAt.getTime() - b.lastAccessedAt.getTime(),\n        );\n        let currentSize = totalSize;\n        toRemove = [];\n\n        for (const entry of sorted) {\n          if (currentSize <= policy.sizeLimit) break;\n          toRemove.push(entry);\n          currentSize -= entry.size;\n        }\n      }\n    }\n\n    const spaceSaved = toRemove.reduce((sum, entry) => sum + entry.size, 0);\n\n    if (!dryRun) {\n      for (const entry of toRemove) {\n        await this.deleteEntry(entry.id);\n      }\n    }\n\n    return { removed: toRemove.length, spaceSaved };\n  }\n\n  private async cleanupOrphanedReferences(dryRun?: boolean): Promise<number> {\n    // Implementation would check for broken references between entries\n    return 0;\n  }\n\n  private async removeDuplicateEntries(\n    dryRun?: boolean,\n  ): Promise<{ removed: number; spaceSaved: number }> {\n    const duplicates = this.findDuplicateKeys(Array.from(this.entries.values()));\n    let removed = 0;\n    let spaceSaved = 0;\n\n    for (const duplicate of duplicates) {\n      // Keep the newest entry, remove others\n      const sorted = duplicate.entries.sort(\n        (a, b) => b.updatedAt.getTime() - a.updatedAt.getTime(),\n      );\n      const toRemove = sorted.slice(1);\n\n      for (const entry of toRemove) {\n        spaceSaved += entry.size;\n        removed++;\n\n        if (!dryRun) {\n          await this.deleteEntry(entry.id);\n        }\n      }\n    }\n\n    return { removed, spaceSaved };\n  }\n\n  private async archiveEntries(entries: MemoryEntry[], archivePath: string): Promise<void> {\n    const archiveData = {\n      archivedAt: new Date().toISOString(),\n      entries: entries,\n    };\n\n    const archiveFile = join(archivePath, `archive-${Date.now()}.json`);\n    await fs.mkdir(dirname(archiveFile), { recursive: true });\n    await fs.writeFile(archiveFile, JSON.stringify(archiveData, null, 2));\n\n    // Remove archived entries from active memory\n    for (const entry of entries) {\n      await this.deleteEntry(entry.id);\n    }\n  }\n\n  private async rebuildIndex(): Promise<void> {\n    this.logger.info('Rebuilding memory index');\n\n    this.index = this.createEmptyIndex();\n\n    for (const entry of this.entries.values()) {\n      this.updateIndex(entry, 'create');\n    }\n\n    this.logger.info('Memory index rebuilt successfully');\n  }\n\n  private startAutoCleanup(): void {\n    this.cleanupInterval = setInterval(async () => {\n      try {\n        await this.cleanup({\n          removeExpired: true,\n          removeUnaccessed: 7, // Remove entries not accessed in 7 days\n          compressEligible: true,\n        });\n      } catch (error) {\n        this.logger.error('Auto cleanup failed', error);\n      }\n    }, this.config.cleanupInterval);\n  }\n\n  // === PERSISTENCE ===\n\n  private async loadPersistedData(): Promise<void> {\n    try {\n      const dataFile = join(this.dataPath, 'entries.json');\n      const indexFile = join(this.indexPath, 'index.json');\n\n      // Load entries\n      try {\n        const entriesData = await fs.readFile(dataFile, 'utf-8');\n        const entriesArray = JSON.parse(entriesData);\n\n        for (const entryData of entriesArray) {\n          // Convert date strings back to Date objects\n          entryData.createdAt = new Date(entryData.createdAt);\n          entryData.updatedAt = new Date(entryData.updatedAt);\n          entryData.lastAccessedAt = new Date(entryData.lastAccessedAt);\n          if (entryData.expiresAt) {\n            entryData.expiresAt = new Date(entryData.expiresAt);\n          }\n\n          this.entries.set(entryData.id, entryData);\n        }\n\n        this.logger.info(`Loaded ${entriesArray.length} entries from persistence`);\n      } catch (error) {\n        // File doesn't exist or is corrupted\n        this.logger.info('No persisted entries found, starting fresh');\n      }\n\n      // Rebuild index\n      if (this.config.indexingEnabled) {\n        await this.rebuildIndex();\n      }\n    } catch (error) {\n      this.logger.error('Failed to load persisted data', error);\n    }\n  }\n\n  private async persistData(): Promise<void> {\n    try {\n      const dataFile = join(this.dataPath, 'entries.json');\n      const entriesArray = Array.from(this.entries.values());\n\n      await fs.writeFile(dataFile, JSON.stringify(entriesArray, null, 2));\n      this.logger.info(`Persisted ${entriesArray.length} entries`);\n    } catch (error) {\n      this.logger.error('Failed to persist data', error);\n    }\n  }\n\n  private async createBackup(): Promise<void> {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const backupFile = join(this.backupPath, `backup-${timestamp}.json`);\n\n      const backup = {\n        timestamp: new Date().toISOString(),\n        version: '1.0',\n        entries: Array.from(this.entries.values()),\n        statistics: await this.getStatistics(),\n      };\n\n      await fs.writeFile(backupFile, JSON.stringify(backup, null, 2));\n      this.logger.info(`Created backup: ${backupFile}`);\n\n      // Clean old backups\n      await this.cleanOldBackups();\n    } catch (error) {\n      this.logger.error('Failed to create backup', error);\n    }\n  }\n\n  private async cleanOldBackups(): Promise<void> {\n    try {\n      const files = await fs.readdir(this.backupPath);\n      const backupFiles = files.filter((f) => f.startsWith('backup-') && f.endsWith('.json'));\n\n      if (backupFiles.length <= this.config.backupRetention) {\n        return;\n      }\n\n      // Sort by creation time and remove oldest\n      const fileStats = await Promise.all(\n        backupFiles.map(async (file) => ({\n          file,\n          stat: await fs.stat(join(this.backupPath, file)),\n        })),\n      );\n\n      fileStats.sort((a, b) => a.stat.mtime.getTime() - b.stat.mtime.getTime());\n\n      const toDelete = fileStats.slice(0, fileStats.length - this.config.backupRetention);\n\n      for (const { file } of toDelete) {\n        await fs.unlink(join(this.backupPath, file));\n        this.logger.debug(`Deleted old backup: ${file}`);\n      }\n    } catch (error) {\n      this.logger.error('Failed to clean old backups', error);\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private async compressData(data: string): Promise<string> {\n    // In a real implementation, you would use a compression library\n    return data;\n  }\n\n  private async encryptData(\n    data: string,\n    encryption: NonNullable<ExportOptions['encryption']>,\n  ): Promise<string> {\n    // In a real implementation, you would use a proper encryption library\n    return data;\n  }\n\n  // === PUBLIC API ===\n\n  async listNamespaces(): Promise<string[]> {\n    const namespaces = new Set<string>();\n    for (const entry of this.entries.values()) {\n      namespaces.add(entry.namespace);\n    }\n    return Array.from(namespaces).sort();\n  }\n\n  async listTypes(): Promise<string[]> {\n    const types = new Set<string>();\n    for (const entry of this.entries.values()) {\n      types.add(entry.type);\n    }\n    return Array.from(types).sort();\n  }\n\n  async listTags(): Promise<string[]> {\n    const tags = new Set<string>();\n    for (const entry of this.entries.values()) {\n      entry.tags.forEach((tag) => tags.add(tag));\n    }\n    return Array.from(tags).sort();\n  }\n\n  async getEntryById(id: string): Promise<MemoryEntry | null> {\n    return this.entries.get(id) || null;\n  }\n\n  async exists(key: string, namespace?: string): Promise<boolean> {\n    return this.findEntryByKey(key, namespace) !== undefined;\n  }\n\n  async count(options: Partial<QueryOptions> = {}): Promise<number> {\n    const result = await this.query({ ...options, limit: 0 });\n    return result.total;\n  }\n\n  async clear(namespace?: string): Promise<number> {\n    const entries = Array.from(this.entries.values());\n    const toDelete = namespace ? entries.filter((entry) => entry.namespace === namespace) : entries;\n\n    for (const entry of toDelete) {\n      await this.deleteEntry(entry.id);\n    }\n\n    return toDelete.length;\n  }\n\n  getConfiguration(): typeof this.config {\n    return { ...this.config };\n  }\n\n  async updateConfiguration(updates: Partial<typeof this.config>): Promise<void> {\n    this.config = { ...this.config, ...updates };\n\n    // Apply configuration changes\n    if (updates.autoCleanup !== undefined) {\n      if (updates.autoCleanup && !this.cleanupInterval) {\n        this.startAutoCleanup();\n      } else if (!updates.autoCleanup && this.cleanupInterval) {\n        clearInterval(this.cleanupInterval);\n        this.cleanupInterval = undefined;\n      }\n    }\n\n    this.emit('memory:configuration-updated', { config: this.config });\n  }\n}\n"],
  "mappings": "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",
  "names": ["fs"]
}
