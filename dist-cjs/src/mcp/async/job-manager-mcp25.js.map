{"version":3,"sources":["../../../../src/mcp/async/job-manager-mcp25.ts"],"sourcesContent":["/**\r\n * MCP 2025-11 Async Job Manager\r\n *\r\n * Implements async job lifecycle per MCP 2025-11 specification:\r\n * - Job handles with request_id\r\n * - Poll/resume semantics\r\n * - Progress tracking\r\n * - Job persistence\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport type { ILogger } from '../../interfaces/logger.js';\r\n\r\n/**\r\n * MCP tool request (2025-11 format)\r\n */\r\nexport interface MCPToolRequest {\r\n  request_id: string;\r\n  tool_id: string;\r\n  arguments: Record<string, any>;\r\n  session?: string;\r\n  mode: 'async' | 'sync';\r\n  context?: {\r\n    trace_id?: string;\r\n    client_name?: string;\r\n    [key: string]: any;\r\n  };\r\n}\r\n\r\n/**\r\n * MCP job handle (2025-11 format)\r\n */\r\nexport interface MCPJobHandle {\r\n  request_id: string;\r\n  job_id: string;\r\n  status: 'in_progress' | 'success' | 'error';\r\n  poll_after: number; // seconds\r\n  progress?: {\r\n    percent: number;\r\n    message?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * MCP job result (2025-11 format)\r\n */\r\nexport interface MCPJobResult {\r\n  request_id: string;\r\n  status: 'success' | 'error' | 'in_progress';\r\n  result?: any;\r\n  error?: {\r\n    code: string;\r\n    message: string;\r\n    details?: any;\r\n  };\r\n  progress?: {\r\n    percent: number;\r\n    message?: string;\r\n  };\r\n  metadata: {\r\n    duration_ms?: number;\r\n    tokens_used?: number;\r\n    [key: string]: any;\r\n  };\r\n}\r\n\r\n/**\r\n * Internal job state\r\n */\r\ninterface AsyncJob {\r\n  request_id: string;\r\n  job_id: string;\r\n  tool_id: string;\r\n  arguments: Record<string, any>;\r\n  mode: 'async' | 'sync';\r\n  status: 'queued' | 'running' | 'success' | 'error' | 'cancelled';\r\n  progress: number;\r\n  progress_message?: string;\r\n  result?: any;\r\n  error?: any;\r\n  context?: any;\r\n  created_at: Date;\r\n  started_at?: Date;\r\n  completed_at?: Date;\r\n  tokens_used?: number;\r\n  abortController?: AbortController;\r\n}\r\n\r\n/**\r\n * Job persistence interface\r\n */\r\nexport interface JobPersistence {\r\n  save(job: AsyncJob): Promise<void>;\r\n  load(job_id: string): Promise<AsyncJob | null>;\r\n  list(filter?: { status?: string; limit?: number }): Promise<AsyncJob[]>;\r\n  delete(job_id: string): Promise<void>;\r\n}\r\n\r\n/**\r\n * Simple in-memory job persistence (fallback)\r\n */\r\nexport class MemoryJobPersistence implements JobPersistence {\r\n  private jobs: Map<string, AsyncJob> = new Map();\r\n\r\n  async save(job: AsyncJob): Promise<void> {\r\n    this.jobs.set(job.job_id, { ...job });\r\n  }\r\n\r\n  async load(job_id: string): Promise<AsyncJob | null> {\r\n    const job = this.jobs.get(job_id);\r\n    return job ? { ...job } : null;\r\n  }\r\n\r\n  async list(filter?: { status?: string; limit?: number }): Promise<AsyncJob[]> {\r\n    let jobs = Array.from(this.jobs.values());\r\n\r\n    if (filter?.status) {\r\n      jobs = jobs.filter(j => j.status === filter.status);\r\n    }\r\n\r\n    if (filter?.limit) {\r\n      jobs = jobs.slice(0, filter.limit);\r\n    }\r\n\r\n    return jobs;\r\n  }\r\n\r\n  async delete(job_id: string): Promise<void> {\r\n    this.jobs.delete(job_id);\r\n  }\r\n}\r\n\r\n/**\r\n * MCP 2025-11 Async Job Manager\r\n */\r\nexport class MCPAsyncJobManager extends EventEmitter {\r\n  private jobs: Map<string, AsyncJob> = new Map();\r\n  private executors: Map<string, Promise<any>> = new Map();\r\n  private persistence: JobPersistence;\r\n\r\n  constructor(\r\n    persistence: JobPersistence | null,\r\n    private logger: ILogger,\r\n    private config: {\r\n      maxJobs?: number;\r\n      jobTTL?: number;\r\n      defaultPollInterval?: number;\r\n    } = {}\r\n  ) {\r\n    super();\r\n    this.persistence = persistence || new MemoryJobPersistence();\r\n\r\n    // Default config\r\n    this.config.maxJobs = this.config.maxJobs || 1000;\r\n    this.config.jobTTL = this.config.jobTTL || 86400000; // 24 hours\r\n    this.config.defaultPollInterval = this.config.defaultPollInterval || 5;\r\n\r\n    // Cleanup expired jobs periodically\r\n    setInterval(() => this.cleanupExpiredJobs(), 3600000); // Every hour\r\n  }\r\n\r\n  /**\r\n   * Submit async job (MCP 2025-11 format)\r\n   */\r\n  async submitJob(\r\n    request: MCPToolRequest,\r\n    executor: (args: any, onProgress: (percent: number, message?: string) => void) => Promise<any>\r\n  ): Promise<MCPJobHandle> {\r\n    // Check capacity\r\n    if (this.jobs.size >= this.config.maxJobs!) {\r\n      throw new Error('Job queue full. Please try again later.');\r\n    }\r\n\r\n    // Check for duplicate request_id (prevent race conditions)\r\n    const existingJob = Array.from(this.jobs.values()).find(\r\n      j => j.request_id === request.request_id &&\r\n           (j.status === 'queued' || j.status === 'running')\r\n    );\r\n    if (existingJob) {\r\n      throw new Error(`Duplicate request_id: ${request.request_id}. Job already submitted.`);\r\n    }\r\n\r\n    // Create job\r\n    const job: AsyncJob = {\r\n      request_id: request.request_id,\r\n      job_id: uuidv4(),\r\n      tool_id: request.tool_id,\r\n      arguments: request.arguments,\r\n      mode: request.mode,\r\n      status: 'queued',\r\n      progress: 0,\r\n      context: request.context,\r\n      created_at: new Date(),\r\n    };\r\n\r\n    // Save to persistence\r\n    await this.persistence.save(job);\r\n    this.jobs.set(job.job_id, job);\r\n\r\n    this.logger.info('Job submitted', {\r\n      job_id: job.job_id,\r\n      request_id: job.request_id,\r\n      tool_id: job.tool_id,\r\n    });\r\n\r\n    // Start execution in background\r\n    this.executeJob(job, executor);\r\n\r\n    // Return job handle immediately\r\n    return {\r\n      request_id: job.request_id,\r\n      job_id: job.job_id,\r\n      status: 'in_progress',\r\n      poll_after: this.config.defaultPollInterval!,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Poll job status\r\n   */\r\n  async pollJob(job_id: string): Promise<MCPJobHandle> {\r\n    const job = await this.persistence.load(job_id);\r\n\r\n    if (!job) {\r\n      throw new Error(`Job not found: ${job_id}`);\r\n    }\r\n\r\n    const status = job.status === 'success' ? 'success' :\r\n                   job.status === 'error' ? 'error' : 'in_progress';\r\n\r\n    const handle: MCPJobHandle = {\r\n      request_id: job.request_id,\r\n      job_id: job.job_id,\r\n      status,\r\n      poll_after: status === 'in_progress' ? this.config.defaultPollInterval! : 0,\r\n    };\r\n\r\n    if (status === 'in_progress') {\r\n      handle.progress = {\r\n        percent: job.progress,\r\n        message: job.progress_message,\r\n      };\r\n    }\r\n\r\n    return handle;\r\n  }\r\n\r\n  /**\r\n   * Resume job (get results)\r\n   */\r\n  async resumeJob(job_id: string): Promise<MCPJobResult> {\r\n    const job = await this.persistence.load(job_id);\r\n\r\n    if (!job) {\r\n      throw new Error(`Job not found: ${job_id}`);\r\n    }\r\n\r\n    const result: MCPJobResult = {\r\n      request_id: job.request_id,\r\n      status: job.status === 'success' ? 'success' :\r\n              job.status === 'error' ? 'error' : 'in_progress',\r\n      metadata: {},\r\n    };\r\n\r\n    if (job.status === 'success') {\r\n      result.result = job.result;\r\n      result.metadata.duration_ms = job.completed_at && job.started_at\r\n        ? job.completed_at.getTime() - job.started_at.getTime()\r\n        : undefined;\r\n      result.metadata.tokens_used = job.tokens_used;\r\n    } else if (job.status === 'error') {\r\n      result.error = {\r\n        code: 'EXECUTION_ERROR',\r\n        message: job.error?.message || 'Job execution failed',\r\n        details: job.error,\r\n      };\r\n    } else {\r\n      // Still in progress\r\n      result.progress = {\r\n        percent: job.progress,\r\n        message: job.progress_message,\r\n      };\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Cancel a running job\r\n   */\r\n  async cancelJob(job_id: string): Promise<boolean> {\r\n    const job = this.jobs.get(job_id);\r\n\r\n    if (!job) {\r\n      return false;\r\n    }\r\n\r\n    if (job.status === 'success' || job.status === 'error') {\r\n      return false; // Already finished\r\n    }\r\n\r\n    // Abort execution if AbortController is available\r\n    if (job.abortController) {\r\n      job.abortController.abort();\r\n    }\r\n\r\n    job.status = 'cancelled';\r\n    job.completed_at = new Date();\r\n    await this.persistence.save(job);\r\n\r\n    this.emit('job:cancelled', job_id);\r\n    this.logger.info('Job cancelled', { job_id });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * List jobs\r\n   */\r\n  async listJobs(filter?: {\r\n    status?: string;\r\n    limit?: number;\r\n  }): Promise<AsyncJob[]> {\r\n    return await this.persistence.list(filter);\r\n  }\r\n\r\n  /**\r\n   * Execute job in background\r\n   */\r\n  private async executeJob(\r\n    job: AsyncJob,\r\n    executor: (args: any, onProgress: (percent: number, message?: string) => void) => Promise<any>\r\n  ): Promise<void> {\r\n    // Update status to running\r\n    job.status = 'running';\r\n    job.started_at = new Date();\r\n\r\n    // Create AbortController for cancellation support\r\n    job.abortController = new AbortController();\r\n\r\n    await this.persistence.save(job);\r\n\r\n    this.emit('job:started', job.job_id);\r\n    this.logger.info('Job started', { job_id: job.job_id, tool_id: job.tool_id });\r\n\r\n    try {\r\n      // Progress callback\r\n      const onProgress = (percent: number, message?: string) => {\r\n        job.progress = Math.min(100, Math.max(0, percent));\r\n        job.progress_message = message;\r\n        this.persistence.save(job).catch(err =>\r\n          this.logger.error('Failed to save progress', { job_id: job.job_id, error: err })\r\n        );\r\n        this.emit('job:progress', job.job_id, job.progress, message);\r\n      };\r\n\r\n      // Check if already cancelled\r\n      if (job.abortController.signal.aborted) {\r\n        throw new Error('Job cancelled before execution');\r\n      }\r\n\r\n      // Execute with abort support\r\n      const result = await executor(job.arguments, onProgress);\r\n\r\n      // Mark successful\r\n      job.status = 'success';\r\n      job.result = result;\r\n      job.progress = 100;\r\n      job.completed_at = new Date();\r\n      await this.persistence.save(job);\r\n\r\n      this.emit('job:completed', job.job_id, result);\r\n      this.logger.info('Job completed', {\r\n        job_id: job.job_id,\r\n        duration_ms: job.completed_at.getTime() - job.started_at!.getTime(),\r\n      });\r\n    } catch (error: any) {\r\n      // Mark failed\r\n      job.status = 'error';\r\n      job.error = {\r\n        message: error.message,\r\n        stack: error.stack,\r\n        code: error.code,\r\n      };\r\n      job.completed_at = new Date();\r\n      await this.persistence.save(job);\r\n\r\n      this.emit('job:failed', job.job_id, error);\r\n      this.logger.error('Job failed', {\r\n        job_id: job.job_id,\r\n        error: error.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired jobs\r\n   */\r\n  private async cleanupExpiredJobs(): Promise<number> {\r\n    const now = Date.now();\r\n    const jobs = await this.persistence.list();\r\n    let cleaned = 0;\r\n\r\n    for (const job of jobs) {\r\n      const age = now - job.created_at.getTime();\r\n\r\n      // Remove if expired and not running\r\n      if (age > this.config.jobTTL! && job.status !== 'running') {\r\n        await this.persistence.delete(job.job_id);\r\n        this.jobs.delete(job.job_id);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      this.logger.info('Cleaned up expired jobs', { count: cleaned });\r\n    }\r\n\r\n    return cleaned;\r\n  }\r\n\r\n  /**\r\n   * Get metrics\r\n   */\r\n  getMetrics() {\r\n    const jobs = Array.from(this.jobs.values());\r\n\r\n    return {\r\n      total: jobs.length,\r\n      byStatus: {\r\n        queued: jobs.filter(j => j.status === 'queued').length,\r\n        running: jobs.filter(j => j.status === 'running').length,\r\n        success: jobs.filter(j => j.status === 'success').length,\r\n        error: jobs.filter(j => j.status === 'error').length,\r\n        cancelled: jobs.filter(j => j.status === 'cancelled').length,\r\n      },\r\n      averageDuration: this.calculateAverageDuration(jobs),\r\n    };\r\n  }\r\n\r\n  private calculateAverageDuration(jobs: AsyncJob[]): number {\r\n    const completed = jobs.filter(j =>\r\n      (j.status === 'success' || j.status === 'error') &&\r\n      j.started_at && j.completed_at\r\n    );\r\n\r\n    if (completed.length === 0) return 0;\r\n\r\n    const total = completed.reduce((sum, j) =>\r\n      sum + (j.completed_at!.getTime() - j.started_at!.getTime()), 0\r\n    );\r\n\r\n    return total / completed.length;\r\n  }\r\n}\r\n"],"names":["EventEmitter","v4","uuidv4","MemoryJobPersistence","jobs","Map","save","job","set","job_id","load","get","list","filter","Array","from","values","status","j","limit","slice","delete","MCPAsyncJobManager","executors","persistence","logger","config","maxJobs","jobTTL","defaultPollInterval","setInterval","cleanupExpiredJobs","submitJob","request","executor","size","Error","existingJob","find","request_id","tool_id","arguments","mode","progress","context","created_at","Date","info","executeJob","poll_after","pollJob","handle","percent","message","progress_message","resumeJob","result","metadata","duration_ms","completed_at","started_at","getTime","undefined","tokens_used","error","code","details","cancelJob","abortController","abort","emit","listJobs","AbortController","onProgress","Math","min","max","catch","err","signal","aborted","stack","now","cleaned","age","count","getMetrics","total","length","byStatus","queued","running","success","cancelled","averageDuration","calculateAverageDuration","completed","reduce","sum"],"mappings":"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"}