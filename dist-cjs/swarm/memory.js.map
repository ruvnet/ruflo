{
  "version": 3,
  "sources": ["../../src/swarm/memory.ts"],
  "sourcesContent": ["/**\n * Distributed Memory System with Cross-Agent Sharing\n */\n\nimport { EventEmitter } from 'node:events';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\nimport * as crypto from 'node:crypto';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport {\n  MemoryEntry,\n  MemoryPartition,\n  SwarmMemory,\n  AccessLevel,\n  ConsistencyLevel,\n  MemoryType,\n  MemoryPermissions,\n  AgentId,\n  SwarmEvent,\n  SWARM_CONSTANTS,\n} from './types.js';\n\nexport interface MemoryQuery {\n  namespace?: string;\n  partition?: string;\n  key?: string;\n  tags?: string[];\n  type?: MemoryType;\n  owner?: AgentId;\n  accessLevel?: AccessLevel;\n  createdAfter?: Date;\n  createdBefore?: Date;\n  expiresAfter?: Date;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'createdAt' | 'updatedAt' | 'key' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface MemorySearchOptions {\n  query: string;\n  searchFields?: string[];\n  fuzzyMatch?: boolean;\n  maxResults?: number;\n  threshold?: number;\n  includeContent?: boolean;\n}\n\nexport interface MemoryStatistics {\n  totalEntries: number;\n  totalSize: number;\n  partitionCount: number;\n  entriesByType: Record<MemoryType, number>;\n  entriesByAccess: Record<AccessLevel, number>;\n  averageSize: number;\n  oldestEntry: Date;\n  newestEntry: Date;\n  expiringEntries: number;\n}\n\nexport interface MemoryBackup {\n  timestamp: Date;\n  version: string;\n  checksum: string;\n  metadata: Record<string, any>;\n  entries: MemoryEntry[];\n  partitions: MemoryPartition[];\n}\n\nexport interface MemoryConfig {\n  namespace: string;\n  persistencePath: string;\n  maxMemorySize: number;\n  maxEntrySize: number;\n  defaultTtl: number;\n  enableCompression: boolean;\n  enableEncryption: boolean;\n  encryptionKey?: string;\n  consistencyLevel: ConsistencyLevel;\n  syncInterval: number;\n  backupInterval: number;\n  maxBackups: number;\n  enableDistribution: boolean;\n  distributionNodes: string[];\n  replicationFactor: number;\n  enableCaching: boolean;\n  cacheSize: number;\n  cacheTtl: number;\n}\n\nexport class SwarmMemoryManager extends EventEmitter {\n  private logger: Logger;\n  private config: MemoryConfig;\n  private memory: SwarmMemory;\n  private partitions: Map<string, MemoryPartition> = new Map();\n  private entries: Map<string, MemoryEntry> = new Map();\n  private index: MemoryIndex;\n  private cache: MemoryCache;\n  private replication: MemoryReplication;\n  private persistence: MemoryPersistence;\n  private encryption: MemoryEncryption;\n  private isInitialized = false;\n\n  // Background processes\n  private syncTimer?: NodeJS.Timeout;\n  private backupTimer?: NodeJS.Timeout;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  constructor(config: Partial<MemoryConfig & { logging?: any }> = {}) {\n    super();\n\n    // Configure logger based on config or default to quiet mode\n    const logLevel = config.logging?.level || 'error';\n    const logFormat = config.logging?.format || 'text';\n    const logDestination = config.logging?.destination || 'console';\n\n    this.logger = new Logger(\n      { level: logLevel, format: logFormat, destination: logDestination },\n      { component: 'SwarmMemoryManager' },\n    );\n    this.config = this.mergeWithDefaults(config);\n\n    // Initialize memory structure\n    this.memory = {\n      namespace: this.config.namespace,\n      partitions: [],\n      permissions: {\n        read: 'swarm',\n        write: 'team',\n        delete: 'private',\n        share: 'team',\n      },\n      persistent: true,\n      backupEnabled: true,\n      distributed: this.config.enableDistribution,\n      consistency: this.config.consistencyLevel,\n      cacheEnabled: this.config.enableCaching,\n      compressionEnabled: this.config.enableCompression,\n    };\n\n    // Initialize subsystems\n    this.index = new MemoryIndex();\n    this.cache = new MemoryCache(this.config.cacheSize, this.config.cacheTtl);\n    this.replication = new MemoryReplication(this.config);\n    this.persistence = new MemoryPersistence(this.config);\n    this.encryption = new MemoryEncryption(this.config);\n\n    this.setupEventHandlers();\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    this.logger.info('Initializing swarm memory manager...');\n\n    try {\n      // Initialize subsystems\n      await this.persistence.initialize();\n      await this.encryption.initialize();\n      await this.replication.initialize();\n      await this.index.initialize();\n\n      // Load existing data\n      await this.loadMemoryState();\n\n      // Create default partitions\n      await this.createDefaultPartitions();\n\n      // Start background processes\n      this.startBackgroundProcesses();\n\n      this.isInitialized = true;\n\n      this.emit('memory:initialized', {\n        namespace: this.config.namespace,\n        entriesLoaded: this.entries.size,\n        partitionsLoaded: this.partitions.size,\n      });\n\n      this.logger.info('Swarm memory manager initialized', {\n        namespace: this.config.namespace,\n        entries: this.entries.size,\n        partitions: this.partitions.size,\n      });\n    } catch (error) {\n      this.logger.error('Failed to initialize memory manager', { error });\n      throw error;\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down swarm memory manager...');\n\n    try {\n      // Stop background processes\n      this.stopBackgroundProcesses();\n\n      // Save final state\n      await this.saveMemoryState();\n\n      // Shutdown subsystems\n      await this.replication.shutdown();\n      await this.persistence.shutdown();\n      await this.encryption.shutdown();\n\n      this.isInitialized = false;\n\n      this.emit('memory:shutdown');\n      this.logger.info('Swarm memory manager shut down');\n    } catch (error) {\n      this.logger.error('Error during memory manager shutdown', { error });\n    }\n  }\n\n  // ===== MEMORY OPERATIONS =====\n\n  async store(\n    key: string,\n    value: any,\n    options: Partial<{\n      partition: string;\n      type: MemoryType;\n      tags: string[];\n      owner: AgentId;\n      accessLevel: AccessLevel;\n      ttl: number;\n      metadata: Record<string, any>;\n    }> = {},\n  ): Promise<string> {\n    this.ensureInitialized();\n\n    const entryId = generateId('mem');\n    const now = new Date();\n\n    // Validate access permissions\n    if (options.owner) {\n      await this.validateAccess(options.owner, 'write', options.partition);\n    }\n\n    // Determine partition\n    const partitionName = options.partition || 'default';\n    const partition = await this.getOrCreatePartition(partitionName);\n\n    // Create memory entry\n    const entry: MemoryEntry = {\n      id: entryId,\n      key,\n      value: await this.serializeValue(value),\n      type: options.type || 'knowledge',\n      tags: options.tags || [],\n      owner: options.owner || { id: 'system', swarmId: '', type: 'coordinator', instance: 0 },\n      accessLevel: options.accessLevel || 'team',\n      createdAt: now,\n      updatedAt: now,\n      expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n      version: 1,\n      references: [],\n      dependencies: [],\n    };\n\n    // Validate entry size\n    const entrySize = this.calculateEntrySize(entry);\n    if (entrySize > this.config.maxEntrySize) {\n      throw new Error(`Entry size ${entrySize} exceeds maximum ${this.config.maxEntrySize}`);\n    }\n\n    // Check memory limits\n    await this.enforceMemoryLimits(entrySize);\n\n    // Store entry\n    this.entries.set(entryId, entry);\n    partition.entries.push(entry);\n\n    // Update index\n    await this.index.addEntry(entry);\n\n    // Update cache\n    if (this.config.enableCaching) {\n      this.cache.set(key, entry);\n    }\n\n    // Replicate if enabled\n    if (this.config.enableDistribution) {\n      await this.replication.replicate(entry);\n    }\n\n    // Emit event\n    this.emit('memory:stored', {\n      entryId,\n      key,\n      partition: partitionName,\n      type: entry.type,\n      size: entrySize,\n    });\n\n    this.logger.debug('Stored memory entry', {\n      entryId,\n      key,\n      partition: partitionName,\n      type: entry.type,\n      size: entrySize,\n    });\n\n    return entryId;\n  }\n\n  async retrieve(\n    key: string,\n    options: Partial<{\n      partition: string;\n      requester: AgentId;\n      includeMetadata: boolean;\n    }> = {},\n  ): Promise<any> {\n    this.ensureInitialized();\n\n    // Try cache first\n    if (this.config.enableCaching) {\n      const cached = this.cache.get(key);\n      if (cached && !this.isExpired(cached)) {\n        if (options.requester) {\n          await this.validateAccess(options.requester, 'read', options.partition);\n        }\n        return options.includeMetadata ? cached : await this.deserializeValue(cached.value);\n      }\n    }\n\n    // Find entry\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      return null;\n    }\n\n    // Check expiration\n    if (this.isExpired(entry)) {\n      await this.deleteEntry(entry.id);\n      return null;\n    }\n\n    // Validate access\n    if (options.requester) {\n      await this.validateAccess(options.requester, 'read', options.partition);\n    }\n\n    // Update cache\n    if (this.config.enableCaching) {\n      this.cache.set(key, entry);\n    }\n\n    // Emit event\n    this.emit('memory:retrieved', {\n      entryId: entry.id,\n      key,\n      requester: options.requester?.id,\n    });\n\n    return options.includeMetadata ? entry : await this.deserializeValue(entry.value);\n  }\n\n  async update(\n    key: string,\n    value: any,\n    options: Partial<{\n      partition: string;\n      updater: AgentId;\n      metadata: Record<string, any>;\n      incrementVersion: boolean;\n    }> = {},\n  ): Promise<boolean> {\n    this.ensureInitialized();\n\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      return false;\n    }\n\n    // Validate access\n    if (options.updater) {\n      await this.validateAccess(options.updater, 'write', options.partition);\n    }\n\n    // Create backup of old version\n    if (options.incrementVersion !== false) {\n      entry.previousVersions = entry.previousVersions || [];\n      entry.previousVersions.push({ ...entry });\n\n      // Limit version history\n      if (entry.previousVersions.length > 10) {\n        entry.previousVersions = entry.previousVersions.slice(-10);\n      }\n    }\n\n    // Update entry\n    entry.value = await this.serializeValue(value);\n    entry.updatedAt = new Date();\n    if (options.incrementVersion !== false) {\n      entry.version++;\n    }\n\n    // Update index\n    await this.index.updateEntry(entry);\n\n    // Update cache\n    if (this.config.enableCaching) {\n      this.cache.set(key, entry);\n    }\n\n    // Replicate if enabled\n    if (this.config.enableDistribution) {\n      await this.replication.replicate(entry);\n    }\n\n    this.emit('memory:updated', {\n      entryId: entry.id,\n      key,\n      version: entry.version,\n      updater: options.updater?.id,\n    });\n\n    return true;\n  }\n\n  async delete(\n    key: string,\n    options: Partial<{\n      partition: string;\n      deleter: AgentId;\n      force: boolean;\n    }> = {},\n  ): Promise<boolean> {\n    this.ensureInitialized();\n\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      return false;\n    }\n\n    // Validate access\n    if (options.deleter && !options.force) {\n      await this.validateAccess(options.deleter, 'delete', options.partition);\n    }\n\n    return await this.deleteEntry(entry.id);\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    this.ensureInitialized();\n\n    let results = Array.from(this.entries.values());\n\n    // Apply filters\n    if (query.partition) {\n      const partition = this.partitions.get(query.partition);\n      if (partition) {\n        const entryIds = new Set(partition.entries.map((e) => e.id));\n        results = results.filter((e) => entryIds.has(e.id));\n      } else {\n        return [];\n      }\n    }\n\n    if (query.key) {\n      results = results.filter((e) => e.key === query.key);\n    }\n\n    if (query.type) {\n      results = results.filter((e) => e.type === query.type);\n    }\n\n    if (query.owner) {\n      results = results.filter((e) => e.owner.id === query.owner!.id);\n    }\n\n    if (query.accessLevel) {\n      results = results.filter((e) => e.accessLevel === query.accessLevel);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter((e) => query.tags!.some((tag) => e.tags.includes(tag)));\n    }\n\n    if (query.createdAfter) {\n      results = results.filter((e) => e.createdAt >= query.createdAfter!);\n    }\n\n    if (query.createdBefore) {\n      results = results.filter((e) => e.createdAt <= query.createdBefore!);\n    }\n\n    if (query.expiresAfter) {\n      results = results.filter((e) => e.expiresAt && e.expiresAt >= query.expiresAfter!);\n    }\n\n    // Filter out expired entries\n    results = results.filter((e) => !this.isExpired(e));\n\n    // Sort results\n    if (query.sortBy) {\n      results.sort((a, b) => {\n        let compareValue = 0;\n\n        switch (query.sortBy) {\n          case 'createdAt':\n            compareValue = a.createdAt.getTime() - b.createdAt.getTime();\n            break;\n          case 'updatedAt':\n            compareValue = a.updatedAt.getTime() - b.updatedAt.getTime();\n            break;\n          case 'key':\n            compareValue = a.key.localeCompare(b.key);\n            break;\n          default:\n            compareValue = 0;\n        }\n\n        return query.sortOrder === 'desc' ? -compareValue : compareValue;\n      });\n    }\n\n    // Apply pagination\n    const offset = query.offset || 0;\n    const limit = query.limit || results.length;\n    results = results.slice(offset, offset + limit);\n\n    return results;\n  }\n\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\n    this.ensureInitialized();\n    return await this.index.search(options);\n  }\n\n  // ===== SHARING AND COLLABORATION =====\n\n  async shareMemory(\n    key: string,\n    targetAgent: AgentId,\n    options: Partial<{\n      partition: string;\n      sharer: AgentId;\n      accessLevel: AccessLevel;\n      expiresAt: Date;\n    }> = {},\n  ): Promise<string> {\n    this.ensureInitialized();\n\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      throw new Error(`Memory entry not found: ${key}`);\n    }\n\n    // Validate sharing permissions\n    if (options.sharer) {\n      await this.validateAccess(options.sharer, 'share', options.partition);\n    }\n\n    // Create shared copy\n    const sharedEntryId = generateId('shared-mem');\n    const sharedEntry: MemoryEntry = {\n      ...entry,\n      id: sharedEntryId,\n      owner: targetAgent,\n      accessLevel: options.accessLevel || entry.accessLevel,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      expiresAt: options.expiresAt,\n      references: [...entry.references, entry.id],\n    };\n\n    // Store shared entry\n    this.entries.set(sharedEntryId, sharedEntry);\n    await this.index.addEntry(sharedEntry);\n\n    // Add to target agent's partition\n    const targetPartition = await this.getOrCreatePartition(`agent_${targetAgent.id}`);\n    targetPartition.entries.push(sharedEntry);\n\n    this.emit('memory:shared', {\n      originalId: entry.id,\n      sharedId: sharedEntryId,\n      key,\n      sharer: options.sharer?.id,\n      target: targetAgent.id,\n    });\n\n    this.logger.info('Shared memory entry', {\n      key,\n      from: options.sharer?.id,\n      to: targetAgent.id,\n      sharedId: sharedEntryId,\n    });\n\n    return sharedEntryId;\n  }\n\n  async broadcastMemory(\n    key: string,\n    targetAgents: AgentId[],\n    options: Partial<{\n      partition: string;\n      broadcaster: AgentId;\n      accessLevel: AccessLevel;\n    }> = {},\n  ): Promise<string[]> {\n    this.ensureInitialized();\n\n    const sharedIds: string[] = [];\n\n    for (const targetAgent of targetAgents) {\n      try {\n        const sharedId = await this.shareMemory(key, targetAgent, {\n          ...options,\n          sharer: options.broadcaster,\n        });\n        sharedIds.push(sharedId);\n      } catch (error) {\n        this.logger.warn('Failed to share memory with agent', {\n          key,\n          targetAgent: targetAgent.id,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    this.emit('memory:broadcasted', {\n      key,\n      broadcaster: options.broadcaster?.id,\n      targets: targetAgents.map((a) => a.id),\n      sharedCount: sharedIds.length,\n    });\n\n    return sharedIds;\n  }\n\n  async synchronizeWith(\n    targetNode: string,\n    options: Partial<{\n      partition: string;\n      direction: 'pull' | 'push' | 'bidirectional';\n      filter: MemoryQuery;\n    }> = {},\n  ): Promise<void> {\n    this.ensureInitialized();\n\n    if (!this.config.enableDistribution) {\n      throw new Error('Distribution not enabled');\n    }\n\n    await this.replication.synchronizeWith(targetNode, options);\n\n    this.emit('memory:synchronized', {\n      targetNode,\n      direction: options.direction || 'bidirectional',\n      partition: options.partition,\n    });\n  }\n\n  // ===== PARTITION MANAGEMENT =====\n\n  async createPartition(\n    name: string,\n    options: Partial<{\n      type: MemoryType;\n      maxSize: number;\n      ttl: number;\n      readOnly: boolean;\n      shared: boolean;\n      indexed: boolean;\n      compressed: boolean;\n    }> = {},\n    skipInitCheck: boolean = false,\n  ): Promise<string> {\n    if (!skipInitCheck) {\n      this.ensureInitialized();\n    }\n\n    if (this.partitions.has(name)) {\n      throw new Error(`Partition already exists: ${name}`);\n    }\n\n    const partition: MemoryPartition = {\n      id: generateId('partition'),\n      name,\n      type: options.type || 'knowledge',\n      entries: [],\n      maxSize: options.maxSize || this.config.maxMemorySize,\n      ttl: options.ttl,\n      readOnly: options.readOnly || false,\n      shared: options.shared || true,\n      indexed: options.indexed !== false,\n      compressed: options.compressed || this.config.enableCompression,\n    };\n\n    this.partitions.set(name, partition);\n    this.memory.partitions.push(partition);\n\n    this.emit('memory:partition-created', {\n      partitionId: partition.id,\n      name,\n      type: partition.type,\n    });\n\n    this.logger.info('Created memory partition', {\n      name,\n      type: partition.type,\n      maxSize: partition.maxSize,\n    });\n\n    return partition.id;\n  }\n\n  async deletePartition(name: string, force: boolean = false): Promise<boolean> {\n    this.ensureInitialized();\n\n    const partition = this.partitions.get(name);\n    if (!partition) {\n      return false;\n    }\n\n    if (partition.entries.length > 0 && !force) {\n      throw new Error(`Partition ${name} contains entries. Use force=true to delete.`);\n    }\n\n    // Delete all entries in partition\n    for (const entry of partition.entries) {\n      await this.deleteEntry(entry.id);\n    }\n\n    this.partitions.delete(name);\n    this.memory.partitions = this.memory.partitions.filter((p) => p.id !== partition.id);\n\n    this.emit('memory:partition-deleted', {\n      partitionId: partition.id,\n      name,\n    });\n\n    return true;\n  }\n\n  getPartition(name: string): MemoryPartition | undefined {\n    return this.partitions.get(name);\n  }\n\n  getPartitions(): MemoryPartition[] {\n    return Array.from(this.partitions.values());\n  }\n\n  // ===== BACKUP AND RECOVERY =====\n\n  async createBackup(): Promise<string> {\n    this.ensureInitialized();\n\n    const backup: MemoryBackup = {\n      timestamp: new Date(),\n      version: '1.0.0',\n      checksum: '',\n      metadata: {\n        namespace: this.config.namespace,\n        entryCount: this.entries.size,\n        partitionCount: this.partitions.size,\n      },\n      entries: Array.from(this.entries.values()),\n      partitions: Array.from(this.partitions.values()),\n    };\n\n    // Calculate checksum\n    backup.checksum = this.calculateChecksum(backup);\n\n    const backupId = generateId('backup');\n    await this.persistence.saveBackup(backupId, backup);\n\n    this.emit('memory:backup-created', {\n      backupId,\n      entryCount: backup.entries.length,\n      size: JSON.stringify(backup).length,\n    });\n\n    return backupId;\n  }\n\n  async restoreFromBackup(backupId: string): Promise<void> {\n    this.ensureInitialized();\n\n    const backup = await this.persistence.loadBackup(backupId);\n    if (!backup) {\n      throw new Error(`Backup not found: ${backupId}`);\n    }\n\n    // Verify checksum\n    const calculatedChecksum = this.calculateChecksum(backup);\n    if (calculatedChecksum !== backup.checksum) {\n      throw new Error('Backup checksum verification failed');\n    }\n\n    // Clear current state\n    this.entries.clear();\n    this.partitions.clear();\n    await this.index.clear();\n\n    // Restore entries\n    for (const entry of backup.entries) {\n      this.entries.set(entry.id, entry);\n      await this.index.addEntry(entry);\n    }\n\n    // Restore partitions\n    for (const partition of backup.partitions) {\n      this.partitions.set(partition.name, partition);\n    }\n\n    this.memory.partitions = backup.partitions;\n\n    this.emit('memory:backup-restored', {\n      backupId,\n      entryCount: backup.entries.length,\n      partitionCount: backup.partitions.length,\n    });\n\n    this.logger.info('Restored from backup', {\n      backupId,\n      entries: backup.entries.length,\n      partitions: backup.partitions.length,\n    });\n  }\n\n  // ===== STATISTICS AND MONITORING =====\n\n  getStatistics(): MemoryStatistics {\n    const entries = Array.from(this.entries.values());\n    const validEntries = entries.filter((e) => !this.isExpired(e));\n\n    const entriesByType: Record<MemoryType, number> = {\n      knowledge: 0,\n      state: 0,\n      cache: 0,\n      logs: 0,\n      results: 0,\n      communication: 0,\n      configuration: 0,\n      metrics: 0,\n    };\n\n    const entriesByAccess: Record<AccessLevel, number> = {\n      private: 0,\n      team: 0,\n      swarm: 0,\n      public: 0,\n      system: 0,\n    };\n\n    let totalSize = 0;\n    let oldestEntry = new Date();\n    let newestEntry = new Date(0);\n    let expiringEntries = 0;\n\n    for (const entry of validEntries) {\n      entriesByType[entry.type]++;\n      entriesByAccess[entry.accessLevel]++;\n\n      const entrySize = this.calculateEntrySize(entry);\n      totalSize += entrySize;\n\n      if (entry.createdAt < oldestEntry) {\n        oldestEntry = entry.createdAt;\n      }\n\n      if (entry.createdAt > newestEntry) {\n        newestEntry = entry.createdAt;\n      }\n\n      if (entry.expiresAt && entry.expiresAt.getTime() - Date.now() < 24 * 60 * 60 * 1000) {\n        expiringEntries++;\n      }\n    }\n\n    return {\n      totalEntries: validEntries.length,\n      totalSize,\n      partitionCount: this.partitions.size,\n      entriesByType,\n      entriesByAccess,\n      averageSize: validEntries.length > 0 ? totalSize / validEntries.length : 0,\n      oldestEntry,\n      newestEntry,\n      expiringEntries,\n    };\n  }\n\n  async exportMemory(\n    options: Partial<{\n      format: 'json' | 'csv';\n      includeExpired: boolean;\n      filter: MemoryQuery;\n    }> = {},\n  ): Promise<string> {\n    this.ensureInitialized();\n\n    let entries = Array.from(this.entries.values());\n\n    if (!options.includeExpired) {\n      entries = entries.filter((e) => !this.isExpired(e));\n    }\n\n    if (options.filter) {\n      const filteredResults = await this.query(options.filter);\n      const filteredIds = new Set(filteredResults.map((e) => e.id));\n      entries = entries.filter((e) => filteredIds.has(e.id));\n    }\n\n    if (options.format === 'csv') {\n      return this.entriesToCSV(entries);\n    } else {\n      return JSON.stringify(\n        {\n          exported: new Date().toISOString(),\n          namespace: this.config.namespace,\n          entryCount: entries.length,\n          entries: entries.map((e) => ({\n            ...e,\n            value: e.value, // Value is already serialized\n          })),\n        },\n        null,\n        2,\n      );\n    }\n  }\n\n  // ===== PRIVATE METHODS =====\n\n  private ensureInitialized(): void {\n    if (!this.isInitialized) {\n      throw new Error('Memory manager not initialized');\n    }\n  }\n\n  private async findEntry(key: string, partition?: string): Promise<MemoryEntry | null> {\n    for (const entry of this.entries.values()) {\n      if (entry.key === key) {\n        if (partition) {\n          const part = this.partitions.get(partition);\n          if (part && part.entries.find((e) => e.id === entry.id)) {\n            return entry;\n          }\n        } else {\n          return entry;\n        }\n      }\n    }\n    return null;\n  }\n\n  private async deleteEntry(entryId: string): Promise<boolean> {\n    const entry = this.entries.get(entryId);\n    if (!entry) {\n      return false;\n    }\n\n    // Remove from entries\n    this.entries.delete(entryId);\n\n    // Remove from partitions\n    for (const partition of this.partitions.values()) {\n      partition.entries = partition.entries.filter((e) => e.id !== entryId);\n    }\n\n    // Remove from index\n    await this.index.removeEntry(entryId);\n\n    // Remove from cache\n    if (this.config.enableCaching) {\n      this.cache.delete(entry.key);\n    }\n\n    this.emit('memory:deleted', {\n      entryId,\n      key: entry.key,\n    });\n\n    return true;\n  }\n\n  private isExpired(entry: MemoryEntry): boolean {\n    return entry.expiresAt ? entry.expiresAt <= new Date() : false;\n  }\n\n  private async validateAccess(\n    agent: AgentId,\n    operation: 'read' | 'write' | 'delete' | 'share',\n    partition?: string,\n  ): Promise<void> {\n    // Implement access control logic here\n    // For now, allow all operations\n    return;\n  }\n\n  private async getOrCreatePartition(name: string): Promise<MemoryPartition> {\n    let partition = this.partitions.get(name);\n    if (!partition) {\n      await this.createPartition(name, {}, !this.isInitialized);\n      partition = this.partitions.get(name)!;\n    }\n    return partition;\n  }\n\n  private async serializeValue(value: any): Promise<any> {\n    // Apply compression and encryption if enabled\n    let serialized = JSON.stringify(value);\n\n    if (this.config.enableCompression) {\n      // Compression would be implemented here\n      // For now, just return the serialized value\n    }\n\n    if (this.config.enableEncryption) {\n      serialized = await this.encryption.encrypt(serialized);\n    }\n\n    return serialized;\n  }\n\n  private async deserializeValue(value: any): Promise<any> {\n    let deserialized = value;\n\n    if (this.config.enableEncryption) {\n      deserialized = await this.encryption.decrypt(deserialized);\n    }\n\n    if (this.config.enableCompression) {\n      // Decompression would be implemented here\n      // For now, just use the deserialized value\n    }\n\n    return JSON.parse(deserialized);\n  }\n\n  private calculateEntrySize(entry: MemoryEntry): number {\n    return JSON.stringify(entry).length;\n  }\n\n  private async enforceMemoryLimits(newEntrySize: number): Promise<void> {\n    const stats = this.getStatistics();\n    const projectedSize = stats.totalSize + newEntrySize;\n\n    if (projectedSize > this.config.maxMemorySize) {\n      // Remove expired entries first\n      await this.cleanupExpiredEntries();\n\n      // If still over limit, remove oldest entries\n      const updatedStats = this.getStatistics();\n      if (updatedStats.totalSize + newEntrySize > this.config.maxMemorySize) {\n        await this.evictOldEntries(newEntrySize);\n      }\n    }\n  }\n\n  private async cleanupExpiredEntries(): Promise<void> {\n    const expiredEntries = Array.from(this.entries.values()).filter((e) => this.isExpired(e));\n\n    for (const entry of expiredEntries) {\n      await this.deleteEntry(entry.id);\n    }\n\n    if (expiredEntries.length > 0) {\n      this.logger.info('Cleaned up expired entries', { count: expiredEntries.length });\n    }\n  }\n\n  private async evictOldEntries(requiredSpace: number): Promise<void> {\n    const entries = Array.from(this.entries.values())\n      .filter((e) => !this.isExpired(e))\n      .sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n\n    let freedSpace = 0;\n    let evictedCount = 0;\n\n    for (const entry of entries) {\n      if (freedSpace >= requiredSpace) {\n        break;\n      }\n\n      if (entry.accessLevel !== 'system') {\n        // Don't evict system entries\n        const entrySize = this.calculateEntrySize(entry);\n        await this.deleteEntry(entry.id);\n        freedSpace += entrySize;\n        evictedCount++;\n      }\n    }\n\n    this.logger.warn('Evicted old entries for space', {\n      evictedCount,\n      freedSpace,\n      requiredSpace,\n    });\n  }\n\n  private calculateChecksum(backup: MemoryBackup): string {\n    const content = JSON.stringify({\n      entries: backup.entries,\n      partitions: backup.partitions,\n    });\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  private entriesToCSV(entries: MemoryEntry[]): string {\n    const headers = ['id', 'key', 'type', 'accessLevel', 'createdAt', 'updatedAt', 'owner', 'tags'];\n    const rows = entries.map((entry) => [\n      entry.id,\n      entry.key,\n      entry.type,\n      entry.accessLevel,\n      entry.createdAt.toISOString(),\n      entry.updatedAt.toISOString(),\n      entry.owner.id,\n      entry.tags.join(';'),\n    ]);\n\n    return [headers, ...rows].map((row) => row.join(',')).join('\\n');\n  }\n\n  private async loadMemoryState(): Promise<void> {\n    try {\n      const state = await this.persistence.loadState();\n      if (state) {\n        // Load entries\n        for (const entry of state.entries || []) {\n          this.entries.set(entry.id, entry);\n          await this.index.addEntry(entry);\n        }\n\n        // Load partitions\n        for (const partition of state.partitions || []) {\n          this.partitions.set(partition.name, partition);\n        }\n\n        this.memory.partitions = state.partitions || [];\n\n        this.logger.info('Loaded memory state', {\n          entries: this.entries.size,\n          partitions: this.partitions.size,\n        });\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load memory state', { error });\n    }\n  }\n\n  private async saveMemoryState(): Promise<void> {\n    try {\n      const state = {\n        namespace: this.config.namespace,\n        timestamp: new Date(),\n        entries: Array.from(this.entries.values()),\n        partitions: Array.from(this.partitions.values()),\n      };\n\n      await this.persistence.saveState(state);\n    } catch (error) {\n      this.logger.error('Failed to save memory state', { error });\n    }\n  }\n\n  private async createDefaultPartitions(): Promise<void> {\n    const defaultPartitions = [\n      { name: 'default', type: 'knowledge' as MemoryType },\n      { name: 'system', type: 'configuration' as MemoryType },\n      { name: 'cache', type: 'cache' as MemoryType },\n      { name: 'logs', type: 'logs' as MemoryType },\n    ];\n\n    for (const partition of defaultPartitions) {\n      if (!this.partitions.has(partition.name)) {\n        await this.createPartition(partition.name, { type: partition.type }, true);\n      }\n    }\n  }\n\n  private mergeWithDefaults(config: Partial<MemoryConfig>): MemoryConfig {\n    return {\n      namespace: 'default',\n      persistencePath: './swarm-memory',\n      maxMemorySize: 100 * 1024 * 1024, // 100MB\n      maxEntrySize: 10 * 1024 * 1024, // 10MB\n      defaultTtl: 24 * 60 * 60 * 1000, // 24 hours\n      enableCompression: false,\n      enableEncryption: false,\n      consistencyLevel: 'eventual',\n      syncInterval: 60000, // 1 minute\n      backupInterval: 3600000, // 1 hour\n      maxBackups: 24,\n      enableDistribution: false,\n      distributionNodes: [],\n      replicationFactor: 1,\n      enableCaching: true,\n      cacheSize: 1000,\n      cacheTtl: 300000, // 5 minutes\n      ...config,\n    };\n  }\n\n  private startBackgroundProcesses(): void {\n    // Sync process\n    if (this.config.syncInterval > 0) {\n      this.syncTimer = setInterval(() => {\n        this.performSync();\n      }, this.config.syncInterval);\n    }\n\n    // Backup process\n    if (this.config.backupInterval > 0) {\n      this.backupTimer = setInterval(() => {\n        this.createBackup().catch((error) => {\n          this.logger.error('Background backup failed', { error });\n        });\n      }, this.config.backupInterval);\n    }\n\n    // Cleanup process\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 60000); // Every minute\n  }\n\n  private stopBackgroundProcesses(): void {\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = undefined;\n    }\n\n    if (this.backupTimer) {\n      clearInterval(this.backupTimer);\n      this.backupTimer = undefined;\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n  }\n\n  private async performSync(): Promise<void> {\n    try {\n      await this.saveMemoryState();\n\n      if (this.config.enableDistribution) {\n        await this.replication.sync();\n      }\n    } catch (error) {\n      this.logger.error('Background sync failed', { error });\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Handle replication events\n    this.replication.on('entry-received', async (data: any) => {\n      const entry = data.entry as MemoryEntry;\n      this.entries.set(entry.id, entry);\n      await this.index.addEntry(entry);\n\n      this.emit('memory:replicated', {\n        entryId: entry.id,\n        key: entry.key,\n        source: data.source,\n      });\n    });\n  }\n}\n\n// ===== SUPPORTING CLASSES =====\n\nclass MemoryIndex {\n  private index: Map<string, Set<string>> = new Map();\n\n  async initialize(): Promise<void> {\n    // Initialize search index\n  }\n\n  async addEntry(entry: MemoryEntry): Promise<void> {\n    // Add entry to search index\n    this.indexTerms(entry.id, [entry.key, ...entry.tags, entry.type]);\n  }\n\n  async updateEntry(entry: MemoryEntry): Promise<void> {\n    await this.removeEntry(entry.id);\n    await this.addEntry(entry);\n  }\n\n  async removeEntry(entryId: string): Promise<void> {\n    // Remove from all index terms\n    for (const termSet of this.index.values()) {\n      termSet.delete(entryId);\n    }\n  }\n\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\n    // Implement search logic\n    return [];\n  }\n\n  async clear(): Promise<void> {\n    this.index.clear();\n  }\n\n  private indexTerms(entryId: string, terms: string[]): void {\n    for (const term of terms) {\n      const normalizedTerm = term.toLowerCase();\n      if (!this.index.has(normalizedTerm)) {\n        this.index.set(normalizedTerm, new Set());\n      }\n      this.index.get(normalizedTerm)!.add(entryId);\n    }\n  }\n}\n\nclass MemoryCache {\n  private cache: Map<string, { entry: MemoryEntry; expiry: number }> = new Map();\n  private maxSize: number;\n  private ttl: number;\n\n  constructor(maxSize: number, ttl: number) {\n    this.maxSize = maxSize;\n    this.ttl = ttl;\n  }\n\n  set(key: string, entry: MemoryEntry): void {\n    // Evict if at capacity\n    if (this.cache.size >= this.maxSize) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n\n    this.cache.set(key, {\n      entry,\n      expiry: Date.now() + this.ttl,\n    });\n  }\n\n  get(key: string): MemoryEntry | null {\n    const cached = this.cache.get(key);\n    if (!cached) {\n      return null;\n    }\n\n    if (Date.now() > cached.expiry) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return cached.entry;\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n}\n\nclass MemoryReplication extends EventEmitter {\n  private config: MemoryConfig;\n\n  constructor(config: MemoryConfig) {\n    super();\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    // Initialize replication\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown replication\n  }\n\n  async replicate(entry: MemoryEntry): Promise<void> {\n    // Replicate entry to other nodes\n  }\n\n  async synchronizeWith(targetNode: string, options: any): Promise<void> {\n    // Synchronize with target node\n  }\n\n  async sync(): Promise<void> {\n    // Perform background sync\n  }\n}\n\nclass MemoryPersistence {\n  private config: MemoryConfig;\n\n  constructor(config: MemoryConfig) {\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    await fs.mkdir(this.config.persistencePath, { recursive: true });\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown persistence\n  }\n\n  async saveState(state: any): Promise<void> {\n    const statePath = path.join(this.config.persistencePath, 'state.json');\n    await fs.writeFile(statePath, JSON.stringify(state, null, 2));\n  }\n\n  async loadState(): Promise<any> {\n    try {\n      const statePath = path.join(this.config.persistencePath, 'state.json');\n      const content = await fs.readFile(statePath, 'utf-8');\n      return JSON.parse(content);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async saveBackup(backupId: string, backup: MemoryBackup): Promise<void> {\n    const backupPath = path.join(this.config.persistencePath, 'backups', `${backupId}.json`);\n    await fs.mkdir(path.dirname(backupPath), { recursive: true });\n    await fs.writeFile(backupPath, JSON.stringify(backup, null, 2));\n  }\n\n  async loadBackup(backupId: string): Promise<MemoryBackup | null> {\n    try {\n      const backupPath = path.join(this.config.persistencePath, 'backups', `${backupId}.json`);\n      const content = await fs.readFile(backupPath, 'utf-8');\n      return JSON.parse(content);\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\nclass MemoryEncryption {\n  private config: MemoryConfig;\n\n  constructor(config: MemoryConfig) {\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    // Initialize encryption\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown encryption\n  }\n\n  async encrypt(data: string): Promise<string> {\n    // Implement encryption\n    return data;\n  }\n\n  async decrypt(data: string): Promise<string> {\n    // Implement decryption\n    return data;\n  }\n}\n\nexport default SwarmMemoryManager;\n"],
  "mappings": "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",
  "names": []
}
