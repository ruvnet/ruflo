{
  "version": 3,
  "sources": ["../../src/swarm/mcp-integration-wrapper.ts"],
  "sourcesContent": ["/**\n * MCP Integration Wrapper for Swarm System\n * \n * This module provides a comprehensive wrapper around MCP tools to enable\n * seamless integration with the swarm orchestration system. It handles\n * tool discovery, execution, error handling, and result aggregation.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { createClaudeFlowTools } from '../mcp/claude-flow-tools.js';\nimport { createRuvSwarmTools } from '../mcp/ruv-swarm-tools.js';\nimport type { MCPTool, MCPContext } from '../utils/types.js';\nimport type { AdvancedSwarmOrchestrator } from './advanced-orchestrator.js';\nimport {\n  SwarmAgent,\n  SwarmTask,\n  TaskResult,\n  SwarmExecutionContext,\n  AgentState,\n  TaskDefinition,\n} from './types.js';\n\nexport interface MCPToolExecutionResult {\n  success: boolean;\n  result?: any;\n  error?: string;\n  duration: number;\n  toolName: string;\n  agentId: string;\n  taskId?: string;\n  metadata: {\n    timestamp: Date;\n    executionId: string;\n    attempts: number;\n    resourcesUsed?: any;\n  };\n}\n\nexport interface MCPToolRegistry {\n  tools: Map<string, MCPTool>;\n  categories: Map<string, string[]>;\n  capabilities: Map<string, string[]>;\n  permissions: Map<string, string[]>;\n}\n\nexport interface MCPExecutionContext extends MCPContext {\n  orchestrator: AdvancedSwarmOrchestrator;\n  agent: SwarmAgent;\n  task?: SwarmTask;\n  swarmId: string;\n  executionId: string;\n  timeout: number;\n  maxRetries: number;\n}\n\nexport interface MCPIntegrationConfig {\n  enableClaudeFlowTools: boolean;\n  enableRuvSwarmTools: boolean;\n  enableCustomTools: boolean;\n  toolTimeout: number;\n  maxRetries: number;\n  enableCaching: boolean;\n  cacheTimeout: number;\n  enableMetrics: boolean;\n  enableLogging: boolean;\n  enableErrorRecovery: boolean;\n  parallelExecution: boolean;\n  maxConcurrentTools: number;\n}\n\nexport class MCPIntegrationWrapper extends EventEmitter {\n  private logger: Logger;\n  private config: MCPIntegrationConfig;\n  private toolRegistry: MCPToolRegistry;\n  private executionCache: Map<string, MCPToolExecutionResult> = new Map();\n  private activeExecutions: Map<string, AbortController> = new Map();\n  private metrics: MCPIntegrationMetrics;\n\n  constructor(config: Partial<MCPIntegrationConfig> = {}) {\n    super();\n    \n    this.logger = new Logger('MCPIntegrationWrapper');\n    this.config = this.createDefaultConfig(config);\n    this.toolRegistry = this.initializeToolRegistry();\n    this.metrics = this.initializeMetrics();\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the MCP integration wrapper\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing MCP integration wrapper...');\n\n    try {\n      // Register Claude Flow tools\n      if (this.config.enableClaudeFlowTools) {\n        await this.registerClaudeFlowTools();\n      }\n\n      // Register ruv-swarm tools\n      if (this.config.enableRuvSwarmTools) {\n        await this.registerRuvSwarmTools();\n      }\n\n      // Start cache cleanup if enabled\n      if (this.config.enableCaching) {\n        this.startCacheCleanup();\n      }\n\n      this.logger.info('MCP integration wrapper initialized successfully', {\n        totalTools: this.toolRegistry.tools.size,\n        categories: this.toolRegistry.categories.size,\n        capabilities: this.toolRegistry.capabilities.size,\n      });\n\n      this.emit('initialized', {\n        toolCount: this.toolRegistry.tools.size,\n        config: this.config,\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to initialize MCP integration wrapper', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the wrapper gracefully\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down MCP integration wrapper...');\n\n    try {\n      // Cancel all active executions\n      for (const [executionId, controller] of this.activeExecutions) {\n        controller.abort();\n        this.logger.debug('Cancelled execution', { executionId });\n      }\n      this.activeExecutions.clear();\n\n      // Clear cache if needed\n      this.executionCache.clear();\n\n      this.logger.info('MCP integration wrapper shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during MCP wrapper shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute an MCP tool within a swarm context\n   */\n  async executeTool(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext\n  ): Promise<MCPToolExecutionResult> {\n    const executionId = generateId('mcp-execution');\n    const startTime = performance.now();\n\n    this.logger.info('Executing MCP tool', {\n      toolName,\n      executionId,\n      agentId: context.agent.id,\n      taskId: context.task?.id,\n      swarmId: context.swarmId,\n    });\n\n    try {\n      // Check if tool exists\n      const tool = this.toolRegistry.tools.get(toolName);\n      if (!tool) {\n        throw new Error(`Tool not found: ${toolName}`);\n      }\n\n      // Check cache if enabled\n      if (this.config.enableCaching) {\n        const cached = await this.getCachedResult(toolName, input, context);\n        if (cached) {\n          this.logger.debug('Using cached result', { toolName, executionId });\n          return cached;\n        }\n      }\n\n      // Create abort controller for timeout\n      const abortController = new AbortController();\n      this.activeExecutions.set(executionId, abortController);\n\n      // Set up timeout\n      const timeoutHandle = setTimeout(() => {\n        abortController.abort();\n      }, context.timeout || this.config.toolTimeout);\n\n      try {\n        // Execute tool with retry logic\n        const result = await this.executeWithRetry(\n          tool,\n          input,\n          context,\n          executionId,\n          abortController.signal\n        );\n\n        clearTimeout(timeoutHandle);\n\n        const duration = performance.now() - startTime;\n        const executionResult: MCPToolExecutionResult = {\n          success: true,\n          result,\n          duration,\n          toolName,\n          agentId: context.agent.id,\n          taskId: context.task?.id,\n          metadata: {\n            timestamp: new Date(),\n            executionId,\n            attempts: 1,\n          },\n        };\n\n        // Cache result if enabled\n        if (this.config.enableCaching) {\n          await this.cacheResult(toolName, input, context, executionResult);\n        }\n\n        // Update metrics\n        this.updateMetrics(executionResult);\n\n        this.logger.info('MCP tool executed successfully', {\n          toolName,\n          executionId,\n          duration,\n        });\n\n        this.emit('tool:executed', executionResult);\n        return executionResult;\n\n      } finally {\n        clearTimeout(timeoutHandle);\n        this.activeExecutions.delete(executionId);\n      }\n\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const executionResult: MCPToolExecutionResult = {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration,\n        toolName,\n        agentId: context.agent.id,\n        taskId: context.task?.id,\n        metadata: {\n          timestamp: new Date(),\n          executionId,\n          attempts: 1,\n        },\n      };\n\n      this.updateMetrics(executionResult);\n\n      this.logger.error('MCP tool execution failed', {\n        toolName,\n        executionId,\n        error: executionResult.error,\n        duration,\n      });\n\n      this.emit('tool:failed', executionResult);\n      return executionResult;\n    }\n  }\n\n  /**\n   * Execute multiple tools in parallel\n   */\n  async executeToolsParallel(\n    toolExecutions: Array<{\n      toolName: string;\n      input: any;\n      context: MCPExecutionContext;\n    }>\n  ): Promise<MCPToolExecutionResult[]> {\n    if (!this.config.parallelExecution) {\n      // Execute sequentially if parallel execution is disabled\n      const results: MCPToolExecutionResult[] = [];\n      for (const execution of toolExecutions) {\n        const result = await this.executeTool(\n          execution.toolName,\n          execution.input,\n          execution.context\n        );\n        results.push(result);\n      }\n      return results;\n    }\n\n    this.logger.info('Executing tools in parallel', {\n      toolCount: toolExecutions.length,\n      maxConcurrent: this.config.maxConcurrentTools,\n    });\n\n    // Limit concurrent executions\n    const semaphore = new Semaphore(this.config.maxConcurrentTools);\n    \n    const promises = toolExecutions.map(async (execution) => {\n      await semaphore.acquire();\n      try {\n        return await this.executeTool(\n          execution.toolName,\n          execution.input,\n          execution.context\n        );\n      } finally {\n        semaphore.release();\n      }\n    });\n\n    const results = await Promise.allSettled(promises);\n    \n    return results.map((result, index) => {\n      if (result.status === 'fulfilled') {\n        return result.value;\n      } else {\n        // Create error result\n        return {\n          success: false,\n          error: result.reason instanceof Error ? result.reason.message : String(result.reason),\n          duration: 0,\n          toolName: toolExecutions[index].toolName,\n          agentId: toolExecutions[index].context.agent.id,\n          taskId: toolExecutions[index].context.task?.id,\n          metadata: {\n            timestamp: new Date(),\n            executionId: generateId('failed-execution'),\n            attempts: 1,\n          },\n        };\n      }\n    });\n  }\n\n  /**\n   * Get available tools with filtering options\n   */\n  getAvailableTools(options: {\n    category?: string;\n    capability?: string;\n    agent?: SwarmAgent;\n  } = {}): MCPTool[] {\n    let tools = Array.from(this.toolRegistry.tools.values());\n\n    // Filter by category\n    if (options.category) {\n      const categoryTools = this.toolRegistry.categories.get(options.category) || [];\n      tools = tools.filter(tool => categoryTools.includes(tool.name));\n    }\n\n    // Filter by capability\n    if (options.capability) {\n      const capabilityTools = this.toolRegistry.capabilities.get(options.capability) || [];\n      tools = tools.filter(tool => capabilityTools.includes(tool.name));\n    }\n\n    // Filter by agent permissions\n    if (options.agent) {\n      tools = tools.filter(tool => this.hasPermission(tool, options.agent!));\n    }\n\n    return tools;\n  }\n\n  /**\n   * Get tool information\n   */\n  getToolInfo(toolName: string): MCPTool | null {\n    return this.toolRegistry.tools.get(toolName) || null;\n  }\n\n  /**\n   * Get integration metrics\n   */\n  getMetrics(): MCPIntegrationMetrics {\n    return {\n      ...this.metrics,\n      cacheHitRate: this.calculateCacheHitRate(),\n      averageExecutionTime: this.calculateAverageExecutionTime(),\n      toolUsageDistribution: this.calculateToolUsageDistribution(),\n    };\n  }\n\n  /**\n   * Create MCP execution context for swarm operations\n   */\n  createExecutionContext(\n    orchestrator: AdvancedSwarmOrchestrator,\n    agent: SwarmAgent,\n    swarmId: string,\n    task?: SwarmTask\n  ): MCPExecutionContext {\n    return {\n      sessionId: generateId('mcp-session'),\n      orchestrator,\n      agent,\n      task,\n      swarmId,\n      executionId: generateId('mcp-execution'),\n      timeout: this.config.toolTimeout,\n      maxRetries: this.config.maxRetries,\n    };\n  }\n\n  // Private methods\n\n  private async registerClaudeFlowTools(): Promise<void> {\n    this.logger.info('Registering Claude Flow tools...');\n    \n    const claudeFlowTools = createClaudeFlowTools(this.logger);\n    \n    for (const tool of claudeFlowTools) {\n      this.toolRegistry.tools.set(tool.name, tool);\n      \n      // Categorize tool\n      const category = this.categorizeClaudeFlowTool(tool.name);\n      if (!this.toolRegistry.categories.has(category)) {\n        this.toolRegistry.categories.set(category, []);\n      }\n      this.toolRegistry.categories.get(category)!.push(tool.name);\n      \n      // Add capabilities\n      const capabilities = this.extractCapabilities(tool);\n      for (const capability of capabilities) {\n        if (!this.toolRegistry.capabilities.has(capability)) {\n          this.toolRegistry.capabilities.set(capability, []);\n        }\n        this.toolRegistry.capabilities.get(capability)!.push(tool.name);\n      }\n    }\n\n    this.logger.info(`Registered ${claudeFlowTools.length} Claude Flow tools`);\n  }\n\n  private async registerRuvSwarmTools(): Promise<void> {\n    this.logger.info('Registering ruv-swarm tools...');\n    \n    const ruvSwarmTools = createRuvSwarmTools(this.logger);\n    \n    for (const tool of ruvSwarmTools) {\n      this.toolRegistry.tools.set(tool.name, tool);\n      \n      // Categorize tool\n      const category = this.categorizeRuvSwarmTool(tool.name);\n      if (!this.toolRegistry.categories.has(category)) {\n        this.toolRegistry.categories.set(category, []);\n      }\n      this.toolRegistry.categories.get(category)!.push(tool.name);\n      \n      // Add capabilities\n      const capabilities = this.extractCapabilities(tool);\n      for (const capability of capabilities) {\n        if (!this.toolRegistry.capabilities.has(capability)) {\n          this.toolRegistry.capabilities.set(capability, []);\n        }\n        this.toolRegistry.capabilities.get(capability)!.push(tool.name);\n      }\n    }\n\n    this.logger.info(`Registered ${ruvSwarmTools.length} ruv-swarm tools`);\n  }\n\n  private async executeWithRetry(\n    tool: MCPTool,\n    input: any,\n    context: MCPExecutionContext,\n    executionId: string,\n    signal: AbortSignal\n  ): Promise<any> {\n    let lastError: Error | null = null;\n    const maxRetries = context.maxRetries || this.config.maxRetries;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        // Check if execution was aborted\n        if (signal.aborted) {\n          throw new Error('Execution aborted');\n        }\n\n        this.logger.debug('Executing tool attempt', {\n          toolName: tool.name,\n          executionId,\n          attempt,\n          maxRetries,\n        });\n\n        const result = await tool.handler(input, context);\n        \n        if (attempt > 1) {\n          this.logger.info('Tool execution succeeded after retry', {\n            toolName: tool.name,\n            executionId,\n            attempt,\n          });\n        }\n\n        return result;\n\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        \n        this.logger.warn('Tool execution attempt failed', {\n          toolName: tool.name,\n          executionId,\n          attempt,\n          maxRetries,\n          error: lastError.message,\n        });\n\n        // Don't retry on certain errors\n        if (this.isNonRetryableError(lastError)) {\n          break;\n        }\n\n        // Wait before retry (exponential backoff)\n        if (attempt < maxRetries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError || new Error('Tool execution failed after all retries');\n  }\n\n  private isNonRetryableError(error: Error): boolean {\n    const nonRetryablePatterns = [\n      /not found/i,\n      /invalid input/i,\n      /permission denied/i,\n      /unauthorized/i,\n      /forbidden/i,\n    ];\n\n    return nonRetryablePatterns.some(pattern => pattern.test(error.message));\n  }\n\n  private async getCachedResult(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext\n  ): Promise<MCPToolExecutionResult | null> {\n    const cacheKey = this.generateCacheKey(toolName, input, context);\n    const cached = this.executionCache.get(cacheKey);\n    \n    if (cached) {\n      const age = Date.now() - cached.metadata.timestamp.getTime();\n      if (age < this.config.cacheTimeout) {\n        this.metrics.cacheHits++;\n        return cached;\n      } else {\n        // Remove expired entry\n        this.executionCache.delete(cacheKey);\n      }\n    }\n\n    this.metrics.cacheMisses++;\n    return null;\n  }\n\n  private async cacheResult(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext,\n    result: MCPToolExecutionResult\n  ): Promise<void> {\n    const cacheKey = this.generateCacheKey(toolName, input, context);\n    this.executionCache.set(cacheKey, result);\n  }\n\n  private generateCacheKey(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext\n  ): string {\n    const inputHash = this.hashObject(input);\n    const contextHash = this.hashObject({\n      agentId: context.agent.id,\n      swarmId: context.swarmId,\n      taskId: context.task?.id,\n    });\n    \n    return `${toolName}:${inputHash}:${contextHash}`;\n  }\n\n  private hashObject(obj: any): string {\n    // Simple hash function for caching\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash.toString(36);\n  }\n\n  private hasPermission(tool: MCPTool, agent: SwarmAgent): boolean {\n    // Check if agent has permission to use this tool\n    const toolPermissions = this.toolRegistry.permissions.get(tool.name) || [];\n    \n    // If no specific permissions defined, allow all\n    if (toolPermissions.length === 0) {\n      return true;\n    }\n\n    // Check agent capabilities against tool permissions\n    return agent.capabilities.some(capability => \n      toolPermissions.includes(capability)\n    );\n  }\n\n  private categorizeClaudeFlowTool(toolName: string): string {\n    if (toolName.includes('agents/')) return 'agent-management';\n    if (toolName.includes('tasks/')) return 'task-management';\n    if (toolName.includes('memory/')) return 'memory-management';\n    if (toolName.includes('system/')) return 'system-monitoring';\n    if (toolName.includes('config/')) return 'configuration';\n    if (toolName.includes('workflow/')) return 'workflow-management';\n    if (toolName.includes('terminal/')) return 'terminal-management';\n    return 'general';\n  }\n\n  private categorizeRuvSwarmTool(toolName: string): string {\n    if (toolName.includes('swarm_')) return 'swarm-lifecycle';\n    if (toolName.includes('agent_')) return 'agent-management';\n    if (toolName.includes('task_')) return 'task-orchestration';\n    if (toolName.includes('memory_')) return 'memory-persistence';\n    if (toolName.includes('neural_')) return 'neural-capabilities';\n    if (toolName.includes('benchmark_')) return 'performance-benchmarking';\n    return 'general';\n  }\n\n  private extractCapabilities(tool: MCPTool): string[] {\n    const capabilities: string[] = [];\n    \n    // Extract capabilities from tool name and description\n    const text = `${tool.name} ${tool.description}`.toLowerCase();\n    \n    const capabilityPatterns = [\n      'agent', 'task', 'memory', 'system', 'config', 'workflow',\n      'terminal', 'swarm', 'neural', 'benchmark', 'monitoring',\n      'orchestration', 'coordination', 'analysis', 'research',\n      'development', 'testing', 'documentation', 'optimization',\n    ];\n\n    for (const pattern of capabilityPatterns) {\n      if (text.includes(pattern)) {\n        capabilities.push(pattern);\n      }\n    }\n\n    return capabilities.length > 0 ? capabilities : ['general'];\n  }\n\n  private updateMetrics(result: MCPToolExecutionResult): void {\n    this.metrics.totalExecutions++;\n    \n    if (result.success) {\n      this.metrics.successfulExecutions++;\n    } else {\n      this.metrics.failedExecutions++;\n    }\n\n    this.metrics.totalExecutionTime += result.duration;\n\n    // Update tool-specific metrics\n    if (!this.metrics.toolExecutions.has(result.toolName)) {\n      this.metrics.toolExecutions.set(result.toolName, {\n        count: 0,\n        totalTime: 0,\n        successCount: 0,\n        failureCount: 0,\n      });\n    }\n\n    const toolStats = this.metrics.toolExecutions.get(result.toolName)!;\n    toolStats.count++;\n    toolStats.totalTime += result.duration;\n    \n    if (result.success) {\n      toolStats.successCount++;\n    } else {\n      toolStats.failureCount++;\n    }\n  }\n\n  private calculateCacheHitRate(): number {\n    const total = this.metrics.cacheHits + this.metrics.cacheMisses;\n    return total > 0 ? this.metrics.cacheHits / total : 0;\n  }\n\n  private calculateAverageExecutionTime(): number {\n    return this.metrics.totalExecutions > 0 \n      ? this.metrics.totalExecutionTime / this.metrics.totalExecutions \n      : 0;\n  }\n\n  private calculateToolUsageDistribution(): Record<string, number> {\n    const distribution: Record<string, number> = {};\n    \n    for (const [toolName, stats] of this.metrics.toolExecutions) {\n      distribution[toolName] = stats.count;\n    }\n\n    return distribution;\n  }\n\n  private startCacheCleanup(): void {\n    // Clean up expired cache entries every 5 minutes\n    setInterval(() => {\n      const now = Date.now();\n      const expired: string[] = [];\n\n      for (const [key, result] of this.executionCache) {\n        const age = now - result.metadata.timestamp.getTime();\n        if (age > this.config.cacheTimeout) {\n          expired.push(key);\n        }\n      }\n\n      expired.forEach(key => this.executionCache.delete(key));\n      \n      if (expired.length > 0) {\n        this.logger.debug('Cleaned up expired cache entries', { \n          count: expired.length \n        });\n      }\n    }, 300000); // 5 minutes\n  }\n\n  private initializeToolRegistry(): MCPToolRegistry {\n    return {\n      tools: new Map(),\n      categories: new Map(),\n      capabilities: new Map(),\n      permissions: new Map(),\n    };\n  }\n\n  private initializeMetrics(): MCPIntegrationMetrics {\n    return {\n      totalExecutions: 0,\n      successfulExecutions: 0,\n      failedExecutions: 0,\n      totalExecutionTime: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      toolExecutions: new Map(),\n      cacheHitRate: 0,\n      averageExecutionTime: 0,\n      toolUsageDistribution: {},\n    };\n  }\n\n  private createDefaultConfig(config: Partial<MCPIntegrationConfig>): MCPIntegrationConfig {\n    return {\n      enableClaudeFlowTools: true,\n      enableRuvSwarmTools: true,\n      enableCustomTools: true,\n      toolTimeout: 30000, // 30 seconds\n      maxRetries: 3,\n      enableCaching: true,\n      cacheTimeout: 300000, // 5 minutes\n      enableMetrics: true,\n      enableLogging: true,\n      enableErrorRecovery: true,\n      parallelExecution: true,\n      maxConcurrentTools: 5,\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('tool:executed', (result) => {\n      if (this.config.enableLogging) {\n        this.logger.debug('Tool execution completed', {\n          toolName: result.toolName,\n          success: result.success,\n          duration: result.duration,\n        });\n      }\n    });\n\n    this.on('tool:failed', (result) => {\n      if (this.config.enableLogging) {\n        this.logger.warn('Tool execution failed', {\n          toolName: result.toolName,\n          error: result.error,\n          duration: result.duration,\n        });\n      }\n    });\n  }\n}\n\n// Supporting interfaces and classes\n\ninterface MCPIntegrationMetrics {\n  totalExecutions: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  totalExecutionTime: number;\n  cacheHits: number;\n  cacheMisses: number;\n  toolExecutions: Map<string, {\n    count: number;\n    totalTime: number;\n    successCount: number;\n    failureCount: number;\n  }>;\n  cacheHitRate: number;\n  averageExecutionTime: number;\n  toolUsageDistribution: Record<string, number>;\n}\n\nclass Semaphore {\n  private permits: number;\n  private waitQueue: Array<() => void> = [];\n\n  constructor(permits: number) {\n    this.permits = permits;\n  }\n\n  async acquire(): Promise<void> {\n    if (this.permits > 0) {\n      this.permits--;\n      return Promise.resolve();\n    }\n\n    return new Promise<void>((resolve) => {\n      this.waitQueue.push(resolve);\n    });\n  }\n\n  release(): void {\n    if (this.waitQueue.length > 0) {\n      const resolve = this.waitQueue.shift()!;\n      resolve();\n    } else {\n      this.permits++;\n    }\n  }\n}\n\nexport default MCPIntegrationWrapper;"],
  "mappings": "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",
  "names": ["results"]
}
