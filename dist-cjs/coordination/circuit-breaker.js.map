{
  "version": 3,
  "sources": ["../../src/coordination/circuit-breaker.ts"],
  "sourcesContent": ["/**\n * Circuit breaker pattern for fault tolerance\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number; // Number of failures before opening\n  successThreshold: number; // Number of successes before closing\n  timeout: number; // Time in ms before attempting to close\n  halfOpenLimit: number; // Max requests in half-open state\n}\n\nexport enum CircuitState {\n  CLOSED = 'closed',\n  OPEN = 'open',\n  HALF_OPEN = 'half-open',\n}\n\nexport interface CircuitBreakerMetrics {\n  state: CircuitState;\n  failures: number;\n  successes: number;\n  lastFailureTime?: Date;\n  lastSuccessTime?: Date;\n  totalRequests: number;\n  rejectedRequests: number;\n  halfOpenRequests: number;\n}\n\n/**\n * Circuit breaker for protecting against cascading failures\n */\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failures = 0;\n  private successes = 0;\n  private lastFailureTime?: Date;\n  private lastSuccessTime?: Date;\n  private nextAttempt?: Date;\n  private halfOpenRequests = 0;\n  private totalRequests = 0;\n  private rejectedRequests = 0;\n\n  constructor(\n    private name: string,\n    private config: CircuitBreakerConfig,\n    private logger: ILogger,\n    private eventBus?: IEventBus,\n  ) {}\n\n  /**\n   * Execute a function with circuit breaker protection\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    this.totalRequests++;\n\n    // Check if we should execute\n    if (!this.canExecute()) {\n      this.rejectedRequests++;\n      const error = new Error(`Circuit breaker '${this.name}' is OPEN`);\n      this.logStateChange('Request rejected');\n      throw error;\n    }\n\n    try {\n      // Execute the function\n      const result = await fn();\n\n      // Record success\n      this.onSuccess();\n\n      return result;\n    } catch (error) {\n      // Record failure\n      this.onFailure();\n\n      throw error;\n    }\n  }\n\n  /**\n   * Check if execution is allowed\n   */\n  private canExecute(): boolean {\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        return true;\n\n      case CircuitState.OPEN:\n        // Check if we should transition to half-open\n        if (this.nextAttempt && new Date() >= this.nextAttempt) {\n          this.transitionTo(CircuitState.HALF_OPEN);\n          return true;\n        }\n        return false;\n\n      case CircuitState.HALF_OPEN:\n        // Allow limited requests in half-open state\n        return this.halfOpenRequests < this.config.halfOpenLimit;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Handle successful execution\n   */\n  private onSuccess(): void {\n    this.lastSuccessTime = new Date();\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        this.failures = 0; // Reset failure count\n        break;\n\n      case CircuitState.HALF_OPEN:\n        this.successes++;\n        this.halfOpenRequests++;\n\n        // Check if we should close the circuit\n        if (this.successes >= this.config.successThreshold) {\n          this.transitionTo(CircuitState.CLOSED);\n        }\n        break;\n\n      case CircuitState.OPEN:\n        // Shouldn't happen, but handle gracefully\n        this.transitionTo(CircuitState.HALF_OPEN);\n        break;\n    }\n  }\n\n  /**\n   * Handle failed execution\n   */\n  private onFailure(): void {\n    this.lastFailureTime = new Date();\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        this.failures++;\n\n        // Check if we should open the circuit\n        if (this.failures >= this.config.failureThreshold) {\n          this.transitionTo(CircuitState.OPEN);\n        }\n        break;\n\n      case CircuitState.HALF_OPEN:\n        // Single failure in half-open state reopens the circuit\n        this.transitionTo(CircuitState.OPEN);\n        break;\n\n      case CircuitState.OPEN:\n        // Already open, update next attempt time\n        this.nextAttempt = new Date(Date.now() + this.config.timeout);\n        break;\n    }\n  }\n\n  /**\n   * Transition to a new state\n   */\n  private transitionTo(newState: CircuitState): void {\n    const oldState = this.state;\n    this.state = newState;\n\n    this.logger.info(`Circuit breaker '${this.name}' state change`, {\n      from: oldState,\n      to: newState,\n      failures: this.failures,\n      successes: this.successes,\n    });\n\n    // Reset counters based on new state\n    switch (newState) {\n      case CircuitState.CLOSED:\n        this.failures = 0;\n        this.successes = 0;\n        this.halfOpenRequests = 0;\n        delete this.nextAttempt;\n        break;\n\n      case CircuitState.OPEN:\n        this.successes = 0;\n        this.halfOpenRequests = 0;\n        this.nextAttempt = new Date(Date.now() + this.config.timeout);\n        break;\n\n      case CircuitState.HALF_OPEN:\n        this.successes = 0;\n        this.failures = 0;\n        this.halfOpenRequests = 0;\n        break;\n    }\n\n    // Emit state change event\n    if (this.eventBus) {\n      this.eventBus.emit('circuitbreaker:state-change', {\n        name: this.name,\n        from: oldState,\n        to: newState,\n        metrics: this.getMetrics(),\n      });\n    }\n  }\n\n  /**\n   * Force the circuit to a specific state\n   */\n  forceState(state: CircuitState): void {\n    this.logger.warn(`Forcing circuit breaker '${this.name}' to state`, { state });\n    this.transitionTo(state);\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  /**\n   * Get circuit breaker metrics\n   */\n  getMetrics(): CircuitBreakerMetrics {\n    const metrics: CircuitBreakerMetrics = {\n      state: this.state,\n      failures: this.failures,\n      successes: this.successes,\n      totalRequests: this.totalRequests,\n      rejectedRequests: this.rejectedRequests,\n      halfOpenRequests: this.halfOpenRequests,\n    };\n\n    if (this.lastFailureTime !== undefined) {\n      metrics.lastFailureTime = this.lastFailureTime;\n    }\n\n    if (this.lastSuccessTime !== undefined) {\n      metrics.lastSuccessTime = this.lastSuccessTime;\n    }\n\n    return metrics;\n  }\n\n  /**\n   * Reset the circuit breaker\n   */\n  reset(): void {\n    this.logger.info(`Resetting circuit breaker '${this.name}'`);\n    this.state = CircuitState.CLOSED;\n    this.failures = 0;\n    this.successes = 0;\n    delete this.lastFailureTime;\n    delete this.lastSuccessTime;\n    delete this.nextAttempt;\n    this.halfOpenRequests = 0;\n    this.totalRequests = 0;\n    this.rejectedRequests = 0;\n  }\n\n  /**\n   * Log state change with consistent format\n   */\n  private logStateChange(message: string): void {\n    this.logger.debug(`Circuit breaker '${this.name}': ${message}`, {\n      state: this.state,\n      failures: this.failures,\n      successes: this.successes,\n      nextAttempt: this.nextAttempt,\n    });\n  }\n}\n\n/**\n * Manager for multiple circuit breakers\n */\nexport class CircuitBreakerManager {\n  private breakers = new Map<string, CircuitBreaker>();\n\n  constructor(\n    private defaultConfig: CircuitBreakerConfig,\n    private logger: ILogger,\n    private eventBus?: IEventBus,\n  ) {}\n\n  /**\n   * Get or create a circuit breaker\n   */\n  getBreaker(name: string, config?: Partial<CircuitBreakerConfig>): CircuitBreaker {\n    let breaker = this.breakers.get(name);\n\n    if (!breaker) {\n      const finalConfig = { ...this.defaultConfig, ...config };\n      breaker = new CircuitBreaker(name, finalConfig, this.logger, this.eventBus);\n      this.breakers.set(name, breaker);\n    }\n\n    return breaker;\n  }\n\n  /**\n   * Execute with circuit breaker\n   */\n  async execute<T>(\n    name: string,\n    fn: () => Promise<T>,\n    config?: Partial<CircuitBreakerConfig>,\n  ): Promise<T> {\n    const breaker = this.getBreaker(name, config);\n    return breaker.execute(fn);\n  }\n\n  /**\n   * Get all circuit breakers\n   */\n  getAllBreakers(): Map<string, CircuitBreaker> {\n    return new Map(this.breakers);\n  }\n\n  /**\n   * Get metrics for all breakers\n   */\n  getAllMetrics(): Record<string, CircuitBreakerMetrics> {\n    const metrics: Record<string, CircuitBreakerMetrics> = {};\n\n    for (const [name, breaker] of this.breakers) {\n      metrics[name] = breaker.getMetrics();\n    }\n\n    return metrics;\n  }\n\n  /**\n   * Reset a specific breaker\n   */\n  resetBreaker(name: string): void {\n    const breaker = this.breakers.get(name);\n    if (breaker) {\n      breaker.reset();\n    }\n  }\n\n  /**\n   * Reset all breakers\n   */\n  resetAll(): void {\n    for (const breaker of this.breakers.values()) {\n      breaker.reset();\n    }\n  }\n\n  /**\n   * Force a breaker to a specific state\n   */\n  forceState(name: string, state: CircuitState): void {\n    const breaker = this.breakers.get(name);\n    if (breaker) {\n      breaker.forceState(state);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["CircuitState"]
}
