{"version":3,"sources":["../../../../../src/cli/simple-commands/sparc/coordinator.js"],"sourcesContent":["// SPARC Coordinator\r\n// Integrates SPARC methodology with swarm system for enhanced coordination\r\n\r\nimport { SparcPhase } from './phase-base.js';\r\n\r\nexport class SparcCoordinator {\r\n  constructor(phases, options = {}) {\r\n    this.phases = phases;\r\n    this.options = options;\r\n    this.swarmId = null;\r\n    this.agents = [];\r\n    this.phaseAgents = new Map();\r\n    this.coordination = {\r\n      strategy: 'adaptive',\r\n      topology: 'hierarchical',\r\n      communication: 'event-driven',\r\n      loadBalancing: 'capability-based',\r\n    };\r\n    this.metrics = {\r\n      phaseExecutions: 0,\r\n      agentUtilization: {},\r\n      coordinationEfficiency: 0,\r\n      qualityGates: [],\r\n      learningData: [],\r\n    };\r\n    this.neuralContext = null;\r\n    this.swarmEnabled = options.swarmEnabled || false;\r\n  }\r\n\r\n  /**\r\n   * Initialize swarm for SPARC execution\r\n   */\r\n  async initializeSwarm() {\r\n    if (!this.swarmEnabled) {\r\n      console.log('ðŸ”„ SPARC running in standalone mode');\r\n      return;\r\n    }\r\n\r\n    console.log('ðŸ Initializing SPARC Swarm Coordination');\r\n\r\n    try {\r\n      // Initialize swarm using ruv-swarm hooks\r\n      const swarmConfig = {\r\n        topology: this.coordination.topology,\r\n        maxAgents: this.calculateOptimalAgentCount(),\r\n        strategy: 'sparc_methodology',\r\n        communication: this.coordination.communication,\r\n        loadBalancing: this.coordination.loadBalancing,\r\n      };\r\n\r\n      this.swarmId = await this.executeSwarmHook('swarm_init', swarmConfig);\r\n      console.log(`ðŸ†” Swarm initialized: ${this.swarmId}`);\r\n\r\n      // Spawn specialized SPARC agents\r\n      await this.spawnSparcAgents();\r\n\r\n      // Setup inter-phase coordination\r\n      await this.setupPhaseCoordination();\r\n\r\n      console.log('âœ… SPARC Swarm coordination initialized');\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Swarm initialization failed: ${error.message}`);\r\n      console.log('ðŸ”„ Falling back to standalone mode');\r\n      this.swarmEnabled = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate optimal agent count based on SPARC phases\r\n   */\r\n  calculateOptimalAgentCount() {\r\n    const baseAgents = Object.keys(this.phases).length; // One per phase\r\n    const complexityMultiplier = this.assessTaskComplexity();\r\n    const parallelismFactor = this.options.parallelExecution ? 2 : 1;\r\n\r\n    return Math.min(20, Math.max(5, baseAgents * complexityMultiplier * parallelismFactor));\r\n  }\r\n\r\n  /**\r\n   * Assess task complexity for agent allocation\r\n   */\r\n  assessTaskComplexity() {\r\n    const taskDescription = this.options.taskDescription || '';\r\n    const complexityKeywords = [\r\n      'complex',\r\n      'enterprise',\r\n      'scalable',\r\n      'distributed',\r\n      'microservice',\r\n      'integration',\r\n    ];\r\n    const matchedKeywords = complexityKeywords.filter((keyword) =>\r\n      taskDescription.toLowerCase().includes(keyword),\r\n    );\r\n\r\n    if (matchedKeywords.length >= 3) return 3; // High complexity\r\n    if (matchedKeywords.length >= 1) return 2; // Medium complexity\r\n    return 1; // Low complexity\r\n  }\r\n\r\n  /**\r\n   * Spawn specialized SPARC agents\r\n   */\r\n  async spawnSparcAgents() {\r\n    const agentTypes = [\r\n      {\r\n        type: 'sparc_specification',\r\n        role: 'Requirements Analyst',\r\n        capabilities: ['analysis', 'documentation', 'validation'],\r\n      },\r\n      {\r\n        type: 'sparc_pseudocode',\r\n        role: 'Logic Designer',\r\n        capabilities: ['design', 'flowcharts', 'algorithms'],\r\n      },\r\n      {\r\n        type: 'sparc_architecture',\r\n        role: 'System Architect',\r\n        capabilities: ['architecture', 'design_patterns', 'scalability'],\r\n      },\r\n      {\r\n        type: 'sparc_refinement',\r\n        role: 'TDD Engineer',\r\n        capabilities: ['testing', 'refactoring', 'code_quality'],\r\n      },\r\n      {\r\n        type: 'sparc_completion',\r\n        role: 'Integration Specialist',\r\n        capabilities: ['integration', 'deployment', 'validation'],\r\n      },\r\n      {\r\n        type: 'sparc_coordinator',\r\n        role: 'SPARC Orchestrator',\r\n        capabilities: ['coordination', 'monitoring', 'optimization'],\r\n      },\r\n    ];\r\n\r\n    for (const agentSpec of agentTypes) {\r\n      try {\r\n        const agentId = await this.executeSwarmHook('agent_spawn', {\r\n          type: agentSpec.type,\r\n          role: agentSpec.role,\r\n          capabilities: agentSpec.capabilities,\r\n          maxConcurrentTasks: this.getAgentConcurrency(agentSpec.type),\r\n          specialization: 'sparc_methodology',\r\n        });\r\n\r\n        const agent = {\r\n          id: agentId,\r\n          type: agentSpec.type,\r\n          role: agentSpec.role,\r\n          capabilities: agentSpec.capabilities,\r\n          status: 'ready',\r\n          currentPhase: null,\r\n          assignedTasks: [],\r\n          performance: {\r\n            tasksCompleted: 0,\r\n            averageTime: 0,\r\n            qualityScore: 1.0,\r\n            efficiency: 1.0,\r\n          },\r\n        };\r\n\r\n        this.agents.push(agent);\r\n        console.log(`  ðŸ¤– Spawned ${agentSpec.role} (${agentSpec.type})`);\r\n      } catch (error) {\r\n        console.warn(`âš ï¸ Failed to spawn ${agentSpec.role}: ${error.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get agent concurrency based on type\r\n   */\r\n  getAgentConcurrency(agentType) {\r\n    const concurrencyMap = {\r\n      sparc_specification: 2,\r\n      sparc_pseudocode: 1,\r\n      sparc_architecture: 3,\r\n      sparc_refinement: 4,\r\n      sparc_completion: 2,\r\n      sparc_coordinator: 1,\r\n    };\r\n\r\n    return concurrencyMap[agentType] || 2;\r\n  }\r\n\r\n  /**\r\n   * Setup phase coordination\r\n   */\r\n  async setupPhaseCoordination() {\r\n    // Map agents to phases\r\n    for (const agent of this.agents) {\r\n      const phaseName = agent.type.replace('sparc_', '');\r\n      if (this.phases[phaseName]) {\r\n        if (!this.phaseAgents.has(phaseName)) {\r\n          this.phaseAgents.set(phaseName, []);\r\n        }\r\n        this.phaseAgents.get(phaseName).push(agent);\r\n      }\r\n    }\r\n\r\n    // Setup phase dependencies\r\n    await this.executeSwarmHook('setup_dependencies', {\r\n      phases: Object.keys(this.phases),\r\n      dependencies: {\r\n        pseudocode: ['specification'],\r\n        architecture: ['specification', 'pseudocode'],\r\n        refinement: ['specification', 'pseudocode', 'architecture'],\r\n        completion: ['specification', 'pseudocode', 'architecture', 'refinement'],\r\n      },\r\n    });\r\n\r\n    // Setup quality gates between phases\r\n    await this.setupQualityGates();\r\n  }\r\n\r\n  /**\r\n   * Setup quality gates between phases\r\n   */\r\n  async setupQualityGates() {\r\n    const qualityGates = [\r\n      {\r\n        phase: 'specification',\r\n        criteria: ['requirements_complete', 'acceptance_criteria_defined'],\r\n        threshold: 0.9,\r\n      },\r\n      {\r\n        phase: 'pseudocode',\r\n        criteria: ['flow_diagram_complete', 'algorithms_defined'],\r\n        threshold: 0.85,\r\n      },\r\n      {\r\n        phase: 'architecture',\r\n        criteria: ['components_defined', 'patterns_selected'],\r\n        threshold: 0.85,\r\n      },\r\n      {\r\n        phase: 'refinement',\r\n        criteria: ['tests_passing', 'code_quality_acceptable'],\r\n        threshold: 0.8,\r\n      },\r\n      {\r\n        phase: 'completion',\r\n        criteria: ['validation_passed', 'deployment_successful'],\r\n        threshold: 0.9,\r\n      },\r\n    ];\r\n\r\n    for (const gate of qualityGates) {\r\n      await this.executeSwarmHook('register_quality_gate', gate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pre-phase coordination\r\n   */\r\n  async prePhase(phaseName) {\r\n    if (!this.swarmEnabled) return;\r\n\r\n    console.log(`ðŸ”„ Pre-phase coordination: ${phaseName}`);\r\n\r\n    try {\r\n      // Load neural context for the phase\r\n      await this.loadNeuralContext(phaseName);\r\n\r\n      // Assign agents to phase\r\n      await this.assignAgentsToPhase(phaseName);\r\n\r\n      // Prepare phase environment\r\n      await this.preparePhaseEnvironment(phaseName);\r\n\r\n      // Store phase initiation in memory\r\n      await this.executeSwarmHook('memory_store', {\r\n        key: `sparc_phase_${phaseName}_start`,\r\n        value: {\r\n          timestamp: Date.now(),\r\n          agents: this.phaseAgents.get(phaseName)?.map((a) => a.id) || [],\r\n          neuralContext: this.neuralContext,\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Pre-phase coordination failed for ${phaseName}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load neural context for phase\r\n   */\r\n  async loadNeuralContext(phaseName) {\r\n    try {\r\n      const neuralData = await this.executeSwarmHook('neural_load_context', {\r\n        phase: phaseName,\r\n        methodology: 'sparc',\r\n        taskType: this.classifyTaskType(),\r\n      });\r\n\r\n      this.neuralContext = {\r\n        phase: phaseName,\r\n        patterns: neuralData.patterns || [],\r\n        insights: neuralData.insights || [],\r\n        recommendations: neuralData.recommendations || [],\r\n        confidence: neuralData.confidence || 0.5,\r\n      };\r\n\r\n      console.log(\r\n        `ðŸ§  Neural context loaded for ${phaseName} (confidence: ${this.neuralContext.confidence.toFixed(2)})`,\r\n      );\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Neural context loading failed: ${error.message}`);\r\n      this.neuralContext = {\r\n        phase: phaseName,\r\n        patterns: [],\r\n        insights: [],\r\n        recommendations: [],\r\n        confidence: 0.5,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Classify task type for neural learning\r\n   */\r\n  classifyTaskType() {\r\n    const taskDescription = this.options.taskDescription || '';\r\n    const taskLower = taskDescription.toLowerCase();\r\n\r\n    if (taskLower.includes('api') || taskLower.includes('service')) return 'api_development';\r\n    if (taskLower.includes('ui') || taskLower.includes('frontend')) return 'frontend_development';\r\n    if (taskLower.includes('data') || taskLower.includes('database')) return 'data_management';\r\n    if (taskLower.includes('test') || taskLower.includes('testing')) return 'testing';\r\n    if (taskLower.includes('deploy') || taskLower.includes('infrastructure')) return 'deployment';\r\n\r\n    return 'general_development';\r\n  }\r\n\r\n  /**\r\n   * Assign agents to phase\r\n   */\r\n  async assignAgentsToPhase(phaseName) {\r\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\r\n\r\n    for (const agent of phaseAgents) {\r\n      agent.currentPhase = phaseName;\r\n      agent.status = 'assigned';\r\n\r\n      await this.executeSwarmHook('agent_assign', {\r\n        agentId: agent.id,\r\n        phase: phaseName,\r\n        priority: this.getPhasePriority(phaseName),\r\n        context: this.neuralContext,\r\n      });\r\n    }\r\n\r\n    // If no dedicated agents, assign general coordinator\r\n    if (phaseAgents.length === 0) {\r\n      const coordinator = this.agents.find((a) => a.type === 'sparc_coordinator');\r\n      if (coordinator) {\r\n        coordinator.currentPhase = phaseName;\r\n        coordinator.status = 'assigned';\r\n\r\n        await this.executeSwarmHook('agent_assign', {\r\n          agentId: coordinator.id,\r\n          phase: phaseName,\r\n          priority: this.getPhasePriority(phaseName),\r\n          context: this.neuralContext,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get phase priority for scheduling\r\n   */\r\n  getPhasePriority(phaseName) {\r\n    const priorities = {\r\n      specification: 5, // Highest priority\r\n      pseudocode: 4,\r\n      architecture: 4,\r\n      refinement: 3,\r\n      completion: 2,\r\n    };\r\n\r\n    return priorities[phaseName] || 1;\r\n  }\r\n\r\n  /**\r\n   * Prepare phase environment\r\n   */\r\n  async preparePhaseEnvironment(phaseName) {\r\n    // Create phase-specific workspace\r\n    await this.executeSwarmHook('create_workspace', {\r\n      phase: phaseName,\r\n      namespace: this.options.namespace || 'sparc',\r\n      isolation: true,\r\n    });\r\n\r\n    // Load previous phase artifacts\r\n    const dependencies = this.getPhaseDependencies(phaseName);\r\n    for (const dependency of dependencies) {\r\n      await this.executeSwarmHook('load_artifacts', {\r\n        fromPhase: dependency,\r\n        toPhase: phaseName,\r\n        artifactTypes: ['outputs', 'decisions', 'validations'],\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get phase dependencies\r\n   */\r\n  getPhaseDependencies(phaseName) {\r\n    const dependencies = {\r\n      specification: [],\r\n      pseudocode: ['specification'],\r\n      architecture: ['specification', 'pseudocode'],\r\n      refinement: ['specification', 'pseudocode', 'architecture'],\r\n      completion: ['specification', 'pseudocode', 'architecture', 'refinement'],\r\n    };\r\n\r\n    return dependencies[phaseName] || [];\r\n  }\r\n\r\n  /**\r\n   * Post-phase coordination\r\n   */\r\n  async postPhase(phaseName, result) {\r\n    if (!this.swarmEnabled) return;\r\n\r\n    console.log(`âœ… Post-phase coordination: ${phaseName}`);\r\n\r\n    try {\r\n      // Validate phase results\r\n      const validation = await this.validatePhaseResults(phaseName, result);\r\n\r\n      // Update agent performance\r\n      await this.updateAgentPerformance(phaseName, result, validation);\r\n\r\n      // Store phase completion in memory\r\n      await this.executeSwarmHook('memory_store', {\r\n        key: `sparc_phase_${phaseName}_complete`,\r\n        value: {\r\n          timestamp: Date.now(),\r\n          result: result,\r\n          validation: validation,\r\n          agents:\r\n            this.phaseAgents.get(phaseName)?.map((a) => ({\r\n              id: a.id,\r\n              performance: a.performance,\r\n            })) || [],\r\n        },\r\n      });\r\n\r\n      // Neural learning from phase execution\r\n      if (this.options.neuralLearning) {\r\n        await this.recordNeuralLearning(phaseName, result, validation);\r\n      }\r\n\r\n      // Prepare handoff to next phase\r\n      await this.preparePhaseHandoff(phaseName, result);\r\n\r\n      // Update metrics\r\n      this.updateCoordinationMetrics(phaseName, result, validation);\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Post-phase coordination failed for ${phaseName}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate phase results\r\n   */\r\n  async validatePhaseResults(phaseName, result) {\r\n    const validation = {\r\n      phase: phaseName,\r\n      passed: true,\r\n      score: 0,\r\n      issues: [],\r\n      recommendations: [],\r\n    };\r\n\r\n    try {\r\n      // Execute swarm-based validation\r\n      const swarmValidation = await this.executeSwarmHook('validate_phase', {\r\n        phase: phaseName,\r\n        result: result,\r\n        criteria: this.getValidationCriteria(phaseName),\r\n      });\r\n\r\n      validation.passed = swarmValidation.passed;\r\n      validation.score = swarmValidation.score;\r\n      validation.issues = swarmValidation.issues || [];\r\n      validation.recommendations = swarmValidation.recommendations || [];\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Swarm validation failed: ${error.message}`);\r\n      // Fallback to basic validation\r\n      validation.passed = !!result;\r\n      validation.score = result ? 85 : 0;\r\n    }\r\n\r\n    return validation;\r\n  }\r\n\r\n  /**\r\n   * Get validation criteria for phase\r\n   */\r\n  getValidationCriteria(phaseName) {\r\n    const criteria = {\r\n      specification: {\r\n        requiredFields: ['requirements', 'acceptanceCriteria', 'userStories'],\r\n        qualityThresholds: { completeness: 0.9, clarity: 0.8 },\r\n      },\r\n      pseudocode: {\r\n        requiredFields: ['flowDiagram', 'pseudocode', 'algorithms'],\r\n        qualityThresholds: { completeness: 0.85, complexity: 0.7 },\r\n      },\r\n      architecture: {\r\n        requiredFields: ['systemDesign', 'components', 'designPatterns'],\r\n        qualityThresholds: { modularity: 0.8, scalability: 0.75 },\r\n      },\r\n      refinement: {\r\n        requiredFields: ['testResults', 'codeQuality', 'implementations'],\r\n        qualityThresholds: { testCoverage: 0.8, codeQuality: 0.75 },\r\n      },\r\n      completion: {\r\n        requiredFields: ['validation', 'deployment', 'documentation'],\r\n        qualityThresholds: { completeness: 0.9, readiness: 0.85 },\r\n      },\r\n    };\r\n\r\n    return criteria[phaseName] || { requiredFields: [], qualityThresholds: {} };\r\n  }\r\n\r\n  /**\r\n   * Update agent performance metrics\r\n   */\r\n  async updateAgentPerformance(phaseName, result, validation) {\r\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\r\n\r\n    for (const agent of phaseAgents) {\r\n      agent.performance.tasksCompleted += 1;\r\n\r\n      // Update quality score based on validation\r\n      const qualityScore = validation.score / 100;\r\n      agent.performance.qualityScore = (agent.performance.qualityScore + qualityScore) / 2;\r\n\r\n      // Update efficiency based on execution time\r\n      const executionTime = Date.now() - this.getPhaseStartTime(phaseName);\r\n      const expectedTime = this.getExpectedPhaseTime(phaseName);\r\n      const efficiency = Math.min(1, expectedTime / executionTime);\r\n      agent.performance.efficiency = (agent.performance.efficiency + efficiency) / 2;\r\n\r\n      // Update average time\r\n      agent.performance.averageTime = (agent.performance.averageTime + executionTime) / 2;\r\n\r\n      // Store performance update\r\n      await this.executeSwarmHook('update_agent_performance', {\r\n        agentId: agent.id,\r\n        performance: agent.performance,\r\n        phase: phaseName,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get phase start time\r\n   */\r\n  getPhaseStartTime(phaseName) {\r\n    // This would typically be stored in memory or agent state\r\n    return Date.now() - 5 * 60 * 1000; // Default to 5 minutes ago\r\n  }\r\n\r\n  /**\r\n   * Get expected phase execution time\r\n   */\r\n  getExpectedPhaseTime(phaseName) {\r\n    const expectedTimes = {\r\n      specification: 10 * 60 * 1000, // 10 minutes\r\n      pseudocode: 5 * 60 * 1000, // 5 minutes\r\n      architecture: 15 * 60 * 1000, // 15 minutes\r\n      refinement: 20 * 60 * 1000, // 20 minutes\r\n      completion: 10 * 60 * 1000, // 10 minutes\r\n    };\r\n\r\n    return expectedTimes[phaseName] || 10 * 60 * 1000;\r\n  }\r\n\r\n  /**\r\n   * Record neural learning from phase execution\r\n   */\r\n  async recordNeuralLearning(phaseName, result, validation) {\r\n    try {\r\n      const learningData = {\r\n        phase: phaseName,\r\n        taskType: this.classifyTaskType(),\r\n        methodology: 'sparc',\r\n        execution: {\r\n          result: result,\r\n          validation: validation,\r\n          timestamp: Date.now(),\r\n        },\r\n        context: {\r\n          taskDescription: this.options.taskDescription,\r\n          neuralContext: this.neuralContext,\r\n          agentPerformance: this.getAgentPerformanceData(phaseName),\r\n        },\r\n        outcomes: {\r\n          success: validation.passed,\r\n          quality: validation.score,\r\n          efficiency: this.calculatePhaseEfficiency(phaseName),\r\n          learnings: this.extractLearnings(phaseName, result, validation),\r\n        },\r\n      };\r\n\r\n      await this.executeSwarmHook('neural_record_learning', learningData);\r\n\r\n      // Train neural patterns based on this execution\r\n      await this.executeSwarmHook('neural_train', {\r\n        data: learningData,\r\n        updateWeights: true,\r\n        savePattern: true,\r\n      });\r\n\r\n      console.log(`ðŸ§  Neural learning recorded for ${phaseName}`);\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Neural learning failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get agent performance data for phase\r\n   */\r\n  getAgentPerformanceData(phaseName) {\r\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\r\n    return phaseAgents.map((agent) => ({\r\n      id: agent.id,\r\n      type: agent.type,\r\n      performance: agent.performance,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Calculate phase efficiency\r\n   */\r\n  calculatePhaseEfficiency(phaseName) {\r\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\r\n    if (phaseAgents.length === 0) return 0.5;\r\n\r\n    const avgEfficiency =\r\n      phaseAgents.reduce((sum, agent) => sum + agent.performance.efficiency, 0) /\r\n      phaseAgents.length;\r\n    return avgEfficiency;\r\n  }\r\n\r\n  /**\r\n   * Extract learnings from phase execution\r\n   */\r\n  extractLearnings(phaseName, result, validation) {\r\n    const learnings = [];\r\n\r\n    if (validation.passed) {\r\n      learnings.push(`${phaseName} phase executed successfully`);\r\n      if (validation.score > 90) {\r\n        learnings.push(`High quality output achieved in ${phaseName}`);\r\n      }\r\n    } else {\r\n      learnings.push(`${phaseName} phase encountered issues: ${validation.issues.join(', ')}`);\r\n    }\r\n\r\n    if (validation.recommendations.length > 0) {\r\n      learnings.push(`Recommendations for ${phaseName}: ${validation.recommendations.join(', ')}`);\r\n    }\r\n\r\n    return learnings;\r\n  }\r\n\r\n  /**\r\n   * Prepare handoff to next phase\r\n   */\r\n  async preparePhaseHandoff(phaseName, result) {\r\n    const nextPhase = this.getNextPhase(phaseName);\r\n    if (!nextPhase) return;\r\n\r\n    // Prepare artifacts for next phase\r\n    await this.executeSwarmHook('prepare_handoff', {\r\n      fromPhase: phaseName,\r\n      toPhase: nextPhase,\r\n      artifacts: {\r\n        outputs: result,\r\n        decisions: this.extractDecisions(result),\r\n        context: this.neuralContext,\r\n      },\r\n    });\r\n\r\n    // Pre-warm next phase agents\r\n    const nextPhaseAgents = this.phaseAgents.get(nextPhase) || [];\r\n    for (const agent of nextPhaseAgents) {\r\n      await this.executeSwarmHook('agent_prewarm', {\r\n        agentId: agent.id,\r\n        phase: nextPhase,\r\n        context: result,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get next phase in SPARC sequence\r\n   */\r\n  getNextPhase(currentPhase) {\r\n    const sequence = ['specification', 'pseudocode', 'architecture', 'refinement', 'completion'];\r\n    const currentIndex = sequence.indexOf(currentPhase);\r\n    return currentIndex >= 0 && currentIndex < sequence.length - 1\r\n      ? sequence[currentIndex + 1]\r\n      : null;\r\n  }\r\n\r\n  /**\r\n   * Extract decisions from phase result\r\n   */\r\n  extractDecisions(result) {\r\n    const decisions = [];\r\n\r\n    if (result.architecturalDecisions) {\r\n      decisions.push(...result.architecturalDecisions);\r\n    }\r\n\r\n    if (result.designDecisions) {\r\n      decisions.push(...result.designDecisions);\r\n    }\r\n\r\n    if (result.qualityGates) {\r\n      decisions.push(\r\n        ...result.qualityGates.map((gate) => ({\r\n          decision: `Quality gate: ${gate.name}`,\r\n          rationale: gate.rationale || 'Quality assurance',\r\n          impact: gate.impact || 'process',\r\n        })),\r\n      );\r\n    }\r\n\r\n    return decisions;\r\n  }\r\n\r\n  /**\r\n   * Update coordination metrics\r\n   */\r\n  updateCoordinationMetrics(phaseName, result, validation) {\r\n    this.metrics.phaseExecutions += 1;\r\n\r\n    // Update agent utilization\r\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\r\n    for (const agent of phaseAgents) {\r\n      if (!this.metrics.agentUtilization[agent.id]) {\r\n        this.metrics.agentUtilization[agent.id] = { phases: 0, totalTime: 0, quality: 0 };\r\n      }\r\n      this.metrics.agentUtilization[agent.id].phases += 1;\r\n      this.metrics.agentUtilization[agent.id].quality += validation.score;\r\n    }\r\n\r\n    // Update coordination efficiency\r\n    const efficiency = this.calculatePhaseEfficiency(phaseName);\r\n    this.metrics.coordinationEfficiency = (this.metrics.coordinationEfficiency + efficiency) / 2;\r\n\r\n    // Record quality gate\r\n    this.metrics.qualityGates.push({\r\n      phase: phaseName,\r\n      passed: validation.passed,\r\n      score: validation.score,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    // Record learning data\r\n    if (validation.passed) {\r\n      this.metrics.learningData.push({\r\n        phase: phaseName,\r\n        success: true,\r\n        quality: validation.score,\r\n        patterns: this.neuralContext?.patterns || [],\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finalize coordination\r\n   */\r\n  async finalize() {\r\n    if (!this.swarmEnabled) return;\r\n\r\n    console.log('ðŸ Finalizing SPARC coordination');\r\n\r\n    try {\r\n      // Generate coordination report\r\n      const report = await this.generateCoordinationReport();\r\n\r\n      // Store final metrics\r\n      await this.executeSwarmHook('memory_store', {\r\n        key: 'sparc_coordination_final',\r\n        value: {\r\n          metrics: this.metrics,\r\n          report: report,\r\n          timestamp: Date.now(),\r\n        },\r\n      });\r\n\r\n      // Shutdown agents\r\n      for (const agent of this.agents) {\r\n        await this.executeSwarmHook('agent_shutdown', {\r\n          agentId: agent.id,\r\n          graceful: true,\r\n        });\r\n      }\r\n\r\n      // Shutdown swarm\r\n      await this.executeSwarmHook('swarm_shutdown', {\r\n        swarmId: this.swarmId,\r\n        preserveData: true,\r\n      });\r\n\r\n      console.log('âœ… SPARC coordination finalized');\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Coordination finalization failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate coordination report\r\n   */\r\n  async generateCoordinationReport() {\r\n    const report = {\r\n      summary: {\r\n        phasesExecuted: this.metrics.phaseExecutions,\r\n        agentsUtilized: Object.keys(this.metrics.agentUtilization).length,\r\n        coordinationEfficiency: this.metrics.coordinationEfficiency,\r\n        qualityGatesPassed: this.metrics.qualityGates.filter((g) => g.passed).length,\r\n        totalQualityGates: this.metrics.qualityGates.length,\r\n      },\r\n      agentPerformance: this.calculateAgentPerformanceSummary(),\r\n      phaseAnalysis: this.analyzePhasePerformance(),\r\n      recommendations: this.generateRecommendations(),\r\n      neuralInsights: this.extractNeuralInsights(),\r\n    };\r\n\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * Calculate agent performance summary\r\n   */\r\n  calculateAgentPerformanceSummary() {\r\n    const summary = {};\r\n\r\n    for (const agent of this.agents) {\r\n      summary[agent.id] = {\r\n        type: agent.type,\r\n        role: agent.role,\r\n        tasksCompleted: agent.performance.tasksCompleted,\r\n        averageQuality: agent.performance.qualityScore,\r\n        efficiency: agent.performance.efficiency,\r\n        averageTime: agent.performance.averageTime,\r\n      };\r\n    }\r\n\r\n    return summary;\r\n  }\r\n\r\n  /**\r\n   * Analyze phase performance\r\n   */\r\n  analyzePhasePerformance() {\r\n    const analysis = {};\r\n\r\n    for (const gate of this.metrics.qualityGates) {\r\n      if (!analysis[gate.phase]) {\r\n        analysis[gate.phase] = {\r\n          executions: 0,\r\n          passed: 0,\r\n          averageScore: 0,\r\n          totalScore: 0,\r\n        };\r\n      }\r\n\r\n      analysis[gate.phase].executions += 1;\r\n      if (gate.passed) analysis[gate.phase].passed += 1;\r\n      analysis[gate.phase].totalScore += gate.score;\r\n    }\r\n\r\n    // Calculate averages\r\n    for (const phase of Object.keys(analysis)) {\r\n      analysis[phase].averageScore = analysis[phase].totalScore / analysis[phase].executions;\r\n      analysis[phase].successRate = analysis[phase].passed / analysis[phase].executions;\r\n    }\r\n\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * Generate recommendations for improvement\r\n   */\r\n  generateRecommendations() {\r\n    const recommendations = [];\r\n\r\n    // Analyze agent utilization\r\n    const avgUtilization =\r\n      Object.values(this.metrics.agentUtilization).reduce((sum, agent) => sum + agent.phases, 0) /\r\n      Object.keys(this.metrics.agentUtilization).length;\r\n\r\n    if (avgUtilization < 2) {\r\n      recommendations.push('Consider reducing agent count for better utilization');\r\n    } else if (avgUtilization > 4) {\r\n      recommendations.push('Consider increasing agent count to distribute load');\r\n    }\r\n\r\n    // Analyze coordination efficiency\r\n    if (this.metrics.coordinationEfficiency < 0.7) {\r\n      recommendations.push('Improve coordination efficiency through better task decomposition');\r\n    }\r\n\r\n    // Analyze quality gates\r\n    const qualityGateSuccess =\r\n      this.metrics.qualityGates.filter((g) => g.passed).length / this.metrics.qualityGates.length;\r\n    if (qualityGateSuccess < 0.8) {\r\n      recommendations.push('Review quality gate criteria and provide additional agent training');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  /**\r\n   * Extract neural insights\r\n   */\r\n  extractNeuralInsights() {\r\n    const insights = [];\r\n\r\n    // Pattern analysis\r\n    const successfulPatterns = this.metrics.learningData.filter((d) => d.success);\r\n    if (successfulPatterns.length > 0) {\r\n      insights.push(`${successfulPatterns.length} successful execution patterns identified`);\r\n    }\r\n\r\n    // Quality analysis\r\n    const avgQuality =\r\n      this.metrics.learningData.reduce((sum, d) => sum + d.quality, 0) /\r\n      this.metrics.learningData.length;\r\n    if (avgQuality > 85) {\r\n      insights.push('High quality outcomes consistently achieved');\r\n    } else if (avgQuality < 70) {\r\n      insights.push('Quality improvements needed in execution');\r\n    }\r\n\r\n    return insights;\r\n  }\r\n\r\n  /**\r\n   * Execute swarm hook with error handling\r\n   */\r\n  async executeSwarmHook(hookName, data = {}) {\r\n    if (!this.swarmEnabled) {\r\n      throw new Error('Swarm not enabled');\r\n    }\r\n\r\n    try {\r\n      const { spawn } = await import('child_process');\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const args = ['ruv-swarm', 'hook', hookName];\r\n\r\n        // Add data as JSON argument\r\n        if (Object.keys(data).length > 0) {\r\n          args.push('--data', JSON.stringify(data));\r\n        }\r\n\r\n        const process = spawn('npx', args, {\r\n          stdio: 'pipe',\r\n        });\r\n\r\n        let output = '';\r\n        let error = '';\r\n\r\n        process.stdout.on('data', (data) => {\r\n          output += data.toString();\r\n        });\r\n\r\n        process.stderr.on('data', (data) => {\r\n          error += data.toString();\r\n        });\r\n\r\n        process.on('close', (code) => {\r\n          if (code === 0) {\r\n            try {\r\n              const result = JSON.parse(output);\r\n              resolve(result);\r\n            } catch (parseError) {\r\n              resolve(output.trim());\r\n            }\r\n          } else {\r\n            reject(new Error(`Hook ${hookName} failed: ${error}`));\r\n          }\r\n        });\r\n\r\n        process.on('error', (err) => {\r\n          reject(err);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      throw new Error(`Failed to execute swarm hook ${hookName}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record learning from SPARC execution\r\n   */\r\n  async recordLearning(learningData) {\r\n    if (!this.options.neuralLearning) return;\r\n\r\n    try {\r\n      await this.executeSwarmHook('neural_record_learning', {\r\n        methodology: 'sparc',\r\n        data: learningData,\r\n        timestamp: Date.now(),\r\n      });\r\n    } catch (error) {\r\n      console.warn(`âš ï¸ Failed to record learning: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get coordination status\r\n   */\r\n  getStatus() {\r\n    return {\r\n      swarmEnabled: this.swarmEnabled,\r\n      swarmId: this.swarmId,\r\n      agentCount: this.agents.length,\r\n      phaseAgents: Object.fromEntries(\r\n        Array.from(this.phaseAgents.entries()).map(([phase, agents]) => [\r\n          phase,\r\n          agents.map((a) => ({ id: a.id, type: a.type, status: a.status })),\r\n        ]),\r\n      ),\r\n      metrics: this.metrics,\r\n      coordination: this.coordination,\r\n    };\r\n  }\r\n}\r\n\r\nexport default SparcCoordinator;\r\n"],"names":["SparcCoordinator","phases","options","swarmId","agents","phaseAgents","Map","coordination","strategy","topology","communication","loadBalancing","metrics","phaseExecutions","agentUtilization","coordinationEfficiency","qualityGates","learningData","neuralContext","swarmEnabled","initializeSwarm","console","log","swarmConfig","maxAgents","calculateOptimalAgentCount","executeSwarmHook","spawnSparcAgents","setupPhaseCoordination","error","warn","message","baseAgents","Object","keys","length","complexityMultiplier","assessTaskComplexity","parallelismFactor","parallelExecution","Math","min","max","taskDescription","complexityKeywords","matchedKeywords","filter","keyword","toLowerCase","includes","agentTypes","type","role","capabilities","agentSpec","agentId","maxConcurrentTasks","getAgentConcurrency","specialization","agent","id","status","currentPhase","assignedTasks","performance","tasksCompleted","averageTime","qualityScore","efficiency","push","agentType","concurrencyMap","sparc_specification","sparc_pseudocode","sparc_architecture","sparc_refinement","sparc_completion","sparc_coordinator","phaseName","replace","has","set","get","dependencies","pseudocode","architecture","refinement","completion","setupQualityGates","phase","criteria","threshold","gate","prePhase","loadNeuralContext","assignAgentsToPhase","preparePhaseEnvironment","key","value","timestamp","Date","now","map","a","neuralData","methodology","taskType","classifyTaskType","patterns","insights","recommendations","confidence","toFixed","taskLower","priority","getPhasePriority","context","coordinator","find","priorities","specification","namespace","isolation","getPhaseDependencies","dependency","fromPhase","toPhase","artifactTypes","postPhase","result","validation","validatePhaseResults","updateAgentPerformance","neuralLearning","recordNeuralLearning","preparePhaseHandoff","updateCoordinationMetrics","passed","score","issues","swarmValidation","getValidationCriteria","requiredFields","qualityThresholds","completeness","clarity","complexity","modularity","scalability","testCoverage","codeQuality","readiness","executionTime","getPhaseStartTime","expectedTime","getExpectedPhaseTime","expectedTimes","execution","agentPerformance","getAgentPerformanceData","outcomes","success","quality","calculatePhaseEfficiency","learnings","extractLearnings","data","updateWeights","savePattern","avgEfficiency","reduce","sum","join","nextPhase","getNextPhase","artifacts","outputs","decisions","extractDecisions","nextPhaseAgents","sequence","currentIndex","indexOf","architecturalDecisions","designDecisions","decision","name","rationale","impact","totalTime","finalize","report","generateCoordinationReport","graceful","preserveData","summary","phasesExecuted","agentsUtilized","qualityGatesPassed","g","totalQualityGates","calculateAgentPerformanceSummary","phaseAnalysis","analyzePhasePerformance","generateRecommendations","neuralInsights","extractNeuralInsights","averageQuality","analysis","executions","averageScore","totalScore","successRate","avgUtilization","values","qualityGateSuccess","successfulPatterns","d","avgQuality","hookName","Error","spawn","Promise","resolve","reject","args","JSON","stringify","process","stdio","output","stdout","on","toString","stderr","code","parse","parseError","trim","err","recordLearning","getStatus","agentCount","fromEntries","Array","from","entries"],"mappings":"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"}