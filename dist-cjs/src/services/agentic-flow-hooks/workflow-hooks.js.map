{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/workflow-hooks.ts"],"sourcesContent":["/**\r\n * Self-improving workflow hooks for agentic-flow\r\n * \r\n * Enables adaptive workflows with provider selection\r\n * and continuous improvement based on outcomes.\r\n */\r\n\r\nimport { agenticHookManager } from './hook-manager.js';\r\nimport type {\r\n  AgenticHookContext,\r\n  HookHandlerResult,\r\n  WorkflowHookPayload,\r\n  WorkflowDecision,\r\n  Learning,\r\n  SideEffect,\r\n  Pattern,\r\n} from './types.js';\r\n\r\n// ===== Workflow Start Hook =====\r\n\r\nexport const workflowStartHook = {\r\n  id: 'agentic-workflow-start',\r\n  type: 'workflow-start' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: WorkflowHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { workflowId, state } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Load workflow history and learnings\r\n    const history = await loadWorkflowHistory(workflowId, context);\r\n    const learnings = await loadWorkflowLearnings(workflowId, context);\r\n    \r\n    // Select optimal provider based on history\r\n    const provider = await selectOptimalProvider(\r\n      workflowId,\r\n      state,\r\n      history,\r\n      context\r\n    );\r\n    \r\n    // Initialize workflow state\r\n    const enhancedState = {\r\n      ...state,\r\n      startTime: Date.now(),\r\n      provider,\r\n      learnings: learnings.slice(-10), // Last 10 learnings\r\n      predictions: await generateWorkflowPredictions(workflowId, state, context),\r\n    };\r\n    \r\n    // Store workflow session\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `workflow:session:${workflowId}:${context.sessionId}`,\r\n        value: enhancedState,\r\n        ttl: 86400, // 24 hours\r\n      },\r\n    });\r\n    \r\n    // Track workflow start\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'increment',\r\n      data: { name: `workflow.starts.${workflowId}` },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      modified: true,\r\n      payload: {\r\n        ...payload,\r\n        state: enhancedState,\r\n      },\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Workflow Step Hook =====\r\n\r\nexport const workflowStepHook = {\r\n  id: 'agentic-workflow-step',\r\n  type: 'workflow-step' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: WorkflowHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { workflowId, step, state } = payload;\r\n    \r\n    if (!step) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Measure step performance\r\n    const stepStart = Date.now();\r\n    \r\n    // Check for step optimizations\r\n    const optimizations = await getStepOptimizations(\r\n      workflowId,\r\n      step,\r\n      context\r\n    );\r\n    \r\n    if (optimizations.length > 0) {\r\n      // Apply step optimizations\r\n      const optimizedState = applyStepOptimizations(\r\n        state,\r\n        optimizations\r\n      );\r\n      \r\n      sideEffects.push({\r\n        type: 'log',\r\n        action: 'write',\r\n        data: {\r\n          level: 'info',\r\n          message: `Applied ${optimizations.length} optimizations to step ${step}`,\r\n          data: { optimizations },\r\n        },\r\n      });\r\n      \r\n      return {\r\n        continue: true,\r\n        modified: true,\r\n        payload: {\r\n          ...payload,\r\n          state: optimizedState,\r\n        },\r\n        sideEffects,\r\n      };\r\n    }\r\n    \r\n    // Track step execution\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `workflow:step:${workflowId}:${step}:${Date.now()}`,\r\n        value: {\r\n          step,\r\n          state: summarizeState(state),\r\n          timestamp: Date.now(),\r\n        },\r\n        ttl: 86400,\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Workflow Decision Hook =====\r\n\r\nexport const workflowDecisionHook = {\r\n  id: 'agentic-workflow-decision',\r\n  type: 'workflow-decision' as const,\r\n  priority: 90,\r\n  handler: async (\r\n    payload: WorkflowHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { workflowId, decision, state } = payload;\r\n    \r\n    if (!decision) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Enhance decision with historical data\r\n    const historicalOutcomes = await getDecisionOutcomes(\r\n      workflowId,\r\n      decision.point,\r\n      context\r\n    );\r\n    \r\n    // Calculate confidence adjustments\r\n    const adjustedDecision = adjustDecisionConfidence(\r\n      decision,\r\n      historicalOutcomes\r\n    );\r\n    \r\n    // Generate alternative paths\r\n    const alternatives = await generateAlternativeDecisions(\r\n      workflowId,\r\n      decision,\r\n      state,\r\n      context\r\n    );\r\n    \r\n    if (alternatives.length > 0) {\r\n      // Check if better alternative exists\r\n      const bestAlternative = alternatives.find(alt => \r\n        alt.confidence > adjustedDecision.confidence * 1.2\r\n      );\r\n      \r\n      if (bestAlternative) {\r\n        sideEffects.push({\r\n          type: 'notification',\r\n          action: 'emit',\r\n          data: {\r\n            event: 'workflow:decision:alternative',\r\n            data: {\r\n              original: adjustedDecision,\r\n              suggested: bestAlternative,\r\n            },\r\n          },\r\n        });\r\n        \r\n        // Override with better decision\r\n        adjustedDecision.selected = bestAlternative.selected;\r\n        adjustedDecision.confidence = bestAlternative.confidence;\r\n        adjustedDecision.reasoning = `${adjustedDecision.reasoning} (AI-optimized)`;\r\n      }\r\n    }\r\n    \r\n    // Store decision for learning\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `decision:${workflowId}:${decision.point}:${Date.now()}`,\r\n        value: {\r\n          ...adjustedDecision,\r\n          alternatives,\r\n          state: summarizeState(state),\r\n        },\r\n        ttl: 604800, // 7 days\r\n      },\r\n    });\r\n    \r\n    // Track decision metrics\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'update',\r\n      data: {\r\n        name: `workflow.decisions.confidence.${workflowId}`,\r\n        value: adjustedDecision.confidence,\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      modified: true,\r\n      payload: {\r\n        ...payload,\r\n        decision: adjustedDecision,\r\n      },\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Workflow Complete Hook =====\r\n\r\nexport const workflowCompleteHook = {\r\n  id: 'agentic-workflow-complete',\r\n  type: 'workflow-complete' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: WorkflowHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { workflowId, state, metrics } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Calculate workflow performance\r\n    const performance = calculateWorkflowPerformance(state, metrics);\r\n    \r\n    // Extract learnings from this execution\r\n    const learnings = await extractWorkflowLearnings(\r\n      workflowId,\r\n      state,\r\n      performance,\r\n      context\r\n    );\r\n    \r\n    // Store learnings\r\n    for (const learning of learnings) {\r\n      sideEffects.push({\r\n        type: 'memory',\r\n        action: 'store',\r\n        data: {\r\n          key: `learning:${workflowId}:${learning.type}:${Date.now()}`,\r\n          value: learning,\r\n          ttl: 0, // Permanent\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Update workflow success patterns\r\n    if (performance.success) {\r\n      const pattern: Pattern = {\r\n        id: `workflow_success_${Date.now()}`,\r\n        type: 'success',\r\n        confidence: performance.score,\r\n        occurrences: 1,\r\n        context: {\r\n          workflowId,\r\n          provider: state.provider,\r\n          duration: metrics?.duration || 0,\r\n          decisions: countDecisions(state),\r\n        },\r\n      };\r\n      \r\n      context.neural.patterns.add(pattern);\r\n      \r\n      sideEffects.push({\r\n        type: 'neural',\r\n        action: 'train',\r\n        data: {\r\n          patterns: [pattern],\r\n          modelId: `workflow-optimizer-${workflowId}`,\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Generate improvement suggestions\r\n    const improvements = await generateImprovementSuggestions(\r\n      workflowId,\r\n      state,\r\n      performance,\r\n      learnings,\r\n      context\r\n    );\r\n    \r\n    if (improvements.length > 0) {\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'workflow:improvements:suggested',\r\n          data: {\r\n            workflowId,\r\n            improvements,\r\n            performance,\r\n          },\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Update workflow metrics\r\n    sideEffects.push(\r\n      {\r\n        type: 'metric',\r\n        action: 'update',\r\n        data: {\r\n          name: `workflow.completion.rate.${workflowId}`,\r\n          value: performance.success ? 1 : 0,\r\n        },\r\n      },\r\n      {\r\n        type: 'metric',\r\n        action: 'update',\r\n        data: {\r\n          name: `workflow.performance.score.${workflowId}`,\r\n          value: performance.score,\r\n        },\r\n      }\r\n    );\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Workflow Error Hook =====\r\n\r\nexport const workflowErrorHook = {\r\n  id: 'agentic-workflow-error',\r\n  type: 'workflow-error' as const,\r\n  priority: 95,\r\n  handler: async (\r\n    payload: WorkflowHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { workflowId, error, state } = payload;\r\n    \r\n    if (!error) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Analyze error pattern\r\n    const errorPattern = await analyzeErrorPattern(\r\n      workflowId,\r\n      error,\r\n      state,\r\n      context\r\n    );\r\n    \r\n    // Store error for learning\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `error:${workflowId}:${Date.now()}`,\r\n        value: {\r\n          error: {\r\n            message: error.message,\r\n            stack: error.stack,\r\n            type: error.name,\r\n          },\r\n          pattern: errorPattern,\r\n          state: summarizeState(state),\r\n          timestamp: Date.now(),\r\n        },\r\n        ttl: 604800, // 7 days\r\n      },\r\n    });\r\n    \r\n    // Check for recovery strategies\r\n    const recovery = await findRecoveryStrategy(\r\n      workflowId,\r\n      error,\r\n      errorPattern,\r\n      context\r\n    );\r\n    \r\n    if (recovery) {\r\n      sideEffects.push({\r\n        type: 'log',\r\n        action: 'write',\r\n        data: {\r\n          level: 'info',\r\n          message: 'Recovery strategy found',\r\n          data: recovery,\r\n        },\r\n      });\r\n      \r\n      // Apply recovery\r\n      const recoveredState = applyRecoveryStrategy(state, recovery);\r\n      \r\n      return {\r\n        continue: true,\r\n        modified: true,\r\n        payload: {\r\n          ...payload,\r\n          state: recoveredState,\r\n          error: undefined, // Clear error after recovery\r\n        },\r\n        sideEffects,\r\n      };\r\n    }\r\n    \r\n    // Learn from failure\r\n    const failureLearning: Learning = {\r\n      type: 'failure',\r\n      context: `Error in workflow ${workflowId}: ${error.message}`,\r\n      value: {\r\n        errorType: error.name,\r\n        state: summarizeState(state),\r\n        pattern: errorPattern,\r\n      },\r\n      applicability: errorPattern.confidence,\r\n    };\r\n    \r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `learning:failure:${workflowId}:${Date.now()}`,\r\n        value: failureLearning,\r\n        ttl: 0, // Permanent\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Helper Functions =====\r\n\r\nasync function loadWorkflowHistory(\r\n  workflowId: string,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  const historyKey = `workflow:history:${workflowId}`;\r\n  return await context.memory.cache.get(historyKey) || [];\r\n}\r\n\r\nasync function loadWorkflowLearnings(\r\n  workflowId: string,\r\n  context: AgenticHookContext\r\n): Promise<Learning[]> {\r\n  const learningsKey = `workflow:learnings:${workflowId}`;\r\n  return await context.memory.cache.get(learningsKey) || [];\r\n}\r\n\r\nasync function selectOptimalProvider(\r\n  workflowId: string,\r\n  state: any,\r\n  history: any[],\r\n  context: AgenticHookContext\r\n): Promise<string> {\r\n  // Analyze historical performance by provider\r\n  const providerStats = new Map<string, { success: number; total: number }>();\r\n  \r\n  for (const execution of history) {\r\n    const provider = execution.provider;\r\n    if (!provider) continue;\r\n    \r\n    const stats = providerStats.get(provider) || { success: 0, total: 0 };\r\n    stats.total++;\r\n    if (execution.success) stats.success++;\r\n    providerStats.set(provider, stats);\r\n  }\r\n  \r\n  // Calculate success rates\r\n  let bestProvider = 'openai'; // Default\r\n  let bestRate = 0;\r\n  \r\n  for (const [provider, stats] of providerStats) {\r\n    const rate = stats.success / stats.total;\r\n    if (rate > bestRate && stats.total >= 5) {\r\n      bestRate = rate;\r\n      bestProvider = provider;\r\n    }\r\n  }\r\n  \r\n  // Check current provider health\r\n  const healthKey = `provider:health:${bestProvider}`;\r\n  const health = await context.memory.cache.get(healthKey);\r\n  \r\n  if (health && health.score < 0.5) {\r\n    // Provider unhealthy, select alternative\r\n    return selectAlternativeProvider(bestProvider, providerStats);\r\n  }\r\n  \r\n  return bestProvider;\r\n}\r\n\r\nasync function generateWorkflowPredictions(\r\n  workflowId: string,\r\n  state: any,\r\n  context: AgenticHookContext\r\n): Promise<any> {\r\n  // Generate predictions for workflow execution\r\n  const predictions = {\r\n    estimatedDuration: 0,\r\n    successProbability: 0.7,\r\n    likelyBottlenecks: [],\r\n    recommendedOptimizations: [],\r\n  };\r\n  \r\n  // Load historical durations\r\n  const history = await loadWorkflowHistory(workflowId, context);\r\n  if (history.length > 0) {\r\n    const durations = history\r\n      .filter(h => h.duration)\r\n      .map(h => h.duration);\r\n    \r\n    if (durations.length > 0) {\r\n      predictions.estimatedDuration = \r\n        durations.reduce((a, b) => a + b, 0) / durations.length;\r\n    }\r\n    \r\n    const successes = history.filter(h => h.success).length;\r\n    predictions.successProbability = successes / history.length;\r\n  }\r\n  \r\n  return predictions;\r\n}\r\n\r\nasync function getStepOptimizations(\r\n  workflowId: string,\r\n  step: string,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  // Get optimizations for specific step\r\n  const optKey = `optimizations:${workflowId}:${step}`;\r\n  return await context.memory.cache.get(optKey) || [];\r\n}\r\n\r\nfunction applyStepOptimizations(\r\n  state: any,\r\n  optimizations: any[]\r\n): any {\r\n  const optimizedState = { ...state };\r\n  \r\n  for (const opt of optimizations) {\r\n    switch (opt.type) {\r\n      case 'skip':\r\n        if (opt.condition && opt.condition(state)) {\r\n          optimizedState.skipSteps = [\r\n            ...(optimizedState.skipSteps || []),\r\n            opt.target,\r\n          ];\r\n        }\r\n        break;\r\n        \r\n      case 'parallel':\r\n        optimizedState.parallelSteps = [\r\n          ...(optimizedState.parallelSteps || []),\r\n          ...opt.steps,\r\n        ];\r\n        break;\r\n        \r\n      case 'cache':\r\n        optimizedState.useCache = true;\r\n        optimizedState.cacheKeys = [\r\n          ...(optimizedState.cacheKeys || []),\r\n          opt.key,\r\n        ];\r\n        break;\r\n    }\r\n  }\r\n  \r\n  return optimizedState;\r\n}\r\n\r\nfunction summarizeState(state: any): any {\r\n  // Create summary of state for storage\r\n  return {\r\n    keys: Object.keys(state),\r\n    size: JSON.stringify(state).length,\r\n    hasError: !!state.error,\r\n    provider: state.provider,\r\n    timestamp: Date.now(),\r\n  };\r\n}\r\n\r\nasync function getDecisionOutcomes(\r\n  workflowId: string,\r\n  decisionPoint: string,\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  // Get historical outcomes for decision point\r\n  const outcomeKey = `outcomes:${workflowId}:${decisionPoint}`;\r\n  return await context.memory.cache.get(outcomeKey) || [];\r\n}\r\n\r\nfunction adjustDecisionConfidence(\r\n  decision: WorkflowDecision,\r\n  historicalOutcomes: any[]\r\n): WorkflowDecision {\r\n  if (historicalOutcomes.length === 0) {\r\n    return decision;\r\n  }\r\n  \r\n  // Calculate success rate for selected option\r\n  const relevantOutcomes = historicalOutcomes.filter(o => \r\n    o.selected === decision.selected\r\n  );\r\n  \r\n  if (relevantOutcomes.length === 0) {\r\n    return decision;\r\n  }\r\n  \r\n  const successRate = relevantOutcomes.filter(o => o.success).length / \r\n    relevantOutcomes.length;\r\n  \r\n  // Adjust confidence based on historical success\r\n  const adjustedConfidence = decision.confidence * 0.7 + successRate * 0.3;\r\n  \r\n  return {\r\n    ...decision,\r\n    confidence: adjustedConfidence,\r\n    learnings: [\r\n      ...decision.learnings,\r\n      {\r\n        type: 'success',\r\n        context: `Historical success rate: ${(successRate * 100).toFixed(1)}%`,\r\n        value: successRate,\r\n        applicability: Math.min(relevantOutcomes.length / 10, 1),\r\n      },\r\n    ],\r\n  };\r\n}\r\n\r\nasync function generateAlternativeDecisions(\r\n  workflowId: string,\r\n  decision: WorkflowDecision,\r\n  state: any,\r\n  context: AgenticHookContext\r\n): Promise<WorkflowDecision[]> {\r\n  // Generate alternative decision paths\r\n  const alternatives: WorkflowDecision[] = [];\r\n  \r\n  // Check each option not selected\r\n  for (const option of decision.options) {\r\n    if (option === decision.selected) continue;\r\n    \r\n    // Calculate alternative confidence\r\n    const altConfidence = await calculateAlternativeConfidence(\r\n      workflowId,\r\n      decision.point,\r\n      option,\r\n      state,\r\n      context\r\n    );\r\n    \r\n    if (altConfidence > 0.5) {\r\n      alternatives.push({\r\n        ...decision,\r\n        selected: option,\r\n        confidence: altConfidence,\r\n        reasoning: `Alternative path based on historical analysis`,\r\n      });\r\n    }\r\n  }\r\n  \r\n  return alternatives;\r\n}\r\n\r\nfunction calculateWorkflowPerformance(\r\n  state: any,\r\n  metrics: any\r\n): any {\r\n  const performance = {\r\n    success: !state.error,\r\n    score: 0,\r\n    duration: metrics?.duration || 0,\r\n    efficiency: 0,\r\n    reliability: 0,\r\n  };\r\n  \r\n  // Calculate performance score\r\n  if (performance.success) {\r\n    performance.score = 0.7; // Base success score\r\n    \r\n    // Adjust for duration\r\n    if (metrics?.duration && state.predictions?.estimatedDuration) {\r\n      const durationRatio = state.predictions.estimatedDuration / metrics.duration;\r\n      performance.efficiency = Math.min(durationRatio, 1);\r\n      performance.score += performance.efficiency * 0.2;\r\n    }\r\n    \r\n    // Adjust for error rate\r\n    if (metrics?.errorRate !== undefined) {\r\n      performance.reliability = 1 - metrics.errorRate;\r\n      performance.score += performance.reliability * 0.1;\r\n    }\r\n  }\r\n  \r\n  return performance;\r\n}\r\n\r\nasync function extractWorkflowLearnings(\r\n  workflowId: string,\r\n  state: any,\r\n  performance: any,\r\n  context: AgenticHookContext\r\n): Promise<Learning[]> {\r\n  const learnings: Learning[] = [];\r\n  \r\n  // Learn from successful execution\r\n  if (performance.success) {\r\n    learnings.push({\r\n      type: 'success',\r\n      context: `Successful workflow execution with score ${performance.score}`,\r\n      value: {\r\n        provider: state.provider,\r\n        duration: performance.duration,\r\n        decisions: extractDecisions(state),\r\n      },\r\n      applicability: performance.score,\r\n    });\r\n  }\r\n  \r\n  // Learn from optimizations\r\n  if (state.appliedOptimizations) {\r\n    for (const opt of state.appliedOptimizations) {\r\n      learnings.push({\r\n        type: 'optimization',\r\n        context: `Applied ${opt.type} optimization at ${opt.step}`,\r\n        value: opt,\r\n        applicability: 0.8,\r\n      });\r\n    }\r\n  }\r\n  \r\n  return learnings;\r\n}\r\n\r\nfunction countDecisions(state: any): number {\r\n  // Count decisions made during workflow\r\n  return state.decisions?.length || 0;\r\n}\r\n\r\nasync function generateImprovementSuggestions(\r\n  workflowId: string,\r\n  state: any,\r\n  performance: any,\r\n  learnings: Learning[],\r\n  context: AgenticHookContext\r\n): Promise<any[]> {\r\n  const suggestions: any[] = [];\r\n  \r\n  // Suggest caching if repeated operations\r\n  if (performance.duration > 5000) {\r\n    suggestions.push({\r\n      type: 'cache',\r\n      target: 'frequent_operations',\r\n      reason: 'Long execution time detected',\r\n      expectedImprovement: '30-50% reduction in duration',\r\n    });\r\n  }\r\n  \r\n  // Suggest parallelization\r\n  if (state.sequentialSteps?.length > 3) {\r\n    suggestions.push({\r\n      type: 'parallel',\r\n      target: 'independent_steps',\r\n      reason: 'Multiple sequential steps detected',\r\n      expectedImprovement: '40-60% reduction in duration',\r\n    });\r\n  }\r\n  \r\n  // Suggest provider switch based on learnings\r\n  const providerLearnings = learnings.filter(l => \r\n    l.type === 'success' && l.value.provider\r\n  );\r\n  \r\n  if (providerLearnings.length > 0) {\r\n    const providerScores = new Map<string, number>();\r\n    for (const learning of providerLearnings) {\r\n      const provider = learning.value.provider;\r\n      const score = providerScores.get(provider) || 0;\r\n      providerScores.set(provider, score + learning.applicability);\r\n    }\r\n    \r\n    const currentScore = providerScores.get(state.provider) || 0;\r\n    for (const [provider, score] of providerScores) {\r\n      if (score > currentScore * 1.2) {\r\n        suggestions.push({\r\n          type: 'provider',\r\n          target: provider,\r\n          reason: `${provider} shows better historical performance`,\r\n          expectedImprovement: `${((score / currentScore - 1) * 100).toFixed(0)}% better reliability`,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  return suggestions;\r\n}\r\n\r\nasync function analyzeErrorPattern(\r\n  workflowId: string,\r\n  error: Error,\r\n  state: any,\r\n  context: AgenticHookContext\r\n): Promise<any> {\r\n  // Analyze error to find patterns\r\n  const pattern = {\r\n    type: classifyError(error),\r\n    confidence: 0.7,\r\n    context: {\r\n      step: state.currentStep,\r\n      provider: state.provider,\r\n      errorMessage: error.message,\r\n    },\r\n  };\r\n  \r\n  // Check for similar errors\r\n  const errorHistory = await context.memory.cache.get(\r\n    `errors:${workflowId}:${pattern.type}`\r\n  ) || [];\r\n  \r\n  if (errorHistory.length > 5) {\r\n    pattern.confidence = 0.9;\r\n    pattern.context.recurring = true;\r\n    pattern.context.occurrences = errorHistory.length;\r\n  }\r\n  \r\n  return pattern;\r\n}\r\n\r\nasync function findRecoveryStrategy(\r\n  workflowId: string,\r\n  error: Error,\r\n  errorPattern: any,\r\n  context: AgenticHookContext\r\n): Promise<any | null> {\r\n  // Find recovery strategy for error\r\n  if (errorPattern.type === 'timeout') {\r\n    return {\r\n      type: 'retry',\r\n      params: {\r\n        maxRetries: 3,\r\n        backoff: 'exponential',\r\n        timeout: 30000,\r\n      },\r\n    };\r\n  }\r\n  \r\n  if (errorPattern.type === 'rate_limit') {\r\n    return {\r\n      type: 'throttle',\r\n      params: {\r\n        delay: 1000,\r\n        maxConcurrent: 1,\r\n      },\r\n    };\r\n  }\r\n  \r\n  if (errorPattern.type === 'validation') {\r\n    return {\r\n      type: 'transform',\r\n      params: {\r\n        sanitize: true,\r\n        validate: true,\r\n      },\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction applyRecoveryStrategy(state: any, recovery: any): any {\r\n  const recoveredState = { ...state };\r\n  \r\n  switch (recovery.type) {\r\n    case 'retry':\r\n      recoveredState.retryConfig = recovery.params;\r\n      recoveredState.shouldRetry = true;\r\n      break;\r\n      \r\n    case 'throttle':\r\n      recoveredState.throttleConfig = recovery.params;\r\n      recoveredState.throttled = true;\r\n      break;\r\n      \r\n    case 'transform':\r\n      recoveredState.transformConfig = recovery.params;\r\n      recoveredState.needsTransform = true;\r\n      break;\r\n  }\r\n  \r\n  recoveredState.recoveryApplied = recovery;\r\n  delete recoveredState.error; // Clear error state\r\n  \r\n  return recoveredState;\r\n}\r\n\r\nfunction selectAlternativeProvider(\r\n  currentProvider: string,\r\n  providerStats: Map<string, { success: number; total: number }>\r\n): string {\r\n  // Select alternative provider based on stats\r\n  let bestAlternative = 'anthropic'; // Default fallback\r\n  let bestRate = 0;\r\n  \r\n  for (const [provider, stats] of providerStats) {\r\n    if (provider === currentProvider) continue;\r\n    \r\n    const rate = stats.success / stats.total;\r\n    if (rate > bestRate && stats.total >= 3) {\r\n      bestRate = rate;\r\n      bestAlternative = provider;\r\n    }\r\n  }\r\n  \r\n  return bestAlternative;\r\n}\r\n\r\nasync function calculateAlternativeConfidence(\r\n  workflowId: string,\r\n  decisionPoint: string,\r\n  option: string,\r\n  state: any,\r\n  context: AgenticHookContext\r\n): Promise<number> {\r\n  // Calculate confidence for alternative option\r\n  const outcomeKey = `outcomes:${workflowId}:${decisionPoint}:${option}`;\r\n  const outcomes = await context.memory.cache.get(outcomeKey) || [];\r\n  \r\n  if (outcomes.length === 0) {\r\n    return 0.5; // Default confidence\r\n  }\r\n  \r\n  const successRate = outcomes.filter((o: any) => o.success).length / \r\n    outcomes.length;\r\n  \r\n  // Adjust for recency\r\n  const recentOutcomes = outcomes.slice(-10);\r\n  const recentSuccessRate = recentOutcomes.filter((o: any) => o.success).length / \r\n    recentOutcomes.length;\r\n  \r\n  return successRate * 0.7 + recentSuccessRate * 0.3;\r\n}\r\n\r\nfunction extractDecisions(state: any): any[] {\r\n  // Extract decisions from state\r\n  return state.decisions || [];\r\n}\r\n\r\nfunction classifyError(error: Error): string {\r\n  const message = error.message.toLowerCase();\r\n  \r\n  if (message.includes('timeout')) return 'timeout';\r\n  if (message.includes('rate limit')) return 'rate_limit';\r\n  if (message.includes('validation')) return 'validation';\r\n  if (message.includes('network')) return 'network';\r\n  if (message.includes('auth')) return 'authentication';\r\n  \r\n  return 'unknown';\r\n}\r\n\r\n// ===== Register Hooks =====\r\n\r\nexport function registerWorkflowHooks(): void {\r\n  agenticHookManager.register(workflowStartHook);\r\n  agenticHookManager.register(workflowStepHook);\r\n  agenticHookManager.register(workflowDecisionHook);\r\n  agenticHookManager.register(workflowCompleteHook);\r\n  agenticHookManager.register(workflowErrorHook);\r\n}"],"names":["agenticHookManager","workflowStartHook","id","type","priority","handler","payload","context","workflowId","state","sideEffects","history","loadWorkflowHistory","learnings","loadWorkflowLearnings","provider","selectOptimalProvider","enhancedState","startTime","Date","now","slice","predictions","generateWorkflowPredictions","push","action","data","key","sessionId","value","ttl","name","continue","modified","workflowStepHook","step","stepStart","optimizations","getStepOptimizations","length","optimizedState","applyStepOptimizations","level","message","summarizeState","timestamp","workflowDecisionHook","decision","historicalOutcomes","getDecisionOutcomes","point","adjustedDecision","adjustDecisionConfidence","alternatives","generateAlternativeDecisions","bestAlternative","find","alt","confidence","event","original","suggested","selected","reasoning","workflowCompleteHook","metrics","performance","calculateWorkflowPerformance","extractWorkflowLearnings","learning","success","pattern","score","occurrences","duration","decisions","countDecisions","neural","patterns","add","modelId","improvements","generateImprovementSuggestions","workflowErrorHook","error","errorPattern","analyzeErrorPattern","stack","recovery","findRecoveryStrategy","recoveredState","applyRecoveryStrategy","undefined","failureLearning","errorType","applicability","historyKey","memory","cache","get","learningsKey","providerStats","Map","execution","stats","total","set","bestProvider","bestRate","rate","healthKey","health","selectAlternativeProvider","estimatedDuration","successProbability","likelyBottlenecks","recommendedOptimizations","durations","filter","h","map","reduce","a","b","successes","optKey","opt","condition","skipSteps","target","parallelSteps","steps","useCache","cacheKeys","keys","Object","size","JSON","stringify","hasError","decisionPoint","outcomeKey","relevantOutcomes","o","successRate","adjustedConfidence","toFixed","Math","min","option","options","altConfidence","calculateAlternativeConfidence","efficiency","reliability","durationRatio","errorRate","extractDecisions","appliedOptimizations","suggestions","reason","expectedImprovement","sequentialSteps","providerLearnings","l","providerScores","currentScore","classifyError","currentStep","errorMessage","errorHistory","recurring","params","maxRetries","backoff","timeout","delay","maxConcurrent","sanitize","validate","retryConfig","shouldRetry","throttleConfig","throttled","transformConfig","needsTransform","recoveryApplied","currentProvider","outcomes","recentOutcomes","recentSuccessRate","toLowerCase","includes","registerWorkflowHooks","register"],"mappings":"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"}