{"version":3,"sources":["../../../src/swarm/prompt-manager.ts"],"sourcesContent":["import * as path from 'path';\r\nimport { EventEmitter } from 'events';\r\nimport { copyPromptsEnhanced, EnhancedPromptCopier } from './prompt-copier-enhanced.js';\r\nimport type { CopyOptions, CopyResult } from './prompt-copier.js';\r\nimport {\r\n  PromptConfigManager,\r\n  PromptPathResolver,\r\n  PromptValidator,\r\n  formatDuration,\r\n  formatFileSize,\r\n} from './prompt-utils.js';\r\nimport { logger } from '../core/logger.js';\r\n\r\nexport interface PromptManagerOptions {\r\n  configPath?: string;\r\n  basePath?: string;\r\n  autoDiscovery?: boolean;\r\n  defaultProfile?: string;\r\n}\r\n\r\nexport interface SyncOptions {\r\n  bidirectional?: boolean;\r\n  deleteOrphaned?: boolean;\r\n  compareHashes?: boolean;\r\n  incrementalOnly?: boolean;\r\n}\r\n\r\nexport interface ValidationReport {\r\n  totalFiles: number;\r\n  validFiles: number;\r\n  invalidFiles: number;\r\n  issues: Array<{\r\n    file: string;\r\n    issues: string[];\r\n    metadata?: any;\r\n  }>;\r\n}\r\n\r\nexport class PromptManager extends EventEmitter {\r\n  private configManager: PromptConfigManager;\r\n  private pathResolver: PromptPathResolver;\r\n  private options: Required<PromptManagerOptions>;\r\n\r\n  constructor(options: PromptManagerOptions = {}) {\r\n    super();\r\n\r\n    this.options = {\r\n      configPath: options.configPath || '.prompt-config.json',\r\n      basePath: options.basePath || process.cwd(),\r\n      autoDiscovery: options.autoDiscovery ?? true,\r\n      defaultProfile: options.defaultProfile || 'sparc',\r\n    };\r\n\r\n    this.configManager = new PromptConfigManager(\r\n      path.resolve(this.options.basePath, this.options.configPath),\r\n    );\r\n    this.pathResolver = new PromptPathResolver(this.options.basePath);\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    logger.info('Initializing PromptManager...');\r\n\r\n    // Load configuration\r\n    await this.configManager.loadConfig();\r\n\r\n    // Auto-discover prompt directories if enabled\r\n    if (this.options.autoDiscovery) {\r\n      const discovered = await this.pathResolver.discoverPromptDirectories();\r\n      if (discovered.length > 0) {\r\n        logger.info(`Auto-discovered ${discovered.length} prompt directories`);\r\n\r\n        // Update config with discovered directories\r\n        const config = this.configManager.getConfig();\r\n        const uniqueDirs = Array.from(\r\n          new Set([\r\n            ...config.sourceDirectories,\r\n            ...discovered.map((dir) => path.relative(this.options.basePath, dir)),\r\n          ]),\r\n        );\r\n\r\n        await this.configManager.saveConfig({\r\n          sourceDirectories: uniqueDirs,\r\n        });\r\n      }\r\n    }\r\n\r\n    this.emit('initialized');\r\n  }\r\n\r\n  async copyPrompts(options: Partial<CopyOptions> = {}): Promise<CopyResult> {\r\n    const config = this.configManager.getConfig();\r\n    const profile = this.options.defaultProfile;\r\n\r\n    // Resolve paths\r\n    const resolved = this.pathResolver.resolvePaths(\r\n      config.sourceDirectories,\r\n      config.destinationDirectory,\r\n    );\r\n\r\n    if (resolved.sources.length === 0) {\r\n      throw new Error('No valid source directories found');\r\n    }\r\n\r\n    // Build copy options\r\n    const copyOptions: CopyOptions = {\r\n      source: resolved.sources[0], // Use first available source\r\n      destination: resolved.destination,\r\n      ...this.configManager.getProfile(profile),\r\n      ...options,\r\n    };\r\n\r\n    logger.info('Starting prompt copy operation', {\r\n      source: copyOptions.source,\r\n      destination: copyOptions.destination,\r\n      profile,\r\n    });\r\n\r\n    this.emit('copyStart', copyOptions);\r\n\r\n    try {\r\n      const result = await (copyOptions.parallel\r\n        ? copyPromptsEnhanced(copyOptions)\r\n        : copyPrompts(copyOptions));\r\n\r\n      this.emit('copyComplete', result);\r\n      return result;\r\n    } catch (error) {\r\n      this.emit('copyError', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async copyFromMultipleSources(options: Partial<CopyOptions> = {}): Promise<CopyResult[]> {\r\n    const config = this.configManager.getConfig();\r\n    const resolved = this.pathResolver.resolvePaths(\r\n      config.sourceDirectories,\r\n      config.destinationDirectory,\r\n    );\r\n\r\n    const results: CopyResult[] = [];\r\n\r\n    for (const source of resolved.sources) {\r\n      try {\r\n        const copyOptions: CopyOptions = {\r\n          source,\r\n          destination: resolved.destination,\r\n          ...this.configManager.getProfile(this.options.defaultProfile),\r\n          ...options,\r\n        };\r\n\r\n        logger.info(`Copying from source: ${source}`);\r\n        const result = await copyPrompts(copyOptions);\r\n        results.push(result);\r\n\r\n        this.emit('sourceComplete', { source, result });\r\n      } catch (error) {\r\n        logger.error(`Failed to copy from ${source}:`, error);\r\n        this.emit('sourceError', { source, error });\r\n\r\n        // Add error result\r\n        results.push({\r\n          success: false,\r\n          totalFiles: 0,\r\n          copiedFiles: 0,\r\n          failedFiles: 0,\r\n          skippedFiles: 0,\r\n          errors: [\r\n            {\r\n              file: source,\r\n              error: error instanceof Error ? error.message : String(error),\r\n              phase: 'read',\r\n            },\r\n          ],\r\n          duration: 0,\r\n        });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  async validatePrompts(sourcePath?: string): Promise<ValidationReport> {\r\n    const config = this.configManager.getConfig();\r\n    const sources = sourcePath ? [sourcePath] : config.sourceDirectories;\r\n\r\n    const resolved = this.pathResolver.resolvePaths(sources, config.destinationDirectory);\r\n\r\n    let totalFiles = 0;\r\n    let validFiles = 0;\r\n    let invalidFiles = 0;\r\n    const issues: ValidationReport['issues'] = [];\r\n\r\n    for (const source of resolved.sources) {\r\n      await this.validateDirectory(source, issues);\r\n    }\r\n\r\n    totalFiles = issues.length;\r\n    validFiles = issues.filter((issue) => issue.issues.length === 0).length;\r\n    invalidFiles = totalFiles - validFiles;\r\n\r\n    const report: ValidationReport = {\r\n      totalFiles,\r\n      validFiles,\r\n      invalidFiles,\r\n      issues: issues.filter((issue) => issue.issues.length > 0), // Only include files with issues\r\n    };\r\n\r\n    this.emit('validationComplete', report);\r\n    return report;\r\n  }\r\n\r\n  private async validateDirectory(\r\n    dirPath: string,\r\n    issues: ValidationReport['issues'],\r\n  ): Promise<void> {\r\n    const fs = require('fs').promises;\r\n\r\n    try {\r\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dirPath, entry.name);\r\n\r\n        if (entry.isFile() && this.isPromptFile(entry.name)) {\r\n          const result = await PromptValidator.validatePromptFile(fullPath);\r\n\r\n          issues.push({\r\n            file: fullPath,\r\n            issues: result.issues,\r\n            metadata: result.metadata,\r\n          });\r\n        } else if (entry.isDirectory()) {\r\n          await this.validateDirectory(fullPath, issues);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error(`Failed to validate directory ${dirPath}:`, error);\r\n    }\r\n  }\r\n\r\n  private isPromptFile(fileName: string): boolean {\r\n    const config = this.configManager.getConfig();\r\n    const patterns = config.defaultOptions.includePatterns;\r\n\r\n    return patterns.some((pattern) => {\r\n      const regex = pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*');\r\n      return new RegExp(regex).test(fileName);\r\n    });\r\n  }\r\n\r\n  async syncPrompts(options: SyncOptions = {}): Promise<{\r\n    forward: CopyResult;\r\n    backward?: CopyResult;\r\n  }> {\r\n    const config = this.configManager.getConfig();\r\n    const resolved = this.pathResolver.resolvePaths(\r\n      config.sourceDirectories,\r\n      config.destinationDirectory,\r\n    );\r\n\r\n    const syncOptions: SyncOptions = {\r\n      bidirectional: false,\r\n      deleteOrphaned: false,\r\n      compareHashes: true,\r\n      incrementalOnly: true,\r\n      ...options,\r\n    };\r\n\r\n    // Forward sync (source to destination)\r\n    const forwardResult = await this.performIncrementalSync(\r\n      resolved.sources[0],\r\n      resolved.destination,\r\n      syncOptions,\r\n    );\r\n\r\n    let backwardResult: CopyResult | undefined;\r\n\r\n    // Backward sync if bidirectional\r\n    if (syncOptions.bidirectional) {\r\n      backwardResult = await this.performIncrementalSync(\r\n        resolved.destination,\r\n        resolved.sources[0],\r\n        syncOptions,\r\n      );\r\n    }\r\n\r\n    return {\r\n      forward: forwardResult,\r\n      backward: backwardResult,\r\n    };\r\n  }\r\n\r\n  private async performIncrementalSync(\r\n    source: string,\r\n    destination: string,\r\n    options: SyncOptions,\r\n  ): Promise<CopyResult> {\r\n    // This would implement incremental sync logic\r\n    // For now, we'll use the regular copy with overwrite\r\n    return copyPrompts({\r\n      source,\r\n      destination,\r\n      conflictResolution: 'overwrite',\r\n      verify: options.compareHashes,\r\n    });\r\n  }\r\n\r\n  async generateReport(): Promise<{\r\n    configuration: any;\r\n    sources: Array<{\r\n      path: string;\r\n      exists: boolean;\r\n      fileCount?: number;\r\n      totalSize?: number;\r\n    }>;\r\n    validation?: ValidationReport;\r\n    lastOperation?: {\r\n      type: string;\r\n      timestamp: Date;\r\n      result: any;\r\n    };\r\n  }> {\r\n    const config = this.configManager.getConfig();\r\n    const resolved = this.pathResolver.resolvePaths(\r\n      config.sourceDirectories,\r\n      config.destinationDirectory,\r\n    );\r\n\r\n    // Analyze sources\r\n    const sources = await Promise.all(\r\n      resolved.sources.map(async (sourcePath) => {\r\n        try {\r\n          const fs = require('fs').promises;\r\n          const stats = await fs.stat(sourcePath);\r\n\r\n          if (!stats.isDirectory()) {\r\n            return { path: sourcePath, exists: false };\r\n          }\r\n\r\n          // Count files and calculate total size\r\n          let fileCount = 0;\r\n          let totalSize = 0;\r\n\r\n          const scanDir = async (dir: string) => {\r\n            const entries = await fs.readdir(dir, { withFileTypes: true });\r\n\r\n            for (const entry of entries) {\r\n              const fullPath = path.join(dir, entry.name);\r\n\r\n              if (entry.isFile() && this.isPromptFile(entry.name)) {\r\n                const fileStats = await fs.stat(fullPath);\r\n                fileCount++;\r\n                totalSize += fileStats.size;\r\n              } else if (entry.isDirectory()) {\r\n                await scanDir(fullPath);\r\n              }\r\n            }\r\n          };\r\n\r\n          await scanDir(sourcePath);\r\n\r\n          return {\r\n            path: sourcePath,\r\n            exists: true,\r\n            fileCount,\r\n            totalSize,\r\n          };\r\n        } catch {\r\n          return { path: sourcePath, exists: false };\r\n        }\r\n      }),\r\n    );\r\n\r\n    return {\r\n      configuration: config,\r\n      sources,\r\n    };\r\n  }\r\n\r\n  // Utility methods\r\n  getConfig() {\r\n    return this.configManager.getConfig();\r\n  }\r\n\r\n  async updateConfig(updates: any): Promise<void> {\r\n    await this.configManager.saveConfig(updates);\r\n  }\r\n\r\n  getProfiles(): string[] {\r\n    return this.configManager.listProfiles();\r\n  }\r\n\r\n  getProfile(name: string) {\r\n    return this.configManager.getProfile(name);\r\n  }\r\n\r\n  async discoverPromptDirectories(): Promise<string[]> {\r\n    return this.pathResolver.discoverPromptDirectories();\r\n  }\r\n}\r\n\r\n// Export factory function\r\nexport function createPromptManager(options?: PromptManagerOptions): PromptManager {\r\n  return new PromptManager(options);\r\n}\r\n\r\n// Export singleton instance\r\nlet defaultManager: PromptManager | null = null;\r\n\r\nexport function getDefaultPromptManager(): PromptManager {\r\n  if (!defaultManager) {\r\n    defaultManager = new PromptManager();\r\n  }\r\n  return defaultManager;\r\n}\r\n"],"names":["path","EventEmitter","copyPromptsEnhanced","PromptConfigManager","PromptPathResolver","PromptValidator","logger","PromptManager","configManager","pathResolver","options","configPath","basePath","process","cwd","autoDiscovery","defaultProfile","resolve","initialize","info","loadConfig","discovered","discoverPromptDirectories","length","config","getConfig","uniqueDirs","Array","from","Set","sourceDirectories","map","dir","relative","saveConfig","emit","copyPrompts","profile","resolved","resolvePaths","destinationDirectory","sources","Error","copyOptions","source","destination","getProfile","result","parallel","error","copyFromMultipleSources","results","push","success","totalFiles","copiedFiles","failedFiles","skippedFiles","errors","file","message","String","phase","duration","validatePrompts","sourcePath","validFiles","invalidFiles","issues","validateDirectory","filter","issue","report","dirPath","fs","require","promises","entries","readdir","withFileTypes","entry","fullPath","join","name","isFile","isPromptFile","validatePromptFile","metadata","isDirectory","fileName","patterns","defaultOptions","includePatterns","some","pattern","regex","replace","RegExp","test","syncPrompts","syncOptions","bidirectional","deleteOrphaned","compareHashes","incrementalOnly","forwardResult","performIncrementalSync","backwardResult","forward","backward","conflictResolution","verify","generateReport","Promise","all","stats","stat","exists","fileCount","totalSize","scanDir","fileStats","size","configuration","updateConfig","updates","getProfiles","listProfiles","createPromptManager","defaultManager","getDefaultPromptManager"],"mappings":"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"}