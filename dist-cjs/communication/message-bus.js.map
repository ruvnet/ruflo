{
  "version": 3,
  "sources": ["../../src/communication/message-bus.ts"],
  "sourcesContent": ["/**\n * Advanced messaging and communication layer for swarm coordination\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { SwarmEvent, EventType, AgentId, CommunicationStrategy } from '../swarm/types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface MessageBusConfig {\n  strategy: CommunicationStrategy;\n  enablePersistence: boolean;\n  enableReliability: boolean;\n  enableOrdering: boolean;\n  enableFiltering: boolean;\n  maxMessageSize: number;\n  maxQueueSize: number;\n  messageRetention: number;\n  acknowledgmentTimeout: number;\n  retryAttempts: number;\n  backoffMultiplier: number;\n  compressionEnabled: boolean;\n  encryptionEnabled: boolean;\n  metricsEnabled: boolean;\n  debugMode: boolean;\n}\n\nexport interface Message {\n  id: string;\n  type: string;\n  sender: AgentId;\n  receivers: AgentId[];\n  content: any;\n  metadata: MessageMetadata;\n  timestamp: Date;\n  expiresAt?: Date;\n  priority: MessagePriority;\n  reliability: ReliabilityLevel;\n}\n\nexport interface MessageMetadata {\n  correlationId?: string;\n  causationId?: string;\n  replyTo?: string;\n  ttl?: number;\n  compressed: boolean;\n  encrypted: boolean;\n  size: number;\n  contentType: string;\n  encoding: string;\n  checksum?: string;\n  route?: string[];\n  deadLetterReason?: string;\n  deadLetterTimestamp?: Date;\n}\n\nexport interface MessageChannel {\n  id: string;\n  name: string;\n  type: ChannelType;\n  participants: AgentId[];\n  config: ChannelConfig;\n  statistics: ChannelStatistics;\n  filters: MessageFilter[];\n  middleware: ChannelMiddleware[];\n}\n\nexport interface ChannelConfig {\n  persistent: boolean;\n  ordered: boolean;\n  reliable: boolean;\n  maxParticipants: number;\n  maxMessageSize: number;\n  maxQueueDepth: number;\n  retentionPeriod: number;\n  accessControl: AccessControlConfig;\n}\n\nexport interface AccessControlConfig {\n  readPermission: 'public' | 'participants' | 'restricted';\n  writePermission: 'public' | 'participants' | 'restricted';\n  adminPermission: 'creator' | 'administrators' | 'system';\n  allowedSenders: AgentId[];\n  allowedReceivers: AgentId[];\n  bannedAgents: AgentId[];\n}\n\nexport interface ChannelStatistics {\n  messagesTotal: number;\n  messagesDelivered: number;\n  messagesFailed: number;\n  bytesTransferred: number;\n  averageLatency: number;\n  throughput: number;\n  errorRate: number;\n  participantCount: number;\n  lastActivity: Date;\n}\n\nexport interface MessageFilter {\n  id: string;\n  name: string;\n  enabled: boolean;\n  conditions: FilterCondition[];\n  action: 'allow' | 'deny' | 'modify' | 'route';\n  priority: number;\n}\n\nexport interface FilterCondition {\n  field: string;\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches' | 'in';\n  value: any;\n  caseSensitive?: boolean;\n}\n\nexport interface ChannelMiddleware {\n  id: string;\n  name: string;\n  enabled: boolean;\n  order: number;\n  process: (message: Message, context: MiddlewareContext) => Promise<Message | null>;\n}\n\nexport interface MiddlewareContext {\n  channel: MessageChannel;\n  direction: 'inbound' | 'outbound';\n  agent: AgentId;\n  metadata: Record<string, any>;\n}\n\nexport interface MessageQueue {\n  id: string;\n  name: string;\n  type: QueueType;\n  messages: Message[];\n  config: QueueConfig;\n  subscribers: QueueSubscriber[];\n  statistics: QueueStatistics;\n}\n\nexport interface QueueConfig {\n  maxSize: number;\n  persistent: boolean;\n  ordered: boolean;\n  durability: 'memory' | 'disk' | 'distributed';\n  deliveryMode: 'at-most-once' | 'at-least-once' | 'exactly-once';\n  deadLetterQueue?: string;\n  retryPolicy: RetryPolicy;\n}\n\nexport interface QueueSubscriber {\n  id: string;\n  agent: AgentId;\n  filter?: MessageFilter;\n  ackMode: 'auto' | 'manual';\n  prefetchCount: number;\n  lastActivity: Date;\n}\n\nexport interface QueueStatistics {\n  depth: number;\n  enqueueRate: number;\n  dequeueRate: number;\n  throughput: number;\n  averageWaitTime: number;\n  subscriberCount: number;\n  deadLetterCount: number;\n}\n\nexport interface RetryPolicy {\n  maxAttempts: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n}\n\nexport interface TopicSubscription {\n  id: string;\n  topic: string;\n  subscriber: AgentId;\n  filter?: MessageFilter;\n  ackRequired: boolean;\n  qos: QualityOfService;\n  createdAt: Date;\n  lastMessage?: Date;\n}\n\nexport interface RoutingRule {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number;\n  conditions: FilterCondition[];\n  actions: RoutingAction[];\n}\n\nexport interface RoutingAction {\n  type: 'forward' | 'duplicate' | 'transform' | 'aggregate' | 'delay';\n  target?: string;\n  config: Record<string, any>;\n}\n\nexport type MessagePriority = 'low' | 'normal' | 'high' | 'critical';\nexport type ReliabilityLevel = 'best-effort' | 'at-least-once' | 'exactly-once';\nexport type ChannelType = 'direct' | 'broadcast' | 'multicast' | 'topic' | 'queue';\nexport type QueueType = 'fifo' | 'lifo' | 'priority' | 'delay' | 'round-robin';\nexport type QualityOfService = 0 | 1 | 2; // MQTT-style QoS levels\n\n/**\n * Advanced message bus with support for multiple communication patterns\n */\nexport class MessageBus extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: MessageBusConfig;\n\n  // Core messaging components\n  private channels = new Map<string, MessageChannel>();\n  private queues = new Map<string, MessageQueue>();\n  private subscriptions = new Map<string, TopicSubscription>();\n  private routingRules = new Map<string, RoutingRule>();\n\n  // Message tracking\n  private messageStore = new Map<string, Message>();\n  private deliveryReceipts = new Map<string, DeliveryReceipt>();\n  private acknowledgments = new Map<string, MessageAcknowledgment>();\n\n  // Routing and delivery\n  private router: MessageRouter;\n  private deliveryManager: DeliveryManager;\n  private retryManager: RetryManager;\n\n  // Performance monitoring\n  private metrics: MessageBusMetrics;\n  private metricsInterval?: NodeJS.Timeout;\n\n  constructor(config: Partial<MessageBusConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      strategy: 'event-driven',\n      enablePersistence: true,\n      enableReliability: true,\n      enableOrdering: false,\n      enableFiltering: true,\n      maxMessageSize: 1024 * 1024, // 1MB\n      maxQueueSize: 10000,\n      messageRetention: 86400000, // 24 hours\n      acknowledgmentTimeout: 30000,\n      retryAttempts: 3,\n      backoffMultiplier: 2,\n      compressionEnabled: false,\n      encryptionEnabled: false,\n      metricsEnabled: true,\n      debugMode: false,\n      ...config,\n    };\n\n    this.router = new MessageRouter(this.config, this.logger);\n    this.deliveryManager = new DeliveryManager(this.config, this.logger);\n    this.retryManager = new RetryManager(this.config, this.logger);\n    this.metrics = new MessageBusMetrics();\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('agent:connected', (data) => {\n      if (hasAgentId(data)) {\n        this.handleAgentConnected(data.agentId);\n      }\n    });\n\n    this.eventBus.on('agent:disconnected', (data) => {\n      if (hasAgentId(data)) {\n        this.handleAgentDisconnected(data.agentId);\n      }\n    });\n\n    this.deliveryManager.on('delivery:success', (data) => {\n      this.handleDeliverySuccess(data);\n    });\n\n    this.deliveryManager.on('delivery:failure', (data) => {\n      this.handleDeliveryFailure(data);\n    });\n\n    this.retryManager.on('retry:exhausted', (data) => {\n      this.handleRetryExhausted(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing message bus', {\n      strategy: this.config.strategy,\n      persistence: this.config.enablePersistence,\n      reliability: this.config.enableReliability,\n    });\n\n    // Initialize components\n    await this.router.initialize();\n    await this.deliveryManager.initialize();\n    await this.retryManager.initialize();\n\n    // Create default channels\n    await this.createDefaultChannels();\n\n    // Start metrics collection\n    if (this.config.metricsEnabled) {\n      this.startMetricsCollection();\n    }\n\n    this.emit('messagebus:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down message bus');\n\n    // Stop metrics collection\n    if (this.metricsInterval) {\n      clearInterval(this.metricsInterval);\n    }\n\n    // Shutdown components\n    await this.retryManager.shutdown();\n    await this.deliveryManager.shutdown();\n    await this.router.shutdown();\n\n    // Persist any remaining messages if enabled\n    if (this.config.enablePersistence) {\n      await this.persistMessages();\n    }\n\n    this.emit('messagebus:shutdown');\n  }\n\n  // === MESSAGE OPERATIONS ===\n\n  async sendMessage(\n    type: string,\n    content: any,\n    sender: AgentId,\n    receivers: AgentId | AgentId[],\n    options: {\n      priority?: MessagePriority;\n      reliability?: ReliabilityLevel;\n      ttl?: number;\n      correlationId?: string;\n      replyTo?: string;\n      channel?: string;\n    } = {},\n  ): Promise<string> {\n    const messageId = generateId('msg');\n    const now = new Date();\n\n    const receiversArray = Array.isArray(receivers) ? receivers : [receivers];\n\n    const message: Message = {\n      id: messageId,\n      type,\n      sender,\n      receivers: receiversArray,\n      content: await this.processContent(content),\n      metadata: {\n        correlationId: options.correlationId,\n        replyTo: options.replyTo,\n        ttl: options.ttl,\n        compressed: this.config.compressionEnabled,\n        encrypted: this.config.encryptionEnabled,\n        size: this.calculateSize(content),\n        contentType: this.detectContentType(content),\n        encoding: 'utf-8',\n        route: [sender.id],\n      },\n      timestamp: now,\n      expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n      priority: options.priority || 'normal',\n      reliability: options.reliability || 'best-effort',\n    };\n\n    // Validate message\n    this.validateMessage(message);\n\n    // Store message if persistence is enabled\n    if (this.config.enablePersistence) {\n      this.messageStore.set(messageId, message);\n    }\n\n    // Route and deliver message\n    await this.routeMessage(message, options.channel);\n\n    this.metrics.recordMessageSent(message);\n\n    this.logger.debug('Message sent', {\n      messageId,\n      type,\n      sender: sender.id,\n      receivers: receiversArray.map((r) => r.id),\n      size: message.metadata.size,\n    });\n\n    this.emit('message:sent', { message });\n\n    return messageId;\n  }\n\n  async broadcastMessage(\n    type: string,\n    content: any,\n    sender: AgentId,\n    options: {\n      channel?: string;\n      filter?: MessageFilter;\n      priority?: MessagePriority;\n      ttl?: number;\n    } = {},\n  ): Promise<string> {\n    const channel = options.channel\n      ? this.channels.get(options.channel)\n      : this.getDefaultBroadcastChannel();\n\n    if (!channel) {\n      throw new Error('No broadcast channel available');\n    }\n\n    // Get all participants as receivers\n    let receivers = channel.participants.filter((p) => p.id !== sender.id);\n\n    // Apply filter if provided\n    if (options.filter) {\n      receivers = await this.filterReceivers(receivers, options.filter, { type, content });\n    }\n\n    return this.sendMessage(type, content, sender, receivers, {\n      priority: options.priority,\n      ttl: options.ttl,\n      channel: channel.id,\n    });\n  }\n\n  async subscribeToTopic(\n    topic: string,\n    subscriber: AgentId,\n    options: {\n      filter?: MessageFilter;\n      qos?: QualityOfService;\n      ackRequired?: boolean;\n    } = {},\n  ): Promise<string> {\n    const subscriptionId = generateId('sub');\n\n    const subscription: TopicSubscription = {\n      id: subscriptionId,\n      topic,\n      subscriber,\n      filter: options.filter,\n      ackRequired: options.ackRequired || false,\n      qos: options.qos || 0,\n      createdAt: new Date(),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    this.logger.info('Topic subscription created', {\n      subscriptionId,\n      topic,\n      subscriber: subscriber.id,\n      qos: subscription.qos,\n    });\n\n    this.emit('subscription:created', { subscription });\n\n    return subscriptionId;\n  }\n\n  async unsubscribeFromTopic(subscriptionId: string): Promise<void> {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) {\n      throw new Error(`Subscription ${subscriptionId} not found`);\n    }\n\n    this.subscriptions.delete(subscriptionId);\n\n    this.logger.info('Topic subscription removed', {\n      subscriptionId,\n      topic: subscription.topic,\n      subscriber: subscription.subscriber.id,\n    });\n\n    this.emit('subscription:removed', { subscription });\n  }\n\n  async acknowledgeMessage(messageId: string, agentId: AgentId): Promise<void> {\n    const message = this.messageStore.get(messageId);\n    if (!message) {\n      throw new Error(`Message ${messageId} not found`);\n    }\n\n    const ack: MessageAcknowledgment = {\n      messageId,\n      agentId,\n      timestamp: new Date(),\n      status: 'acknowledged',\n    };\n\n    this.acknowledgments.set(`${messageId}:${agentId.id}`, ack);\n\n    this.logger.debug('Message acknowledged', {\n      messageId,\n      agentId: agentId.id,\n    });\n\n    this.emit('message:acknowledged', { messageId, agentId });\n\n    // Check if all receivers have acknowledged\n    this.checkAllAcknowledgments(message);\n  }\n\n  // === CHANNEL MANAGEMENT ===\n\n  async createChannel(\n    name: string,\n    type: ChannelType,\n    config: Partial<ChannelConfig> = {},\n  ): Promise<string> {\n    const channelId = generateId('channel');\n\n    const channel: MessageChannel = {\n      id: channelId,\n      name,\n      type,\n      participants: [],\n      config: {\n        persistent: true,\n        ordered: false,\n        reliable: true,\n        maxParticipants: 1000,\n        maxMessageSize: this.config.maxMessageSize,\n        maxQueueDepth: this.config.maxQueueSize,\n        retentionPeriod: this.config.messageRetention,\n        accessControl: {\n          readPermission: 'participants',\n          writePermission: 'participants',\n          adminPermission: 'creator',\n          allowedSenders: [],\n          allowedReceivers: [],\n          bannedAgents: [],\n        },\n        ...config,\n      },\n      statistics: this.createChannelStatistics(),\n      filters: [],\n      middleware: [],\n    };\n\n    this.channels.set(channelId, channel);\n\n    this.logger.info('Channel created', {\n      channelId,\n      name,\n      type,\n      config: channel.config,\n    });\n\n    this.emit('channel:created', { channel });\n\n    return channelId;\n  }\n\n  async joinChannel(channelId: string, agentId: AgentId): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    // Check access permissions\n    if (!this.canJoinChannel(channel, agentId)) {\n      throw new Error(`Agent ${agentId.id} not allowed to join channel ${channelId}`);\n    }\n\n    // Check capacity\n    if (channel.participants.length >= channel.config.maxParticipants) {\n      throw new Error(`Channel ${channelId} is at capacity`);\n    }\n\n    // Add participant if not already present\n    if (!channel.participants.some((p) => p.id === agentId.id)) {\n      channel.participants.push(agentId);\n      channel.statistics.participantCount = channel.participants.length;\n    }\n\n    this.logger.info('Agent joined channel', {\n      channelId,\n      agentId: agentId.id,\n      participantCount: channel.participants.length,\n    });\n\n    this.emit('channel:joined', { channelId, agentId });\n  }\n\n  async leaveChannel(channelId: string, agentId: AgentId): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    // Remove participant\n    channel.participants = channel.participants.filter((p) => p.id !== agentId.id);\n    channel.statistics.participantCount = channel.participants.length;\n\n    this.logger.info('Agent left channel', {\n      channelId,\n      agentId: agentId.id,\n      participantCount: channel.participants.length,\n    });\n\n    this.emit('channel:left', { channelId, agentId });\n  }\n\n  // === QUEUE MANAGEMENT ===\n\n  async createQueue(\n    name: string,\n    type: QueueType,\n    config: Partial<QueueConfig> = {},\n  ): Promise<string> {\n    const queueId = generateId('queue');\n\n    const queue: MessageQueue = {\n      id: queueId,\n      name,\n      type,\n      messages: [],\n      config: {\n        maxSize: this.config.maxQueueSize,\n        persistent: this.config.enablePersistence,\n        ordered: this.config.enableOrdering,\n        durability: 'memory',\n        deliveryMode: 'at-least-once',\n        retryPolicy: {\n          maxAttempts: this.config.retryAttempts,\n          initialDelay: 1000,\n          maxDelay: 30000,\n          backoffMultiplier: this.config.backoffMultiplier,\n          jitter: true,\n        },\n        ...config,\n      },\n      subscribers: [],\n      statistics: this.createQueueStatistics(),\n    };\n\n    this.queues.set(queueId, queue);\n\n    this.logger.info('Queue created', {\n      queueId,\n      name,\n      type,\n      config: queue.config,\n    });\n\n    this.emit('queue:created', { queue });\n\n    return queueId;\n  }\n\n  async enqueueMessage(queueId: string, message: Message): Promise<void> {\n    const queue = this.queues.get(queueId);\n    if (!queue) {\n      throw new Error(`Queue ${queueId} not found`);\n    }\n\n    // Check queue capacity\n    if (queue.messages.length >= queue.config.maxSize) {\n      if (queue.config.deadLetterQueue) {\n        await this.sendToDeadLetterQueue(queue.config.deadLetterQueue, message, 'queue_full');\n        return;\n      } else {\n        throw new Error(`Queue ${queueId} is full`);\n      }\n    }\n\n    // Insert message based on queue type\n    this.insertMessageInQueue(queue, message);\n\n    queue.statistics.depth = queue.messages.length;\n    queue.statistics.enqueueRate++;\n\n    this.logger.debug('Message enqueued', {\n      queueId,\n      messageId: message.id,\n      queueDepth: queue.messages.length,\n    });\n\n    this.emit('message:enqueued', { queueId, message });\n\n    // Process queue for delivery\n    await this.processQueue(queue);\n  }\n\n  async dequeueMessage(queueId: string, subscriberId: string): Promise<Message | null> {\n    const queue = this.queues.get(queueId);\n    if (!queue) {\n      throw new Error(`Queue ${queueId} not found`);\n    }\n\n    const subscriber = queue.subscribers.find((s) => s.id === subscriberId);\n    if (!subscriber) {\n      throw new Error(`Subscriber ${subscriberId} not found in queue ${queueId}`);\n    }\n\n    // Find next eligible message\n    let message: Message | null = null;\n    let messageIndex = -1;\n\n    for (let i = 0; i < queue.messages.length; i++) {\n      const msg = queue.messages[i];\n\n      // Check if message matches subscriber filter\n      if (subscriber.filter && !this.matchesFilter(msg, subscriber.filter)) {\n        continue;\n      }\n\n      message = msg;\n      messageIndex = i;\n      break;\n    }\n\n    if (!message) {\n      return null;\n    }\n\n    // Remove message from queue (for at-least-once, remove after ack)\n    if (queue.config.deliveryMode === 'at-most-once') {\n      queue.messages.splice(messageIndex, 1);\n    }\n\n    queue.statistics.depth = queue.messages.length;\n    queue.statistics.dequeueRate++;\n    subscriber.lastActivity = new Date();\n\n    this.logger.debug('Message dequeued', {\n      queueId,\n      messageId: message.id,\n      subscriberId,\n      queueDepth: queue.messages.length,\n    });\n\n    this.emit('message:dequeued', { queueId, message, subscriberId });\n\n    return message;\n  }\n\n  // === ROUTING AND DELIVERY ===\n\n  private async routeMessage(message: Message, preferredChannel?: string): Promise<void> {\n    // Apply routing rules\n    const route = await this.router.calculateRoute(message, preferredChannel);\n\n    // Update message route\n    message.metadata.route = [...(message.metadata.route || []), ...route.hops];\n\n    // Deliver to targets\n    for (const target of route.targets) {\n      await this.deliverMessage(message, target);\n    }\n  }\n\n  private async deliverMessage(message: Message, target: DeliveryTarget): Promise<void> {\n    try {\n      await this.deliveryManager.deliver(message, target);\n      this.metrics.recordDeliverySuccess(message);\n    } catch (error) {\n      this.metrics.recordDeliveryFailure(message);\n\n      // Handle delivery failure based on reliability level\n      if (message.reliability !== 'best-effort') {\n        await this.retryManager.scheduleRetry(message, target, error);\n      }\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private validateMessage(message: Message): void {\n    if (message.metadata.size > this.config.maxMessageSize) {\n      throw new Error(\n        `Message size ${message.metadata.size} exceeds limit ${this.config.maxMessageSize}`,\n      );\n    }\n\n    if (message.expiresAt && message.expiresAt <= new Date()) {\n      throw new Error('Message has already expired');\n    }\n\n    if (message.receivers.length === 0) {\n      throw new Error('Message must have at least one receiver');\n    }\n  }\n\n  private async processContent(content: any): Promise<any> {\n    let processed = content;\n\n    // Compress if enabled\n    if (this.config.compressionEnabled) {\n      processed = await this.compress(processed);\n    }\n\n    // Encrypt if enabled\n    if (this.config.encryptionEnabled) {\n      processed = await this.encrypt(processed);\n    }\n\n    return processed;\n  }\n\n  private calculateSize(content: any): number {\n    return JSON.stringify(content).length;\n  }\n\n  private detectContentType(content: any): string {\n    if (typeof content === 'string') return 'text/plain';\n    if (typeof content === 'object') return 'application/json';\n    if (Buffer.isBuffer(content)) return 'application/octet-stream';\n    return 'application/unknown';\n  }\n\n  private async filterReceivers(\n    receivers: AgentId[],\n    filter: MessageFilter,\n    context: any,\n  ): Promise<AgentId[]> {\n    // Placeholder for receiver filtering logic\n    return receivers;\n  }\n\n  private canJoinChannel(channel: MessageChannel, agentId: AgentId): boolean {\n    const acl = channel.config.accessControl;\n\n    // Check banned list\n    if (acl.bannedAgents.some((banned) => banned.id === agentId.id)) {\n      return false;\n    }\n\n    // Check allowed list (if specified)\n    if (acl.allowedSenders.length > 0) {\n      return acl.allowedSenders.some((allowed) => allowed.id === agentId.id);\n    }\n\n    return true;\n  }\n\n  private matchesFilter(message: Message, filter: MessageFilter): boolean {\n    return filter.conditions.every((condition) => {\n      const fieldValue = this.getFieldValue(message, condition.field);\n      return this.evaluateCondition(fieldValue, condition.operator, condition.value);\n    });\n  }\n\n  private getFieldValue(message: Message, field: string): any {\n    const parts = field.split('.');\n    let value: any = message;\n\n    for (const part of parts) {\n      value = value?.[part];\n    }\n\n    return value;\n  }\n\n  private evaluateCondition(fieldValue: any, operator: string, compareValue: any): boolean {\n    switch (operator) {\n      case 'eq':\n        return fieldValue === compareValue;\n      case 'ne':\n        return fieldValue !== compareValue;\n      case 'gt':\n        return fieldValue > compareValue;\n      case 'lt':\n        return fieldValue < compareValue;\n      case 'contains':\n        return String(fieldValue).includes(String(compareValue));\n      case 'matches':\n        return new RegExp(compareValue).test(String(fieldValue));\n      case 'in':\n        return Array.isArray(compareValue) && compareValue.includes(fieldValue);\n      default:\n        return false;\n    }\n  }\n\n  private insertMessageInQueue(queue: MessageQueue, message: Message): void {\n    switch (queue.type) {\n      case 'fifo':\n        queue.messages.push(message);\n        break;\n      case 'lifo':\n        queue.messages.unshift(message);\n        break;\n      case 'priority':\n        this.insertByPriority(queue.messages, message);\n        break;\n      case 'delay':\n        this.insertByTimestamp(queue.messages, message);\n        break;\n      default:\n        queue.messages.push(message);\n    }\n  }\n\n  private insertByPriority(messages: Message[], message: Message): void {\n    const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };\n    const messagePriority = priorityOrder[message.priority];\n\n    let insertIndex = messages.length;\n    for (let i = 0; i < messages.length; i++) {\n      const currentPriority = priorityOrder[messages[i].priority];\n      if (messagePriority < currentPriority) {\n        insertIndex = i;\n        break;\n      }\n    }\n\n    messages.splice(insertIndex, 0, message);\n  }\n\n  private insertByTimestamp(messages: Message[], message: Message): void {\n    const targetTime = message.expiresAt || message.timestamp;\n\n    let insertIndex = messages.length;\n    for (let i = 0; i < messages.length; i++) {\n      const currentTime = messages[i].expiresAt || messages[i].timestamp;\n      if (targetTime <= currentTime) {\n        insertIndex = i;\n        break;\n      }\n    }\n\n    messages.splice(insertIndex, 0, message);\n  }\n\n  private async processQueue(queue: MessageQueue): Promise<void> {\n    // Process messages for subscribers\n    for (const subscriber of queue.subscribers) {\n      if (subscriber.prefetchCount > 0) {\n        // Deliver up to prefetch count\n        for (let i = 0; i < subscriber.prefetchCount; i++) {\n          const message = await this.dequeueMessage(queue.id, subscriber.id);\n          if (!message) break;\n\n          await this.deliverMessageToSubscriber(message, subscriber);\n        }\n      }\n    }\n  }\n\n  private async deliverMessageToSubscriber(\n    message: Message,\n    subscriber: QueueSubscriber,\n  ): Promise<void> {\n    try {\n      // Deliver message to subscriber\n      this.emit('message:delivered', {\n        message,\n        subscriber: subscriber.agent,\n      });\n\n      // Handle acknowledgment if required\n      if (subscriber.ackMode === 'auto') {\n        await this.acknowledgeMessage(message.id, subscriber.agent);\n      }\n    } catch (error) {\n      this.logger.error('Failed to deliver message to subscriber', {\n        messageId: message.id,\n        subscriberId: subscriber.id,\n        error,\n      });\n    }\n  }\n\n  private checkAllAcknowledgments(message: Message): void {\n    const requiredAcks = message.receivers.length;\n    const receivedAcks = message.receivers.filter((receiver) =>\n      this.acknowledgments.has(`${message.id}:${receiver.id}`),\n    ).length;\n\n    if (receivedAcks === requiredAcks) {\n      this.emit('message:fully-acknowledged', { message });\n\n      // Clean up acknowledgments\n      message.receivers.forEach((receiver) => {\n        this.acknowledgments.delete(`${message.id}:${receiver.id}`);\n      });\n    }\n  }\n\n  private async createDefaultChannels(): Promise<void> {\n    // System broadcast channel\n    await this.createChannel('system-broadcast', 'broadcast', {\n      persistent: true,\n      reliable: true,\n      maxParticipants: 10000,\n    });\n\n    // Agent coordination channel\n    await this.createChannel('agent-coordination', 'multicast', {\n      persistent: true,\n      reliable: true,\n      ordered: true,\n    });\n\n    // Task distribution channel\n    await this.createChannel('task-distribution', 'topic', {\n      persistent: true,\n      reliable: false,\n    });\n  }\n\n  private getDefaultBroadcastChannel(): MessageChannel | undefined {\n    return Array.from(this.channels.values()).find((channel) => channel.type === 'broadcast');\n  }\n\n  private createChannelStatistics(): ChannelStatistics {\n    return {\n      messagesTotal: 0,\n      messagesDelivered: 0,\n      messagesFailed: 0,\n      bytesTransferred: 0,\n      averageLatency: 0,\n      throughput: 0,\n      errorRate: 0,\n      participantCount: 0,\n      lastActivity: new Date(),\n    };\n  }\n\n  private createQueueStatistics(): QueueStatistics {\n    return {\n      depth: 0,\n      enqueueRate: 0,\n      dequeueRate: 0,\n      throughput: 0,\n      averageWaitTime: 0,\n      subscriberCount: 0,\n      deadLetterCount: 0,\n    };\n  }\n\n  private startMetricsCollection(): void {\n    this.metricsInterval = setInterval(() => {\n      this.updateMetrics();\n    }, 10000); // Every 10 seconds\n  }\n\n  private updateMetrics(): void {\n    // Update channel statistics\n    for (const channel of this.channels.values()) {\n      // Calculate throughput, latency, etc.\n      this.updateChannelStatistics(channel);\n    }\n\n    // Update queue statistics\n    for (const queue of this.queues.values()) {\n      this.updateQueueStatistics(queue);\n    }\n\n    // Emit metrics event\n    this.emit('metrics:updated', { metrics: this.getMetrics() });\n  }\n\n  private updateChannelStatistics(channel: MessageChannel): void {\n    // Placeholder for channel statistics calculation\n    channel.statistics.lastActivity = new Date();\n  }\n\n  private updateQueueStatistics(queue: MessageQueue): void {\n    // Placeholder for queue statistics calculation\n    queue.statistics.depth = queue.messages.length;\n  }\n\n  private handleAgentConnected(agentId: AgentId): void {\n    this.logger.info('Agent connected to message bus', { agentId: agentId.id });\n    this.emit('agent:connected', { agentId });\n  }\n\n  private handleAgentDisconnected(agentId: AgentId): void {\n    this.logger.info('Agent disconnected from message bus', { agentId: agentId.id });\n\n    // Remove from all channels\n    for (const channel of this.channels.values()) {\n      channel.participants = channel.participants.filter((p) => p.id !== agentId.id);\n    }\n\n    // Remove subscriptions\n    for (const [subId, subscription] of this.subscriptions) {\n      if (subscription.subscriber.id === agentId.id) {\n        this.subscriptions.delete(subId);\n      }\n    }\n\n    this.emit('agent:disconnected', { agentId });\n  }\n\n  private handleDeliverySuccess(data: any): void {\n    this.metrics.recordDeliverySuccess(data.message);\n  }\n\n  private handleDeliveryFailure(data: any): void {\n    this.metrics.recordDeliveryFailure(data.message);\n  }\n\n  private handleRetryExhausted(data: any): void {\n    this.logger.error('Message delivery retry exhausted', {\n      messageId: data.message.id,\n      target: data.target,\n    });\n\n    // Send to dead letter queue if configured\n    this.sendToDeadLetterQueue('system-dlq', data.message, 'retry_exhausted');\n  }\n\n  private async sendToDeadLetterQueue(\n    queueId: string,\n    message: Message,\n    reason: string,\n  ): Promise<void> {\n    try {\n      message.metadata.deadLetterReason = reason;\n      message.metadata.deadLetterTimestamp = new Date();\n\n      await this.enqueueMessage(queueId, message);\n    } catch (error) {\n      this.logger.error('Failed to send message to dead letter queue', {\n        messageId: message.id,\n        queueId,\n        reason,\n        error,\n      });\n    }\n  }\n\n  private async compress(content: any): Promise<any> {\n    // Placeholder for compression\n    return content;\n  }\n\n  private async encrypt(content: any): Promise<any> {\n    // Placeholder for encryption\n    return content;\n  }\n\n  private async persistMessages(): Promise<void> {\n    // Placeholder for message persistence\n    this.logger.info('Persisting messages', { count: this.messageStore.size });\n  }\n\n  // === PUBLIC API ===\n\n  getChannel(channelId: string): MessageChannel | undefined {\n    return this.channels.get(channelId);\n  }\n\n  getAllChannels(): MessageChannel[] {\n    return Array.from(this.channels.values());\n  }\n\n  getQueue(queueId: string): MessageQueue | undefined {\n    return this.queues.get(queueId);\n  }\n\n  getAllQueues(): MessageQueue[] {\n    return Array.from(this.queues.values());\n  }\n\n  getSubscription(subscriptionId: string): TopicSubscription | undefined {\n    return this.subscriptions.get(subscriptionId);\n  }\n\n  getAllSubscriptions(): TopicSubscription[] {\n    return Array.from(this.subscriptions.values());\n  }\n\n  getMetrics(): any {\n    return {\n      channels: this.channels.size,\n      queues: this.queues.size,\n      subscriptions: this.subscriptions.size,\n      storedMessages: this.messageStore.size,\n      deliveryReceipts: this.deliveryReceipts.size,\n      acknowledgments: this.acknowledgments.size,\n      busMetrics: this.metrics.getMetrics(),\n    };\n  }\n\n  getMessage(messageId: string): Message | undefined {\n    return this.messageStore.get(messageId);\n  }\n\n  async addChannelFilter(channelId: string, filter: MessageFilter): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    channel.filters.push(filter);\n    channel.filters.sort((a, b) => a.priority - b.priority);\n  }\n\n  async addChannelMiddleware(channelId: string, middleware: ChannelMiddleware): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    channel.middleware.push(middleware);\n    channel.middleware.sort((a, b) => a.order - b.order);\n  }\n}\n\n// === HELPER CLASSES ===\n\ninterface DeliveryReceipt {\n  messageId: string;\n  target: string;\n  status: 'delivered' | 'failed' | 'pending';\n  timestamp: Date;\n  attempts: number;\n  error?: string;\n}\n\ninterface MessageAcknowledgment {\n  messageId: string;\n  agentId: AgentId;\n  timestamp: Date;\n  status: 'acknowledged' | 'rejected';\n}\n\ninterface DeliveryTarget {\n  type: 'agent' | 'channel' | 'queue' | 'topic';\n  id: string;\n  address?: string;\n}\n\ninterface RouteResult {\n  targets: DeliveryTarget[];\n  hops: string[];\n  cost: number;\n}\n\nclass MessageRouter {\n  constructor(\n    private config: MessageBusConfig,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.debug('Message router initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.debug('Message router shutdown');\n  }\n\n  async calculateRoute(message: Message, preferredChannel?: string): Promise<RouteResult> {\n    const targets: DeliveryTarget[] = [];\n    const hops: string[] = [];\n\n    // Simple routing - direct to receivers\n    for (const receiver of message.receivers) {\n      targets.push({\n        type: 'agent',\n        id: receiver.id,\n      });\n      hops.push(receiver.id);\n    }\n\n    return {\n      targets,\n      hops,\n      cost: targets.length,\n    };\n  }\n}\n\nclass DeliveryManager extends EventEmitter {\n  constructor(\n    private config: MessageBusConfig,\n    private logger: ILogger,\n  ) {\n    super();\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.debug('Delivery manager initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.debug('Delivery manager shutdown');\n  }\n\n  async deliver(message: Message, target: DeliveryTarget): Promise<void> {\n    // Simulate delivery\n    this.logger.debug('Delivering message', {\n      messageId: message.id,\n      target: target.id,\n      type: target.type,\n    });\n\n    // Emit delivery success\n    this.emit('delivery:success', { message, target });\n  }\n}\n\nclass RetryManager extends EventEmitter {\n  private retryQueue: Array<{ message: Message; target: DeliveryTarget; attempts: number }> = [];\n  private retryInterval?: NodeJS.Timeout;\n\n  constructor(\n    private config: MessageBusConfig,\n    private logger: ILogger,\n  ) {\n    super();\n  }\n\n  async initialize(): Promise<void> {\n    this.startRetryProcessor();\n    this.logger.debug('Retry manager initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.retryInterval) {\n      clearInterval(this.retryInterval);\n    }\n    this.logger.debug('Retry manager shutdown');\n  }\n\n  async scheduleRetry(message: Message, target: DeliveryTarget, error: any): Promise<void> {\n    const existingEntry = this.retryQueue.find(\n      (entry) => entry.message.id === message.id && entry.target.id === target.id,\n    );\n\n    if (existingEntry) {\n      existingEntry.attempts++;\n    } else {\n      this.retryQueue.push({ message, target, attempts: 1 });\n    }\n\n    this.logger.debug('Retry scheduled', {\n      messageId: message.id,\n      target: target.id,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n\n  private startRetryProcessor(): void {\n    this.retryInterval = setInterval(() => {\n      this.processRetries();\n    }, 5000); // Process retries every 5 seconds\n  }\n\n  private async processRetries(): Promise<void> {\n    const now = Date.now();\n    const toRetry = this.retryQueue.filter((entry) => {\n      const delay = this.calculateDelay(entry.attempts);\n      return now >= entry.message.timestamp.getTime() + delay;\n    });\n\n    for (const entry of toRetry) {\n      if (entry.attempts >= this.config.retryAttempts) {\n        // Remove from retry queue and emit exhausted event\n        this.retryQueue = this.retryQueue.filter((r) => r !== entry);\n        this.emit('retry:exhausted', entry);\n      } else {\n        // Retry delivery\n        try {\n          // Simulate retry delivery\n          this.logger.debug('Retrying message delivery', {\n            messageId: entry.message.id,\n            attempt: entry.attempts,\n          });\n\n          // Remove from retry queue on success\n          this.retryQueue = this.retryQueue.filter((r) => r !== entry);\n        } catch (error) {\n          // Keep in retry queue for next attempt\n          this.logger.warn('Retry attempt failed', {\n            messageId: entry.message.id,\n            attempt: entry.attempts,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      }\n    }\n  }\n\n  private calculateDelay(attempts: number): number {\n    const baseDelay = 1000; // 1 second\n    return Math.min(\n      baseDelay * Math.pow(this.config.backoffMultiplier, attempts - 1),\n      30000, // Max 30 seconds\n    );\n  }\n}\n\nclass MessageBusMetrics {\n  private messagesSent = 0;\n  private messagesDelivered = 0;\n  private messagesFailed = 0;\n  private bytesTransferred = 0;\n  private deliveryLatencies: number[] = [];\n\n  recordMessageSent(message: Message): void {\n    this.messagesSent++;\n    this.bytesTransferred += message.metadata.size;\n  }\n\n  recordDeliverySuccess(message: Message): void {\n    this.messagesDelivered++;\n    const latency = Date.now() - message.timestamp.getTime();\n    this.deliveryLatencies.push(latency);\n\n    // Keep only last 1000 latencies\n    if (this.deliveryLatencies.length > 1000) {\n      this.deliveryLatencies.shift();\n    }\n  }\n\n  recordDeliveryFailure(message: Message): void {\n    this.messagesFailed++;\n  }\n\n  getMetrics(): any {\n    const avgLatency =\n      this.deliveryLatencies.length > 0\n        ? this.deliveryLatencies.reduce((sum, lat) => sum + lat, 0) / this.deliveryLatencies.length\n        : 0;\n\n    return {\n      messagesSent: this.messagesSent,\n      messagesDelivered: this.messagesDelivered,\n      messagesFailed: this.messagesFailed,\n      bytesTransferred: this.bytesTransferred,\n      averageLatency: avgLatency,\n      successRate: this.messagesSent > 0 ? (this.messagesDelivered / this.messagesSent) * 100 : 100,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
