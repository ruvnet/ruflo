{
  "version": 3,
  "sources": ["../../src/swarm/claude-flow-executor.ts"],
  "sourcesContent": ["/**\n * Claude Flow SPARC Executor\n * Executes tasks using the full claude-flow SPARC system in non-interactive mode\n */\n\nimport type { TaskDefinition, AgentState, TaskResult } from './types.js';\nimport { Logger } from '../core/logger.js';\nimport * as path from 'node:path';\nimport { spawn } from 'node:child_process';\nimport { getClaudeFlowBin } from '../utils/paths.js';\n\nexport interface ClaudeFlowExecutorConfig {\n  logger?: Logger;\n  claudeFlowPath?: string;\n  enableSparc?: boolean;\n  verbose?: boolean;\n  timeoutMinutes?: number;\n}\n\nexport class ClaudeFlowExecutor {\n  private logger: Logger;\n  private claudeFlowPath: string;\n  private enableSparc: boolean;\n  private verbose: boolean;\n  private timeoutMinutes: number;\n\n  constructor(config: ClaudeFlowExecutorConfig = {}) {\n    this.logger =\n      config.logger ||\n      new Logger(\n        { level: 'info', format: 'text', destination: 'console' },\n        { component: 'ClaudeFlowExecutor' },\n      );\n    this.claudeFlowPath = config.claudeFlowPath || getClaudeFlowBin();\n    this.enableSparc = config.enableSparc ?? true;\n    this.verbose = config.verbose ?? false;\n    this.timeoutMinutes = config.timeoutMinutes ?? 59;\n  }\n\n  async executeTask(\n    task: TaskDefinition,\n    agent: AgentState,\n    targetDir?: string,\n  ): Promise<TaskResult> {\n    this.logger.info('Executing task with Claude Flow SPARC', {\n      taskId: task.id.id,\n      taskName: task.name,\n      agentType: agent.type,\n      targetDir,\n    });\n\n    const startTime = Date.now();\n\n    try {\n      // Determine the SPARC mode based on task type and agent type\n      const sparcMode = this.determineSparcMode(task, agent);\n\n      // Build the command\n      const command = this.buildSparcCommand(task, sparcMode, targetDir);\n\n      this.logger.info('Executing SPARC command', {\n        mode: sparcMode,\n        command: command.join(' '),\n      });\n\n      // Execute the command\n      const result = await this.executeCommand(command);\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      return {\n        output: result.output,\n        artifacts: result.artifacts || {},\n        metadata: {\n          executionTime,\n          sparcMode,\n          command: command.join(' '),\n          exitCode: result.exitCode,\n          quality: 0.95,\n          completeness: 0.9,\n        },\n        error: result.error,\n      };\n    } catch (error) {\n      this.logger.error('Failed to execute Claude Flow SPARC command', {\n        error: error instanceof Error ? error.message : String(error),\n        taskId: task.id.id,\n      });\n\n      return {\n        output: '',\n        artifacts: {},\n        metadata: {\n          executionTime: Date.now() - startTime,\n          quality: 0,\n          completeness: 0,\n        },\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  private determineSparcMode(task: TaskDefinition, agent: AgentState): string {\n    // Map task types and agent types to SPARC modes\n    const modeMap = {\n      // Task type mappings\n      coding: 'code',\n      testing: 'tdd',\n      analysis: 'spec-pseudocode',\n      documentation: 'docs-writer',\n      research: 'spec-pseudocode',\n      review: 'refinement-optimization-mode',\n      deployment: 'devops',\n      optimization: 'refinement-optimization-mode',\n      integration: 'integration',\n\n      // Agent type overrides\n      coder: 'code',\n      tester: 'tdd',\n      analyst: 'spec-pseudocode',\n      documenter: 'docs-writer',\n      reviewer: 'refinement-optimization-mode',\n      researcher: 'spec-pseudocode',\n      coordinator: 'architect',\n    };\n\n    // Check for specific keywords in task description\n    const description = task.description.toLowerCase();\n    if (description.includes('architecture') || description.includes('design')) {\n      return 'architect';\n    }\n    if (description.includes('security')) {\n      return 'security-review';\n    }\n    if (description.includes('debug')) {\n      return 'debug';\n    }\n    if (description.includes('test')) {\n      return 'tdd';\n    }\n    if (description.includes('document')) {\n      return 'docs-writer';\n    }\n    if (description.includes('integrate')) {\n      return 'integration';\n    }\n\n    // Use agent type first, then task type\n    return modeMap[agent.type] || modeMap[task.type] || 'code';\n  }\n\n  private buildSparcCommand(task: TaskDefinition, mode: string, targetDir?: string): string[] {\n    const command = [\n      this.claudeFlowPath,\n      'sparc',\n      'run',\n      mode,\n      `\"${this.formatTaskDescription(task)}\"`,\n    ];\n\n    // Add options\n    if (targetDir) {\n      command.push('--target-dir', targetDir);\n    }\n\n    if (this.verbose) {\n      command.push('--verbose');\n    }\n\n    // Add non-interactive flag\n    command.push('--non-interactive');\n\n    // Add auto-confirm flag\n    command.push('--yes');\n\n    return command;\n  }\n\n  private formatTaskDescription(task: TaskDefinition): string {\n    // Format the task description for SPARC command\n    let description = task.description;\n\n    // If the task has specific instructions, include them\n    if (task.instructions && task.instructions !== task.description) {\n      description = `${task.description}. ${task.instructions}`;\n    }\n\n    // Add context if available\n    if (task.context?.targetDir) {\n      description += ` in ${task.context.targetDir}`;\n    }\n\n    return description.replace(/\"/g, '\\\\\"');\n  }\n\n  private async executeCommand(command: string[]): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const [cmd, ...args] = command;\n\n      const proc = spawn(cmd, args, {\n        shell: true,\n        env: {\n          ...process.env,\n          CLAUDE_FLOW_NON_INTERACTIVE: 'true',\n          CLAUDE_FLOW_AUTO_CONFIRM: 'true',\n        },\n      });\n\n      let stdout = '';\n      let stderr = '';\n      const artifacts: Record<string, any> = {};\n\n      proc.stdout.on('data', (data) => {\n        const chunk = data.toString();\n        stdout += chunk;\n\n        // Parse artifacts from output\n        const artifactMatch = chunk.match(/Created file: (.+)/g);\n        if (artifactMatch) {\n          artifactMatch.forEach((match) => {\n            const filePath = match.replace('Created file: ', '').trim();\n            artifacts[filePath] = true;\n          });\n        }\n      });\n\n      proc.stderr.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', (code) => {\n        clearTimeout(timeoutId); // Clear timeout when process completes\n        if (code === 0) {\n          resolve({\n            output: stdout,\n            artifacts,\n            exitCode: code,\n            error: null,\n          });\n        } else {\n          resolve({\n            output: stdout,\n            artifacts,\n            exitCode: code,\n            error: stderr || `Command exited with code ${code}`,\n          });\n        }\n      });\n\n      proc.on('error', (err) => {\n        reject(err);\n      });\n\n      // Handle timeout - configurable for SPARC operations\n      const timeoutMs = this.timeoutMinutes * 60 * 1000;\n      const timeoutId = setTimeout(() => {\n        proc.kill('SIGTERM');\n        reject(new Error('Command execution timeout'));\n      }, timeoutMs);\n    });\n  }\n}\n\n// Export for use in swarm coordinator\nexport default ClaudeFlowExecutor;\n"],
  "mappings": "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",
  "names": []
}
