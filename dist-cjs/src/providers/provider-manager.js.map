{"version":3,"sources":["../../../src/providers/provider-manager.ts"],"sourcesContent":["/**\r\n * Provider Manager - Central orchestration for multi-LLM providers\r\n * Handles provider selection, fallback, load balancing, and cost optimization\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { ILogger } from '../core/logger.js';\r\nimport { ConfigManager } from '../config/config-manager.js';\r\nimport {\r\n  ILLMProvider,\r\n  LLMProvider,\r\n  LLMProviderConfig,\r\n  LLMRequest,\r\n  LLMResponse,\r\n  LLMStreamEvent,\r\n  LLMModel,\r\n  FallbackStrategy,\r\n  FallbackRule,\r\n  LoadBalancer,\r\n  ProviderMetrics,\r\n  CostOptimizer,\r\n  CostConstraints,\r\n  OptimizationResult,\r\n  RateLimiter,\r\n  ProviderMonitor,\r\n  CacheConfig,\r\n  LLMProviderError,\r\n  RateLimitError,\r\n  isRateLimitError,\r\n} from './types.js';\r\n\r\n// Import providers\r\nimport { AnthropicProvider } from './anthropic-provider.js';\r\nimport { OpenAIProvider } from './openai-provider.js';\r\nimport { GoogleProvider } from './google-provider.js';\r\nimport { CohereProvider } from './cohere-provider.js';\r\nimport { OllamaProvider } from './ollama-provider.js';\r\n\r\nexport interface ProviderManagerConfig {\r\n  providers: Record<LLMProvider, LLMProviderConfig>;\r\n  defaultProvider: LLMProvider;\r\n  fallbackStrategy?: FallbackStrategy;\r\n  loadBalancing?: {\r\n    enabled: boolean;\r\n    strategy: 'round-robin' | 'least-loaded' | 'latency-based' | 'cost-based';\r\n  };\r\n  costOptimization?: {\r\n    enabled: boolean;\r\n    maxCostPerRequest?: number;\r\n    preferredProviders?: LLMProvider[];\r\n  };\r\n  caching?: CacheConfig;\r\n  monitoring?: {\r\n    enabled: boolean;\r\n    metricsInterval: number;\r\n  };\r\n}\r\n\r\nexport class ProviderManager extends EventEmitter {\r\n  private providers: Map<LLMProvider, ILLMProvider> = new Map();\r\n  private logger: ILogger;\r\n  private config: ProviderManagerConfig;\r\n  private requestCount: Map<LLMProvider, number> = new Map();\r\n  private lastUsed: Map<LLMProvider, Date> = new Map();\r\n  private providerMetrics: Map<LLMProvider, ProviderMetrics[]> = new Map();\r\n  private cache: Map<string, { response: LLMResponse; timestamp: Date }> = new Map();\r\n  private currentProviderIndex = 0;\r\n\r\n  constructor(logger: ILogger, configManager: ConfigManager, config: ProviderManagerConfig) {\r\n    super();\r\n    this.logger = logger;\r\n    this.config = config;\r\n\r\n    // Initialize providers\r\n    this.initializeProviders();\r\n\r\n    // Start monitoring if enabled\r\n    if (config.monitoring?.enabled) {\r\n      this.startMonitoring();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize all configured providers\r\n   */\r\n  private async initializeProviders(): Promise<void> {\r\n    for (const [providerName, providerConfig] of Object.entries(this.config.providers)) {\r\n      try {\r\n        const provider = await this.createProvider(providerName as LLMProvider, providerConfig);\r\n        if (provider) {\r\n          this.providers.set(providerName as LLMProvider, provider);\r\n          this.requestCount.set(providerName as LLMProvider, 0);\r\n          this.logger.info(`Initialized ${providerName} provider`);\r\n        }\r\n      } catch (error) {\r\n        this.logger.error(`Failed to initialize ${providerName} provider`, error);\r\n      }\r\n    }\r\n\r\n    if (this.providers.size === 0) {\r\n      throw new Error('No providers could be initialized');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a provider instance\r\n   */\r\n  private async createProvider(name: LLMProvider, config: LLMProviderConfig): Promise<ILLMProvider | null> {\r\n    const providerOptions = {\r\n      logger: this.logger,\r\n      config,\r\n    };\r\n\r\n    try {\r\n      let provider: ILLMProvider;\r\n\r\n      switch (name) {\r\n        case 'anthropic':\r\n          provider = new AnthropicProvider(providerOptions);\r\n          break;\r\n        case 'openai':\r\n          provider = new OpenAIProvider(providerOptions);\r\n          break;\r\n        case 'google':\r\n          provider = new GoogleProvider(providerOptions);\r\n          break;\r\n        case 'cohere':\r\n          provider = new CohereProvider(providerOptions);\r\n          break;\r\n        case 'ollama':\r\n          provider = new OllamaProvider(providerOptions);\r\n          break;\r\n        default:\r\n          this.logger.warn(`Unknown provider: ${name}`);\r\n          return null;\r\n      }\r\n\r\n      await provider.initialize();\r\n      \r\n      // Set up event listeners\r\n      provider.on('response', (data) => this.handleProviderResponse(name, data));\r\n      provider.on('error', (error) => this.handleProviderError(name, error));\r\n      provider.on('health_check', (result) => this.handleHealthCheck(name, result));\r\n\r\n      return provider;\r\n    } catch (error) {\r\n      this.logger.error(`Failed to create ${name} provider`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Complete a request using the appropriate provider\r\n   */\r\n  async complete(request: LLMRequest): Promise<LLMResponse> {\r\n    // Check cache first\r\n    if (this.config.caching?.enabled) {\r\n      const cached = this.checkCache(request);\r\n      if (cached) {\r\n        this.logger.debug('Returning cached response');\r\n        return cached;\r\n      }\r\n    }\r\n\r\n    // Select provider based on strategy\r\n    const provider = await this.selectProvider(request);\r\n    \r\n    try {\r\n      const response = await provider.complete(request);\r\n      \r\n      // Cache successful response\r\n      if (this.config.caching?.enabled) {\r\n        this.cacheResponse(request, response);\r\n      }\r\n      \r\n      // Update metrics\r\n      this.updateProviderMetrics(provider.name, {\r\n        success: true,\r\n        latency: response.latency || 0,\r\n        cost: response.cost?.totalCost || 0,\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      // Handle error and potentially fallback\r\n      return this.handleRequestError(error, request, provider);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stream complete a request\r\n   */\r\n  async *streamComplete(request: LLMRequest): AsyncIterable<LLMStreamEvent> {\r\n    const provider = await this.selectProvider(request);\r\n    \r\n    try {\r\n      yield* provider.streamComplete(request);\r\n      \r\n      // Update metrics\r\n      this.updateProviderMetrics(provider.name, {\r\n        success: true,\r\n        latency: 0, // Will be updated by stream events\r\n        cost: 0, // Will be updated by stream events\r\n      });\r\n    } catch (error) {\r\n      // Handle error and potentially fallback\r\n      const fallbackProvider = await this.getFallbackProvider(error, provider);\r\n      if (fallbackProvider) {\r\n        this.logger.info(`Falling back to ${fallbackProvider.name} provider`);\r\n        yield* fallbackProvider.streamComplete(request);\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select the best provider for a request\r\n   */\r\n  private async selectProvider(request: LLMRequest): Promise<ILLMProvider> {\r\n    // If specific provider requested\r\n    if (request.providerOptions?.preferredProvider) {\r\n      const provider = this.providers.get(request.providerOptions.preferredProvider);\r\n      if (provider && this.isProviderAvailable(provider)) {\r\n        return provider;\r\n      }\r\n    }\r\n\r\n    // Cost optimization\r\n    if (this.config.costOptimization?.enabled && request.costConstraints) {\r\n      const optimized = await this.selectOptimalProvider(request);\r\n      if (optimized) {\r\n        return optimized;\r\n      }\r\n    }\r\n\r\n    // Load balancing\r\n    if (this.config.loadBalancing?.enabled) {\r\n      return this.selectLoadBalancedProvider();\r\n    }\r\n\r\n    // Default provider\r\n    const defaultProvider = this.providers.get(this.config.defaultProvider);\r\n    if (defaultProvider && this.isProviderAvailable(defaultProvider)) {\r\n      return defaultProvider;\r\n    }\r\n\r\n    // First available provider\r\n    for (const provider of this.providers.values()) {\r\n      if (this.isProviderAvailable(provider)) {\r\n        return provider;\r\n      }\r\n    }\r\n\r\n    throw new Error('No available providers');\r\n  }\r\n\r\n  /**\r\n   * Select provider based on cost optimization\r\n   */\r\n  private async selectOptimalProvider(request: LLMRequest): Promise<ILLMProvider | null> {\r\n    let bestProvider: ILLMProvider | null = null;\r\n    let bestCost = Infinity;\r\n\r\n    for (const provider of this.providers.values()) {\r\n      if (!this.isProviderAvailable(provider)) continue;\r\n\r\n      try {\r\n        const estimate = await provider.estimateCost(request);\r\n        \r\n        if (estimate.estimatedCost.total < bestCost &&\r\n            (!request.costConstraints?.maxCostPerRequest || \r\n             estimate.estimatedCost.total <= request.costConstraints.maxCostPerRequest)) {\r\n          bestCost = estimate.estimatedCost.total;\r\n          bestProvider = provider;\r\n        }\r\n      } catch (error) {\r\n        this.logger.warn(`Failed to estimate cost for ${provider.name}`, error);\r\n      }\r\n    }\r\n\r\n    return bestProvider;\r\n  }\r\n\r\n  /**\r\n   * Select provider using load balancing\r\n   */\r\n  private selectLoadBalancedProvider(): ILLMProvider {\r\n    const availableProviders = Array.from(this.providers.values()).filter(p => \r\n      this.isProviderAvailable(p)\r\n    );\r\n\r\n    if (availableProviders.length === 0) {\r\n      throw new Error('No available providers');\r\n    }\r\n\r\n    switch (this.config.loadBalancing?.strategy) {\r\n      case 'round-robin':\r\n        return this.roundRobinSelect(availableProviders);\r\n        \r\n      case 'least-loaded':\r\n        return this.leastLoadedSelect(availableProviders);\r\n        \r\n      case 'latency-based':\r\n        return this.latencyBasedSelect(availableProviders);\r\n        \r\n      case 'cost-based':\r\n        return this.costBasedSelect(availableProviders);\r\n        \r\n      default:\r\n        return availableProviders[0];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Round-robin provider selection\r\n   */\r\n  private roundRobinSelect(providers: ILLMProvider[]): ILLMProvider {\r\n    const provider = providers[this.currentProviderIndex % providers.length];\r\n    this.currentProviderIndex++;\r\n    return provider;\r\n  }\r\n\r\n  /**\r\n   * Select least loaded provider\r\n   */\r\n  private leastLoadedSelect(providers: ILLMProvider[]): ILLMProvider {\r\n    let minLoad = Infinity;\r\n    let selectedProvider = providers[0];\r\n\r\n    for (const provider of providers) {\r\n      const status = provider.getStatus();\r\n      if (status.currentLoad < minLoad) {\r\n        minLoad = status.currentLoad;\r\n        selectedProvider = provider;\r\n      }\r\n    }\r\n\r\n    return selectedProvider;\r\n  }\r\n\r\n  /**\r\n   * Select provider with lowest latency\r\n   */\r\n  private latencyBasedSelect(providers: ILLMProvider[]): ILLMProvider {\r\n    let minLatency = Infinity;\r\n    let selectedProvider = providers[0];\r\n\r\n    for (const provider of providers) {\r\n      const metrics = this.providerMetrics.get(provider.name);\r\n      if (metrics && metrics.length > 0) {\r\n        const avgLatency = metrics.reduce((sum, m) => sum + m.latency, 0) / metrics.length;\r\n        if (avgLatency < minLatency) {\r\n          minLatency = avgLatency;\r\n          selectedProvider = provider;\r\n        }\r\n      }\r\n    }\r\n\r\n    return selectedProvider;\r\n  }\r\n\r\n  /**\r\n   * Select provider with lowest cost\r\n   */\r\n  private costBasedSelect(providers: ILLMProvider[]): ILLMProvider {\r\n    let minCost = Infinity;\r\n    let selectedProvider = providers[0];\r\n\r\n    for (const provider of providers) {\r\n      const metrics = this.providerMetrics.get(provider.name);\r\n      if (metrics && metrics.length > 0) {\r\n        const avgCost = metrics.reduce((sum, m) => sum + m.cost, 0) / metrics.length;\r\n        if (avgCost < minCost) {\r\n          minCost = avgCost;\r\n          selectedProvider = provider;\r\n        }\r\n      }\r\n    }\r\n\r\n    return selectedProvider;\r\n  }\r\n\r\n  /**\r\n   * Check if provider is available\r\n   */\r\n  private isProviderAvailable(provider: ILLMProvider): boolean {\r\n    const status = provider.getStatus();\r\n    return status.available;\r\n  }\r\n\r\n  /**\r\n   * Handle request error with fallback\r\n   */\r\n  private async handleRequestError(\r\n    error: unknown,\r\n    request: LLMRequest,\r\n    failedProvider: ILLMProvider\r\n  ): Promise<LLMResponse> {\r\n    this.logger.error(`Provider ${failedProvider.name} failed`, error);\r\n    \r\n    // Update metrics\r\n    this.updateProviderMetrics(failedProvider.name, {\r\n      success: false,\r\n      latency: 0,\r\n      cost: 0,\r\n    });\r\n\r\n    // Try fallback\r\n    const fallbackProvider = await this.getFallbackProvider(error, failedProvider);\r\n    if (fallbackProvider) {\r\n      this.logger.info(`Falling back to ${fallbackProvider.name} provider`);\r\n      return fallbackProvider.complete(request);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n\r\n  /**\r\n   * Get fallback provider based on error\r\n   */\r\n  private async getFallbackProvider(\r\n    error: unknown,\r\n    failedProvider: ILLMProvider\r\n  ): Promise<ILLMProvider | null> {\r\n    if (!this.config.fallbackStrategy?.enabled) {\r\n      return null;\r\n    }\r\n\r\n    const errorCondition = this.getErrorCondition(error);\r\n    const fallbackRule = this.config.fallbackStrategy.rules.find(rule => \r\n      rule.condition === errorCondition\r\n    );\r\n\r\n    if (!fallbackRule) {\r\n      return null;\r\n    }\r\n\r\n    // Find first available fallback provider\r\n    for (const providerName of fallbackRule.fallbackProviders) {\r\n      const provider = this.providers.get(providerName);\r\n      if (provider && provider !== failedProvider && this.isProviderAvailable(provider)) {\r\n        return provider;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Determine error condition for fallback\r\n   */\r\n  private getErrorCondition(error: unknown): FallbackRule['condition'] {\r\n    if (isRateLimitError(error)) {\r\n      return 'rate_limit';\r\n    }\r\n    \r\n    if (error instanceof LLMProviderError) {\r\n      if (error.statusCode === 503) {\r\n        return 'unavailable';\r\n      }\r\n      if (error.code === 'TIMEOUT') {\r\n        return 'timeout';\r\n      }\r\n    }\r\n    \r\n    return 'error';\r\n  }\r\n\r\n  /**\r\n   * Cache management\r\n   */\r\n  private checkCache(request: LLMRequest): LLMResponse | null {\r\n    const cacheKey = this.generateCacheKey(request);\r\n    const cached = this.cache.get(cacheKey);\r\n    \r\n    if (cached) {\r\n      const age = Date.now() - cached.timestamp.getTime();\r\n      if (age < (this.config.caching?.ttl || 3600) * 1000) {\r\n        return cached.response;\r\n      }\r\n      // Remove expired entry\r\n      this.cache.delete(cacheKey);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  private cacheResponse(request: LLMRequest, response: LLMResponse): void {\r\n    const cacheKey = this.generateCacheKey(request);\r\n    this.cache.set(cacheKey, {\r\n      response,\r\n      timestamp: new Date(),\r\n    });\r\n    \r\n    // Cleanup old cache entries\r\n    if (this.cache.size > 1000) {\r\n      const oldestKey = this.cache.keys().next().value;\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  private generateCacheKey(request: LLMRequest): string {\r\n    return JSON.stringify({\r\n      model: request.model,\r\n      messages: request.messages,\r\n      temperature: request.temperature,\r\n      maxTokens: request.maxTokens,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update provider metrics\r\n   */\r\n  private updateProviderMetrics(\r\n    provider: LLMProvider,\r\n    metrics: { success: boolean; latency: number; cost: number }\r\n  ): void {\r\n    const count = this.requestCount.get(provider) || 0;\r\n    this.requestCount.set(provider, count + 1);\r\n    this.lastUsed.set(provider, new Date());\r\n\r\n    const providerMetricsList = this.providerMetrics.get(provider) || [];\r\n    const errorRate = metrics.success ? 0 : 1;\r\n    const successRate = metrics.success ? 1 : 0;\r\n\r\n    providerMetricsList.push({\r\n      provider,\r\n      timestamp: new Date(),\r\n      latency: metrics.latency,\r\n      errorRate,\r\n      successRate,\r\n      load: this.providers.get(provider)?.getStatus().currentLoad || 0,\r\n      cost: metrics.cost,\r\n      availability: this.providers.get(provider)?.getStatus().available ? 1 : 0,\r\n    });\r\n\r\n    // Keep only recent metrics (last 100)\r\n    if (providerMetricsList.length > 100) {\r\n      providerMetricsList.shift();\r\n    }\r\n\r\n    this.providerMetrics.set(provider, providerMetricsList);\r\n  }\r\n\r\n  /**\r\n   * Event handlers\r\n   */\r\n  private handleProviderResponse(provider: LLMProvider, data: any): void {\r\n    this.emit('provider_response', { provider, ...data });\r\n  }\r\n\r\n  private handleProviderError(provider: LLMProvider, error: any): void {\r\n    this.emit('provider_error', { provider, error });\r\n  }\r\n\r\n  private handleHealthCheck(provider: LLMProvider, result: any): void {\r\n    this.emit('health_check', { provider, result });\r\n  }\r\n\r\n  /**\r\n   * Start monitoring\r\n   */\r\n  private startMonitoring(): void {\r\n    setInterval(() => {\r\n      this.emitMetrics();\r\n    }, this.config.monitoring?.metricsInterval || 60000);\r\n  }\r\n\r\n  /**\r\n   * Emit aggregated metrics\r\n   */\r\n  private emitMetrics(): void {\r\n    const metrics = {\r\n      providers: {} as Record<LLMProvider, any>,\r\n      totalRequests: 0,\r\n      totalCost: 0,\r\n      averageLatency: 0,\r\n    };\r\n\r\n    for (const [provider, count] of this.requestCount.entries()) {\r\n      const providerMetricsList = this.providerMetrics.get(provider) || [];\r\n      const avgLatency = providerMetricsList.length > 0\r\n        ? providerMetricsList.reduce((sum, m) => sum + m.latency, 0) / providerMetricsList.length\r\n        : 0;\r\n      const totalCost = providerMetricsList.reduce((sum, m) => sum + m.cost, 0);\r\n\r\n      metrics.providers[provider] = {\r\n        requests: count,\r\n        averageLatency: avgLatency,\r\n        totalCost,\r\n        lastUsed: this.lastUsed.get(provider),\r\n        available: this.providers.get(provider)?.getStatus().available,\r\n      };\r\n\r\n      metrics.totalRequests += count;\r\n      metrics.totalCost += totalCost;\r\n    }\r\n\r\n    if (metrics.totalRequests > 0) {\r\n      let totalLatency = 0;\r\n      let latencyCount = 0;\r\n      \r\n      for (const providerMetricsList of this.providerMetrics.values()) {\r\n        for (const metric of providerMetricsList) {\r\n          totalLatency += metric.latency;\r\n          latencyCount++;\r\n        }\r\n      }\r\n      \r\n      metrics.averageLatency = latencyCount > 0 ? totalLatency / latencyCount : 0;\r\n    }\r\n\r\n    this.emit('metrics', metrics);\r\n  }\r\n\r\n  /**\r\n   * Get available providers\r\n   */\r\n  getAvailableProviders(): LLMProvider[] {\r\n    return Array.from(this.providers.keys()).filter(name => {\r\n      const provider = this.providers.get(name);\r\n      return provider && this.isProviderAvailable(provider);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get provider by name\r\n   */\r\n  getProvider(name: LLMProvider): ILLMProvider | undefined {\r\n    return this.providers.get(name);\r\n  }\r\n\r\n  /**\r\n   * Get all providers\r\n   */\r\n  getAllProviders(): Map<LLMProvider, ILLMProvider> {\r\n    return new Map(this.providers);\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   */\r\n  destroy(): void {\r\n    for (const provider of this.providers.values()) {\r\n      provider.destroy();\r\n    }\r\n    \r\n    this.providers.clear();\r\n    this.cache.clear();\r\n    this.providerMetrics.clear();\r\n    this.removeAllListeners();\r\n  }\r\n}"],"names":["EventEmitter","LLMProviderError","isRateLimitError","AnthropicProvider","OpenAIProvider","GoogleProvider","CohereProvider","OllamaProvider","ProviderManager","providers","Map","logger","config","requestCount","lastUsed","providerMetrics","cache","currentProviderIndex","configManager","initializeProviders","monitoring","enabled","startMonitoring","providerName","providerConfig","Object","entries","provider","createProvider","set","info","error","size","Error","name","providerOptions","warn","initialize","on","data","handleProviderResponse","handleProviderError","result","handleHealthCheck","complete","request","caching","cached","checkCache","debug","selectProvider","response","cacheResponse","updateProviderMetrics","success","latency","cost","totalCost","handleRequestError","streamComplete","fallbackProvider","getFallbackProvider","preferredProvider","get","isProviderAvailable","costOptimization","costConstraints","optimized","selectOptimalProvider","loadBalancing","selectLoadBalancedProvider","defaultProvider","values","bestProvider","bestCost","Infinity","estimate","estimateCost","estimatedCost","total","maxCostPerRequest","availableProviders","Array","from","filter","p","length","strategy","roundRobinSelect","leastLoadedSelect","latencyBasedSelect","costBasedSelect","minLoad","selectedProvider","status","getStatus","currentLoad","minLatency","metrics","avgLatency","reduce","sum","m","minCost","avgCost","available","failedProvider","fallbackStrategy","errorCondition","getErrorCondition","fallbackRule","rules","find","rule","condition","fallbackProviders","statusCode","code","cacheKey","generateCacheKey","age","Date","now","timestamp","getTime","ttl","delete","oldestKey","keys","next","value","JSON","stringify","model","messages","temperature","maxTokens","count","providerMetricsList","errorRate","successRate","push","load","availability","shift","emit","setInterval","emitMetrics","metricsInterval","totalRequests","averageLatency","requests","totalLatency","latencyCount","metric","getAvailableProviders","getProvider","getAllProviders","destroy","clear","removeAllListeners"],"mappings":"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"}