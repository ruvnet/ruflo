{
  "version": 3,
  "sources": ["../../../src/services/agentic-flow-hooks/neural-hooks.ts"],
  "sourcesContent": ["/**\n * Neural training hooks for agentic-flow\n * \n * Enables learning from multi-model responses with\n * pattern detection and adaptive optimization.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  NeuralHookPayload,\n  Pattern,\n  TrainingData,\n  Prediction,\n  Adaptation,\n  SideEffect,\n} from './types.js';\n\n// ===== Pre-Neural Train Hook =====\n\nexport const preNeuralTrainHook = {\n  id: 'agentic-pre-neural-train',\n  type: 'pre-neural-train' as const,\n  priority: 100,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { operation, modelId, trainingData } = payload;\n    \n    if (operation !== 'train' || !trainingData) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate training data\n    const validation = validateTrainingData(trainingData);\n    if (!validation.valid) {\n      return {\n        continue: false,\n        sideEffects: [\n          {\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'error',\n              message: 'Invalid training data',\n              data: validation,\n            },\n          },\n        ],\n      };\n    }\n    \n    // Augment training data with historical patterns\n    const augmentedData = await augmentTrainingData(\n      trainingData,\n      modelId,\n      context\n    );\n    \n    // Balance dataset if needed\n    const balancedData = balanceTrainingData(augmentedData);\n    \n    // Apply data preprocessing\n    const preprocessedData = preprocessTrainingData(balancedData);\n    \n    // Store training session metadata\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `neural:training:${modelId}:${Date.now()}`,\n        value: {\n          originalSize: trainingData.inputs.length,\n          augmentedSize: augmentedData.inputs.length,\n          balancedSize: balancedData.inputs.length,\n          epochs: balancedData.epochs,\n          timestamp: Date.now(),\n        },\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        trainingData: preprocessedData,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Post-Neural Train Hook =====\n\nexport const postNeuralTrainHook = {\n  id: 'agentic-post-neural-train',\n  type: 'post-neural-train' as const,\n  priority: 100,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { modelId, accuracy, trainingData } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Store training results\n    const trainingResult = {\n      modelId,\n      accuracy,\n      timestamp: Date.now(),\n      sessionId: context.sessionId,\n      dataSize: trainingData?.inputs.length || 0,\n      epochs: trainingData?.epochs || 0,\n    };\n    \n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `neural:results:${modelId}:${Date.now()}`,\n        value: trainingResult,\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Update model performance history\n    await updateModelPerformance(modelId, accuracy, context);\n    \n    // Check if model should be promoted\n    const shouldPromote = await evaluateModelPromotion(modelId, accuracy, context);\n    if (shouldPromote) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'neural:model:promoted',\n          data: { modelId, accuracy },\n        },\n      });\n    }\n    \n    // Extract learned patterns\n    const patterns = await extractLearnedPatterns(modelId, context);\n    if (patterns.length > 0) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'store-patterns',\n        data: { patterns },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Neural Pattern Detected Hook =====\n\nexport const neuralPatternDetectedHook = {\n  id: 'agentic-neural-pattern-detected',\n  type: 'neural-pattern-detected' as const,\n  priority: 90,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { patterns } = payload;\n    \n    if (!patterns || patterns.length === 0) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Analyze pattern significance\n    for (const pattern of patterns) {\n      const significance = calculatePatternSignificance(pattern);\n      \n      if (significance > 0.7) {\n        // High significance pattern\n        sideEffects.push({\n          type: 'memory',\n          action: 'store',\n          data: {\n            key: `pattern:significant:${pattern.id}`,\n            value: {\n              pattern,\n              significance,\n              detectedAt: Date.now(),\n              context: context.metadata,\n            },\n            ttl: 0, // Permanent\n          },\n        });\n        \n        // Trigger adaptation if needed\n        const adaptation = await generateAdaptation(pattern, context);\n        if (adaptation) {\n          sideEffects.push({\n            type: 'neural',\n            action: 'adapt',\n            data: { adaptation },\n          });\n        }\n      }\n      \n      // Update pattern store\n      context.neural.patterns.add(pattern);\n    }\n    \n    // Check for pattern combinations\n    const combinations = findPatternCombinations(patterns, context);\n    if (combinations.length > 0) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Pattern combinations detected',\n          data: { combinations },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Neural Prediction Hook =====\n\nexport const neuralPredictionHook = {\n  id: 'agentic-neural-prediction',\n  type: 'neural-prediction' as const,\n  priority: 100,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { prediction, modelId } = payload;\n    \n    if (!prediction) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate prediction confidence\n    if (prediction.confidence < 0.5) {\n      // Low confidence - consider alternatives\n      const alternatives = await generateAlternatives(\n        prediction.input,\n        modelId,\n        context\n      );\n      \n      if (alternatives.length > 0) {\n        return {\n          continue: true,\n          modified: true,\n          payload: {\n            ...payload,\n            prediction: {\n              ...prediction,\n              alternatives: [...prediction.alternatives, ...alternatives],\n            },\n          },\n          sideEffects: [\n            {\n              type: 'metric',\n              action: 'increment',\n              data: { name: 'neural.predictions.low_confidence' },\n            },\n          ],\n        };\n      }\n    }\n    \n    // Store prediction for future training\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `prediction:${modelId}:${Date.now()}`,\n        value: {\n          input: prediction.input,\n          output: prediction.output,\n          confidence: prediction.confidence,\n          timestamp: Date.now(),\n        },\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    // Track prediction metrics\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `neural.predictions.confidence.${modelId}`,\n        value: prediction.confidence,\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Neural Adaptation Hook =====\n\nexport const neuralAdaptationHook = {\n  id: 'agentic-neural-adaptation',\n  type: 'neural-adaptation' as const,\n  priority: 90,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { adaptations, modelId } = payload;\n    \n    if (!adaptations || adaptations.length === 0) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate adaptations\n    const validAdaptations = adaptations.filter(a => \n      validateAdaptation(a, modelId, context)\n    );\n    \n    if (validAdaptations.length === 0) {\n      return { continue: true };\n    }\n    \n    // Apply adaptations in order of impact\n    const sortedAdaptations = validAdaptations.sort((a, b) => \n      Math.abs(b.impact) - Math.abs(a.impact)\n    );\n    \n    for (const adaptation of sortedAdaptations) {\n      // Store adaptation history\n      sideEffects.push({\n        type: 'memory',\n        action: 'store',\n        data: {\n          key: `adaptation:${modelId}:${adaptation.target}:${Date.now()}`,\n          value: adaptation,\n          ttl: 604800, // 7 days\n        },\n      });\n      \n      // Apply adaptation based on type\n      switch (adaptation.type) {\n        case 'parameter':\n          await applyParameterAdaptation(adaptation, modelId, context);\n          break;\n          \n        case 'architecture':\n          await applyArchitectureAdaptation(adaptation, modelId, context);\n          break;\n          \n        case 'strategy':\n          await applyStrategyAdaptation(adaptation, modelId, context);\n          break;\n      }\n      \n      // Track adaptation metrics\n      sideEffects.push({\n        type: 'metric',\n        action: 'increment',\n        data: { name: `neural.adaptations.${adaptation.type}` },\n      });\n    }\n    \n    // Trigger retraining if significant adaptations\n    const totalImpact = sortedAdaptations.reduce((sum, a) => \n      sum + Math.abs(a.impact), 0\n    );\n    \n    if (totalImpact > 0.5) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'retrain',\n        data: {\n          modelId,\n          reason: 'significant_adaptations',\n          adaptations: sortedAdaptations.length,\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nfunction validateTrainingData(data: TrainingData): { valid: boolean; errors?: string[] } {\n  const errors: string[] = [];\n  \n  if (!data.inputs || data.inputs.length === 0) {\n    errors.push('No input data provided');\n  }\n  \n  if (!data.outputs || data.outputs.length === 0) {\n    errors.push('No output data provided');\n  }\n  \n  if (data.inputs.length !== data.outputs.length) {\n    errors.push('Input and output lengths do not match');\n  }\n  \n  if (data.batchSize <= 0) {\n    errors.push('Invalid batch size');\n  }\n  \n  if (data.epochs <= 0) {\n    errors.push('Invalid number of epochs');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors: errors.length > 0 ? errors : undefined,\n  };\n}\n\nasync function augmentTrainingData(\n  data: TrainingData,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<TrainingData> {\n  // Augment with historical successful patterns\n  const historicalPatterns = await loadHistoricalPatterns(modelId, context);\n  \n  const augmented: TrainingData = {\n    ...data,\n    inputs: [...data.inputs],\n    outputs: [...data.outputs],\n    labels: data.labels ? [...data.labels] : undefined,\n    weights: data.weights ? [...data.weights] : undefined,\n  };\n  \n  // Add successful patterns\n  for (const pattern of historicalPatterns) {\n    if (pattern.type === 'success' && pattern.confidence > 0.8) {\n      augmented.inputs.push(pattern.context.input);\n      augmented.outputs.push(pattern.context.output);\n      \n      if (augmented.weights) {\n        // Give higher weight to successful patterns\n        augmented.weights.push(pattern.confidence);\n      }\n    }\n  }\n  \n  return augmented;\n}\n\nfunction balanceTrainingData(data: TrainingData): TrainingData {\n  // Balance dataset to prevent bias\n  if (!data.labels) {\n    return data;\n  }\n  \n  // Count occurrences of each label\n  const labelCounts = new Map<string, number>();\n  for (const label of data.labels) {\n    labelCounts.set(label, (labelCounts.get(label) || 0) + 1);\n  }\n  \n  // Find minimum count\n  const minCount = Math.min(...labelCounts.values());\n  \n  // Balance by undersampling\n  const balanced: TrainingData = {\n    ...data,\n    inputs: [],\n    outputs: [],\n    labels: [],\n    weights: data.weights ? [] : undefined,\n  };\n  \n  const labelIndices = new Map<string, number[]>();\n  data.labels.forEach((label, i) => {\n    if (!labelIndices.has(label)) {\n      labelIndices.set(label, []);\n    }\n    labelIndices.get(label)!.push(i);\n  });\n  \n  // Sample equally from each label\n  for (const [label, indices] of labelIndices.entries()) {\n    const sampled = indices\n      .sort(() => Math.random() - 0.5)\n      .slice(0, minCount);\n    \n    for (const idx of sampled) {\n      balanced.inputs.push(data.inputs[idx]);\n      balanced.outputs.push(data.outputs[idx]);\n      balanced.labels!.push(label);\n      \n      if (data.weights && balanced.weights) {\n        balanced.weights.push(data.weights[idx]);\n      }\n    }\n  }\n  \n  return balanced;\n}\n\nfunction preprocessTrainingData(data: TrainingData): TrainingData {\n  // Apply preprocessing transformations\n  const processed: TrainingData = {\n    ...data,\n    inputs: data.inputs.map(input => normalizeInput(input)),\n    outputs: data.outputs.map(output => normalizeOutput(output)),\n  };\n  \n  return processed;\n}\n\nfunction normalizeInput(input: any): any {\n  // Normalize input data\n  // Placeholder - actual implementation would depend on data type\n  return input;\n}\n\nfunction normalizeOutput(output: any): any {\n  // Normalize output data\n  // Placeholder - actual implementation would depend on data type\n  return output;\n}\n\nasync function updateModelPerformance(\n  modelId: string,\n  accuracy: number,\n  context: AgenticHookContext\n): Promise<void> {\n  const perfKey = `model:performance:${modelId}`;\n  const history = await context.memory.cache.get(perfKey) || [];\n  \n  history.push({\n    accuracy,\n    timestamp: Date.now(),\n    sessionId: context.sessionId,\n  });\n  \n  // Keep last 100 performance records\n  if (history.length > 100) {\n    history.shift();\n  }\n  \n  await context.memory.cache.set(perfKey, history);\n}\n\nasync function evaluateModelPromotion(\n  modelId: string,\n  accuracy: number,\n  context: AgenticHookContext\n): Promise<boolean> {\n  // Check if model should be promoted to production\n  const perfKey = `model:performance:${modelId}`;\n  const history = await context.memory.cache.get(perfKey) || [];\n  \n  if (history.length < 10) {\n    return false; // Not enough history\n  }\n  \n  // Calculate average accuracy over last 10 runs\n  const recent = history.slice(-10);\n  const avgAccuracy = recent.reduce((sum: number, h: any) => \n    sum + h.accuracy, 0\n  ) / recent.length;\n  \n  // Promote if consistently above threshold\n  return avgAccuracy > 0.85 && accuracy > 0.85;\n}\n\nasync function extractLearnedPatterns(\n  modelId: string,\n  context: AgenticHookContext\n): Promise<Pattern[]> {\n  // Extract patterns learned during training\n  // Placeholder implementation\n  return [];\n}\n\nfunction calculatePatternSignificance(pattern: Pattern): number {\n  // Calculate pattern significance score\n  const baseScore = pattern.confidence;\n  const occurrenceBonus = Math.min(pattern.occurrences / 100, 0.2);\n  \n  return Math.min(baseScore + occurrenceBonus, 1.0);\n}\n\nasync function generateAdaptation(\n  pattern: Pattern,\n  context: AgenticHookContext\n): Promise<Adaptation | null> {\n  // Generate adaptation based on pattern\n  if (pattern.type === 'failure' && pattern.confidence > 0.8) {\n    return {\n      type: 'parameter',\n      target: 'learning_rate',\n      oldValue: context.neural.training.learningRate,\n      newValue: context.neural.training.learningRate * 0.9,\n      reason: `High confidence failure pattern detected: ${pattern.id}`,\n      impact: -0.1,\n    };\n  }\n  \n  if (pattern.type === 'optimization' && pattern.confidence > 0.9) {\n    return {\n      type: 'strategy',\n      target: 'batch_size',\n      oldValue: 32,\n      newValue: 64,\n      reason: `Optimization opportunity detected: ${pattern.id}`,\n      impact: 0.2,\n    };\n  }\n  \n  return null;\n}\n\nfunction findPatternCombinations(\n  patterns: Pattern[],\n  context: AgenticHookContext\n): Array<{ patterns: Pattern[]; significance: number }> {\n  const combinations: Array<{ patterns: Pattern[]; significance: number }> = [];\n  \n  // Find co-occurring patterns\n  for (let i = 0; i < patterns.length; i++) {\n    for (let j = i + 1; j < patterns.length; j++) {\n      const pattern1 = patterns[i];\n      const pattern2 = patterns[j];\n      \n      // Check if patterns are related\n      if (areRelatedPatterns(pattern1, pattern2)) {\n        const significance = \n          (pattern1.confidence + pattern2.confidence) / 2 * 1.2;\n        \n        combinations.push({\n          patterns: [pattern1, pattern2],\n          significance: Math.min(significance, 1.0),\n        });\n      }\n    }\n  }\n  \n  return combinations;\n}\n\nfunction areRelatedPatterns(p1: Pattern, p2: Pattern): boolean {\n  // Check if patterns are related\n  // Simplified implementation\n  return p1.type === p2.type || \n    Object.keys(p1.context).some(key => key in p2.context);\n}\n\nasync function generateAlternatives(\n  input: any,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<Array<{ output: any; confidence: number }>> {\n  // Generate alternative predictions\n  // Placeholder implementation\n  return [];\n}\n\nfunction validateAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): boolean {\n  // Validate adaptation is safe to apply\n  if (Math.abs(adaptation.impact) > 0.5) {\n    // Large impact adaptations need more validation\n    return context.neural.training.epoch > 10;\n  }\n  \n  return true;\n}\n\nasync function applyParameterAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply parameter adaptation\n  // Placeholder implementation\n}\n\nasync function applyArchitectureAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply architecture adaptation\n  // Placeholder implementation\n}\n\nasync function applyStrategyAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply strategy adaptation\n  // Placeholder implementation\n}\n\nasync function loadHistoricalPatterns(\n  modelId: string,\n  context: AgenticHookContext\n): Promise<Pattern[]> {\n  // Load historical patterns\n  const patterns: Pattern[] = [];\n  \n  // Get recent patterns from memory\n  const patternKeys = await context.memory.cache.get(`patterns:${modelId}`) || [];\n  \n  for (const key of patternKeys.slice(-100)) {\n    const pattern = await context.memory.cache.get(key);\n    if (pattern) {\n      patterns.push(pattern);\n    }\n  }\n  \n  return patterns;\n}\n\n// ===== Register Hooks =====\n\nexport function registerNeuralHooks(): void {\n  agenticHookManager.register(preNeuralTrainHook);\n  agenticHookManager.register(postNeuralTrainHook);\n  agenticHookManager.register(neuralPatternDetectedHook);\n  agenticHookManager.register(neuralPredictionHook);\n  agenticHookManager.register(neuralAdaptationHook);\n}"],
  "mappings": "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",
  "names": []
}
