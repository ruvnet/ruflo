{"version":3,"sources":["../../../../../src/verification/tests/mocks/false-reporting-scenarios.test.ts"],"sourcesContent":["/**\r\n * Mock Agent Scenarios for False Reporting Detection Tests\r\n * \r\n * Tests various scenarios where agents might provide false or misleading reports:\r\n * - Intentional false claims about task completion\r\n * - Exaggerated performance improvements\r\n * - Hidden failures in implementation\r\n * - Inconsistent reporting between agents\r\n * - Fabricated test results and evidence\r\n */\r\n\r\nimport { jest } from '@jest/globals';\r\nimport { EventEmitter } from 'events';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport * as os from 'os';\r\n\r\n// Import verification components\r\n// Dynamic import for CommonJS module\r\nimport { createRequire } from 'module';\r\nconst require = createRequire(import.meta.url);\r\nconst TruthScoreCalc = require('../../../../.claude/helpers/truth-score.js');\r\n\r\ninterface MockAgent {\r\n  id: string;\r\n  type: string;\r\n  deceptionLevel: number; // 0 = honest, 1 = completely deceptive\r\n  deceptionStrategy: DeceptionStrategy;\r\n  behaviorPattern: BehaviorPattern;\r\n  reportHistory: AgentReport[];\r\n  detectedAs: 'honest' | 'suspicious' | 'deceptive' | 'unknown';\r\n}\r\n\r\ninterface DeceptionStrategy {\r\n  type: 'overconfident' | 'fabrication' | 'selective_reporting' | 'gaslighting' | 'collusion';\r\n  parameters: Record<string, any>;\r\n}\r\n\r\ninterface BehaviorPattern {\r\n  consistency: number; // 0-1, how consistent the agent's reports are\r\n  timeToReport: number; // Average time to submit reports (ms)\r\n  detailLevel: number; // 0-1, how detailed the reports are\r\n  evidenceQuality: number; // 0-1, quality of evidence provided\r\n}\r\n\r\ninterface AgentReport {\r\n  id: string;\r\n  agentId: string;\r\n  taskId: string;\r\n  claimedOutcome: TaskOutcome;\r\n  evidence: any;\r\n  timestamp: number;\r\n  truthScore?: number;\r\n  verified: boolean;\r\n  conflicts: string[];\r\n}\r\n\r\ninterface TaskOutcome {\r\n  success: boolean;\r\n  testsPass: boolean;\r\n  noErrors: boolean;\r\n  performance: {\r\n    improvement: number;\r\n    metrics: Record<string, number>;\r\n  };\r\n  quality: {\r\n    codeQuality: number;\r\n    documentation: number;\r\n    maintainability: number;\r\n  };\r\n}\r\n\r\ninterface VerificationResult {\r\n  reportId: string;\r\n  agentId: string;\r\n  truthScore: number;\r\n  deceptionDetected: boolean;\r\n  deceptionType: string[];\r\n  confidence: number;\r\n  evidence: any;\r\n  recommendations: string[];\r\n}\r\n\r\ndescribe('False Reporting Detection Scenarios', () => {\r\n  let tempDir: string;\r\n  let truthCalculator: any;\r\n  let deceptionDetector: DeceptionDetector;\r\n  let mockAgents: Map<string, MockAgent>;\r\n\r\n  beforeEach(async () => {\r\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'false-reporting-test-'));\r\n\r\n    // Setup truth score calculator\r\n    truthCalculator = new TruthScoreCalc();\r\n    truthCalculator.configPath = path.join(tempDir, 'verification.json');\r\n    truthCalculator.memoryPath = path.join(tempDir, 'truth-scores');\r\n    await truthCalculator.init();\r\n    \r\n    // Setup deception detector\r\n    deceptionDetector = new DeceptionDetector(truthCalculator, tempDir);\r\n    await deceptionDetector.initialize();\r\n    \r\n    // Create mock agents with different deception strategies\r\n    mockAgents = new Map();\r\n    await createMockAgentScenarios();\r\n  });\r\n\r\n  afterEach(async () => {\r\n    await fs.rm(tempDir, { recursive: true, force: true });\r\n  });\r\n\r\n  async function createMockAgentScenarios() {\r\n    const agentConfigs = [\r\n      // Honest baseline agent\r\n      {\r\n        id: 'honest-agent-001',\r\n        type: 'coder',\r\n        deceptionLevel: 0,\r\n        deceptionStrategy: { type: 'overconfident', parameters: {} },\r\n        behaviorPattern: {\r\n          consistency: 0.95,\r\n          timeToReport: 5000,\r\n          detailLevel: 0.8,\r\n          evidenceQuality: 0.9\r\n        }\r\n      },\r\n      // Overconfident agent\r\n      {\r\n        id: 'overconfident-agent-002',\r\n        type: 'coder',\r\n        deceptionLevel: 0.3,\r\n        deceptionStrategy: {\r\n          type: 'overconfident',\r\n          parameters: { confidenceMultiplier: 1.5, hideMinorIssues: true }\r\n        },\r\n        behaviorPattern: {\r\n          consistency: 0.7,\r\n          timeToReport: 3000,\r\n          detailLevel: 0.6,\r\n          evidenceQuality: 0.7\r\n        }\r\n      },\r\n      // Fabricating agent\r\n      {\r\n        id: 'fabricating-agent-003',\r\n        type: 'tester',\r\n        deceptionLevel: 0.8,\r\n        deceptionStrategy: {\r\n          type: 'fabrication',\r\n          parameters: { fabricateResults: true, fakePassRate: 0.95 }\r\n        },\r\n        behaviorPattern: {\r\n          consistency: 0.4,\r\n          timeToReport: 1000, // Reports very quickly (suspicious)\r\n          detailLevel: 0.9, // High detail to seem legitimate\r\n          evidenceQuality: 0.3 // Low quality evidence\r\n        }\r\n      },\r\n      // Selective reporting agent\r\n      {\r\n        id: 'selective-agent-004',\r\n        type: 'reviewer',\r\n        deceptionLevel: 0.5,\r\n        deceptionStrategy: {\r\n          type: 'selective_reporting',\r\n          parameters: { reportOnlyPositives: true, hideFailures: true }\r\n        },\r\n        behaviorPattern: {\r\n          consistency: 0.8,\r\n          timeToReport: 7000,\r\n          detailLevel: 0.5,\r\n          evidenceQuality: 0.6\r\n        }\r\n      },\r\n      // Gaslighting agent\r\n      {\r\n        id: 'gaslighting-agent-005',\r\n        type: 'coordinator',\r\n        deceptionLevel: 0.9,\r\n        deceptionStrategy: {\r\n          type: 'gaslighting',\r\n          parameters: { contradictOthers: true, rewriteHistory: true }\r\n        },\r\n        behaviorPattern: {\r\n          consistency: 0.2,\r\n          timeToReport: 4000,\r\n          detailLevel: 0.7,\r\n          evidenceQuality: 0.4\r\n        }\r\n      }\r\n    ];\r\n\r\n    for (const config of agentConfigs) {\r\n      const agent = createMockAgent(config);\r\n      mockAgents.set(config.id, agent);\r\n    }\r\n  }\r\n\r\n  function createMockAgent(config: any): MockAgent {\r\n    return {\r\n      id: config.id,\r\n      type: config.type,\r\n      deceptionLevel: config.deceptionLevel,\r\n      deceptionStrategy: config.deceptionStrategy,\r\n      behaviorPattern: config.behaviorPattern,\r\n      reportHistory: [],\r\n      detectedAs: 'unknown'\r\n    };\r\n  }\r\n\r\n  describe('Overconfident Agent Scenarios', () => {\r\n    test('should detect agent consistently overestimating success rates', async () => {\r\n      const agent = mockAgents.get('overconfident-agent-002')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate series of overconfident reports\r\n      for (let i = 0; i < 20; i++) {\r\n        const actualSuccess = Math.random() > 0.3; // 70% actual success rate\r\n        const claimedSuccess = actualSuccess || Math.random() > 0.2; // Claims 94% success rate\r\n\r\n        const report = generateReport(agent, `task-${i}`, {\r\n          actualOutcome: {\r\n            success: actualSuccess,\r\n            testsPass: actualSuccess,\r\n            noErrors: actualSuccess,\r\n            performance: { improvement: Math.random() * 0.2, metrics: {} },\r\n            quality: { codeQuality: Math.random() * 0.3 + 0.4, documentation: 0.5, maintainability: 0.6 }\r\n          },\r\n          claimedOutcome: {\r\n            success: claimedSuccess,\r\n            testsPass: claimedSuccess,\r\n            noErrors: claimedSuccess,\r\n            performance: { improvement: Math.random() * 0.3 + 0.2, metrics: {} }, // Exaggerated\r\n            quality: { codeQuality: Math.random() * 0.2 + 0.8, documentation: 0.9, maintainability: 0.9 }\r\n          }\r\n        });\r\n\r\n        reports.push(report);\r\n        agent.reportHistory.push(report);\r\n      }\r\n\r\n      // Analyze pattern for deception\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('overconfidence');\r\n      expect(analysis.confidence).toBeGreaterThan(0.7);\r\n      expect(analysis.truthScore).toBeLessThan(0.6);\r\n\r\n      // Check specific indicators\r\n      expect(analysis.evidence.successRateDiscrepancy).toBeGreaterThan(0.15);\r\n      expect(analysis.evidence.performanceExaggeration).toBeGreaterThan(0.1);\r\n      expect(analysis.recommendations).toContain('Implement additional verification for this agent');\r\n    });\r\n\r\n    test('should detect pattern of hiding minor issues', async () => {\r\n      const agent = mockAgents.get('overconfident-agent-002')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate reports where agent hides minor issues\r\n      for (let i = 0; i < 15; i++) {\r\n        const minorIssues = Math.floor(Math.random() * 5) + 1; // 1-5 minor issues\r\n        const majorIssues = Math.random() > 0.8 ? 1 : 0; // Occasional major issue\r\n\r\n        const report = generateReport(agent, `minor-issues-task-${i}`, {\r\n          actualOutcome: {\r\n            success: majorIssues === 0,\r\n            testsPass: true,\r\n            noErrors: false, // Has minor errors\r\n            performance: { improvement: 0.1, metrics: { minorIssues, majorIssues } },\r\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\r\n          },\r\n          claimedOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true, // Claims no errors\r\n            performance: { improvement: 0.15, metrics: { minorIssues: 0, majorIssues: 0 } },\r\n            quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\r\n          }\r\n        });\r\n\r\n        reports.push(report);\r\n        agent.reportHistory.push(report);\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('issue_hiding');\r\n      expect(analysis.evidence.hiddenIssuesCount).toBeGreaterThan(10);\r\n      expect(analysis.recommendations).toContain('Require detailed issue reporting');\r\n    });\r\n  });\r\n\r\n  describe('Evidence Fabrication Scenarios', () => {\r\n    test('should detect fabricated test results', async () => {\r\n      const agent = mockAgents.get('fabricating-agent-003')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate reports with fabricated test results\r\n      for (let i = 0; i < 25; i++) {\r\n        const actualTestResults = {\r\n          total: 100,\r\n          passed: Math.floor(Math.random() * 30) + 60, // 60-90% pass rate\r\n          failed: 0,\r\n          skipped: 0\r\n        };\r\n        actualTestResults.failed = actualTestResults.total - actualTestResults.passed;\r\n\r\n        const fabricatedResults = {\r\n          total: 100,\r\n          passed: Math.floor(Math.random() * 5) + 95, // 95-100% pass rate\r\n          failed: 0,\r\n          skipped: 0\r\n        };\r\n        fabricatedResults.failed = fabricatedResults.total - fabricatedResults.passed;\r\n\r\n        const report = generateReport(agent, `fabrication-task-${i}`, {\r\n          actualOutcome: {\r\n            success: actualTestResults.passed > 80,\r\n            testsPass: actualTestResults.passed === actualTestResults.total,\r\n            noErrors: false,\r\n            performance: { improvement: 0.05, metrics: actualTestResults },\r\n            quality: { codeQuality: 0.6, documentation: 0.5, maintainability: 0.6 }\r\n          },\r\n          claimedOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.15, metrics: fabricatedResults },\r\n            quality: { codeQuality: 0.95, documentation: 0.9, maintainability: 0.95 }\r\n          },\r\n          evidence: {\r\n            testResults: fabricatedResults,\r\n            executionTime: Math.random() * 100 + 50, // Suspiciously consistent timing\r\n            testLogs: generateFakeTestLogs(fabricatedResults)\r\n          }\r\n        });\r\n\r\n        reports.push(report);\r\n        agent.reportHistory.push(report);\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('fabrication');\r\n      expect(analysis.deceptionType).toContain('unrealistic_results');\r\n      expect(analysis.confidence).toBeGreaterThan(0.8);\r\n\r\n      // Check fabrication indicators\r\n      expect(analysis.evidence.unrealisticSuccessRate).toBe(true);\r\n      expect(analysis.evidence.suspiciouslyFastReporting).toBe(true);\r\n      expect(analysis.evidence.evidenceInconsistency).toBeGreaterThan(0.5);\r\n    });\r\n\r\n    test('should detect impossible performance improvements', async () => {\r\n      const agent = mockAgents.get('fabricating-agent-003')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate reports with impossible performance claims\r\n      for (let i = 0; i < 10; i++) {\r\n        const report = generateReport(agent, `impossible-perf-task-${i}`, {\r\n          actualOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: {\r\n              improvement: Math.random() * 0.1 + 0.05, // 5-15% actual improvement\r\n              metrics: {\r\n                responseTime: 1000,\r\n                throughput: 100,\r\n                memoryUsage: 500\r\n              }\r\n            },\r\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\r\n          },\r\n          claimedOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: {\r\n              improvement: Math.random() * 0.5 + 0.8, // 80-130% claimed improvement (impossible)\r\n              metrics: {\r\n                responseTime: 100, // 10x improvement\r\n                throughput: 1000, // 10x improvement\r\n                memoryUsage: 50 // 10x improvement\r\n              }\r\n            },\r\n            quality: { codeQuality: 0.99, documentation: 0.99, maintainability: 0.99 }\r\n          }\r\n        });\r\n\r\n        reports.push(report);\r\n        agent.reportHistory.push(report);\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('impossible_claims');\r\n      expect(analysis.evidence.impossiblePerformanceGains).toBe(true);\r\n      expect(analysis.recommendations).toContain('Require third-party verification for performance claims');\r\n    });\r\n  });\r\n\r\n  describe('Selective Reporting Scenarios', () => {\r\n    test('should detect agent that only reports successes', async () => {\r\n      const agent = mockAgents.get('selective-agent-004')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate mixed actual outcomes but agent only reports successes\r\n      const actualOutcomes = [];\r\n      for (let i = 0; i < 30; i++) {\r\n        const success = Math.random() > 0.4; // 60% actual success rate\r\n        actualOutcomes.push(success);\r\n\r\n        // Agent only reports the successful ones\r\n        if (success || Math.random() > 0.9) { // Reports 90% of successes, 10% of failures\r\n          const report = generateReport(agent, `selective-task-${i}`, {\r\n            actualOutcome: {\r\n              success,\r\n              testsPass: success,\r\n              noErrors: success,\r\n              performance: { improvement: success ? 0.1 : -0.05, metrics: {} },\r\n              quality: { codeQuality: success ? 0.8 : 0.4, documentation: 0.6, maintainability: 0.7 }\r\n            },\r\n            claimedOutcome: {\r\n              success: true, // Always claims success\r\n              testsPass: true,\r\n              noErrors: true,\r\n              performance: { improvement: 0.12, metrics: {} },\r\n              quality: { codeQuality: 0.85, documentation: 0.8, maintainability: 0.8 }\r\n            }\r\n          });\r\n\r\n          reports.push(report);\r\n          agent.reportHistory.push(report);\r\n        }\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('selective_reporting');\r\n      expect(analysis.evidence.missingFailureReports).toBe(true);\r\n      expect(analysis.evidence.suspiciousSuccessRate).toBeGreaterThan(0.95);\r\n      expect(analysis.recommendations).toContain('Mandatory reporting of all task outcomes');\r\n    });\r\n\r\n    test('should detect cherry-picked metrics reporting', async () => {\r\n      const agent = mockAgents.get('selective-agent-004')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate reports where agent only reports favorable metrics\r\n      for (let i = 0; i < 20; i++) {\r\n        const fullMetrics = {\r\n          responseTime: Math.random() * 1000 + 500, // 500-1500ms\r\n          throughput: Math.random() * 200 + 50, // 50-250 rps\r\n          memoryUsage: Math.random() * 800 + 200, // 200-1000MB\r\n          errorRate: Math.random() * 0.1, // 0-10% errors\r\n          cpuUsage: Math.random() * 100, // 0-100% CPU\r\n          diskIO: Math.random() * 1000 // 0-1000 IOPS\r\n        };\r\n\r\n        // Agent only reports the best 2-3 metrics\r\n        const favorableMetrics = Object.entries(fullMetrics)\r\n          .sort(([keyA, valueA], [keyB, valueB]) => {\r\n            // Sort by how \"good\" the metric looks (lower is better for most)\r\n            const goodValues = { responseTime: -valueA, errorRate: -valueA, default: valueB };\r\n            return (goodValues[keyA] || goodValues.default) - (goodValues[keyB] || goodValues.default);\r\n          })\r\n          .slice(0, 3)\r\n          .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});\r\n\r\n        const report = generateReport(agent, `cherry-pick-task-${i}`, {\r\n          actualOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: fullMetrics.errorRate < 0.05,\r\n            performance: { improvement: 0.05, metrics: fullMetrics },\r\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\r\n          },\r\n          claimedOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.15, metrics: favorableMetrics },\r\n            quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\r\n          }\r\n        });\r\n\r\n        reports.push(report);\r\n        agent.reportHistory.push(report);\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('cherry_picking');\r\n      expect(analysis.evidence.incompleteMetricsReporting).toBe(true);\r\n      expect(analysis.recommendations).toContain('Require comprehensive metrics reporting');\r\n    });\r\n  });\r\n\r\n  describe('Gaslighting and Manipulation Scenarios', () => {\r\n    test('should detect agent contradicting previous statements', async () => {\r\n      const agent = mockAgents.get('gaslighting-agent-005')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate contradictory reports about the same tasks\r\n      const taskIds = Array.from({ length: 5 }, (_, i) => `contradiction-task-${i}`);\r\n\r\n      for (const taskId of taskIds) {\r\n        // First report - claims failure\r\n        const firstReport = generateReport(agent, taskId, {\r\n          actualOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.1, metrics: {} },\r\n            quality: { codeQuality: 0.8, documentation: 0.7, maintainability: 0.8 }\r\n          },\r\n          claimedOutcome: {\r\n            success: false,\r\n            testsPass: false,\r\n            noErrors: false,\r\n            performance: { improvement: -0.05, metrics: {} },\r\n            quality: { codeQuality: 0.4, documentation: 0.3, maintainability: 0.5 }\r\n          },\r\n          timestamp: Date.now()\r\n        });\r\n\r\n        // Second report - claims success for same task\r\n        const secondReport = generateReport(agent, taskId, {\r\n          actualOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.1, metrics: {} },\r\n            quality: { codeQuality: 0.8, documentation: 0.7, maintainability: 0.8 }\r\n          },\r\n          claimedOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.2, metrics: {} },\r\n            quality: { codeQuality: 0.95, documentation: 0.9, maintainability: 0.95 }\r\n          },\r\n          timestamp: Date.now() + 60000 // 1 minute later\r\n        });\r\n\r\n        reports.push(firstReport, secondReport);\r\n        agent.reportHistory.push(firstReport, secondReport);\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('gaslighting');\r\n      expect(analysis.deceptionType).toContain('contradictory_statements');\r\n      expect(analysis.evidence.contradictionCount).toBeGreaterThan(3);\r\n      expect(analysis.recommendations).toContain('Implement immutable audit trail for agent reports');\r\n    });\r\n\r\n    test('should detect agent attempting to discredit other agents', async () => {\r\n      const gaslightingAgent = mockAgents.get('gaslighting-agent-005')!;\r\n      const honestAgent = mockAgents.get('honest-agent-001')!;\r\n      const reports: AgentReport[] = [];\r\n\r\n      // Generate scenario where gaslighting agent contradicts honest agent\r\n      for (let i = 0; i < 10; i++) {\r\n        const taskId = `discredit-task-${i}`;\r\n\r\n        // Honest agent reports realistic outcome\r\n        const honestReport = generateReport(honestAgent, taskId, {\r\n          actualOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.08, metrics: {} },\r\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\r\n          },\r\n          claimedOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.08, metrics: {} },\r\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\r\n          }\r\n        });\r\n\r\n        // Gaslighting agent contradicts with false negative report\r\n        const gaslightingReport = generateReport(gaslightingAgent, taskId, {\r\n          actualOutcome: {\r\n            success: true,\r\n            testsPass: true,\r\n            noErrors: true,\r\n            performance: { improvement: 0.08, metrics: {} },\r\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\r\n          },\r\n          claimedOutcome: {\r\n            success: false,\r\n            testsPass: false,\r\n            noErrors: false,\r\n            performance: { improvement: -0.1, metrics: {} },\r\n            quality: { codeQuality: 0.3, documentation: 0.2, maintainability: 0.4 }\r\n          },\r\n          evidence: {\r\n            contradicts: honestReport.id,\r\n            claimsOtherAgentWrong: true\r\n          }\r\n        });\r\n\r\n        reports.push(honestReport, gaslightingReport);\r\n        gaslightingAgent.reportHistory.push(gaslightingReport);\r\n      }\r\n\r\n      const analysis = await deceptionDetector.analyzeAgentPattern(gaslightingAgent.id, reports);\r\n\r\n      expect(analysis.deceptionDetected).toBe(true);\r\n      expect(analysis.deceptionType).toContain('discrediting_others');\r\n      expect(analysis.evidence.contradictionsWithOtherAgents).toBeGreaterThan(7);\r\n      expect(analysis.evidence.systematicDisagreement).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Collusion Detection', () => {\r\n    test('should detect agents colluding to hide failures', async () => {\r\n      const colludingAgents = [\r\n        mockAgents.get('overconfident-agent-002')!,\r\n        mockAgents.get('selective-agent-004')!\r\n      ];\r\n\r\n      const reports: AgentReport[] = [];\r\n      const sharedFailures = ['shared-failure-1', 'shared-failure-2', 'shared-failure-3'];\r\n\r\n      // Generate coordinated false reports\r\n      for (const taskId of sharedFailures) {\r\n        for (const agent of colludingAgents) {\r\n          const report = generateReport(agent, taskId, {\r\n            actualOutcome: {\r\n              success: false,\r\n              testsPass: false,\r\n              noErrors: false,\r\n              performance: { improvement: -0.05, metrics: {} },\r\n              quality: { codeQuality: 0.3, documentation: 0.2, maintainability: 0.4 }\r\n            },\r\n            claimedOutcome: {\r\n              success: true,\r\n              testsPass: true,\r\n              noErrors: true,\r\n              performance: { improvement: 0.15, metrics: {} },\r\n              quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\r\n            },\r\n            evidence: {\r\n              crossReferencedWith: colludingAgents.map(a => a.id).filter(id => id !== agent.id)\r\n            }\r\n          });\r\n\r\n          reports.push(report);\r\n          agent.reportHistory.push(report);\r\n        }\r\n      }\r\n\r\n      // Analyze for collusion patterns\r\n      const collusionAnalysis = await deceptionDetector.analyzeCollusionPatterns(\r\n        colludingAgents.map(a => a.id),\r\n        reports\r\n      );\r\n\r\n      expect(collusionAnalysis.collusionDetected).toBe(true);\r\n      expect(collusionAnalysis.collusionType).toContain('coordinated_false_reporting');\r\n      expect(collusionAnalysis.confidence).toBeGreaterThan(0.7);\r\n      expect(collusionAnalysis.evidence.synchronizedReporting).toBe(true);\r\n      expect(collusionAnalysis.evidence.identicalFalseClaims).toBeGreaterThan(2);\r\n    });\r\n  });\r\n\r\n  // Helper functions\r\n  function generateReport(\r\n    agent: MockAgent,\r\n    taskId: string,\r\n    scenario: {\r\n      actualOutcome: TaskOutcome;\r\n      claimedOutcome: TaskOutcome;\r\n      evidence?: any;\r\n      timestamp?: number;\r\n    }\r\n  ): AgentReport {\r\n    const reportId = `report-${Date.now()}-${Math.random()}`;\r\n    \r\n    // Apply agent's deception strategy\r\n    const modifiedClaim = applyDeceptionStrategy(agent, scenario.claimedOutcome);\r\n    \r\n    // Generate evidence based on agent's behavior pattern\r\n    const evidence = generateEvidence(agent, scenario.actualOutcome, modifiedClaim, scenario.evidence);\r\n\r\n    return {\r\n      id: reportId,\r\n      agentId: agent.id,\r\n      taskId,\r\n      claimedOutcome: modifiedClaim,\r\n      evidence,\r\n      timestamp: scenario.timestamp || Date.now(),\r\n      verified: false,\r\n      conflicts: []\r\n    };\r\n  }\r\n\r\n  function applyDeceptionStrategy(agent: MockAgent, claimedOutcome: TaskOutcome): TaskOutcome {\r\n    const strategy = agent.deceptionStrategy;\r\n    const deceptionLevel = agent.deceptionLevel;\r\n    const modified = JSON.parse(JSON.stringify(claimedOutcome));\r\n\r\n    switch (strategy.type) {\r\n      case 'overconfident':\r\n        if (strategy.parameters.confidenceMultiplier) {\r\n          modified.performance.improvement *= strategy.parameters.confidenceMultiplier;\r\n          modified.quality.codeQuality = Math.min(1, modified.quality.codeQuality * 1.2);\r\n        }\r\n        if (strategy.parameters.hideMinorIssues) {\r\n          modified.noErrors = true;\r\n        }\r\n        break;\r\n\r\n      case 'fabrication':\r\n        if (strategy.parameters.fabricateResults) {\r\n          modified.success = true;\r\n          modified.testsPass = true;\r\n          modified.performance.improvement = Math.random() * 0.5 + 0.3;\r\n        }\r\n        break;\r\n\r\n      case 'selective_reporting':\r\n        if (strategy.parameters.reportOnlyPositives && !modified.success) {\r\n          return null; // Don't report failures\r\n        }\r\n        break;\r\n\r\n      case 'gaslighting':\r\n        // Randomly flip outcomes to create contradictions\r\n        if (Math.random() < deceptionLevel * 0.5) {\r\n          modified.success = !modified.success;\r\n          modified.testsPass = !modified.testsPass;\r\n        }\r\n        break;\r\n    }\r\n\r\n    return modified;\r\n  }\r\n\r\n  function generateEvidence(\r\n    agent: MockAgent,\r\n    actualOutcome: TaskOutcome,\r\n    claimedOutcome: TaskOutcome,\r\n    additionalEvidence?: any\r\n  ): any {\r\n    const evidence: any = {\r\n      ...additionalEvidence,\r\n      reportingTime: agent.behaviorPattern.timeToReport + (Math.random() - 0.5) * 1000,\r\n      detailLevel: agent.behaviorPattern.detailLevel,\r\n      evidenceQuality: agent.behaviorPattern.evidenceQuality\r\n    };\r\n\r\n    // Add inconsistencies based on deception level\r\n    if (agent.deceptionLevel > 0.5) {\r\n      evidence.inconsistencies = [\r\n        'Test logs don\\'t match reported results',\r\n        'Performance metrics seem unrealistic',\r\n        'Evidence quality unusually low'\r\n      ];\r\n    }\r\n\r\n    return evidence;\r\n  }\r\n\r\n  function generateFakeTestLogs(testResults: any): string {\r\n    // Generate fake test logs that look real but have inconsistencies\r\n    const logs = [];\r\n    logs.push(`Running ${testResults.total} tests...`);\r\n    logs.push(`PASS: ${testResults.passed} tests`);\r\n    if (testResults.failed > 0) {\r\n      logs.push(`FAIL: ${testResults.failed} tests`);\r\n    }\r\n    logs.push('All tests completed successfully!'); // Contradictory message\r\n    return logs.join('\\n');\r\n  }\r\n});\r\n\r\n// Mock Deception Detector Implementation\r\nclass DeceptionDetector {\r\n  private truthCalculator: any;\r\n  private dataPath: string;\r\n  private behaviorProfiles: Map<string, any> = new Map();\r\n\r\n  constructor(truthCalculator: any, dataPath: string) {\r\n    this.truthCalculator = truthCalculator;\r\n    this.dataPath = dataPath;\r\n  }\r\n\r\n  async initialize() {\r\n    await fs.mkdir(path.join(this.dataPath, 'deception-analysis'), { recursive: true });\r\n  }\r\n\r\n  async analyzeAgentPattern(agentId: string, reports: AgentReport[]): Promise<VerificationResult> {\r\n    const analysis = {\r\n      reportId: `analysis-${agentId}`,\r\n      agentId,\r\n      truthScore: 0,\r\n      deceptionDetected: false,\r\n      deceptionType: [],\r\n      confidence: 0,\r\n      evidence: {},\r\n      recommendations: []\r\n    };\r\n\r\n    // Calculate truth scores for all reports\r\n    const truthScores = reports.map(report => {\r\n      return this.calculateReportTruthScore(report);\r\n    });\r\n\r\n    analysis.truthScore = truthScores.reduce((sum, score) => sum + score, 0) / truthScores.length;\r\n\r\n    // Detect overconfidence pattern\r\n    const successClaimRate = reports.filter(r => r.claimedOutcome.success).length / reports.length;\r\n    const avgTruthScore = analysis.truthScore;\r\n    \r\n    if (successClaimRate > 0.9 && avgTruthScore < 0.7) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('overconfidence');\r\n      analysis.evidence.successRateDiscrepancy = successClaimRate - avgTruthScore;\r\n    }\r\n\r\n    // Detect issue hiding\r\n    const hiddenIssues = reports.filter(r => \r\n      r.claimedOutcome.noErrors && r.evidence?.inconsistencies?.length > 0\r\n    ).length;\r\n    \r\n    if (hiddenIssues > reports.length * 0.5) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('issue_hiding');\r\n      analysis.evidence.hiddenIssuesCount = hiddenIssues;\r\n    }\r\n\r\n    // Detect fabrication\r\n    const unrealisticResults = reports.filter(r => \r\n      r.claimedOutcome.performance.improvement > 0.5 || // >50% improvement\r\n      r.claimedOutcome.quality.codeQuality > 0.95 // >95% quality\r\n    ).length;\r\n\r\n    if (unrealisticResults > 0) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('fabrication', 'unrealistic_results');\r\n      analysis.evidence.unrealisticSuccessRate = true;\r\n    }\r\n\r\n    // Detect fast reporting (suspicious)\r\n    const avgReportingTime = reports.reduce((sum, r) => sum + (r.evidence?.reportingTime || 5000), 0) / reports.length;\r\n    if (avgReportingTime < 2000) {\r\n      analysis.evidence.suspiciouslyFastReporting = true;\r\n    }\r\n\r\n    // Detect impossible claims\r\n    const impossibleClaims = reports.filter(r =>\r\n      r.claimedOutcome.performance.improvement > 1.0 // >100% improvement\r\n    ).length;\r\n\r\n    if (impossibleClaims > 0) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('impossible_claims');\r\n      analysis.evidence.impossiblePerformanceGains = true;\r\n    }\r\n\r\n    // Detect selective reporting\r\n    const allSuccesses = reports.every(r => r.claimedOutcome.success);\r\n    if (allSuccesses && reports.length > 10) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('selective_reporting');\r\n      analysis.evidence.missingFailureReports = true;\r\n      analysis.evidence.suspiciousSuccessRate = 1.0;\r\n    }\r\n\r\n    // Detect cherry picking\r\n    const incompleteMetrics = reports.filter(r => {\r\n      const metrics = r.claimedOutcome.performance.metrics;\r\n      return Object.keys(metrics).length < 3; // Less than 3 metrics reported\r\n    }).length;\r\n\r\n    if (incompleteMetrics > reports.length * 0.7) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('cherry_picking');\r\n      analysis.evidence.incompleteMetricsReporting = true;\r\n    }\r\n\r\n    // Detect contradictions\r\n    const contradictions = this.detectContradictions(reports);\r\n    if (contradictions > 0) {\r\n      analysis.deceptionDetected = true;\r\n      analysis.deceptionType.push('gaslighting', 'contradictory_statements');\r\n      analysis.evidence.contradictionCount = contradictions;\r\n    }\r\n\r\n    // Calculate confidence\r\n    analysis.confidence = Math.min(1.0, analysis.deceptionType.length * 0.3 + (1 - analysis.truthScore));\r\n\r\n    // Generate recommendations\r\n    if (analysis.deceptionDetected) {\r\n      analysis.recommendations = this.generateRecommendations(analysis.deceptionType);\r\n    }\r\n\r\n    return analysis;\r\n  }\r\n\r\n  async analyzeCollusionPatterns(agentIds: string[], reports: AgentReport[]): Promise<any> {\r\n    const agentReports = new Map();\r\n    \r\n    // Group reports by agent\r\n    for (const report of reports) {\r\n      if (!agentReports.has(report.agentId)) {\r\n        agentReports.set(report.agentId, []);\r\n      }\r\n      agentReports.get(report.agentId).push(report);\r\n    }\r\n\r\n    // Look for synchronization patterns\r\n    const taskReports = new Map();\r\n    for (const report of reports) {\r\n      if (!taskReports.has(report.taskId)) {\r\n        taskReports.set(report.taskId, []);\r\n      }\r\n      taskReports.get(report.taskId).push(report);\r\n    }\r\n\r\n    let synchronizedReporting = 0;\r\n    let identicalFalseClaims = 0;\r\n\r\n    for (const [taskId, taskReportsArray] of taskReports) {\r\n      if (taskReportsArray.length > 1) {\r\n        // Check for synchronized timing\r\n        const timestamps = taskReportsArray.map(r => r.timestamp);\r\n        const maxTimestamp = Math.max(...timestamps);\r\n        const minTimestamp = Math.min(...timestamps);\r\n        \r\n        if (maxTimestamp - minTimestamp < 60000) { // Within 1 minute\r\n          synchronizedReporting++;\r\n        }\r\n\r\n        // Check for identical false claims\r\n        const claims = taskReportsArray.map(r => JSON.stringify(r.claimedOutcome));\r\n        const uniqueClaims = new Set(claims);\r\n        \r\n        if (uniqueClaims.size === 1 && taskReportsArray[0].claimedOutcome.success) {\r\n          // All agents claim same success - check if it's false\r\n          const avgTruthScore = taskReportsArray.reduce((sum, r) => \r\n            sum + this.calculateReportTruthScore(r), 0) / taskReportsArray.length;\r\n          \r\n          if (avgTruthScore < 0.5) {\r\n            identicalFalseClaims++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      collusionDetected: synchronizedReporting > 0 || identicalFalseClaims > 0,\r\n      collusionType: ['coordinated_false_reporting'],\r\n      confidence: Math.min(1.0, (synchronizedReporting + identicalFalseClaims) * 0.3),\r\n      evidence: {\r\n        synchronizedReporting: synchronizedReporting > 0,\r\n        identicalFalseClaims,\r\n        analysedTasks: taskReports.size,\r\n        involvedAgents: agentIds\r\n      }\r\n    };\r\n  }\r\n\r\n  private calculateReportTruthScore(report: AgentReport): number {\r\n    // Simplified truth score calculation\r\n    let score = 0.8; // Base score\r\n\r\n    // Penalize for inconsistencies\r\n    if (report.evidence?.inconsistencies?.length > 0) {\r\n      score -= report.evidence.inconsistencies.length * 0.1;\r\n    }\r\n\r\n    // Penalize for unrealistic claims\r\n    if (report.claimedOutcome.performance.improvement > 0.5) {\r\n      score -= 0.3;\r\n    }\r\n\r\n    if (report.claimedOutcome.quality.codeQuality > 0.95) {\r\n      score -= 0.2;\r\n    }\r\n\r\n    // Penalize for fast reporting\r\n    if (report.evidence?.reportingTime < 2000) {\r\n      score -= 0.1;\r\n    }\r\n\r\n    return Math.max(0, Math.min(1, score));\r\n  }\r\n\r\n  private detectContradictions(reports: AgentReport[]): number {\r\n    let contradictions = 0;\r\n    const taskReports = new Map();\r\n\r\n    // Group by task\r\n    for (const report of reports) {\r\n      if (!taskReports.has(report.taskId)) {\r\n        taskReports.set(report.taskId, []);\r\n      }\r\n      taskReports.get(report.taskId).push(report);\r\n    }\r\n\r\n    // Check for contradictory reports on same task\r\n    for (const [taskId, taskReportsArray] of taskReports) {\r\n      if (taskReportsArray.length > 1) {\r\n        for (let i = 0; i < taskReportsArray.length - 1; i++) {\r\n          const report1 = taskReportsArray[i];\r\n          const report2 = taskReportsArray[i + 1];\r\n          \r\n          if (report1.claimedOutcome.success !== report2.claimedOutcome.success) {\r\n            contradictions++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return contradictions;\r\n  }\r\n\r\n  private generateRecommendations(deceptionTypes: string[]): string[] {\r\n    const recommendations = [];\r\n\r\n    if (deceptionTypes.includes('overconfidence')) {\r\n      recommendations.push('Implement additional verification for this agent');\r\n      recommendations.push('Require independent validation of claims');\r\n    }\r\n\r\n    if (deceptionTypes.includes('fabrication')) {\r\n      recommendations.push('Require third-party verification for performance claims');\r\n      recommendations.push('Implement automated evidence validation');\r\n    }\r\n\r\n    if (deceptionTypes.includes('selective_reporting')) {\r\n      recommendations.push('Mandatory reporting of all task outcomes');\r\n      recommendations.push('Automated detection of missing reports');\r\n    }\r\n\r\n    if (deceptionTypes.includes('cherry_picking')) {\r\n      recommendations.push('Require comprehensive metrics reporting');\r\n      recommendations.push('Standardize required evidence formats');\r\n    }\r\n\r\n    if (deceptionTypes.includes('gaslighting')) {\r\n      recommendations.push('Implement immutable audit trail for agent reports');\r\n      recommendations.push('Enable cross-agent verification workflows');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n}"],"names":["fs","path","os","createRequire","require","url","TruthScoreCalc","describe","tempDir","truthCalculator","deceptionDetector","mockAgents","beforeEach","mkdtemp","join","tmpdir","configPath","memoryPath","init","DeceptionDetector","initialize","Map","createMockAgentScenarios","afterEach","rm","recursive","force","agentConfigs","id","type","deceptionLevel","deceptionStrategy","parameters","behaviorPattern","consistency","timeToReport","detailLevel","evidenceQuality","confidenceMultiplier","hideMinorIssues","fabricateResults","fakePassRate","reportOnlyPositives","hideFailures","contradictOthers","rewriteHistory","config","agent","createMockAgent","set","reportHistory","detectedAs","test","get","reports","i","actualSuccess","Math","random","claimedSuccess","report","generateReport","actualOutcome","success","testsPass","noErrors","performance","improvement","metrics","quality","codeQuality","documentation","maintainability","claimedOutcome","push","analysis","analyzeAgentPattern","expect","deceptionDetected","toBe","deceptionType","toContain","confidence","toBeGreaterThan","truthScore","toBeLessThan","evidence","successRateDiscrepancy","performanceExaggeration","recommendations","minorIssues","floor","majorIssues","hiddenIssuesCount","actualTestResults","total","passed","failed","skipped","fabricatedResults","testResults","executionTime","testLogs","generateFakeTestLogs","unrealisticSuccessRate","suspiciouslyFastReporting","evidenceInconsistency","responseTime","throughput","memoryUsage","impossiblePerformanceGains","actualOutcomes","missingFailureReports","suspiciousSuccessRate","fullMetrics","errorRate","cpuUsage","diskIO","favorableMetrics","Object","entries","sort","keyA","valueA","keyB","valueB","goodValues","default","slice","reduce","obj","key","value","incompleteMetricsReporting","taskIds","Array","from","length","_","taskId","firstReport","timestamp","Date","now","secondReport","contradictionCount","gaslightingAgent","honestAgent","honestReport","gaslightingReport","contradicts","claimsOtherAgentWrong","contradictionsWithOtherAgents","systematicDisagreement","colludingAgents","sharedFailures","crossReferencedWith","map","a","filter","collusionAnalysis","analyzeCollusionPatterns","collusionDetected","collusionType","synchronizedReporting","identicalFalseClaims","scenario","reportId","modifiedClaim","applyDeceptionStrategy","generateEvidence","agentId","verified","conflicts","strategy","modified","JSON","parse","stringify","min","additionalEvidence","reportingTime","inconsistencies","logs","dataPath","behaviorProfiles","mkdir","truthScores","calculateReportTruthScore","sum","score","successClaimRate","r","avgTruthScore","hiddenIssues","unrealisticResults","avgReportingTime","impossibleClaims","allSuccesses","every","incompleteMetrics","keys","contradictions","detectContradictions","generateRecommendations","agentIds","agentReports","has","taskReports","taskReportsArray","timestamps","maxTimestamp","max","minTimestamp","claims","uniqueClaims","Set","size","analysedTasks","involvedAgents","report1","report2","deceptionTypes","includes"],"mappings":"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"}