{
  "version": 3,
  "sources": ["../../src/core/logger.ts"],
  "sourcesContent": ["/**\n * Logging infrastructure for Claude-Flow\n */\n\nimport { promises as fs } from 'node:fs';\nimport * as path from 'node:path';\nimport { Buffer } from 'node:buffer';\nimport process from 'node:process';\nimport type { LoggingConfig } from '../utils/types.js';\nimport { formatBytes } from '../utils/helpers.js';\n\nexport interface ILogger {\n  debug(message: string, meta?: unknown): void;\n  info(message: string, meta?: unknown): void;\n  warn(message: string, meta?: unknown): void;\n  error(message: string, error?: unknown): void;\n  configure(config: LoggingConfig): Promise<void>;\n  level?: string;\n}\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\ninterface LogEntry {\n  timestamp: string;\n  level: string;\n  message: string;\n  context: Record<string, unknown>;\n  data?: unknown;\n  error?: unknown;\n}\n\n/**\n * Logger implementation with context support\n */\nexport class Logger implements ILogger {\n  private static instance: Logger;\n  private config: LoggingConfig;\n  private context: Record<string, unknown>;\n  private fileHandle?: fs.FileHandle;\n  private currentFileSize = 0;\n  private currentFileIndex = 0;\n  private isClosing = false;\n\n  get level(): string {\n    return this.config.level;\n  }\n\n  constructor(\n    config: LoggingConfig = {\n      level: 'info',\n      format: 'json',\n      destination: 'console',\n    },\n    context: Record<string, unknown> = {},\n  ) {\n    // Validate file path if file destination\n    if ((config.destination === 'file' || config.destination === 'both') && !config.filePath) {\n      throw new Error('File path required for file logging');\n    }\n\n    this.config = config;\n    this.context = context;\n  }\n\n  /**\n   * Gets the singleton instance of the logger\n   */\n  static getInstance(config?: LoggingConfig): Logger {\n    if (!Logger.instance) {\n      if (!config) {\n        // Use default config if none provided and not in test environment\n        const isTestEnv = process.env.CLAUDE_FLOW_ENV === 'test';\n        if (isTestEnv) {\n          throw new Error('Logger configuration required for initialization');\n        }\n        config = {\n          level: 'info',\n          format: 'json',\n          destination: 'console',\n        };\n      }\n      Logger.instance = new Logger(config);\n    }\n    return Logger.instance;\n  }\n\n  /**\n   * Updates logger configuration\n   */\n  async configure(config: LoggingConfig): Promise<void> {\n    this.config = config;\n\n    // Reset file handle if destination changed\n    if (this.fileHandle && config.destination !== 'file' && config.destination !== 'both') {\n      await this.fileHandle.close();\n      delete this.fileHandle;\n    }\n  }\n\n  debug(message: string, meta?: unknown): void {\n    this.log(LogLevel.DEBUG, message, meta);\n  }\n\n  info(message: string, meta?: unknown): void {\n    this.log(LogLevel.INFO, message, meta);\n  }\n\n  warn(message: string, meta?: unknown): void {\n    this.log(LogLevel.WARN, message, meta);\n  }\n\n  error(message: string, error?: unknown): void {\n    this.log(LogLevel.ERROR, message, undefined, error);\n  }\n\n  /**\n   * Creates a child logger with additional context\n   */\n  child(context: Record<string, unknown>): Logger {\n    return new Logger(this.config, { ...this.context, ...context });\n  }\n\n  /**\n   * Properly close the logger and release resources\n   */\n  async close(): Promise<void> {\n    this.isClosing = true;\n    if (this.fileHandle) {\n      try {\n        await this.fileHandle.close();\n      } catch (error) {\n        console.error('Error closing log file handle:', error);\n      } finally {\n        delete this.fileHandle;\n      }\n    }\n  }\n\n  private log(level: LogLevel, message: string, data?: unknown, error?: unknown): void {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: LogLevel[level],\n      message,\n      context: this.context,\n      data,\n      error,\n    };\n\n    const formatted = this.format(entry);\n\n    if (this.config.destination === 'console' || this.config.destination === 'both') {\n      this.writeToConsole(level, formatted);\n    }\n\n    if (this.config.destination === 'file' || this.config.destination === 'both') {\n      this.writeToFile(formatted);\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    const configLevel = LogLevel[this.config.level.toUpperCase() as keyof typeof LogLevel];\n    return level >= configLevel;\n  }\n\n  private format(entry: LogEntry): string {\n    if (this.config.format === 'json') {\n      // Handle error serialization for JSON format\n      const jsonEntry = { ...entry };\n      if (jsonEntry.error instanceof Error) {\n        jsonEntry.error = {\n          name: jsonEntry.error.name,\n          message: jsonEntry.error.message,\n          stack: jsonEntry.error.stack,\n        };\n      }\n      return JSON.stringify(jsonEntry);\n    }\n\n    // Text format\n    const contextStr =\n      Object.keys(entry.context).length > 0 ? ` ${JSON.stringify(entry.context)}` : '';\n    const dataStr = entry.data !== undefined ? ` ${JSON.stringify(entry.data)}` : '';\n    const errorStr =\n      entry.error !== undefined\n        ? entry.error instanceof Error\n          ? `\\n  Error: ${entry.error.message}\\n  Stack: ${entry.error.stack}`\n          : ` Error: ${JSON.stringify(entry.error)}`\n        : '';\n\n    return `[${entry.timestamp}] ${entry.level} ${entry.message}${contextStr}${dataStr}${errorStr}`;\n  }\n\n  private writeToConsole(level: LogLevel, message: string): void {\n    switch (level) {\n      case LogLevel.DEBUG:\n        console.debug(message);\n        break;\n      case LogLevel.INFO:\n        console.info(message);\n        break;\n      case LogLevel.WARN:\n        console.warn(message);\n        break;\n      case LogLevel.ERROR:\n        console.error(message);\n        break;\n    }\n  }\n\n  private async writeToFile(message: string): Promise<void> {\n    if (!this.config.filePath || this.isClosing) {\n      return;\n    }\n\n    try {\n      // Check if we need to rotate the log file\n      if (await this.shouldRotate()) {\n        await this.rotate();\n      }\n\n      // Open file handle if not already open\n      if (!this.fileHandle) {\n        this.fileHandle = await fs.open(this.config.filePath, 'a');\n      }\n\n      // Write the message\n      const data = Buffer.from(message + '\\n', 'utf8');\n      await this.fileHandle.write(data);\n      this.currentFileSize += data.length;\n    } catch (error) {\n      console.error('Failed to write to log file:', error);\n    }\n  }\n\n  private async shouldRotate(): Promise<boolean> {\n    if (!this.config.maxFileSize || !this.config.filePath) {\n      return false;\n    }\n\n    try {\n      const stat = await fs.stat(this.config.filePath);\n      return stat.size >= this.config.maxFileSize;\n    } catch {\n      return false;\n    }\n  }\n\n  private async rotate(): Promise<void> {\n    if (!this.config.filePath || !this.config.maxFiles) {\n      return;\n    }\n\n    // Close current file\n    if (this.fileHandle) {\n      await this.fileHandle.close();\n      delete this.fileHandle;\n    }\n\n    // Rename current file\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const rotatedPath = `${this.config.filePath}.${timestamp}`;\n    await fs.rename(this.config.filePath, rotatedPath);\n\n    // Clean up old files\n    await this.cleanupOldFiles();\n\n    // Reset file size\n    this.currentFileSize = 0;\n  }\n\n  private async cleanupOldFiles(): Promise<void> {\n    if (!this.config.filePath || !this.config.maxFiles) {\n      return;\n    }\n\n    const dir = path.dirname(this.config.filePath);\n    const baseFileName = path.basename(this.config.filePath);\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      const files: string[] = [];\n\n      for (const entry of entries) {\n        if (entry.isFile() && entry.name.startsWith(baseFileName + '.')) {\n          files.push(entry.name);\n        }\n      }\n\n      // Sort files by timestamp (newest first)\n      files.sort().reverse();\n\n      // Remove old files\n      const filesToRemove = files.slice(this.config.maxFiles - 1);\n      for (const file of filesToRemove) {\n        await fs.unlink(path.join(dir, file));\n      }\n    } catch (error) {\n      console.error('Failed to cleanup old log files:', error);\n    }\n  }\n}\n\n// Export singleton instance with lazy initialization\nexport const logger = Logger.getInstance();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,qBAA+B;AAC/B,WAAsB;AACtB,yBAAuB;AACvB,0BAAoB;AAab,IAAK,WAAL,kBAAKA,cAAL;AACL,EAAAA,oBAAA,WAAQ,KAAR;AACA,EAAAA,oBAAA,UAAO,KAAP;AACA,EAAAA,oBAAA,UAAO,KAAP;AACA,EAAAA,oBAAA,WAAQ,KAAR;AAJU,SAAAA;AAAA,GAAA;AAmBL,MAAM,OAA0B;AAAA,EAvCvC,OAuCuC;AAAA;AAAA;AAAA,EACrC,OAAe;AAAA,EACP;AAAA,EACA;AAAA,EACA;AAAA,EACA,kBAAkB;AAAA,EAClB,mBAAmB;AAAA,EACnB,YAAY;AAAA,EAEpB,IAAI,QAAgB;AAClB,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,YACE,SAAwB;AAAA,IACtB,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,aAAa;AAAA,EACf,GACA,UAAmC,CAAC,GACpC;AAEA,SAAK,OAAO,gBAAgB,UAAU,OAAO,gBAAgB,WAAW,CAAC,OAAO,UAAU;AACxF,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACvD;AAEA,SAAK,SAAS;AACd,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,YAAY,QAAgC;AACjD,QAAI,CAAC,OAAO,UAAU;AACpB,UAAI,CAAC,QAAQ;AAEX,cAAM,YAAY,oBAAAC,QAAQ,IAAI,oBAAoB;AAClD,YAAI,WAAW;AACb,gBAAM,IAAI,MAAM,kDAAkD;AAAA,QACpE;AACA,iBAAS;AAAA,UACP,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,aAAa;AAAA,QACf;AAAA,MACF;AACA,aAAO,WAAW,IAAI,OAAO,MAAM;AAAA,IACrC;AACA,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,QAAsC;AACpD,SAAK,SAAS;AAGd,QAAI,KAAK,cAAc,OAAO,gBAAgB,UAAU,OAAO,gBAAgB,QAAQ;AACrF,YAAM,KAAK,WAAW,MAAM;AAC5B,aAAO,KAAK;AAAA,IACd;AAAA,EACF;AAAA,EAEA,MAAM,SAAiB,MAAsB;AAC3C,SAAK,IAAI,eAAgB,SAAS,IAAI;AAAA,EACxC;AAAA,EAEA,KAAK,SAAiB,MAAsB;AAC1C,SAAK,IAAI,cAAe,SAAS,IAAI;AAAA,EACvC;AAAA,EAEA,KAAK,SAAiB,MAAsB;AAC1C,SAAK,IAAI,cAAe,SAAS,IAAI;AAAA,EACvC;AAAA,EAEA,MAAM,SAAiB,OAAuB;AAC5C,SAAK,IAAI,eAAgB,SAAS,QAAW,KAAK;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAA0C;AAC9C,WAAO,IAAI,OAAO,KAAK,QAAQ,EAAE,GAAG,KAAK,SAAS,GAAG,QAAQ,CAAC;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAuB;AAC3B,SAAK,YAAY;AACjB,QAAI,KAAK,YAAY;AACnB,UAAI;AACF,cAAM,KAAK,WAAW,MAAM;AAAA,MAC9B,SAAS,OAAO;AACd,gBAAQ,MAAM,kCAAkC,KAAK;AAAA,MACvD,UAAE;AACA,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,IAAI,OAAiB,SAAiB,MAAgB,OAAuB;AACnF,QAAI,CAAC,KAAK,UAAU,KAAK,GAAG;AAC1B;AAAA,IACF;AAEA,UAAM,QAAkB;AAAA,MACtB,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,OAAO,SAAS,KAAK;AAAA,MACrB;AAAA,MACA,SAAS,KAAK;AAAA,MACd;AAAA,MACA;AAAA,IACF;AAEA,UAAM,YAAY,KAAK,OAAO,KAAK;AAEnC,QAAI,KAAK,OAAO,gBAAgB,aAAa,KAAK,OAAO,gBAAgB,QAAQ;AAC/E,WAAK,eAAe,OAAO,SAAS;AAAA,IACtC;AAEA,QAAI,KAAK,OAAO,gBAAgB,UAAU,KAAK,OAAO,gBAAgB,QAAQ;AAC5E,WAAK,YAAY,SAAS;AAAA,IAC5B;AAAA,EACF;AAAA,EAEQ,UAAU,OAA0B;AAC1C,UAAM,cAAc,SAAS,KAAK,OAAO,MAAM,YAAY,CAA0B;AACrF,WAAO,SAAS;AAAA,EAClB;AAAA,EAEQ,OAAO,OAAyB;AACtC,QAAI,KAAK,OAAO,WAAW,QAAQ;AAEjC,YAAM,YAAY,EAAE,GAAG,MAAM;AAC7B,UAAI,UAAU,iBAAiB,OAAO;AACpC,kBAAU,QAAQ;AAAA,UAChB,MAAM,UAAU,MAAM;AAAA,UACtB,SAAS,UAAU,MAAM;AAAA,UACzB,OAAO,UAAU,MAAM;AAAA,QACzB;AAAA,MACF;AACA,aAAO,KAAK,UAAU,SAAS;AAAA,IACjC;AAGA,UAAM,aACJ,OAAO,KAAK,MAAM,OAAO,EAAE,SAAS,IAAI,IAAI,KAAK,UAAU,MAAM,OAAO,CAAC,KAAK;AAChF,UAAM,UAAU,MAAM,SAAS,SAAY,IAAI,KAAK,UAAU,MAAM,IAAI,CAAC,KAAK;AAC9E,UAAM,WACJ,MAAM,UAAU,SACZ,MAAM,iBAAiB,QACrB;AAAA,WAAc,MAAM,MAAM,OAAO;AAAA,WAAc,MAAM,MAAM,KAAK,KAChE,WAAW,KAAK,UAAU,MAAM,KAAK,CAAC,KACxC;AAEN,WAAO,IAAI,MAAM,SAAS,KAAK,MAAM,KAAK,IAAI,MAAM,OAAO,GAAG,UAAU,GAAG,OAAO,GAAG,QAAQ;AAAA,EAC/F;AAAA,EAEQ,eAAe,OAAiB,SAAuB;AAC7D,YAAQ,OAAO;AAAA,MACb,KAAK;AACH,gBAAQ,MAAM,OAAO;AACrB;AAAA,MACF,KAAK;AACH,gBAAQ,KAAK,OAAO;AACpB;AAAA,MACF,KAAK;AACH,gBAAQ,KAAK,OAAO;AACpB;AAAA,MACF,KAAK;AACH,gBAAQ,MAAM,OAAO;AACrB;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,MAAc,YAAY,SAAgC;AACxD,QAAI,CAAC,KAAK,OAAO,YAAY,KAAK,WAAW;AAC3C;AAAA,IACF;AAEA,QAAI;AAEF,UAAI,MAAM,KAAK,aAAa,GAAG;AAC7B,cAAM,KAAK,OAAO;AAAA,MACpB;AAGA,UAAI,CAAC,KAAK,YAAY;AACpB,aAAK,aAAa,MAAM,eAAAC,SAAG,KAAK,KAAK,OAAO,UAAU,GAAG;AAAA,MAC3D;AAGA,YAAM,OAAO,0BAAO,KAAK,UAAU,MAAM,MAAM;AAC/C,YAAM,KAAK,WAAW,MAAM,IAAI;AAChC,WAAK,mBAAmB,KAAK;AAAA,IAC/B,SAAS,OAAO;AACd,cAAQ,MAAM,gCAAgC,KAAK;AAAA,IACrD;AAAA,EACF;AAAA,EAEA,MAAc,eAAiC;AAC7C,QAAI,CAAC,KAAK,OAAO,eAAe,CAAC,KAAK,OAAO,UAAU;AACrD,aAAO;AAAA,IACT;AAEA,QAAI;AACF,YAAM,OAAO,MAAM,eAAAA,SAAG,KAAK,KAAK,OAAO,QAAQ;AAC/C,aAAO,KAAK,QAAQ,KAAK,OAAO;AAAA,IAClC,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAc,SAAwB;AACpC,QAAI,CAAC,KAAK,OAAO,YAAY,CAAC,KAAK,OAAO,UAAU;AAClD;AAAA,IACF;AAGA,QAAI,KAAK,YAAY;AACnB,YAAM,KAAK,WAAW,MAAM;AAC5B,aAAO,KAAK;AAAA,IACd;AAGA,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY,EAAE,QAAQ,SAAS,GAAG;AAC/D,UAAM,cAAc,GAAG,KAAK,OAAO,QAAQ,IAAI,SAAS;AACxD,UAAM,eAAAA,SAAG,OAAO,KAAK,OAAO,UAAU,WAAW;AAGjD,UAAM,KAAK,gBAAgB;AAG3B,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,MAAc,kBAAiC;AAC7C,QAAI,CAAC,KAAK,OAAO,YAAY,CAAC,KAAK,OAAO,UAAU;AAClD;AAAA,IACF;AAEA,UAAM,MAAM,KAAK,QAAQ,KAAK,OAAO,QAAQ;AAC7C,UAAM,eAAe,KAAK,SAAS,KAAK,OAAO,QAAQ;AAEvD,QAAI;AACF,YAAM,UAAU,MAAM,eAAAA,SAAG,QAAQ,KAAK,EAAE,eAAe,KAAK,CAAC;AAC7D,YAAM,QAAkB,CAAC;AAEzB,iBAAW,SAAS,SAAS;AAC3B,YAAI,MAAM,OAAO,KAAK,MAAM,KAAK,WAAW,eAAe,GAAG,GAAG;AAC/D,gBAAM,KAAK,MAAM,IAAI;AAAA,QACvB;AAAA,MACF;AAGA,YAAM,KAAK,EAAE,QAAQ;AAGrB,YAAM,gBAAgB,MAAM,MAAM,KAAK,OAAO,WAAW,CAAC;AAC1D,iBAAW,QAAQ,eAAe;AAChC,cAAM,eAAAA,SAAG,OAAO,KAAK,KAAK,KAAK,IAAI,CAAC;AAAA,MACtC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,oCAAoC,KAAK;AAAA,IACzD;AAAA,EACF;AACF;AAGO,MAAM,SAAS,OAAO,YAAY;",
  "names": ["LogLevel", "process", "fs"]
}
