{
  "version": 3,
  "sources": ["../../src/swarm/claude-code-interface.ts"],
  "sourcesContent": ["/**\n * Claude Code Coordination Interface\n * \n * This module provides the interface layer for coordinating with Claude Code\n * instances, managing agent spawning through the claude CLI, handling process\n * lifecycle, and enabling seamless communication between the swarm system\n * and individual Claude agents.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { spawn, ChildProcess } from 'node:child_process';\nimport { performance } from 'node:perf_hooks';\nimport * as path from 'node:path';\nimport * as fs from 'node:fs/promises';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { MemoryManager } from '../memory/manager.js';\nimport TaskExecutor, { \n  ClaudeExecutionOptions,\n  ExecutionResult,\n  ExecutionContext\n} from './executor.js';\nimport {\n  SwarmAgent,\n  SwarmTask,\n  TaskDefinition,\n  AgentState,\n  AgentCapabilities,\n  TaskResult,\n  SwarmExecutionContext,\n} from './types.js';\n\nexport interface ClaudeCodeConfig {\n  claudeExecutablePath: string;\n  defaultModel: string;\n  maxTokens: number;\n  temperature: number;\n  timeout: number;\n  maxConcurrentAgents: number;\n  enableStreaming: boolean;\n  enableLogging: boolean;\n  workingDirectory: string;\n  environmentVariables: Record<string, string>;\n  agentPoolSize: number;\n  processRecycling: boolean;\n  healthCheckInterval: number;\n}\n\nexport interface ClaudeAgent {\n  id: string;\n  processId: number;\n  process: ChildProcess;\n  type: string;\n  capabilities: string[];\n  status: 'initializing' | 'idle' | 'busy' | 'error' | 'terminated';\n  currentTask?: string;\n  spawnedAt: Date;\n  lastActivity: Date;\n  totalTasks: number;\n  totalDuration: number;\n  metrics: ClaudeAgentMetrics;\n}\n\nexport interface ClaudeAgentMetrics {\n  tasksCompleted: number;\n  tasksFailed: number;\n  averageResponseTime: number;\n  totalTokensUsed: number;\n  memoryUsage: number;\n  cpuUsage: number;\n  errorRate: number;\n  successRate: number;\n}\n\nexport interface ClaudeTaskExecution {\n  id: string;\n  taskId: string;\n  agentId: string;\n  startTime: Date;\n  endTime?: Date;\n  status: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled';\n  input: any;\n  output?: any;\n  error?: string;\n  duration?: number;\n  tokensUsed?: number;\n  retryCount: number;\n  maxRetries: number;\n}\n\nexport interface ClaudeSpawnOptions {\n  type: string;\n  name?: string;\n  capabilities?: string[];\n  systemPrompt?: string;\n  model?: string;\n  maxTokens?: number;\n  temperature?: number;\n  workingDirectory?: string;\n  environment?: Record<string, string>;\n  tools?: string[];\n  priority?: number;\n}\n\nexport interface ProcessPool {\n  idle: ClaudeAgent[];\n  busy: ClaudeAgent[];\n  failed: ClaudeAgent[];\n  totalSpawned: number;\n  totalTerminated: number;\n  recyclingEnabled: boolean;\n  maxAge: number;\n  maxTasks: number;\n}\n\nexport class ClaudeCodeInterface extends EventEmitter {\n  private logger: Logger;\n  private config: ClaudeCodeConfig;\n  private memoryManager: MemoryManager;\n  private processPool: ProcessPool;\n  private activeExecutions: Map<string, ClaudeTaskExecution> = new Map();\n  private agents: Map<string, ClaudeAgent> = new Map();\n  private taskExecutor: TaskExecutor;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private isInitialized: boolean = false;\n\n  constructor(\n    config: Partial<ClaudeCodeConfig> = {},\n    memoryManager: MemoryManager\n  ) {\n    super();\n    \n    this.logger = new Logger('ClaudeCodeInterface');\n    this.config = this.createDefaultConfig(config);\n    this.memoryManager = memoryManager;\n    this.processPool = this.initializeProcessPool();\n    \n    this.taskExecutor = new TaskExecutor({\n      timeoutMs: this.config.timeout,\n      enableMetrics: true,\n      captureOutput: true,\n      streamOutput: this.config.enableStreaming,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the Claude Code interface\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      this.logger.warn('Claude Code interface already initialized');\n      return;\n    }\n\n    this.logger.info('Initializing Claude Code interface...');\n\n    try {\n      // Verify Claude executable exists\n      await this.verifyClaudeExecutable();\n\n      // Initialize task executor\n      await this.taskExecutor.initialize();\n\n      // Pre-warm agent pool if configured\n      if (this.config.agentPoolSize > 0) {\n        await this.prewarmAgentPool();\n      }\n\n      // Start health checks\n      this.startHealthChecks();\n\n      this.isInitialized = true;\n      this.logger.info('Claude Code interface initialized successfully', {\n        poolSize: this.processPool.idle.length,\n        maxConcurrent: this.config.maxConcurrentAgents,\n      });\n\n      this.emit('initialized');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize Claude Code interface', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the interface gracefully\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n\n    this.logger.info('Shutting down Claude Code interface...');\n\n    try {\n      // Stop health checks\n      if (this.healthCheckInterval) {\n        clearInterval(this.healthCheckInterval);\n      }\n\n      // Cancel active executions\n      const cancellationPromises = Array.from(this.activeExecutions.keys())\n        .map(executionId => this.cancelExecution(executionId, 'Interface shutdown'));\n      \n      await Promise.allSettled(cancellationPromises);\n\n      // Terminate all agents\n      await this.terminateAllAgents();\n\n      // Shutdown task executor\n      await this.taskExecutor.shutdown();\n\n      this.isInitialized = false;\n      this.logger.info('Claude Code interface shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during Claude Code interface shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Spawn a new Claude agent with specified configuration\n   */\n  async spawnAgent(options: ClaudeSpawnOptions): Promise<string> {\n    this.logger.info('Spawning Claude agent', {\n      type: options.type,\n      name: options.name,\n      capabilities: options.capabilities,\n    });\n\n    try {\n      // Check if we can spawn more agents\n      if (this.getTotalActiveAgents() >= this.config.maxConcurrentAgents) {\n        throw new Error('Maximum concurrent agents limit reached');\n      }\n\n      // Build Claude command\n      const command = this.buildClaudeCommand(options);\n      \n      // Spawn process\n      const process = spawn(command.executable, command.args, {\n        cwd: options.workingDirectory || this.config.workingDirectory,\n        env: {\n          ...process.env,\n          ...this.config.environmentVariables,\n          ...options.environment,\n        },\n        stdio: ['pipe', 'pipe', 'pipe'],\n        detached: false,\n      });\n\n      if (!process.pid) {\n        throw new Error('Failed to spawn Claude process');\n      }\n\n      // Create agent record\n      const agentId = generateId('claude-agent');\n      const agent: ClaudeAgent = {\n        id: agentId,\n        processId: process.pid,\n        process,\n        type: options.type,\n        capabilities: options.capabilities || [],\n        status: 'initializing',\n        spawnedAt: new Date(),\n        lastActivity: new Date(),\n        totalTasks: 0,\n        totalDuration: 0,\n        metrics: this.initializeAgentMetrics(),\n      };\n\n      this.agents.set(agentId, agent);\n      this.processPool.idle.push(agent);\n      this.processPool.totalSpawned++;\n\n      // Setup process event handlers\n      this.setupProcessEventHandlers(agent);\n\n      // Wait for agent to be ready\n      await this.waitForAgentReady(agent);\n\n      agent.status = 'idle';\n      agent.lastActivity = new Date();\n\n      this.logger.info('Claude agent spawned successfully', {\n        agentId,\n        processId: process.pid,\n        type: options.type,\n      });\n\n      this.emit('agent:spawned', {\n        agentId,\n        type: options.type,\n        processId: process.pid,\n      });\n\n      return agentId;\n\n    } catch (error) {\n      this.logger.error('Failed to spawn Claude agent', {\n        type: options.type,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a task using a Claude agent\n   */\n  async executeTask(\n    taskDefinition: TaskDefinition,\n    agentId?: string,\n    options: Partial<ClaudeExecutionOptions> = {}\n  ): Promise<ClaudeTaskExecution> {\n    const executionId = generateId('claude-execution');\n    \n    this.logger.info('Executing task with Claude agent', {\n      executionId,\n      taskId: taskDefinition.id.id,\n      agentId,\n    });\n\n    try {\n      // Get or select agent\n      const agent = agentId ? this.agents.get(agentId) : await this.selectOptimalAgent(taskDefinition);\n      \n      if (!agent) {\n        throw new Error(agentId ? `Agent not found: ${agentId}` : 'No suitable agent available');\n      }\n\n      if (agent.status !== 'idle') {\n        throw new Error(`Agent ${agent.id} is not available (status: ${agent.status})`);\n      }\n\n      // Create execution record\n      const execution: ClaudeTaskExecution = {\n        id: executionId,\n        taskId: taskDefinition.id.id,\n        agentId: agent.id,\n        startTime: new Date(),\n        status: 'queued',\n        input: {\n          task: taskDefinition,\n          options,\n        },\n        retryCount: 0,\n        maxRetries: options.maxRetries || 3,\n      };\n\n      this.activeExecutions.set(executionId, execution);\n\n      // Update agent status\n      agent.status = 'busy';\n      agent.currentTask = executionId;\n      agent.lastActivity = new Date();\n\n      // Move agent from idle to busy pool\n      this.moveAgentToBusyPool(agent);\n\n      // Execute task\n      execution.status = 'running';\n      const result = await this.executeTaskWithAgent(agent, taskDefinition, options);\n\n      // Update execution record\n      execution.endTime = new Date();\n      execution.duration = execution.endTime.getTime() - execution.startTime.getTime();\n      execution.output = result.result;\n      execution.tokensUsed = result.metadata?.tokensUsed;\n\n      if (result.success) {\n        execution.status = 'completed';\n        agent.metrics.tasksCompleted++;\n      } else {\n        execution.status = 'failed';\n        execution.error = result.error;\n        agent.metrics.tasksFailed++;\n      }\n\n      // Update agent metrics\n      this.updateAgentMetrics(agent, execution);\n\n      // Return agent to idle pool\n      this.returnAgentToIdlePool(agent);\n\n      this.logger.info('Task execution completed', {\n        executionId,\n        success: result.success,\n        duration: execution.duration,\n        tokensUsed: execution.tokensUsed,\n      });\n\n      this.emit('task:completed', {\n        executionId,\n        taskId: taskDefinition.id.id,\n        agentId: agent.id,\n        success: result.success,\n        duration: execution.duration,\n      });\n\n      return execution;\n\n    } catch (error) {\n      const execution = this.activeExecutions.get(executionId);\n      if (execution) {\n        execution.status = 'failed';\n        execution.error = error instanceof Error ? error.message : String(error);\n        execution.endTime = new Date();\n        execution.duration = execution.endTime.getTime() - execution.startTime.getTime();\n\n        // Return agent to pool if it was assigned\n        const agent = this.agents.get(execution.agentId);\n        if (agent) {\n          this.returnAgentToIdlePool(agent);\n        }\n      }\n\n      this.logger.error('Task execution failed', {\n        executionId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Cancel a running task execution\n   */\n  async cancelExecution(executionId: string, reason: string): Promise<void> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution) {\n      throw new Error(`Execution not found: ${executionId}`);\n    }\n\n    this.logger.info('Cancelling task execution', {\n      executionId,\n      reason,\n      taskId: execution.taskId,\n      agentId: execution.agentId,\n    });\n\n    try {\n      execution.status = 'cancelled';\n      execution.error = reason;\n      execution.endTime = new Date();\n      execution.duration = execution.endTime.getTime() - execution.startTime.getTime();\n\n      // Cancel agent task if running\n      const agent = this.agents.get(execution.agentId);\n      if (agent && agent.currentTask === executionId) {\n        await this.cancelAgentTask(agent);\n        this.returnAgentToIdlePool(agent);\n      }\n\n      this.emit('task:cancelled', {\n        executionId,\n        reason,\n        taskId: execution.taskId,\n        agentId: execution.agentId,\n      });\n\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Terminate a specific agent\n   */\n  async terminateAgent(agentId: string, reason: string = 'Manual termination'): Promise<void> {\n    const agent = this.agents.get(agentId);\n    if (!agent) {\n      throw new Error(`Agent not found: ${agentId}`);\n    }\n\n    this.logger.info('Terminating Claude agent', {\n      agentId,\n      processId: agent.processId,\n      reason,\n    });\n\n    try {\n      // Cancel current task if any\n      if (agent.currentTask) {\n        await this.cancelExecution(agent.currentTask, 'Agent termination');\n      }\n\n      // Update status\n      agent.status = 'terminated';\n\n      // Terminate process\n      await this.terminateProcess(agent.process);\n\n      // Remove from pools and agents map\n      this.removeAgentFromPools(agent);\n      this.agents.delete(agentId);\n      this.processPool.totalTerminated++;\n\n      this.logger.info('Claude agent terminated successfully', {\n        agentId,\n        reason,\n        totalTasks: agent.totalTasks,\n        totalDuration: agent.totalDuration,\n      });\n\n      this.emit('agent:terminated', {\n        agentId,\n        reason,\n        metrics: agent.metrics,\n      });\n\n    } catch (error) {\n      this.logger.error('Error terminating agent', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get agent status and metrics\n   */\n  getAgentStatus(agentId: string): ClaudeAgent | null {\n    return this.agents.get(agentId) || null;\n  }\n\n  /**\n   * Get all active agents\n   */\n  getAllAgents(): ClaudeAgent[] {\n    return Array.from(this.agents.values());\n  }\n\n  /**\n   * Get execution status\n   */\n  getExecutionStatus(executionId: string): ClaudeTaskExecution | null {\n    return this.activeExecutions.get(executionId) || null;\n  }\n\n  /**\n   * Get comprehensive interface metrics\n   */\n  getInterfaceMetrics(): {\n    agents: {\n      total: number;\n      idle: number;\n      busy: number;\n      failed: number;\n      terminated: number;\n    };\n    executions: {\n      active: number;\n      completed: number;\n      failed: number;\n      cancelled: number;\n    };\n    performance: {\n      averageResponseTime: number;\n      totalTokensUsed: number;\n      successRate: number;\n      throughput: number;\n    };\n    pool: {\n      totalSpawned: number;\n      totalTerminated: number;\n      recyclingEnabled: boolean;\n      poolUtilization: number;\n    };\n  } {\n    const agents = Array.from(this.agents.values());\n    const executions = Array.from(this.activeExecutions.values());\n\n    const totalCompleted = agents.reduce((sum, a) => sum + a.metrics.tasksCompleted, 0);\n    const totalFailed = agents.reduce((sum, a) => sum + a.metrics.tasksFailed, 0);\n    const totalTokens = agents.reduce((sum, a) => sum + a.metrics.totalTokensUsed, 0);\n    const avgResponseTime = agents.length > 0 \n      ? agents.reduce((sum, a) => sum + a.metrics.averageResponseTime, 0) / agents.length \n      : 0;\n\n    return {\n      agents: {\n        total: agents.length,\n        idle: this.processPool.idle.length,\n        busy: this.processPool.busy.length,\n        failed: this.processPool.failed.length,\n        terminated: this.processPool.totalTerminated,\n      },\n      executions: {\n        active: executions.filter(e => e.status === 'running').length,\n        completed: totalCompleted,\n        failed: totalFailed,\n        cancelled: executions.filter(e => e.status === 'cancelled').length,\n      },\n      performance: {\n        averageResponseTime: avgResponseTime,\n        totalTokensUsed: totalTokens,\n        successRate: totalCompleted + totalFailed > 0 ? totalCompleted / (totalCompleted + totalFailed) : 0,\n        throughput: this.calculateThroughput(),\n      },\n      pool: {\n        totalSpawned: this.processPool.totalSpawned,\n        totalTerminated: this.processPool.totalTerminated,\n        recyclingEnabled: this.processPool.recyclingEnabled,\n        poolUtilization: this.calculatePoolUtilization(),\n      },\n    };\n  }\n\n  // Private methods\n\n  private async verifyClaudeExecutable(): Promise<void> {\n    try {\n      const { spawn } = await import('node:child_process');\n      const process = spawn(this.config.claudeExecutablePath, ['--version'], {\n        stdio: ['ignore', 'pipe', 'pipe'],\n      });\n\n      return new Promise((resolve, reject) => {\n        let output = '';\n        \n        process.stdout?.on('data', (data) => {\n          output += data.toString();\n        });\n\n        process.on('close', (code) => {\n          if (code === 0) {\n            this.logger.info('Claude executable verified', {\n              path: this.config.claudeExecutablePath,\n              version: output.trim(),\n            });\n            resolve();\n          } else {\n            reject(new Error(`Claude executable verification failed with code ${code}`));\n          }\n        });\n\n        process.on('error', reject);\n      });\n\n    } catch (error) {\n      throw new Error(`Claude executable not found: ${this.config.claudeExecutablePath}`);\n    }\n  }\n\n  private async prewarmAgentPool(): Promise<void> {\n    this.logger.info('Pre-warming agent pool', {\n      targetSize: this.config.agentPoolSize,\n    });\n\n    const promises: Promise<string>[] = [];\n    \n    for (let i = 0; i < this.config.agentPoolSize; i++) {\n      promises.push(this.spawnAgent({\n        type: 'general',\n        name: `pool-agent-${i}`,\n        capabilities: ['general'],\n      }));\n    }\n\n    const results = await Promise.allSettled(promises);\n    const successful = results.filter(r => r.status === 'fulfilled').length;\n    const failed = results.filter(r => r.status === 'rejected').length;\n\n    this.logger.info('Agent pool pre-warming completed', {\n      successful,\n      failed,\n      targetSize: this.config.agentPoolSize,\n    });\n  }\n\n  private buildClaudeCommand(options: ClaudeSpawnOptions): {\n    executable: string;\n    args: string[];\n  } {\n    const args: string[] = [];\n\n    // Add model\n    args.push('--model', options.model || this.config.defaultModel);\n\n    // Add max tokens\n    args.push('--max-tokens', String(options.maxTokens || this.config.maxTokens));\n\n    // Add temperature\n    args.push('--temperature', String(options.temperature || this.config.temperature));\n\n    // Add system prompt if provided\n    if (options.systemPrompt) {\n      args.push('--system', options.systemPrompt);\n    }\n\n    // Add tools if specified\n    if (options.tools && options.tools.length > 0) {\n      args.push('--allowedTools', options.tools.join(','));\n    }\n\n    // Enable streaming if configured\n    if (this.config.enableStreaming) {\n      args.push('--stream');\n    }\n\n    // Skip permissions for swarm execution\n    args.push('--dangerously-skip-permissions');\n\n    return {\n      executable: this.config.claudeExecutablePath,\n      args,\n    };\n  }\n\n  private setupProcessEventHandlers(agent: ClaudeAgent): void {\n    const { process } = agent;\n\n    process.on('exit', (code, signal) => {\n      this.logger.info('Claude agent process exited', {\n        agentId: agent.id,\n        processId: agent.processId,\n        code,\n        signal,\n      });\n\n      if (agent.status !== 'terminated') {\n        agent.status = 'error';\n        this.moveAgentToFailedPool(agent);\n      }\n\n      this.emit('agent:exited', {\n        agentId: agent.id,\n        code,\n        signal,\n      });\n    });\n\n    process.on('error', (error) => {\n      this.logger.error('Claude agent process error', {\n        agentId: agent.id,\n        processId: agent.processId,\n        error: error.message,\n      });\n\n      agent.status = 'error';\n      this.moveAgentToFailedPool(agent);\n\n      this.emit('agent:error', {\n        agentId: agent.id,\n        error: error.message,\n      });\n    });\n\n    // Handle stdout/stderr if needed\n    if (this.config.enableLogging) {\n      process.stdout?.on('data', (data) => {\n        this.logger.debug('Agent stdout', {\n          agentId: agent.id,\n          data: data.toString().trim(),\n        });\n      });\n\n      process.stderr?.on('data', (data) => {\n        this.logger.debug('Agent stderr', {\n          agentId: agent.id,\n          data: data.toString().trim(),\n        });\n      });\n    }\n  }\n\n  private async waitForAgentReady(agent: ClaudeAgent, timeout: number = 30000): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      const checkInterval = 1000; // 1 second\n\n      const checkReady = () => {\n        const elapsed = Date.now() - startTime;\n        \n        if (elapsed > timeout) {\n          reject(new Error(`Agent ${agent.id} failed to become ready within ${timeout}ms`));\n          return;\n        }\n\n        // Check if process is still running\n        if (agent.process.killed || agent.process.exitCode !== null) {\n          reject(new Error(`Agent ${agent.id} process terminated during initialization`));\n          return;\n        }\n\n        // For now, assume agent is ready after a short delay\n        // In a real implementation, you might check for specific output or response\n        if (elapsed > 2000) { // 2 seconds\n          resolve();\n        } else {\n          setTimeout(checkReady, checkInterval);\n        }\n      };\n\n      checkReady();\n    });\n  }\n\n  private async selectOptimalAgent(taskDefinition: TaskDefinition): Promise<ClaudeAgent | null> {\n    const availableAgents = this.processPool.idle.filter(agent => agent.status === 'idle');\n    \n    if (availableAgents.length === 0) {\n      // Try to spawn a new agent if under limit\n      if (this.getTotalActiveAgents() < this.config.maxConcurrentAgents) {\n        const agentId = await this.spawnAgent({\n          type: 'task-specific',\n          capabilities: taskDefinition.requirements.capabilities,\n        });\n        return this.agents.get(agentId) || null;\n      }\n      return null;\n    }\n\n    // Select agent based on capabilities and performance\n    const scoredAgents = availableAgents.map(agent => ({\n      agent,\n      score: this.calculateAgentScore(agent, taskDefinition),\n    }));\n\n    scoredAgents.sort((a, b) => b.score - a.score);\n    return scoredAgents[0].agent;\n  }\n\n  private calculateAgentScore(agent: ClaudeAgent, taskDefinition: TaskDefinition): number {\n    let score = 0;\n\n    // Capability match\n    const requiredCapabilities = taskDefinition.requirements.capabilities;\n    const matchingCapabilities = agent.capabilities.filter(cap => \n      requiredCapabilities.includes(cap)\n    );\n    score += (matchingCapabilities.length / requiredCapabilities.length) * 100;\n\n    // Performance metrics\n    score += agent.metrics.successRate * 50;\n    score += Math.max(0, 50 - agent.metrics.averageResponseTime / 1000) * 10; // Prefer faster agents\n\n    // Load balancing - prefer agents with fewer completed tasks\n    const maxTasks = Math.max(...this.processPool.idle.map(a => a.totalTasks), 1);\n    score += (1 - agent.totalTasks / maxTasks) * 20;\n\n    return score;\n  }\n\n  private async executeTaskWithAgent(\n    agent: ClaudeAgent,\n    taskDefinition: TaskDefinition,\n    options: Partial<ClaudeExecutionOptions>\n  ): Promise<ExecutionResult> {\n    const startTime = performance.now();\n\n    try {\n      // Create execution context for the agent\n      const context: ExecutionContext = {\n        task: taskDefinition,\n        agent: this.convertToAgentState(agent),\n        workingDirectory: options.workingDirectory || this.config.workingDirectory,\n        tempDirectory: path.join(this.config.workingDirectory, 'temp', agent.id),\n        logDirectory: path.join(this.config.workingDirectory, 'logs', agent.id),\n        environment: {\n          ...this.config.environmentVariables,\n          CLAUDE_AGENT_ID: agent.id,\n          CLAUDE_TASK_ID: taskDefinition.id.id,\n        },\n        resources: {\n          maxMemory: taskDefinition.requirements.memoryRequired || 512 * 1024 * 1024,\n          maxCpuTime: taskDefinition.requirements.maxDuration || 300000,\n          maxDiskSpace: 1024 * 1024 * 1024,\n          maxNetworkConnections: 10,\n          maxFileHandles: 100,\n          priority: 1,\n        },\n      };\n\n      // Execute using task executor\n      const result = await this.taskExecutor.executeClaudeTask(\n        taskDefinition,\n        context.agent,\n        {\n          model: options.model || this.config.defaultModel,\n          maxTokens: options.maxTokens || this.config.maxTokens,\n          temperature: options.temperature || this.config.temperature,\n          timeout: options.timeout || this.config.timeout,\n          claudePath: this.config.claudeExecutablePath,\n          ...options,\n        }\n      );\n\n      const duration = performance.now() - startTime;\n      \n      // Update agent activity\n      agent.lastActivity = new Date();\n      agent.totalTasks++;\n      agent.totalDuration += duration;\n\n      return result;\n\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      agent.totalDuration += duration;\n      \n      throw error;\n    }\n  }\n\n  private convertToAgentState(agent: ClaudeAgent): AgentState {\n    // Convert ClaudeAgent to AgentState for compatibility\n    return {\n      id: {\n        id: agent.id,\n        swarmId: 'claude-interface',\n        type: agent.type as any,\n        instance: 1,\n      },\n      name: `Claude-${agent.id}`,\n      type: agent.type as any,\n      status: agent.status as any,\n      capabilities: this.createAgentCapabilities(agent.capabilities),\n      metrics: {\n        tasksCompleted: agent.metrics.tasksCompleted,\n        tasksFailed: agent.metrics.tasksFailed,\n        averageExecutionTime: agent.metrics.averageResponseTime,\n        successRate: agent.metrics.successRate,\n        cpuUsage: agent.metrics.cpuUsage,\n        memoryUsage: agent.metrics.memoryUsage,\n        diskUsage: 0,\n        networkUsage: 0,\n        codeQuality: 0.8,\n        testCoverage: 0.7,\n        bugRate: 0.1,\n        userSatisfaction: 0.9,\n        totalUptime: Date.now() - agent.spawnedAt.getTime(),\n        lastActivity: agent.lastActivity,\n        responseTime: agent.metrics.averageResponseTime,\n      },\n      currentTask: agent.currentTask ? {\n        id: agent.currentTask,\n        swarmId: 'claude-interface',\n        sequence: 0,\n        priority: 1,\n      } : undefined,\n      workload: agent.status === 'busy' ? 1 : 0,\n      health: agent.status === 'error' ? 0 : 1,\n      config: {\n        autonomyLevel: 0.8,\n        learningEnabled: false,\n        adaptationEnabled: false,\n        maxTasksPerHour: 60,\n        maxConcurrentTasks: 1,\n        timeoutThreshold: this.config.timeout,\n        reportingInterval: 10000,\n        heartbeatInterval: 5000,\n        permissions: ['read', 'write', 'execute'],\n        trustedAgents: [],\n        expertise: {},\n        preferences: {},\n      },\n      environment: {\n        runtime: 'claude',\n        version: '1.0.0',\n        workingDirectory: this.config.workingDirectory,\n        tempDirectory: path.join(this.config.workingDirectory, 'temp', agent.id),\n        logDirectory: path.join(this.config.workingDirectory, 'logs', agent.id),\n        apiEndpoints: {},\n        credentials: {},\n        availableTools: agent.capabilities,\n        toolConfigs: {},\n      },\n      endpoints: [],\n      lastHeartbeat: agent.lastActivity,\n      taskHistory: [],\n      errorHistory: [],\n      parentAgent: undefined,\n      childAgents: [],\n      collaborators: [],\n    };\n  }\n\n  private createAgentCapabilities(capabilities: string[]): AgentCapabilities {\n    return {\n      codeGeneration: capabilities.includes('coding') || capabilities.includes('codeGeneration'),\n      codeReview: capabilities.includes('review') || capabilities.includes('codeReview'),\n      testing: capabilities.includes('testing'),\n      documentation: capabilities.includes('documentation'),\n      research: capabilities.includes('research'),\n      analysis: capabilities.includes('analysis'),\n      webSearch: capabilities.includes('webSearch'),\n      apiIntegration: capabilities.includes('apiIntegration'),\n      fileSystem: capabilities.includes('fileSystem'),\n      terminalAccess: capabilities.includes('terminal'),\n      languages: capabilities.filter(c => ['javascript', 'typescript', 'python', 'java'].includes(c)),\n      frameworks: capabilities.filter(c => ['react', 'node', 'express'].includes(c)),\n      domains: capabilities.filter(c => ['web', 'api', 'database'].includes(c)),\n      tools: capabilities.filter(c => ['bash', 'git', 'npm'].includes(c)),\n      maxConcurrentTasks: 1,\n      maxMemoryUsage: 512 * 1024 * 1024,\n      maxExecutionTime: this.config.timeout,\n      reliability: 0.9,\n      speed: 1.0,\n      quality: 0.8,\n    };\n  }\n\n  private async cancelAgentTask(agent: ClaudeAgent): Promise<void> {\n    if (agent.process && !agent.process.killed) {\n      // Send interrupt signal\n      agent.process.kill('SIGINT');\n      \n      // Wait briefly for graceful shutdown\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Force kill if still running\n      if (!agent.process.killed) {\n        agent.process.kill('SIGKILL');\n      }\n    }\n\n    agent.currentTask = undefined;\n    agent.status = 'idle';\n    agent.lastActivity = new Date();\n  }\n\n  private async terminateProcess(process: ChildProcess): Promise<void> {\n    if (process.killed || process.exitCode !== null) {\n      return;\n    }\n\n    // Send termination signal\n    process.kill('SIGTERM');\n    \n    // Wait for graceful shutdown\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    // Force kill if still running\n    if (!process.killed && process.exitCode === null) {\n      process.kill('SIGKILL');\n    }\n  }\n\n  private async terminateAllAgents(): Promise<void> {\n    const terminationPromises = Array.from(this.agents.keys())\n      .map(agentId => this.terminateAgent(agentId, 'Interface shutdown'));\n    \n    await Promise.allSettled(terminationPromises);\n  }\n\n  private moveAgentToBusyPool(agent: ClaudeAgent): void {\n    const idleIndex = this.processPool.idle.indexOf(agent);\n    if (idleIndex !== -1) {\n      this.processPool.idle.splice(idleIndex, 1);\n      this.processPool.busy.push(agent);\n    }\n  }\n\n  private returnAgentToIdlePool(agent: ClaudeAgent): void {\n    agent.status = 'idle';\n    agent.currentTask = undefined;\n    agent.lastActivity = new Date();\n\n    const busyIndex = this.processPool.busy.indexOf(agent);\n    if (busyIndex !== -1) {\n      this.processPool.busy.splice(busyIndex, 1);\n      this.processPool.idle.push(agent);\n    }\n  }\n\n  private moveAgentToFailedPool(agent: ClaudeAgent): void {\n    // Remove from other pools\n    this.removeAgentFromPools(agent);\n    this.processPool.failed.push(agent);\n  }\n\n  private removeAgentFromPools(agent: ClaudeAgent): void {\n    const idleIndex = this.processPool.idle.indexOf(agent);\n    if (idleIndex !== -1) {\n      this.processPool.idle.splice(idleIndex, 1);\n    }\n\n    const busyIndex = this.processPool.busy.indexOf(agent);\n    if (busyIndex !== -1) {\n      this.processPool.busy.splice(busyIndex, 1);\n    }\n\n    const failedIndex = this.processPool.failed.indexOf(agent);\n    if (failedIndex !== -1) {\n      this.processPool.failed.splice(failedIndex, 1);\n    }\n  }\n\n  private updateAgentMetrics(agent: ClaudeAgent, execution: ClaudeTaskExecution): void {\n    const metrics = agent.metrics;\n    \n    // Update averages\n    const totalTasks = metrics.tasksCompleted + metrics.tasksFailed;\n    if (execution.duration) {\n      metrics.averageResponseTime = totalTasks > 0 \n        ? ((metrics.averageResponseTime * (totalTasks - 1)) + execution.duration) / totalTasks\n        : execution.duration;\n    }\n\n    // Update success rate\n    metrics.successRate = totalTasks > 0 \n      ? metrics.tasksCompleted / totalTasks \n      : 0;\n\n    // Update error rate\n    metrics.errorRate = 1 - metrics.successRate;\n\n    // Update token usage if available\n    if (execution.tokensUsed) {\n      metrics.totalTokensUsed += execution.tokensUsed;\n    }\n  }\n\n  private getTotalActiveAgents(): number {\n    return this.processPool.idle.length + this.processPool.busy.length;\n  }\n\n  private calculateThroughput(): number {\n    const agents = Array.from(this.agents.values());\n    const totalTasks = agents.reduce((sum, a) => sum + a.totalTasks, 0);\n    const totalTime = agents.reduce((sum, a) => sum + a.totalDuration, 0);\n    \n    return totalTime > 0 ? (totalTasks / totalTime) * 60000 : 0; // tasks per minute\n  }\n\n  private calculatePoolUtilization(): number {\n    const total = this.getTotalActiveAgents();\n    const busy = this.processPool.busy.length;\n    \n    return total > 0 ? busy / total : 0;\n  }\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.healthCheckInterval);\n  }\n\n  private performHealthCheck(): void {\n    const now = Date.now();\n    \n    for (const agent of this.agents.values()) {\n      // Check for stalled agents\n      const inactiveTime = now - agent.lastActivity.getTime();\n      \n      if (agent.status === 'busy' && inactiveTime > this.config.timeout * 2) {\n        this.logger.warn('Agent appears stalled', {\n          agentId: agent.id,\n          inactiveTime,\n          currentTask: agent.currentTask,\n        });\n\n        // Try to recover the agent\n        this.recoverStalledAgent(agent);\n      }\n\n      // Check for failed processes\n      if (agent.process.killed || agent.process.exitCode !== null) {\n        if (agent.status !== 'terminated') {\n          this.logger.warn('Agent process died unexpectedly', {\n            agentId: agent.id,\n            exitCode: agent.process.exitCode,\n          });\n          \n          agent.status = 'error';\n          this.moveAgentToFailedPool(agent);\n        }\n      }\n    }\n  }\n\n  private async recoverStalledAgent(agent: ClaudeAgent): Promise<void> {\n    try {\n      if (agent.currentTask) {\n        await this.cancelExecution(agent.currentTask, 'Agent recovery');\n      }\n      \n      this.returnAgentToIdlePool(agent);\n      \n      this.logger.info('Agent recovered from stalled state', {\n        agentId: agent.id,\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to recover stalled agent', {\n        agentId: agent.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      \n      // Terminate the problematic agent\n      await this.terminateAgent(agent.id, 'Recovery failed');\n    }\n  }\n\n  private initializeProcessPool(): ProcessPool {\n    return {\n      idle: [],\n      busy: [],\n      failed: [],\n      totalSpawned: 0,\n      totalTerminated: 0,\n      recyclingEnabled: this.config.processRecycling,\n      maxAge: 3600000, // 1 hour\n      maxTasks: 100,\n    };\n  }\n\n  private initializeAgentMetrics(): ClaudeAgentMetrics {\n    return {\n      tasksCompleted: 0,\n      tasksFailed: 0,\n      averageResponseTime: 0,\n      totalTokensUsed: 0,\n      memoryUsage: 0,\n      cpuUsage: 0,\n      errorRate: 0,\n      successRate: 0,\n    };\n  }\n\n  private createDefaultConfig(config: Partial<ClaudeCodeConfig>): ClaudeCodeConfig {\n    return {\n      claudeExecutablePath: 'claude',\n      defaultModel: 'claude-3-5-sonnet-20241022',\n      maxTokens: 4096,\n      temperature: 0.7,\n      timeout: 300000, // 5 minutes\n      maxConcurrentAgents: 10,\n      enableStreaming: false,\n      enableLogging: true,\n      workingDirectory: process.cwd(),\n      environmentVariables: {},\n      agentPoolSize: 0,\n      processRecycling: true,\n      healthCheckInterval: 30000, // 30 seconds\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('agent:spawned', (data) => {\n      this.logger.info('Agent spawned event', data);\n    });\n\n    this.on('agent:terminated', (data) => {\n      this.logger.info('Agent terminated event', data);\n    });\n\n    this.on('task:completed', (data) => {\n      this.logger.info('Task completed event', data);\n    });\n\n    this.on('task:cancelled', (data) => {\n      this.logger.warn('Task cancelled event', data);\n    });\n  }\n}\n\nexport default ClaudeCodeInterface;"],
  "mappings": "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",
  "names": ["TaskExecutor", "process", "spawn"]
}
