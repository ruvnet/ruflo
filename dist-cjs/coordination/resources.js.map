{
  "version": 3,
  "sources": ["../../src/coordination/resources.ts"],
  "sourcesContent": ["/**\n * Resource manager for preventing conflicts and deadlocks\n */\n\nimport { Resource, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { ResourceLockError } from '../utils/errors.js';\nimport { delay, timeout } from '../utils/helpers.js';\n\ninterface LockRequest {\n  agentId: string;\n  resourceId: string;\n  timestamp: Date;\n  priority: number;\n}\n\n/**\n * Resource manager implementation\n */\nexport class ResourceManager {\n  private resources = new Map<string, Resource>();\n  private locks = new Map<string, string>(); // resourceId -> agentId\n  private waitQueue = new Map<string, LockRequest[]>(); // resourceId -> queue\n  private agentResources = new Map<string, Set<string>>(); // agentId -> resourceIds\n\n  constructor(\n    private config: CoordinationConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing resource manager');\n\n    // Set up periodic cleanup\n    setInterval(() => this.cleanup(), 30000); // Every 30 seconds\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down resource manager');\n\n    // Release all locks\n    for (const [resourceId, agentId] of this.locks) {\n      await this.release(resourceId, agentId);\n    }\n\n    this.resources.clear();\n    this.locks.clear();\n    this.waitQueue.clear();\n    this.agentResources.clear();\n  }\n\n  async acquire(resourceId: string, agentId: string, priority = 0): Promise<void> {\n    this.logger.debug('Resource acquisition requested', { resourceId, agentId });\n\n    // Check if resource exists\n    if (!this.resources.has(resourceId)) {\n      this.resources.set(resourceId, {\n        id: resourceId,\n        type: 'generic',\n        locked: false,\n      });\n    }\n\n    const resource = this.resources.get(resourceId)!;\n\n    // Check if already locked by this agent\n    if (this.locks.get(resourceId) === agentId) {\n      this.logger.debug('Resource already locked by agent', { resourceId, agentId });\n      return;\n    }\n\n    // Try to acquire lock\n    if (!resource.locked) {\n      await this.lockResource(resourceId, agentId);\n      return;\n    }\n\n    // Add to wait queue\n    const request: LockRequest = {\n      agentId,\n      resourceId,\n      timestamp: new Date(),\n      priority,\n    };\n\n    if (!this.waitQueue.has(resourceId)) {\n      this.waitQueue.set(resourceId, []);\n    }\n\n    const queue = this.waitQueue.get(resourceId)!;\n    queue.push(request);\n\n    // Sort by priority and timestamp\n    queue.sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return b.priority - a.priority; // Higher priority first\n      }\n      return a.timestamp.getTime() - b.timestamp.getTime(); // Earlier first\n    });\n\n    this.logger.info('Agent added to resource wait queue', {\n      resourceId,\n      agentId,\n      queueLength: queue.length,\n    });\n\n    // Wait for resource with timeout\n    const startTime = Date.now();\n    while (Date.now() - startTime < this.config.resourceTimeout) {\n      // Check if we're next in queue and resource is available\n      const nextRequest = queue[0];\n      if (nextRequest?.agentId === agentId && !resource.locked) {\n        // Remove from queue and acquire\n        queue.shift();\n        await this.lockResource(resourceId, agentId);\n        return;\n      }\n\n      // Check if our request is still in queue\n      const ourRequest = queue.find((req) => req.agentId === agentId);\n      if (!ourRequest) {\n        // Request was removed (possibly by cleanup)\n        throw new ResourceLockError('Resource request cancelled');\n      }\n\n      await delay(100);\n    }\n\n    // Timeout - remove from queue\n    const index = queue.findIndex((req) => req.agentId === agentId);\n    if (index !== -1) {\n      queue.splice(index, 1);\n    }\n\n    throw new ResourceLockError(`Resource acquisition timeout for ${resourceId}`, {\n      resourceId,\n      agentId,\n      timeout: this.config.resourceTimeout,\n    });\n  }\n\n  async release(resourceId: string, agentId: string): Promise<void> {\n    this.logger.debug('Resource release requested', { resourceId, agentId });\n\n    const currentLock = this.locks.get(resourceId);\n    if (currentLock !== agentId) {\n      this.logger.warn('Attempted to release unowned resource', {\n        resourceId,\n        agentId,\n        currentLock,\n      });\n      return;\n    }\n\n    // Release the lock\n    this.unlockResource(resourceId, agentId);\n\n    // Process wait queue\n    const queue = this.waitQueue.get(resourceId);\n    if (queue && queue.length > 0) {\n      const nextRequest = queue.shift()!;\n\n      // Grant lock to next in queue\n      await this.lockResource(resourceId, nextRequest.agentId);\n    }\n  }\n\n  async releaseAllForAgent(agentId: string): Promise<void> {\n    const resources = this.agentResources.get(agentId);\n    if (!resources) {\n      return;\n    }\n\n    this.logger.info('Releasing all resources for agent', {\n      agentId,\n      resourceCount: resources.size,\n    });\n\n    const promises = Array.from(resources).map((resourceId) => this.release(resourceId, agentId));\n\n    await Promise.all(promises);\n    this.agentResources.delete(agentId);\n  }\n\n  getAllocations(): Map<string, string> {\n    return new Map(this.locks);\n  }\n\n  getWaitingRequests(): Map<string, string[]> {\n    const waiting = new Map<string, string[]>();\n\n    for (const [resourceId, queue] of this.waitQueue) {\n      if (queue.length > 0) {\n        waiting.set(queue[0].agentId, [...(waiting.get(queue[0].agentId) || []), resourceId]);\n      }\n    }\n\n    return waiting;\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const totalResources = this.resources.size;\n    const lockedResources = this.locks.size;\n    const waitingAgents = new Set<string>();\n    let totalWaiting = 0;\n\n    for (const queue of this.waitQueue.values()) {\n      totalWaiting += queue.length;\n      queue.forEach((req) => waitingAgents.add(req.agentId));\n    }\n\n    return {\n      healthy: true,\n      metrics: {\n        totalResources,\n        lockedResources,\n        freeResources: totalResources - lockedResources,\n        waitingAgents: waitingAgents.size,\n        totalWaitingRequests: totalWaiting,\n      },\n    };\n  }\n\n  private async lockResource(resourceId: string, agentId: string): Promise<void> {\n    const resource = this.resources.get(resourceId)!;\n\n    resource.locked = true;\n    resource.lockedBy = agentId;\n    resource.lockedAt = new Date();\n\n    this.locks.set(resourceId, agentId);\n\n    // Track agent resources\n    if (!this.agentResources.has(agentId)) {\n      this.agentResources.set(agentId, new Set());\n    }\n    this.agentResources.get(agentId)!.add(resourceId);\n\n    this.logger.info('Resource locked', { resourceId, agentId });\n\n    // Emit event\n    this.eventBus.emit(SystemEvents.RESOURCE_ACQUIRED, { resourceId, agentId });\n  }\n\n  private unlockResource(resourceId: string, agentId: string): void {\n    const resource = this.resources.get(resourceId);\n    if (!resource) {\n      return;\n    }\n\n    resource.locked = false;\n    delete resource.lockedBy;\n    delete resource.lockedAt;\n\n    this.locks.delete(resourceId);\n\n    // Remove from agent resources\n    this.agentResources.get(agentId)?.delete(resourceId);\n\n    this.logger.info('Resource unlocked', { resourceId, agentId });\n\n    // Emit event\n    this.eventBus.emit(SystemEvents.RESOURCE_RELEASED, { resourceId, agentId });\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing resource manager maintenance');\n    this.cleanup();\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n\n    // Clean up stale wait requests\n    for (const [resourceId, queue] of this.waitQueue) {\n      const filtered = queue.filter((req) => {\n        const age = now - req.timestamp.getTime();\n        if (age > this.config.resourceTimeout) {\n          this.logger.warn('Removing stale resource request', {\n            resourceId,\n            agentId: req.agentId,\n            age,\n          });\n          return false;\n        }\n        return true;\n      });\n\n      if (filtered.length === 0) {\n        this.waitQueue.delete(resourceId);\n      } else {\n        this.waitQueue.set(resourceId, filtered);\n      }\n    }\n\n    // Clean up locks held too long\n    for (const [resourceId, agentId] of this.locks) {\n      const resource = this.resources.get(resourceId);\n      if (resource?.lockedAt) {\n        const lockAge = now - resource.lockedAt.getTime();\n        if (lockAge > this.config.resourceTimeout * 2) {\n          this.logger.warn('Force releasing stale lock', {\n            resourceId,\n            agentId,\n            lockAge,\n          });\n          this.unlockResource(resourceId, agentId);\n        }\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
