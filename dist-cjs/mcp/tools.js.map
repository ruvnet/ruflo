{
  "version": 3,
  "sources": ["../../src/mcp/tools.ts"],
  "sourcesContent": ["/**\n * Enhanced Tool registry for MCP with capability negotiation and discovery\n */\n\nimport type { MCPTool, MCPCapabilities, MCPProtocolVersion } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError } from '../utils/errors.js';\nimport { EventEmitter } from 'node:events';\n\nexport interface ToolCapability {\n  name: string;\n  version: string;\n  description: string;\n  category: string;\n  tags: string[];\n  requiredPermissions?: string[];\n  supportedProtocolVersions: MCPProtocolVersion[];\n  dependencies?: string[];\n  deprecated?: boolean;\n  deprecationMessage?: string;\n}\n\nexport interface ToolMetrics {\n  name: string;\n  totalInvocations: number;\n  successfulInvocations: number;\n  failedInvocations: number;\n  averageExecutionTime: number;\n  lastInvoked?: Date;\n  totalExecutionTime: number;\n}\n\nexport interface ToolDiscoveryQuery {\n  category?: string;\n  tags?: string[];\n  capabilities?: string[];\n  protocolVersion?: MCPProtocolVersion;\n  includeDeprecated?: boolean;\n  permissions?: string[];\n}\n\n/**\n * Enhanced Tool registry implementation with capability negotiation\n */\nexport class ToolRegistry extends EventEmitter {\n  private tools = new Map<string, MCPTool>();\n  private capabilities = new Map<string, ToolCapability>();\n  private metrics = new Map<string, ToolMetrics>();\n  private categories = new Set<string>();\n  private tags = new Set<string>();\n\n  constructor(private logger: ILogger) {\n    super();\n  }\n\n  /**\n   * Registers a new tool with enhanced capability information\n   */\n  register(tool: MCPTool, capability?: ToolCapability): void {\n    if (this.tools.has(tool.name)) {\n      throw new MCPError(`Tool already registered: ${tool.name}`);\n    }\n\n    // Validate tool schema\n    this.validateTool(tool);\n\n    // Register tool\n    this.tools.set(tool.name, tool);\n\n    // Register capability if provided\n    if (capability) {\n      this.registerCapability(tool.name, capability);\n    } else {\n      // Create default capability\n      const defaultCapability: ToolCapability = {\n        name: tool.name,\n        version: '1.0.0',\n        description: tool.description,\n        category: this.extractCategory(tool.name),\n        tags: this.extractTags(tool),\n        supportedProtocolVersions: [{ major: 2024, minor: 11, patch: 5 }],\n      };\n      this.registerCapability(tool.name, defaultCapability);\n    }\n\n    // Initialize metrics\n    this.metrics.set(tool.name, {\n      name: tool.name,\n      totalInvocations: 0,\n      successfulInvocations: 0,\n      failedInvocations: 0,\n      averageExecutionTime: 0,\n      totalExecutionTime: 0,\n    });\n\n    this.logger.debug('Tool registered', { name: tool.name });\n    this.emit('toolRegistered', { name: tool.name, capability });\n  }\n\n  /**\n   * Unregisters a tool\n   */\n  unregister(name: string): void {\n    if (!this.tools.has(name)) {\n      throw new MCPError(`Tool not found: ${name}`);\n    }\n\n    this.tools.delete(name);\n    this.logger.debug('Tool unregistered', { name });\n  }\n\n  /**\n   * Gets a tool by name\n   */\n  getTool(name: string): MCPTool | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Lists all registered tools\n   */\n  listTools(): Array<{ name: string; description: string }> {\n    return Array.from(this.tools.values()).map((tool) => ({\n      name: tool.name,\n      description: tool.description,\n    }));\n  }\n\n  /**\n   * Gets the number of registered tools\n   */\n  getToolCount(): number {\n    return this.tools.size;\n  }\n\n  /**\n   * Executes a tool with metrics tracking\n   */\n  async executeTool(name: string, input: unknown, context?: any): Promise<unknown> {\n    const tool = this.tools.get(name);\n    if (!tool) {\n      throw new MCPError(`Tool not found: ${name}`);\n    }\n\n    const startTime = Date.now();\n    const metrics = this.metrics.get(name);\n\n    this.logger.debug('Executing tool', { name, input });\n\n    try {\n      // Validate input against schema\n      this.validateInput(tool, input);\n\n      // Check tool capabilities and permissions\n      await this.checkToolCapabilities(name, context);\n\n      // Execute tool handler\n      const result = await tool.handler(input, context);\n\n      // Update success metrics\n      if (metrics) {\n        const executionTime = Date.now() - startTime;\n        metrics.totalInvocations++;\n        metrics.successfulInvocations++;\n        metrics.totalExecutionTime += executionTime;\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\n        metrics.lastInvoked = new Date();\n      }\n\n      this.logger.debug('Tool executed successfully', {\n        name,\n        executionTime: Date.now() - startTime,\n      });\n      this.emit('toolExecuted', { name, success: true, executionTime: Date.now() - startTime });\n\n      return result;\n    } catch (error) {\n      // Update failure metrics\n      if (metrics) {\n        const executionTime = Date.now() - startTime;\n        metrics.totalInvocations++;\n        metrics.failedInvocations++;\n        metrics.totalExecutionTime += executionTime;\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\n        metrics.lastInvoked = new Date();\n      }\n\n      this.logger.error('Tool execution failed', {\n        name,\n        error,\n        executionTime: Date.now() - startTime,\n      });\n      this.emit('toolExecuted', {\n        name,\n        success: false,\n        error,\n        executionTime: Date.now() - startTime,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Validates tool definition\n   */\n  private validateTool(tool: MCPTool): void {\n    if (!tool.name || typeof tool.name !== 'string') {\n      throw new MCPError('Tool name must be a non-empty string');\n    }\n\n    if (!tool.description || typeof tool.description !== 'string') {\n      throw new MCPError('Tool description must be a non-empty string');\n    }\n\n    if (typeof tool.handler !== 'function') {\n      throw new MCPError('Tool handler must be a function');\n    }\n\n    if (!tool.inputSchema || typeof tool.inputSchema !== 'object') {\n      throw new MCPError('Tool inputSchema must be an object');\n    }\n\n    // Validate tool name format (namespace/name)\n    if (!tool.name.includes('/')) {\n      throw new MCPError('Tool name must be in format: namespace/name');\n    }\n  }\n\n  /**\n   * Validates input against tool schema\n   */\n  private validateInput(tool: MCPTool, input: unknown): void {\n    // Simple validation - in production, use a JSON Schema validator\n    const schema = tool.inputSchema as any;\n\n    if (schema.type === 'object' && schema.properties) {\n      if (typeof input !== 'object' || input === null) {\n        throw new MCPError('Input must be an object');\n      }\n\n      const inputObj = input as Record<string, unknown>;\n\n      // Check required properties\n      if (schema.required && Array.isArray(schema.required)) {\n        for (const prop of schema.required) {\n          if (!(prop in inputObj)) {\n            throw new MCPError(`Missing required property: ${prop}`);\n          }\n        }\n      }\n\n      // Check property types\n      for (const [prop, propSchema] of Object.entries(schema.properties)) {\n        if (prop in inputObj) {\n          const value = inputObj[prop];\n          const expectedType = (propSchema as any).type;\n\n          if (expectedType && !this.checkType(value, expectedType)) {\n            throw new MCPError(`Invalid type for property ${prop}: expected ${expectedType}`);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks if a value matches a JSON Schema type\n   */\n  private checkType(value: unknown, type: string): boolean {\n    switch (type) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number';\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'object':\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n      case 'array':\n        return Array.isArray(value);\n      case 'null':\n        return value === null;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Register tool capability information\n   */\n  private registerCapability(toolName: string, capability: ToolCapability): void {\n    this.capabilities.set(toolName, capability);\n    this.categories.add(capability.category);\n    capability.tags.forEach((tag) => this.tags.add(tag));\n  }\n\n  /**\n   * Extract category from tool name\n   */\n  private extractCategory(toolName: string): string {\n    const parts = toolName.split('/');\n    return parts.length > 1 ? parts[0] : 'general';\n  }\n\n  /**\n   * Extract tags from tool definition\n   */\n  private extractTags(tool: MCPTool): string[] {\n    const tags: string[] = [];\n\n    // Extract from description\n    if (tool.description.toLowerCase().includes('file')) tags.push('filesystem');\n    if (tool.description.toLowerCase().includes('search')) tags.push('search');\n    if (tool.description.toLowerCase().includes('memory')) tags.push('memory');\n    if (tool.description.toLowerCase().includes('swarm')) tags.push('swarm');\n    if (tool.description.toLowerCase().includes('task')) tags.push('orchestration');\n\n    return tags.length > 0 ? tags : ['general'];\n  }\n\n  /**\n   * Check tool capabilities and permissions\n   */\n  private async checkToolCapabilities(toolName: string, context?: any): Promise<void> {\n    const capability = this.capabilities.get(toolName);\n    if (!capability) {\n      return; // No capability checks needed\n    }\n\n    // Check if tool is deprecated\n    if (capability.deprecated) {\n      this.logger.warn('Using deprecated tool', {\n        name: toolName,\n        message: capability.deprecationMessage,\n      });\n    }\n\n    // Check required permissions\n    if (capability.requiredPermissions && context?.permissions) {\n      const hasAllPermissions = capability.requiredPermissions.every((permission) =>\n        context.permissions.includes(permission),\n      );\n\n      if (!hasAllPermissions) {\n        throw new MCPError(\n          `Insufficient permissions for tool ${toolName}. Required: ${capability.requiredPermissions.join(', ')}`,\n        );\n      }\n    }\n\n    // Check protocol version compatibility\n    if (context?.protocolVersion) {\n      const isCompatible = capability.supportedProtocolVersions.some((version) =>\n        this.isProtocolVersionCompatible(context.protocolVersion, version),\n      );\n\n      if (!isCompatible) {\n        throw new MCPError(\n          `Tool ${toolName} is not compatible with protocol version ${context.protocolVersion.major}.${context.protocolVersion.minor}.${context.protocolVersion.patch}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Check protocol version compatibility\n   */\n  private isProtocolVersionCompatible(\n    client: MCPProtocolVersion,\n    supported: MCPProtocolVersion,\n  ): boolean {\n    if (client.major !== supported.major) {\n      return false;\n    }\n\n    if (client.minor > supported.minor) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Discover tools based on query criteria\n   */\n  discoverTools(\n    query: ToolDiscoveryQuery = {},\n  ): Array<{ tool: MCPTool; capability: ToolCapability }> {\n    const results: Array<{ tool: MCPTool; capability: ToolCapability }> = [];\n\n    for (const [name, tool] of this.tools) {\n      const capability = this.capabilities.get(name);\n      if (!capability) continue;\n\n      // Filter by category\n      if (query.category && capability.category !== query.category) {\n        continue;\n      }\n\n      // Filter by tags\n      if (query.tags && !query.tags.some((tag) => capability.tags.includes(tag))) {\n        continue;\n      }\n\n      // Filter by capabilities\n      if (query.capabilities && !query.capabilities.every((cap) => capability.tags.includes(cap))) {\n        continue;\n      }\n\n      // Filter by protocol version\n      if (query.protocolVersion) {\n        const isCompatible = capability.supportedProtocolVersions.some((version) =>\n          this.isProtocolVersionCompatible(query.protocolVersion!, version),\n        );\n        if (!isCompatible) continue;\n      }\n\n      // Filter deprecated tools\n      if (!query.includeDeprecated && capability.deprecated) {\n        continue;\n      }\n\n      // Filter by permissions\n      if (query.permissions && capability.requiredPermissions) {\n        const hasAllPermissions = capability.requiredPermissions.every((permission) =>\n          query.permissions!.includes(permission),\n        );\n        if (!hasAllPermissions) continue;\n      }\n\n      results.push({ tool, capability });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get tool capability information\n   */\n  getToolCapability(name: string): ToolCapability | undefined {\n    return this.capabilities.get(name);\n  }\n\n  /**\n   * Get tool metrics\n   */\n  getToolMetrics(name?: string): ToolMetrics | ToolMetrics[] {\n    if (name) {\n      const metrics = this.metrics.get(name);\n      if (!metrics) {\n        throw new MCPError(`Metrics not found for tool: ${name}`);\n      }\n      return metrics;\n    }\n\n    return Array.from(this.metrics.values());\n  }\n\n  /**\n   * Get all available categories\n   */\n  getCategories(): string[] {\n    return Array.from(this.categories);\n  }\n\n  /**\n   * Get all available tags\n   */\n  getTags(): string[] {\n    return Array.from(this.tags);\n  }\n\n  /**\n   * Reset metrics for a tool or all tools\n   */\n  resetMetrics(toolName?: string): void {\n    if (toolName) {\n      const metrics = this.metrics.get(toolName);\n      if (metrics) {\n        Object.assign(metrics, {\n          totalInvocations: 0,\n          successfulInvocations: 0,\n          failedInvocations: 0,\n          averageExecutionTime: 0,\n          totalExecutionTime: 0,\n          lastInvoked: undefined,\n        });\n      }\n    } else {\n      for (const metrics of this.metrics.values()) {\n        Object.assign(metrics, {\n          totalInvocations: 0,\n          successfulInvocations: 0,\n          failedInvocations: 0,\n          averageExecutionTime: 0,\n          totalExecutionTime: 0,\n          lastInvoked: undefined,\n        });\n      }\n    }\n\n    this.emit('metricsReset', { toolName });\n  }\n\n  /**\n   * Get comprehensive registry statistics\n   */\n  getRegistryStats(): {\n    totalTools: number;\n    toolsByCategory: Record<string, number>;\n    toolsByTag: Record<string, number>;\n    totalInvocations: number;\n    successRate: number;\n    averageExecutionTime: number;\n  } {\n    const stats = {\n      totalTools: this.tools.size,\n      toolsByCategory: {} as Record<string, number>,\n      toolsByTag: {} as Record<string, number>,\n      totalInvocations: 0,\n      successRate: 0,\n      averageExecutionTime: 0,\n    };\n\n    // Count by category\n    for (const capability of this.capabilities.values()) {\n      stats.toolsByCategory[capability.category] =\n        (stats.toolsByCategory[capability.category] || 0) + 1;\n\n      for (const tag of capability.tags) {\n        stats.toolsByTag[tag] = (stats.toolsByTag[tag] || 0) + 1;\n      }\n    }\n\n    // Calculate execution stats\n    let totalExecutionTime = 0;\n    let totalSuccessful = 0;\n\n    for (const metrics of this.metrics.values()) {\n      stats.totalInvocations += metrics.totalInvocations;\n      totalSuccessful += metrics.successfulInvocations;\n      totalExecutionTime += metrics.totalExecutionTime;\n    }\n\n    if (stats.totalInvocations > 0) {\n      stats.successRate = (totalSuccessful / stats.totalInvocations) * 100;\n      stats.averageExecutionTime = totalExecutionTime / stats.totalInvocations;\n    }\n\n    return stats;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
