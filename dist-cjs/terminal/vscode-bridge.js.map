{
  "version": 3,
  "sources": ["../../src/terminal/vscode-bridge.ts"],
  "sourcesContent": ["import { getErrorMessage } from '../utils/error-handler.js';\n/**\n * VSCode Extension Bridge for Terminal Integration\n *\n * This file provides the bridge between Claude-Flow and VSCode extension API\n * for terminal management and output capture.\n *\n * NOTE: This file is only used when Claude-Flow is packaged as a VS Code extension.\n * It is excluded from the main CLI build. If you need to use this in a VS Code\n * extension context, install @types/vscode as a devDependency.\n */\n\nimport * as vscode from 'vscode';\n\n/**\n * Terminal output processors registry\n */\nconst terminalOutputProcessors = new Map<string, (data: string) => void>();\n\n/**\n * Active terminals registry\n */\nconst activeTerminals = new Map<string, vscode.Terminal>();\n\n/**\n * Terminal write emulators for output capture\n */\nconst terminalWriteEmulators = new Map<vscode.Terminal, vscode.EventEmitter<string>>();\n\n/**\n * Initialize the VSCode terminal bridge\n */\nexport function initializeTerminalBridge(context: vscode.ExtensionContext): void {\n  // Inject VSCode API into global scope for Claude-Flow\n  (globalThis as any).vscode = vscode;\n\n  // Register terminal output processor function\n  (globalThis as any).registerTerminalOutputProcessor = (\n    terminalId: string,\n    processor: (data: string) => void,\n  ) => {\n    terminalOutputProcessors.set(terminalId, processor);\n  };\n\n  // Override terminal creation to capture output\n  const originalCreateTerminal = vscode.window.createTerminal;\n  (vscode.window as any).createTerminal = function (options: vscode.TerminalOptions) {\n    const terminal = originalCreateTerminal.call(vscode.window, options) as vscode.Terminal;\n\n    // Create write emulator for this terminal\n    const writeEmulator = new vscode.EventEmitter<string>();\n    terminalWriteEmulators.set(terminal, writeEmulator);\n\n    // Find terminal ID from name\n    const match = options.name?.match(/Claude-Flow Terminal ([\\w-]+)/);\n    if (match) {\n      const terminalId = match[1];\n      activeTerminals.set(terminalId, terminal);\n\n      // Set up output capture\n      captureTerminalOutput(terminal, terminalId);\n    }\n\n    return terminal;\n  };\n\n  // Clean up on terminal close\n  context.subscriptions.push(\n    vscode.window.onDidCloseTerminal((terminal: vscode.Terminal) => {\n      // Find and remove from registries\n      for (const [id, term] of activeTerminals.entries()) {\n        if (term === terminal) {\n          activeTerminals.delete(id);\n          terminalOutputProcessors.delete(id);\n          break;\n        }\n      }\n\n      // Clean up write emulator\n      const emulator = terminalWriteEmulators.get(terminal);\n      if (emulator) {\n        emulator.dispose();\n        terminalWriteEmulators.delete(terminal);\n      }\n    }),\n  );\n}\n\n/**\n * Capture terminal output using various methods\n */\nfunction captureTerminalOutput(terminal: vscode.Terminal, terminalId: string): void {\n  // Method 1: Use terminal.sendText override to capture commands\n  const originalSendText = terminal.sendText;\n  (terminal as any).sendText = function (text: string, addNewLine?: boolean) {\n    // Call original method\n    originalSendText.call(terminal, text, addNewLine);\n\n    // Process command\n    const processor = terminalOutputProcessors.get(terminalId);\n    if (processor && text) {\n      // Simulate command echo\n      processor(text + (addNewLine !== false ? '\\n' : ''));\n    }\n  };\n\n  // Method 2: Use proposed API if available\n  if ('onDidWriteData' in terminal) {\n    const writeDataEvent = (terminal as any).onDidWriteData;\n    if (writeDataEvent) {\n      writeDataEvent((data: string) => {\n        const processor = terminalOutputProcessors.get(terminalId);\n        if (processor) {\n          processor(data);\n        }\n      });\n    }\n  }\n\n  // Method 3: Use terminal renderer if available\n  setupTerminalRenderer(terminal, terminalId);\n}\n\n/**\n * Set up terminal renderer for output capture\n */\nfunction setupTerminalRenderer(terminal: vscode.Terminal, terminalId: string): void {\n  // Check if terminal renderer API is available\n  if (vscode.window.registerTerminalProfileProvider) {\n    // This is a more advanced method that requires additional setup\n    // It would involve creating a custom terminal profile that captures output\n\n    // For now, we'll use a simpler approach with periodic output checking\n    let lastOutput = '';\n    const checkOutput = setInterval(() => {\n      // This is a placeholder - actual implementation would depend on\n      // available VSCode APIs for reading terminal content\n\n      // Check if terminal is still active\n      if (!activeTerminals.has(terminalId)) {\n        clearInterval(checkOutput);\n      }\n    }, 100);\n  }\n}\n\n/**\n * Create a terminal with output capture\n */\nexport async function createCapturedTerminal(\n  name: string,\n  shellPath?: string,\n  shellArgs?: string[],\n): Promise<{\n  terminal: vscode.Terminal;\n  onData: vscode.Event<string>;\n}> {\n  const writeEmulator = new vscode.EventEmitter<string>();\n\n  const terminal = vscode.window.createTerminal({\n    name,\n    shellPath,\n    shellArgs,\n  });\n\n  terminalWriteEmulators.set(terminal, writeEmulator);\n\n  return {\n    terminal,\n    onData: writeEmulator.event,\n  };\n}\n\n/**\n * Send command to terminal and capture output\n */\nexport async function executeTerminalCommand(\n  terminal: vscode.Terminal,\n  command: string,\n  timeout: number = 30000,\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const writeEmulator = terminalWriteEmulators.get(terminal);\n    if (!writeEmulator) {\n      reject(new Error('No write emulator for terminal'));\n      return;\n    }\n\n    let output = '';\n    const marker = `__COMMAND_COMPLETE_${Date.now()}__`;\n\n    // Set up output listener\n    const disposable = writeEmulator.event((data: string) => {\n      output += data;\n\n      if (output.includes(marker)) {\n        // Command completed\n        disposable.dispose();\n        const result = output.substring(0, output.indexOf(marker));\n        resolve(result);\n      }\n    });\n\n    // Set timeout\n    const timer = setTimeout(() => {\n      disposable.dispose();\n      reject(new Error('Command timeout'));\n    }, timeout);\n\n    // Execute command with marker\n    terminal.sendText(`${command} && echo \"${marker}\"`);\n\n    // Clear timeout on success\n    writeEmulator.event(() => {\n      if (output.includes(marker)) {\n        clearTimeout(timer);\n      }\n    });\n  });\n}\n\n/**\n * Get terminal by ID\n */\nexport function getTerminalById(terminalId: string): vscode.Terminal | undefined {\n  return activeTerminals.get(terminalId);\n}\n\n/**\n * Dispose all terminal resources\n */\nexport function disposeTerminalBridge(): void {\n  // Clean up all terminals\n  for (const terminal of activeTerminals.values()) {\n    terminal.dispose();\n  }\n  activeTerminals.clear();\n\n  // Clean up processors\n  terminalOutputProcessors.clear();\n\n  // Clean up write emulators\n  for (const emulator of terminalWriteEmulators.values()) {\n    emulator.dispose();\n  }\n  terminalWriteEmulators.clear();\n}\n"],
  "mappings": "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",
  "names": []
}
