{"version":3,"sources":["../../../src/mcp/claude-code-wrapper.ts"],"sourcesContent":["#!/usr/bin/env node\r\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\r\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\r\nimport {\r\n  CallToolRequestSchema,\r\n  ListToolsRequestSchema,\r\n  Tool,\r\n  CallToolResult,\r\n  TextContent,\r\n  ImageContent,\r\n  EmbeddedResource,\r\n} from '@modelcontextprotocol/sdk/types.js';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport { fileURLToPath } from 'url';\r\nimport { SparcMode, loadSparcModes } from './sparc-modes.js';\r\n// Simple ID generation\r\nfunction generateId(): string {\r\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\ninterface SparcContext {\r\n  memoryKey?: string;\r\n  parallel?: boolean;\r\n  timeout?: number;\r\n  workingDirectory?: string;\r\n}\r\n\r\ninterface SwarmAgent {\r\n  id: string;\r\n  mode: string;\r\n  task: string;\r\n  status: 'pending' | 'active' | 'completed' | 'failed';\r\n  result?: any;\r\n}\r\n\r\ninterface SwarmExecution {\r\n  id: string;\r\n  objective: string;\r\n  strategy: string;\r\n  mode: string;\r\n  agents: SwarmAgent[];\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  status: 'active' | 'completed' | 'failed';\r\n}\r\n\r\nexport class ClaudeCodeMCPWrapper {\r\n  private server: Server;\r\n  private sparcModes: Map<string, SparcMode> = new Map();\r\n  private swarmExecutions: Map<string, SwarmExecution> = new Map();\r\n  private claudeCodeMCP: any; // Reference to Claude Code MCP client\r\n\r\n  constructor() {\r\n    this.server = new Server(\r\n      {\r\n        name: 'claude-flow-wrapper',\r\n        version: '1.0.0',\r\n      },\r\n      {\r\n        capabilities: {\r\n          tools: {},\r\n        },\r\n      },\r\n    );\r\n\r\n    this.setupHandlers();\r\n    this.loadSparcModes();\r\n  }\r\n\r\n  private async loadSparcModes() {\r\n    try {\r\n      const modes = await loadSparcModes();\r\n      modes.forEach((mode) => {\r\n        this.sparcModes.set(mode.name, mode);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to load SPARC modes:', error);\r\n    }\r\n  }\r\n\r\n  private setupHandlers() {\r\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({\r\n      tools: await this.getTools(),\r\n    }));\r\n\r\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =>\r\n      this.handleToolCall(request.params.name, request.params.arguments || {}),\r\n    );\r\n  }\r\n\r\n  private async getTools(): Promise<Tool[]> {\r\n    const tools: Tool[] = [];\r\n\r\n    // Add SPARC mode tools\r\n    for (const [name, mode] of this.sparcModes) {\r\n      tools.push({\r\n        name: `sparc_${name}`,\r\n        description: `Execute SPARC ${name} mode: ${mode.description}`,\r\n        inputSchema: {\r\n          type: 'object',\r\n          properties: {\r\n            task: {\r\n              type: 'string',\r\n              description: 'The task description for the SPARC mode to execute',\r\n            },\r\n            context: {\r\n              type: 'object',\r\n              description: 'Optional context or parameters for the task',\r\n              properties: {\r\n                memoryKey: {\r\n                  type: 'string',\r\n                  description: 'Memory key to store results',\r\n                },\r\n                parallel: {\r\n                  type: 'boolean',\r\n                  description: 'Enable parallel execution',\r\n                },\r\n              },\r\n            },\r\n          },\r\n          required: ['task'],\r\n        },\r\n      });\r\n    }\r\n\r\n    // Add meta tools\r\n    tools.push(\r\n      {\r\n        name: 'sparc_list',\r\n        description: 'List all available SPARC modes',\r\n        inputSchema: {\r\n          type: 'object',\r\n          properties: {\r\n            verbose: {\r\n              type: 'boolean',\r\n              description: 'Include detailed information',\r\n            },\r\n          },\r\n        },\r\n      },\r\n      {\r\n        name: 'sparc_swarm',\r\n        description: 'Coordinate multiple SPARC agents in a swarm',\r\n        inputSchema: {\r\n          type: 'object',\r\n          properties: {\r\n            objective: {\r\n              type: 'string',\r\n              description: 'The swarm objective',\r\n            },\r\n            strategy: {\r\n              type: 'string',\r\n              enum: [\r\n                'research',\r\n                'development',\r\n                'analysis',\r\n                'testing',\r\n                'optimization',\r\n                'maintenance',\r\n              ],\r\n              description: 'Swarm execution strategy',\r\n            },\r\n            mode: {\r\n              type: 'string',\r\n              enum: ['centralized', 'distributed', 'hierarchical', 'mesh', 'hybrid'],\r\n              description: 'Coordination mode',\r\n            },\r\n            maxAgents: {\r\n              type: 'number',\r\n              description: 'Maximum number of agents',\r\n              default: 5,\r\n            },\r\n          },\r\n          required: ['objective', 'strategy'],\r\n        },\r\n      },\r\n      {\r\n        name: 'sparc_swarm_status',\r\n        description: 'Check status of running swarms and list created files',\r\n        inputSchema: {\r\n          type: 'object',\r\n          properties: {\r\n            swarmId: {\r\n              type: 'string',\r\n              description: 'Optional swarm ID to check specific swarm',\r\n            },\r\n          },\r\n        },\r\n      },\r\n    );\r\n\r\n    return tools;\r\n  }\r\n\r\n  private async handleToolCall(toolName: string, args: any): Promise<CallToolResult> {\r\n    try {\r\n      if (toolName.startsWith('sparc_')) {\r\n        return await this.handleSparcTool(toolName, args);\r\n      }\r\n\r\n      // Pass through to Claude Code MCP\r\n      return this.forwardToClaudeCode(toolName, args);\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: `Error: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n        isError: true,\r\n      };\r\n    }\r\n  }\r\n\r\n  private async handleSparcTool(toolName: string, args: any): Promise<CallToolResult> {\r\n    const mode = toolName.replace('sparc_', '');\r\n\r\n    // Handle special tools\r\n    if (mode === 'list') {\r\n      return this.listModes(args.verbose);\r\n    }\r\n    if (mode === 'swarm') {\r\n      return this.handleSwarm(args);\r\n    }\r\n    if (mode === 'swarm_status') {\r\n      return this.getSwarmStatus(args.swarmId);\r\n    }\r\n\r\n    // Standard SPARC mode execution\r\n    const sparcMode = this.sparcModes.get(mode);\r\n    if (!sparcMode) {\r\n      throw new Error(`Unknown SPARC mode: ${mode}`);\r\n    }\r\n\r\n    // Execute the SPARC mode directly\r\n    try {\r\n      // Import the execution function dynamically to avoid circular dependencies\r\n      // const { executeSparcMode } = await import('../cli/mcp-stdio-server.js');\r\n      // TODO: Implement proper SPARC mode execution or fix import path\r\n      const executeSparcMode = (mode: string, task: string, tools: any[], context: any) => {\r\n        throw new Error('SPARC mode execution not yet implemented in wrapper');\r\n      };\r\n\r\n      const result = await executeSparcMode(\r\n        mode,\r\n        args.task,\r\n        sparcMode.tools || [],\r\n        args.context || {},\r\n      );\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: result.output,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: `Error executing SPARC ${mode}: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n        isError: true,\r\n      };\r\n    }\r\n  }\r\n\r\n  private buildEnhancedPrompt(mode: SparcMode, task: string, context?: SparcContext): string {\r\n    const parts: string[] = [];\r\n\r\n    // Add SPARC mode header\r\n    parts.push(`SPARC: ${mode.name}\\n`);\r\n    parts.push(`## Mode Description\\n${mode.description}\\n`);\r\n\r\n    // Add available tools\r\n    if (mode.tools && mode.tools.length > 0) {\r\n      parts.push(`## Available Tools`);\r\n      mode.tools.forEach((tool) => {\r\n        parts.push(`- **${tool}**: ${this.getToolDescription(tool)}`);\r\n      });\r\n      parts.push('');\r\n    }\r\n\r\n    // Add usage pattern\r\n    if (mode.usagePattern) {\r\n      parts.push(`## Usage Pattern\\n\\`\\`\\`javascript\\n${mode.usagePattern}\\n\\`\\`\\`\\n`);\r\n    }\r\n\r\n    // Add best practices\r\n    if (mode.bestPractices) {\r\n      parts.push(`## Best Practices`);\r\n      mode.bestPractices.forEach((practice) => {\r\n        parts.push(`- ${practice}`);\r\n      });\r\n      parts.push('');\r\n    }\r\n\r\n    // Add integration capabilities\r\n    if (mode.integrationCapabilities) {\r\n      parts.push(`## Integration Capabilities\\nThis mode integrates with:`);\r\n      mode.integrationCapabilities.forEach((capability) => {\r\n        parts.push(`- ${capability}`);\r\n      });\r\n      parts.push('');\r\n    }\r\n\r\n    // Add instructions\r\n    if (mode.instructions) {\r\n      parts.push(`## Instructions\\n${mode.instructions}\\n`);\r\n    }\r\n\r\n    // Add the actual task\r\n    parts.push(`## TASK: ${task}\\n`);\r\n\r\n    // Add SPARC methodology\r\n    parts.push(this.getSparcMethodology(mode.name, task, context));\r\n\r\n    // Add context if provided\r\n    if (context) {\r\n      if (context.memoryKey) {\r\n        parts.push(`**Memory Key:** \\`${context.memoryKey}\\``);\r\n      }\r\n      if (context.parallel) {\r\n        parts.push(`**Parallel Execution:** Enabled`);\r\n      }\r\n      if (context.workingDirectory) {\r\n        parts.push(`**Working Directory:** ${context.workingDirectory}`);\r\n      }\r\n    }\r\n\r\n    return parts.join('\\n');\r\n  }\r\n\r\n  private getToolDescription(tool: string): string {\r\n    const descriptions: Record<string, string> = {\r\n      TodoWrite: 'Create and manage task coordination',\r\n      TodoRead: 'Monitor task progress and status',\r\n      Task: 'Spawn and manage specialized agents',\r\n      Memory: 'Store and retrieve coordination data',\r\n      Bash: 'Execute system commands',\r\n      Read: 'Read file contents',\r\n      Write: 'Write files',\r\n      Edit: 'Edit existing files',\r\n      MultiEdit: 'Make multiple edits to a file',\r\n      Glob: 'Search for files by pattern',\r\n      Grep: 'Search file contents',\r\n      WebSearch: 'Search the web',\r\n      WebFetch: 'Fetch web content',\r\n    };\r\n    return descriptions[tool] || `${tool} tool`;\r\n  }\r\n\r\n  private getSparcMethodology(mode: string, task: string, context?: SparcContext): string {\r\n    return `\r\n# üéØ SPARC METHODOLOGY EXECUTION FRAMEWORK\r\n\r\nYou are operating in **SPARC ${mode} mode**. Follow the SPARC Workflow precisely:\r\n\r\n## SPARC Workflow Steps\r\n\r\n### 1Ô∏è‚É£ SPECIFICATION - Clarify goals, scope, constraints\r\n**Your Task:** ${task}\r\n\r\n**Analysis Required:**\r\n- Break down into clear, measurable objectives\r\n- Identify all requirements and constraints  \r\n- Define acceptance criteria\r\n- Never hard-code environment variables\r\n\r\n**Use TodoWrite to capture specifications:**\r\n\\`\\`\\`javascript\r\nTodoWrite([\r\n  {\r\n    id: \"specification\",\r\n    content: \"Clarify goals, scope, and constraints for: ${task}\",\r\n    status: \"pending\",\r\n    priority: \"high\"\r\n  },\r\n  {\r\n    id: \"acceptance_criteria\", \r\n    content: \"Define clear acceptance criteria and success metrics\",\r\n    status: \"pending\",\r\n    priority: \"high\"\r\n  }\r\n]);\r\n\\`\\`\\`\r\n\r\n### 2Ô∏è‚É£ PSEUDOCODE - High-level logic with TDD anchors\r\n**Design Approach:**\r\n- Identify core functions and data structures\r\n- Create TDD test anchors before implementation\r\n- Map out component interactions\r\n\r\n### 3Ô∏è‚É£ ARCHITECTURE - Design extensible systems\r\n**Architecture Requirements:**\r\n- Clear service boundaries\r\n- Define interfaces between components\r\n- Design for extensibility and maintainability\r\n- Mode-specific architecture: ${this.getModeSpecificArchitecture(mode)}\r\n\r\n### 4Ô∏è‚É£ REFINEMENT - Iterate with TDD and security\r\n**Refinement Process:**\r\n- TDD implementation cycles\r\n- Security vulnerability checks (injection, XSS, CSRF)\r\n- Performance optimization\r\n- Code review and refactoring\r\n- All files must be ‚â§ 500 lines\r\n\r\n### 5Ô∏è‚É£ COMPLETION - Integrate and verify\r\n**Completion Checklist:**\r\n- [ ] All acceptance criteria met\r\n- [ ] Tests passing (comprehensive test suite)\r\n- [ ] Security review completed\r\n- [ ] Documentation updated\r\n- [ ] Results stored in Memory: \\`sparc_${mode}_${Date.now()}\\`\r\n- [ ] No hard-coded secrets or env vars\r\n- [ ] Proper error handling in all code paths\r\n\r\n## üöÄ Execution Configuration\r\n\r\n**Mode:** ${mode}\r\n**Strategy:** ${this.getModeStrategy(mode)}\r\n**Memory Key:** \\`sparc_${mode}_${Date.now()}\\`\r\n**Batch Operations:** ${context?.parallel ? 'Enabled' : 'Standard operations'}\r\n**Primary Tools:** ${this.sparcModes.get(mode)?.tools?.join(', ') || 'Standard tools'}\r\n\r\n## üìã Must Block (Non-negotiable)\r\n- Every file ‚â§ 500 lines\r\n- No hard-coded secrets or env vars\r\n- All user inputs validated\r\n- No security vulnerabilities\r\n- Proper error handling in all paths\r\n- Each subtask ends with completion check\r\n\r\n## üéØ IMMEDIATE ACTION REQUIRED\r\n\r\n**START NOW with SPARC Step 1 - SPECIFICATION:**\r\n\r\n1. Create comprehensive TodoWrite task breakdown following SPARC workflow\r\n2. Set \"specification\" task to \"in_progress\"\r\n3. Analyze requirements and define acceptance criteria\r\n4. Store initial analysis in Memory: \\`sparc_${mode}_${Date.now()}\\`\r\n\r\n**Remember:** You're in **${mode}** mode. Follow the SPARC workflow systematically:\r\nSpecification ‚Üí Pseudocode ‚Üí Architecture ‚Üí Refinement ‚Üí Completion\r\n\r\nUse the appropriate tools for each phase and maintain progress in TodoWrite.`;\r\n  }\r\n\r\n  private getModeSpecificArchitecture(mode: string): string {\r\n    const architectures: Record<string, string> = {\r\n      orchestrator: 'Design for parallel agent coordination with clear task boundaries',\r\n      coder: 'Focus on clean code architecture with proper abstractions',\r\n      researcher: 'Structure for data collection and analysis pipelines',\r\n      tdd: 'Test-first design with comprehensive test coverage',\r\n      architect: 'System-wide design patterns and component interactions',\r\n      reviewer: 'Code quality gates and review checkpoints',\r\n      debugger: 'Diagnostic and monitoring integration points',\r\n      tester: 'Test framework integration and coverage analysis',\r\n    };\r\n    return architectures[mode] || 'Design for the specific mode requirements';\r\n  }\r\n\r\n  private getModeStrategy(mode: string): string {\r\n    const strategies: Record<string, string> = {\r\n      orchestrator: 'Parallel coordination',\r\n      coder: 'Iterative development',\r\n      researcher: 'Deep analysis',\r\n      tdd: 'Test-driven cycles',\r\n      architect: 'System design',\r\n      reviewer: 'Quality assurance',\r\n      debugger: 'Systematic debugging',\r\n      tester: 'Comprehensive validation',\r\n    };\r\n    return strategies[mode] || 'Mode-specific execution';\r\n  }\r\n\r\n  private listModes(verbose: boolean): CallToolResult {\r\n    const modes = Array.from(this.sparcModes.values());\r\n\r\n    if (verbose) {\r\n      const content = modes.map((mode) => ({\r\n        name: mode.name,\r\n        description: mode.description,\r\n        tools: mode.tools,\r\n        bestPractices: mode.bestPractices,\r\n      }));\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: JSON.stringify(content, null, 2),\r\n          },\r\n        ],\r\n      };\r\n    }\r\n\r\n    const list = modes.map((m) => `- **${m.name}**: ${m.description}`).join('\\n');\r\n    return {\r\n      content: [\r\n        {\r\n          type: 'text',\r\n          text: `Available SPARC modes:\\n\\n${list}`,\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  private async handleSwarm(args: any): Promise<CallToolResult> {\r\n    const { objective, strategy, mode = 'distributed', maxAgents = 5 } = args;\r\n    const swarmId = generateId();\r\n\r\n    // Plan swarm agents\r\n    const agents = this.planSwarmAgents(objective, strategy, maxAgents);\r\n\r\n    // Create swarm execution record\r\n    const execution: SwarmExecution = {\r\n      id: swarmId,\r\n      objective,\r\n      strategy,\r\n      mode,\r\n      agents,\r\n      startTime: new Date(),\r\n      status: 'active',\r\n    };\r\n\r\n    this.swarmExecutions.set(swarmId, execution);\r\n\r\n    // Launch agents based on coordination mode\r\n    if (mode === 'distributed' || mode === 'mesh') {\r\n      // Parallel execution\r\n      await Promise.all(agents.map((agent) => this.launchSwarmAgent(agent, execution)));\r\n    } else {\r\n      // Sequential execution\r\n      for (const agent of agents) {\r\n        await this.launchSwarmAgent(agent, execution);\r\n      }\r\n    }\r\n\r\n    execution.status = 'completed';\r\n    execution.endTime = new Date();\r\n\r\n    return {\r\n      content: [\r\n        {\r\n          type: 'text',\r\n          text: JSON.stringify(\r\n            {\r\n              swarmId,\r\n              objective,\r\n              strategy,\r\n              mode,\r\n              agentCount: agents.length,\r\n              status: 'launched',\r\n              message: 'Swarm coordination initiated',\r\n            },\r\n            null,\r\n            2,\r\n          ),\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  private planSwarmAgents(objective: string, strategy: string, maxAgents: number): SwarmAgent[] {\r\n    const agents: SwarmAgent[] = [];\r\n\r\n    // Strategy-based agent planning\r\n    switch (strategy) {\r\n      case 'research':\r\n        agents.push(\r\n          {\r\n            id: generateId(),\r\n            mode: 'researcher',\r\n            task: `Research: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'analyst',\r\n            task: `Analyze findings for: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'documenter',\r\n            task: `Document research results: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'development':\r\n        agents.push(\r\n          {\r\n            id: generateId(),\r\n            mode: 'architect',\r\n            task: `Design architecture: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          { id: generateId(), mode: 'coder', task: `Implement: ${objective}`, status: 'pending' },\r\n          {\r\n            id: generateId(),\r\n            mode: 'tester',\r\n            task: `Test implementation: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'reviewer',\r\n            task: `Review code: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'analysis':\r\n        agents.push(\r\n          { id: generateId(), mode: 'analyst', task: `Analyze: ${objective}`, status: 'pending' },\r\n          {\r\n            id: generateId(),\r\n            mode: 'optimizer',\r\n            task: `Optimize based on analysis: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'testing':\r\n        agents.push(\r\n          {\r\n            id: generateId(),\r\n            mode: 'tester',\r\n            task: `Create test suite: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'debugger',\r\n            task: `Debug issues: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'optimization':\r\n        agents.push(\r\n          {\r\n            id: generateId(),\r\n            mode: 'analyst',\r\n            task: `Performance analysis: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'optimizer',\r\n            task: `Optimize: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n        );\r\n        break;\r\n\r\n      case 'maintenance':\r\n        agents.push(\r\n          {\r\n            id: generateId(),\r\n            mode: 'reviewer',\r\n            task: `Code review: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'debugger',\r\n            task: `Fix issues: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n          {\r\n            id: generateId(),\r\n            mode: 'documenter',\r\n            task: `Update documentation: ${objective}`,\r\n            status: 'pending',\r\n          },\r\n        );\r\n        break;\r\n    }\r\n\r\n    // Limit to maxAgents\r\n    return agents.slice(0, maxAgents);\r\n  }\r\n\r\n  private async launchSwarmAgent(agent: SwarmAgent, execution: SwarmExecution): Promise<void> {\r\n    agent.status = 'active';\r\n\r\n    try {\r\n      // Use the SPARC mode handler\r\n      const result = await this.handleSparcTool(`sparc_${agent.mode}`, {\r\n        task: agent.task,\r\n        context: {\r\n          memoryKey: `swarm_${execution.id}_${agent.id}`,\r\n          parallel: execution.mode === 'distributed',\r\n        },\r\n      });\r\n\r\n      agent.status = 'completed';\r\n      agent.result = result;\r\n    } catch (error) {\r\n      agent.status = 'failed';\r\n      agent.result = { error: error instanceof Error ? error.message : String(error) };\r\n    }\r\n  }\r\n\r\n  private getSwarmStatus(swarmId?: string): CallToolResult {\r\n    if (swarmId) {\r\n      const execution = this.swarmExecutions.get(swarmId);\r\n      if (!execution) {\r\n        return {\r\n          content: [\r\n            {\r\n              type: 'text',\r\n              text: `No swarm found with ID: ${swarmId}`,\r\n            },\r\n          ],\r\n        };\r\n      }\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: JSON.stringify(execution, null, 2),\r\n          },\r\n        ],\r\n      };\r\n    }\r\n\r\n    // Return all swarms\r\n    const swarms = Array.from(this.swarmExecutions.values()).map((e) => ({\r\n      id: e.id,\r\n      objective: e.objective,\r\n      status: e.status,\r\n      agentCount: e.agents.length,\r\n      startTime: e.startTime,\r\n      endTime: e.endTime,\r\n    }));\r\n\r\n    return {\r\n      content: [\r\n        {\r\n          type: 'text',\r\n          text: JSON.stringify(swarms, null, 2),\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  private async forwardToClaudeCode(toolName: string, args: any): Promise<CallToolResult> {\r\n    // For SPARC tools that were already handled, this shouldn't be called\r\n    // For other tools, we execute them using the existing logic\r\n\r\n    if (toolName === 'Task') {\r\n      // This is a SPARC task that's been enhanced with prompts\r\n      // Extract the mode from the description if possible\r\n      const modeMatch = args.description?.match(/SPARC (\\w+)/);\r\n      if (modeMatch) {\r\n        const modeName = modeMatch[1];\r\n        const mode = this.sparcModes.get(modeName);\r\n        if (mode) {\r\n          // Execute using the existing SPARC execution logic\r\n          try {\r\n            const result = await executeSparcMode(\r\n              modeName,\r\n              args.prompt || '',\r\n              mode.tools || [],\r\n              {},\r\n            );\r\n\r\n            return {\r\n              content: [\r\n                {\r\n                  type: 'text',\r\n                  text: result.output,\r\n                },\r\n              ],\r\n            };\r\n          } catch (error) {\r\n            return {\r\n              content: [\r\n                {\r\n                  type: 'text',\r\n                  text: `Error executing SPARC ${modeName}: ${error instanceof Error ? error.message : String(error)}`,\r\n                },\r\n              ],\r\n              isError: true,\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // For non-SPARC tools, return a message\r\n    return {\r\n      content: [\r\n        {\r\n          type: 'text',\r\n          text: `Tool ${toolName} is not available in this MCP server.`,\r\n        },\r\n      ],\r\n      isError: true,\r\n    };\r\n  }\r\n\r\n  async run() {\r\n    const transport = new StdioServerTransport();\r\n\r\n    // Log startup message\r\n    console.error('üöÄ Claude-Flow MCP Server (Wrapper Mode)');\r\n    console.error('üì¶ Using Claude Code MCP pass-through with SPARC prompt injection');\r\n    console.error('üîß All SPARC tools available with enhanced AI capabilities');\r\n    console.error('‚ÑπÔ∏è  To use legacy mode, set CLAUDE_FLOW_LEGACY_MCP=true');\r\n    console.error('');\r\n\r\n    await this.server.connect(transport);\r\n  }\r\n}\r\n\r\n// Run the server if this is the main module\r\nif (import.meta.url === `file://${process.argv[1]}`) {\r\n  const wrapper = new ClaudeCodeMCPWrapper();\r\n  wrapper.run().catch(console.error);\r\n}\r\n"],"names":["Server","StdioServerTransport","CallToolRequestSchema","ListToolsRequestSchema","path","fileURLToPath","loadSparcModes","generateId","Date","now","Math","random","toString","substr","__filename","url","__dirname","dirname","ClaudeCodeMCPWrapper","server","sparcModes","Map","swarmExecutions","claudeCodeMCP","name","version","capabilities","tools","setupHandlers","modes","forEach","mode","set","error","console","setRequestHandler","getTools","request","handleToolCall","params","arguments","push","description","inputSchema","type","properties","task","context","memoryKey","parallel","required","verbose","objective","strategy","enum","maxAgents","default","swarmId","toolName","args","startsWith","handleSparcTool","forwardToClaudeCode","content","text","Error","message","String","isError","replace","listModes","handleSwarm","getSwarmStatus","sparcMode","get","executeSparcMode","result","output","buildEnhancedPrompt","parts","length","tool","getToolDescription","usagePattern","bestPractices","practice","integrationCapabilities","capability","instructions","getSparcMethodology","workingDirectory","join","descriptions","TodoWrite","TodoRead","Task","Memory","Bash","Read","Write","Edit","MultiEdit","Glob","Grep","WebSearch","WebFetch","getModeSpecificArchitecture","getModeStrategy","architectures","orchestrator","coder","researcher","tdd","architect","reviewer","debugger","tester","strategies","Array","from","values","map","JSON","stringify","list","m","agents","planSwarmAgents","execution","id","startTime","status","Promise","all","agent","launchSwarmAgent","endTime","agentCount","slice","swarms","e","modeMatch","match","modeName","prompt","run","transport","connect","process","argv","wrapper","catch"],"mappings":"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"}