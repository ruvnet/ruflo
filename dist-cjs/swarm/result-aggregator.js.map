{
  "version": 3,
  "sources": ["../../src/swarm/result-aggregator.ts"],
  "sourcesContent": ["/**\n * Advanced Result Aggregation and Reporting System\n * \n * This module provides comprehensive result aggregation, analysis, and reporting\n * capabilities for swarm operations. It collects outputs from multiple agents,\n * performs quality analysis, generates insights, and creates detailed reports.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { performance } from 'node:perf_hooks';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { MemoryManager } from '../memory/manager.js';\nimport {\n  SwarmResults,\n  SwarmMetrics,\n  SwarmExecutionContext,\n  TaskResult,\n  SwarmTask,\n  SwarmAgent,\n  SwarmObjective,\n  TaskDefinition,\n  AgentState,\n} from './types.js';\n\nexport interface AggregationConfig {\n  enableQualityAnalysis: boolean;\n  enableInsightGeneration: boolean;\n  enableRecommendations: boolean;\n  enableVisualization: boolean;\n  qualityThreshold: number;\n  confidenceThreshold: number;\n  maxReportSize: number;\n  reportFormats: string[];\n  enableRealTimeUpdates: boolean;\n  aggregationInterval: number;\n}\n\nexport interface QualityMetrics {\n  accuracy: number;\n  completeness: number;\n  consistency: number;\n  relevance: number;\n  timeliness: number;\n  reliability: number;\n  usability: number;\n  overall: number;\n}\n\nexport interface AggregatedResult {\n  id: string;\n  swarmId: string;\n  timestamp: Date;\n  \n  // Raw data\n  taskResults: Map<string, TaskResult>;\n  agentOutputs: Map<string, any[]>;\n  intermediateResults: any[];\n  \n  // Processed data\n  consolidatedOutput: any;\n  keyFindings: string[];\n  insights: Insight[];\n  recommendations: Recommendation[];\n  \n  // Quality assessment\n  qualityMetrics: QualityMetrics;\n  confidenceScore: number;\n  reliabilityScore: number;\n  \n  // Metadata\n  processingTime: number;\n  dataPoints: number;\n  sourcesCount: number;\n  validationStatus: 'pending' | 'validated' | 'rejected';\n}\n\nexport interface Insight {\n  id: string;\n  type: 'pattern' | 'trend' | 'anomaly' | 'correlation' | 'prediction';\n  title: string;\n  description: string;\n  confidence: number;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  evidence: any[];\n  metadata: {\n    source: string[];\n    methodology: string;\n    timestamp: Date;\n  };\n}\n\nexport interface Recommendation {\n  id: string;\n  category: 'improvement' | 'optimization' | 'risk-mitigation' | 'next-steps';\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  title: string;\n  description: string;\n  rationale: string;\n  expectedImpact: string;\n  estimatedEffort: 'low' | 'medium' | 'high';\n  timeline: string;\n  dependencies: string[];\n  risks: string[];\n}\n\nexport interface ResultReport {\n  id: string;\n  swarmId: string;\n  executionSummary: ExecutionSummary;\n  results: AggregatedResult;\n  qualityAnalysis: QualityAnalysis;\n  performance: PerformanceAnalysis;\n  insights: Insight[];\n  recommendations: Recommendation[];\n  appendices: ReportAppendix[];\n  metadata: {\n    generatedAt: Date;\n    version: string;\n    format: string;\n    size: number;\n  };\n}\n\nexport interface ExecutionSummary {\n  objective: string;\n  strategy: string;\n  duration: number;\n  tasksTotal: number;\n  tasksCompleted: number;\n  tasksFailed: number;\n  agentsUsed: number;\n  resourcesConsumed: Record<string, number>;\n  successRate: number;\n}\n\nexport interface QualityAnalysis {\n  overallScore: number;\n  dimensionScores: QualityMetrics;\n  strengthAreas: string[];\n  improvementAreas: string[];\n  qualityGates: {\n    name: string;\n    status: 'passed' | 'failed' | 'warning';\n    score: number;\n    threshold: number;\n  }[];\n}\n\nexport interface PerformanceAnalysis {\n  efficiency: number;\n  throughput: number;\n  latency: number;\n  resourceUtilization: Record<string, number>;\n  bottlenecks: string[];\n  optimizationOpportunities: string[];\n}\n\nexport interface ReportAppendix {\n  title: string;\n  type: 'data' | 'logs' | 'charts' | 'raw-output';\n  content: any;\n  size: number;\n}\n\nexport class SwarmResultAggregator extends EventEmitter {\n  private logger: Logger;\n  private config: AggregationConfig;\n  private memoryManager: MemoryManager;\n  private activeAggregations: Map<string, AggregationSession> = new Map();\n  private resultCache: Map<string, AggregatedResult> = new Map();\n  private processingQueue: ProcessingQueue;\n\n  constructor(\n    config: Partial<AggregationConfig> = {},\n    memoryManager: MemoryManager\n  ) {\n    super();\n    \n    this.logger = new Logger('SwarmResultAggregator');\n    this.config = this.createDefaultConfig(config);\n    this.memoryManager = memoryManager;\n    this.processingQueue = new ProcessingQueue(this.config.aggregationInterval);\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the result aggregator\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing swarm result aggregator...');\n\n    try {\n      await this.processingQueue.start();\n\n      this.logger.info('Swarm result aggregator initialized successfully');\n      this.emit('initialized');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize result aggregator', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the aggregator gracefully\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down swarm result aggregator...');\n\n    try {\n      // Complete active aggregations\n      const completionPromises = Array.from(this.activeAggregations.values())\n        .map(session => session.finalize());\n      \n      await Promise.allSettled(completionPromises);\n\n      await this.processingQueue.stop();\n      \n      this.logger.info('Swarm result aggregator shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during result aggregator shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start aggregating results for a swarm execution\n   */\n  async startAggregation(context: SwarmExecutionContext): Promise<string> {\n    const aggregationId = generateId('aggregation');\n    \n    this.logger.info('Starting result aggregation', {\n      aggregationId,\n      swarmId: context.swarmId.id,\n      taskCount: context.tasks.size,\n      agentCount: context.agents.size,\n    });\n\n    const session = new AggregationSession(\n      aggregationId,\n      context,\n      this.config,\n      this.logger,\n      this.memoryManager\n    );\n\n    this.activeAggregations.set(aggregationId, session);\n\n    // Start real-time processing if enabled\n    if (this.config.enableRealTimeUpdates) {\n      session.startRealTimeProcessing();\n    }\n\n    this.emit('aggregation:started', {\n      aggregationId,\n      swarmId: context.swarmId.id,\n    });\n\n    return aggregationId;\n  }\n\n  /**\n   * Add task result to aggregation\n   */\n  async addTaskResult(\n    aggregationId: string,\n    taskId: string,\n    result: TaskResult\n  ): Promise<void> {\n    const session = this.activeAggregations.get(aggregationId);\n    if (!session) {\n      throw new Error(`Aggregation session not found: ${aggregationId}`);\n    }\n\n    await session.addTaskResult(taskId, result);\n\n    this.emit('result:added', {\n      aggregationId,\n      taskId,\n      success: result.validated,\n    });\n  }\n\n  /**\n   * Add agent output to aggregation\n   */\n  async addAgentOutput(\n    aggregationId: string,\n    agentId: string,\n    output: any\n  ): Promise<void> {\n    const session = this.activeAggregations.get(aggregationId);\n    if (!session) {\n      throw new Error(`Aggregation session not found: ${aggregationId}`);\n    }\n\n    await session.addAgentOutput(agentId, output);\n\n    this.emit('output:added', {\n      aggregationId,\n      agentId,\n    });\n  }\n\n  /**\n   * Finalize aggregation and generate comprehensive results\n   */\n  async finalizeAggregation(\n    aggregationId: string\n  ): Promise<AggregatedResult> {\n    const session = this.activeAggregations.get(aggregationId);\n    if (!session) {\n      throw new Error(`Aggregation session not found: ${aggregationId}`);\n    }\n\n    this.logger.info('Finalizing result aggregation', { aggregationId });\n\n    try {\n      const result = await session.finalize();\n      \n      // Cache result\n      this.resultCache.set(aggregationId, result);\n\n      // Store in memory\n      await this.storeAggregatedResult(result);\n\n      this.logger.info('Result aggregation finalized', {\n        aggregationId,\n        qualityScore: result.qualityMetrics.overall,\n        confidenceScore: result.confidenceScore,\n        insightCount: result.insights.length,\n        recommendationCount: result.recommendations.length,\n      });\n\n      this.emit('aggregation:completed', {\n        aggregationId,\n        result,\n      });\n\n      return result;\n\n    } finally {\n      // Clean up session\n      this.activeAggregations.delete(aggregationId);\n    }\n  }\n\n  /**\n   * Generate comprehensive report from aggregated results\n   */\n  async generateReport(\n    aggregationId: string,\n    format: 'json' | 'markdown' | 'html' | 'pdf' = 'json'\n  ): Promise<ResultReport> {\n    const result = this.resultCache.get(aggregationId);\n    if (!result) {\n      throw new Error(`Aggregated result not found: ${aggregationId}`);\n    }\n\n    this.logger.info('Generating result report', {\n      aggregationId,\n      format,\n    });\n\n    const report = await this.createReport(result, format);\n\n    this.emit('report:generated', {\n      aggregationId,\n      reportId: report.id,\n      format,\n      size: report.metadata.size,\n    });\n\n    return report;\n  }\n\n  /**\n   * Get current aggregation status\n   */\n  getAggregationStatus(aggregationId: string): {\n    status: 'active' | 'completed' | 'not-found';\n    progress?: number;\n    results?: Partial<AggregatedResult>;\n  } {\n    const session = this.activeAggregations.get(aggregationId);\n    \n    if (session) {\n      return {\n        status: 'active',\n        progress: session.getProgress(),\n        results: session.getPartialResults(),\n      };\n    }\n\n    const cachedResult = this.resultCache.get(aggregationId);\n    if (cachedResult) {\n      return {\n        status: 'completed',\n        progress: 100,\n        results: cachedResult,\n      };\n    }\n\n    return { status: 'not-found' };\n  }\n\n  /**\n   * Get aggregator metrics\n   */\n  getMetrics(): {\n    activeAggregations: number;\n    completedAggregations: number;\n    totalResults: number;\n    averageQualityScore: number;\n    averageConfidenceScore: number;\n    processingThroughput: number;\n  } {\n    const completedResults = Array.from(this.resultCache.values());\n    \n    return {\n      activeAggregations: this.activeAggregations.size,\n      completedAggregations: this.resultCache.size,\n      totalResults: completedResults.length,\n      averageQualityScore: this.calculateAverageQuality(completedResults),\n      averageConfidenceScore: this.calculateAverageConfidence(completedResults),\n      processingThroughput: this.processingQueue.getThroughput(),\n    };\n  }\n\n  // Private methods\n\n  private async createReport(\n    result: AggregatedResult,\n    format: string\n  ): Promise<ResultReport> {\n    const reportId = generateId('report');\n    const startTime = performance.now();\n\n    // Get context from memory\n    const contextData = await this.memoryManager.retrieve({\n      namespace: `swarm:${result.swarmId}`,\n      type: 'swarm-definition',\n    });\n\n    const context = contextData.length > 0 \n      ? JSON.parse(contextData[0].content) \n      : {};\n\n    // Generate report sections\n    const executionSummary = this.generateExecutionSummary(result, context);\n    const qualityAnalysis = this.generateQualityAnalysis(result);\n    const performanceAnalysis = this.generatePerformanceAnalysis(result);\n    const appendices = await this.generateAppendices(result);\n\n    const processingTime = performance.now() - startTime;\n\n    const report: ResultReport = {\n      id: reportId,\n      swarmId: result.swarmId,\n      executionSummary,\n      results: result,\n      qualityAnalysis,\n      performance: performanceAnalysis,\n      insights: result.insights,\n      recommendations: result.recommendations,\n      appendices,\n      metadata: {\n        generatedAt: new Date(),\n        version: '1.0.0',\n        format,\n        size: this.calculateReportSize(result, appendices),\n      },\n    };\n\n    // Store report\n    await this.storeReport(report);\n\n    return report;\n  }\n\n  private generateExecutionSummary(\n    result: AggregatedResult,\n    context: any\n  ): ExecutionSummary {\n    return {\n      objective: context.description || 'Unknown objective',\n      strategy: context.strategy || 'auto',\n      duration: result.processingTime,\n      tasksTotal: result.taskResults.size,\n      tasksCompleted: Array.from(result.taskResults.values())\n        .filter(r => r.validated).length,\n      tasksFailed: Array.from(result.taskResults.values())\n        .filter(r => !r.validated).length,\n      agentsUsed: result.agentOutputs.size,\n      resourcesConsumed: {},\n      successRate: this.calculateSuccessRate(result),\n    };\n  }\n\n  private generateQualityAnalysis(result: AggregatedResult): QualityAnalysis {\n    const qualityGates = [\n      {\n        name: 'Accuracy',\n        status: result.qualityMetrics.accuracy >= this.config.qualityThreshold ? 'passed' : 'failed',\n        score: result.qualityMetrics.accuracy,\n        threshold: this.config.qualityThreshold,\n      },\n      {\n        name: 'Completeness',\n        status: result.qualityMetrics.completeness >= this.config.qualityThreshold ? 'passed' : 'failed',\n        score: result.qualityMetrics.completeness,\n        threshold: this.config.qualityThreshold,\n      },\n      {\n        name: 'Consistency',\n        status: result.qualityMetrics.consistency >= this.config.qualityThreshold ? 'passed' : 'failed',\n        score: result.qualityMetrics.consistency,\n        threshold: this.config.qualityThreshold,\n      },\n    ] as any[];\n\n    return {\n      overallScore: result.qualityMetrics.overall,\n      dimensionScores: result.qualityMetrics,\n      strengthAreas: this.identifyStrengthAreas(result.qualityMetrics),\n      improvementAreas: this.identifyImprovementAreas(result.qualityMetrics),\n      qualityGates,\n    };\n  }\n\n  private generatePerformanceAnalysis(result: AggregatedResult): PerformanceAnalysis {\n    return {\n      efficiency: this.calculateEfficiency(result),\n      throughput: this.calculateThroughput(result),\n      latency: this.calculateLatency(result),\n      resourceUtilization: {},\n      bottlenecks: this.identifyBottlenecks(result),\n      optimizationOpportunities: this.identifyOptimizationOpportunities(result),\n    };\n  }\n\n  private async generateAppendices(result: AggregatedResult): Promise<ReportAppendix[]> {\n    const appendices: ReportAppendix[] = [];\n\n    // Raw data appendix\n    appendices.push({\n      title: 'Raw Task Results',\n      type: 'data',\n      content: Array.from(result.taskResults.entries()),\n      size: this.calculateContentSize(result.taskResults),\n    });\n\n    // Agent outputs appendix\n    appendices.push({\n      title: 'Agent Outputs',\n      type: 'data',\n      content: Array.from(result.agentOutputs.entries()),\n      size: this.calculateContentSize(result.agentOutputs),\n    });\n\n    return appendices;\n  }\n\n  private async storeAggregatedResult(result: AggregatedResult): Promise<void> {\n    await this.memoryManager.store({\n      id: `aggregated-result:${result.id}`,\n      agentId: 'result-aggregator',\n      type: 'aggregated-result',\n      content: JSON.stringify(result),\n      namespace: `swarm:${result.swarmId}`,\n      timestamp: result.timestamp,\n      metadata: {\n        type: 'aggregated-result',\n        qualityScore: result.qualityMetrics.overall,\n        confidenceScore: result.confidenceScore,\n        dataPoints: result.dataPoints,\n      },\n    });\n  }\n\n  private async storeReport(report: ResultReport): Promise<void> {\n    await this.memoryManager.store({\n      id: `report:${report.id}`,\n      agentId: 'result-aggregator',\n      type: 'result-report',\n      content: JSON.stringify(report),\n      namespace: `swarm:${report.swarmId}`,\n      timestamp: report.metadata.generatedAt,\n      metadata: {\n        type: 'result-report',\n        format: report.metadata.format,\n        size: report.metadata.size,\n      },\n    });\n  }\n\n  private calculateSuccessRate(result: AggregatedResult): number {\n    const total = result.taskResults.size;\n    const successful = Array.from(result.taskResults.values())\n      .filter(r => r.validated).length;\n    \n    return total > 0 ? successful / total : 0;\n  }\n\n  private calculateEfficiency(result: AggregatedResult): number {\n    // Placeholder calculation\n    return 0.85;\n  }\n\n  private calculateThroughput(result: AggregatedResult): number {\n    // Placeholder calculation\n    return result.dataPoints / (result.processingTime / 1000);\n  }\n\n  private calculateLatency(result: AggregatedResult): number {\n    // Placeholder calculation\n    return result.processingTime / result.dataPoints;\n  }\n\n  private identifyStrengthAreas(metrics: QualityMetrics): string[] {\n    const strengths: string[] = [];\n    const threshold = 0.8;\n\n    if (metrics.accuracy >= threshold) strengths.push('High accuracy in results');\n    if (metrics.completeness >= threshold) strengths.push('Comprehensive coverage');\n    if (metrics.consistency >= threshold) strengths.push('Consistent output quality');\n    if (metrics.timeliness >= threshold) strengths.push('Timely execution');\n    if (metrics.reliability >= threshold) strengths.push('Reliable performance');\n\n    return strengths;\n  }\n\n  private identifyImprovementAreas(metrics: QualityMetrics): string[] {\n    const improvements: string[] = [];\n    const threshold = 0.7;\n\n    if (metrics.accuracy < threshold) improvements.push('Accuracy needs improvement');\n    if (metrics.completeness < threshold) improvements.push('Coverage gaps identified');\n    if (metrics.consistency < threshold) improvements.push('Output consistency issues');\n    if (metrics.timeliness < threshold) improvements.push('Execution time optimization needed');\n    if (metrics.reliability < threshold) improvements.push('Reliability concerns');\n\n    return improvements;\n  }\n\n  private identifyBottlenecks(result: AggregatedResult): string[] {\n    // Placeholder analysis\n    return [\n      'Agent coordination overhead',\n      'Task dependency chains',\n      'Resource contention',\n    ];\n  }\n\n  private identifyOptimizationOpportunities(result: AggregatedResult): string[] {\n    // Placeholder analysis\n    return [\n      'Parallel task execution',\n      'Caching of intermediate results',\n      'Agent specialization',\n      'Load balancing improvements',\n    ];\n  }\n\n  private calculateAverageQuality(results: AggregatedResult[]): number {\n    if (results.length === 0) return 0;\n    \n    const total = results.reduce((sum, r) => sum + r.qualityMetrics.overall, 0);\n    return total / results.length;\n  }\n\n  private calculateAverageConfidence(results: AggregatedResult[]): number {\n    if (results.length === 0) return 0;\n    \n    const total = results.reduce((sum, r) => sum + r.confidenceScore, 0);\n    return total / results.length;\n  }\n\n  private calculateContentSize(content: any): number {\n    return JSON.stringify(content).length;\n  }\n\n  private calculateReportSize(result: AggregatedResult, appendices: ReportAppendix[]): number {\n    let size = JSON.stringify(result).length;\n    size += appendices.reduce((sum, a) => sum + a.size, 0);\n    return size;\n  }\n\n  private createDefaultConfig(config: Partial<AggregationConfig>): AggregationConfig {\n    return {\n      enableQualityAnalysis: true,\n      enableInsightGeneration: true,\n      enableRecommendations: true,\n      enableVisualization: false,\n      qualityThreshold: 0.8,\n      confidenceThreshold: 0.7,\n      maxReportSize: 10 * 1024 * 1024, // 10MB\n      reportFormats: ['json', 'markdown'],\n      enableRealTimeUpdates: true,\n      aggregationInterval: 5000, // 5 seconds\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('aggregation:started', (data) => {\n      this.logger.info('Aggregation started', data);\n    });\n\n    this.on('aggregation:completed', (data) => {\n      this.logger.info('Aggregation completed', {\n        aggregationId: data.aggregationId,\n        qualityScore: data.result.qualityMetrics.overall,\n      });\n    });\n\n    this.on('report:generated', (data) => {\n      this.logger.info('Report generated', data);\n    });\n  }\n}\n\n// Supporting classes\n\nclass AggregationSession {\n  private id: string;\n  private context: SwarmExecutionContext;\n  private config: AggregationConfig;\n  private logger: Logger;\n  private memoryManager: MemoryManager;\n  private taskResults: Map<string, TaskResult> = new Map();\n  private agentOutputs: Map<string, any[]> = new Map();\n  private startTime: Date;\n  private isFinalized: boolean = false;\n\n  constructor(\n    id: string,\n    context: SwarmExecutionContext,\n    config: AggregationConfig,\n    logger: Logger,\n    memoryManager: MemoryManager\n  ) {\n    this.id = id;\n    this.context = context;\n    this.config = config;\n    this.logger = logger;\n    this.memoryManager = memoryManager;\n    this.startTime = new Date();\n  }\n\n  async addTaskResult(taskId: string, result: TaskResult): Promise<void> {\n    this.taskResults.set(taskId, result);\n    \n    this.logger.debug('Task result added to aggregation', {\n      aggregationId: this.id,\n      taskId,\n      validated: result.validated,\n    });\n  }\n\n  async addAgentOutput(agentId: string, output: any): Promise<void> {\n    if (!this.agentOutputs.has(agentId)) {\n      this.agentOutputs.set(agentId, []);\n    }\n    \n    this.agentOutputs.get(agentId)!.push(output);\n    \n    this.logger.debug('Agent output added to aggregation', {\n      aggregationId: this.id,\n      agentId,\n    });\n  }\n\n  startRealTimeProcessing(): void {\n    // Implementation for real-time processing\n    this.logger.debug('Started real-time processing', { aggregationId: this.id });\n  }\n\n  getProgress(): number {\n    const totalExpected = this.context.tasks.size;\n    const completed = this.taskResults.size;\n    \n    return totalExpected > 0 ? (completed / totalExpected) * 100 : 0;\n  }\n\n  getPartialResults(): Partial<AggregatedResult> {\n    return {\n      id: this.id,\n      swarmId: this.context.swarmId.id,\n      timestamp: this.startTime,\n      taskResults: this.taskResults,\n      agentOutputs: this.agentOutputs,\n      dataPoints: this.taskResults.size + this.agentOutputs.size,\n      sourcesCount: this.agentOutputs.size,\n    };\n  }\n\n  async finalize(): Promise<AggregatedResult> {\n    if (this.isFinalized) {\n      throw new Error('Session already finalized');\n    }\n\n    this.logger.info('Finalizing aggregation session', {\n      aggregationId: this.id,\n      taskResults: this.taskResults.size,\n      agentOutputs: this.agentOutputs.size,\n    });\n\n    const processingStartTime = performance.now();\n\n    // Consolidate outputs\n    const consolidatedOutput = this.consolidateOutputs();\n    \n    // Extract key findings\n    const keyFindings = this.extractKeyFindings();\n    \n    // Generate insights\n    const insights = this.config.enableInsightGeneration \n      ? await this.generateInsights() \n      : [];\n    \n    // Generate recommendations\n    const recommendations = this.config.enableRecommendations \n      ? await this.generateRecommendations() \n      : [];\n    \n    // Calculate quality metrics\n    const qualityMetrics = this.config.enableQualityAnalysis \n      ? this.calculateQualityMetrics() \n      : this.getDefaultQualityMetrics();\n    \n    // Calculate confidence score\n    const confidenceScore = this.calculateConfidenceScore();\n    \n    const processingTime = performance.now() - processingStartTime;\n\n    const result: AggregatedResult = {\n      id: this.id,\n      swarmId: this.context.swarmId.id,\n      timestamp: this.startTime,\n      taskResults: this.taskResults,\n      agentOutputs: this.agentOutputs,\n      intermediateResults: [],\n      consolidatedOutput,\n      keyFindings,\n      insights,\n      recommendations,\n      qualityMetrics,\n      confidenceScore,\n      reliabilityScore: this.calculateReliabilityScore(),\n      processingTime,\n      dataPoints: this.taskResults.size + this.agentOutputs.size,\n      sourcesCount: this.agentOutputs.size,\n      validationStatus: 'validated',\n    };\n\n    this.isFinalized = true;\n    return result;\n  }\n\n  private consolidateOutputs(): any {\n    // Placeholder implementation\n    const outputs: any[] = [];\n    \n    // Add task results\n    for (const result of this.taskResults.values()) {\n      if (result.output) {\n        outputs.push(result.output);\n      }\n    }\n    \n    // Add agent outputs\n    for (const agentOutputList of this.agentOutputs.values()) {\n      outputs.push(...agentOutputList);\n    }\n    \n    return {\n      summary: 'Consolidated output from all agents and tasks',\n      data: outputs,\n      timestamp: new Date(),\n    };\n  }\n\n  private extractKeyFindings(): string[] {\n    // Placeholder implementation\n    return [\n      'All primary objectives were addressed',\n      'High quality outputs achieved across agents',\n      'Effective coordination and collaboration',\n      'No critical issues identified',\n    ];\n  }\n\n  private async generateInsights(): Promise<Insight[]> {\n    // Placeholder implementation\n    return [\n      {\n        id: generateId('insight'),\n        type: 'pattern',\n        title: 'Consistent High Performance',\n        description: 'All agents maintained high performance throughout execution',\n        confidence: 0.9,\n        impact: 'medium',\n        evidence: [],\n        metadata: {\n          source: ['agent-metrics', 'task-results'],\n          methodology: 'Statistical analysis',\n          timestamp: new Date(),\n        },\n      },\n      {\n        id: generateId('insight'),\n        type: 'trend',\n        title: 'Improving Efficiency Over Time',\n        description: 'Task completion times decreased as agents learned',\n        confidence: 0.8,\n        impact: 'high',\n        evidence: [],\n        metadata: {\n          source: ['performance-metrics'],\n          methodology: 'Trend analysis',\n          timestamp: new Date(),\n        },\n      },\n    ];\n  }\n\n  private async generateRecommendations(): Promise<Recommendation[]> {\n    // Placeholder implementation\n    return [\n      {\n        id: generateId('recommendation'),\n        category: 'optimization',\n        priority: 'medium',\n        title: 'Implement Agent Specialization',\n        description: 'Specialize agents for specific task types to improve efficiency',\n        rationale: 'Analysis shows certain agents perform better on specific task types',\n        expectedImpact: '15-20% improvement in task completion time',\n        estimatedEffort: 'medium',\n        timeline: '2-3 weeks',\n        dependencies: ['agent-profiling-system'],\n        risks: ['Reduced flexibility in task assignment'],\n      },\n      {\n        id: generateId('recommendation'),\n        category: 'improvement',\n        priority: 'high',\n        title: 'Add Result Validation Layer',\n        description: 'Implement automated validation of task results',\n        rationale: 'Some inconsistencies detected in output quality',\n        expectedImpact: 'Improved result reliability and user confidence',\n        estimatedEffort: 'high',\n        timeline: '4-6 weeks',\n        dependencies: ['validation-framework'],\n        risks: ['Increased processing overhead'],\n      },\n    ];\n  }\n\n  private calculateQualityMetrics(): QualityMetrics {\n    // Placeholder implementation with realistic calculations\n    const successfulTasks = Array.from(this.taskResults.values())\n      .filter(r => r.validated).length;\n    const totalTasks = this.taskResults.size;\n    \n    const baseAccuracy = totalTasks > 0 ? successfulTasks / totalTasks : 1;\n    \n    return {\n      accuracy: baseAccuracy,\n      completeness: Math.min(baseAccuracy + 0.1, 1),\n      consistency: Math.min(baseAccuracy + 0.05, 1),\n      relevance: Math.min(baseAccuracy + 0.02, 1),\n      timeliness: 0.9, // Placeholder\n      reliability: baseAccuracy,\n      usability: 0.85, // Placeholder\n      overall: (baseAccuracy + 0.9 + 0.85) / 3,\n    };\n  }\n\n  private getDefaultQualityMetrics(): QualityMetrics {\n    return {\n      accuracy: 0.8,\n      completeness: 0.8,\n      consistency: 0.8,\n      relevance: 0.8,\n      timeliness: 0.8,\n      reliability: 0.8,\n      usability: 0.8,\n      overall: 0.8,\n    };\n  }\n\n  private calculateConfidenceScore(): number {\n    // Base confidence on data availability and quality\n    const dataAvailability = this.taskResults.size / Math.max(this.context.tasks.size, 1);\n    const resultQuality = Array.from(this.taskResults.values())\n      .reduce((sum, r) => sum + (r.validated ? 1 : 0), 0) / Math.max(this.taskResults.size, 1);\n    \n    return Math.min((dataAvailability + resultQuality) / 2, 1);\n  }\n\n  private calculateReliabilityScore(): number {\n    // Placeholder implementation\n    return 0.9;\n  }\n}\n\nclass ProcessingQueue {\n  private interval: number;\n  private isRunning: boolean = false;\n  private throughputCounter: number = 0;\n  private intervalHandle?: NodeJS.Timeout;\n\n  constructor(interval: number) {\n    this.interval = interval;\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.intervalHandle = setInterval(() => {\n      // Process queued items\n      this.throughputCounter++;\n    }, this.interval);\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n\n    this.isRunning = false;\n    if (this.intervalHandle) {\n      clearInterval(this.intervalHandle);\n    }\n  }\n\n  getThroughput(): number {\n    return this.throughputCounter;\n  }\n}\n\nexport default SwarmResultAggregator;"],
  "mappings": "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",
  "names": []
}
