{"version":3,"sources":["../../../../src/cli/init/batch-tools.ts"],"sourcesContent":["// init/batch-tools.ts - Batch tools coordination guides\r\nexport async function createBatchToolsGuide(): Promise<void> {\r\n  const fs = await import('fs/promises');\r\n  const path = await import('path');\r\n\r\n  const batchToolsDir = '.claude/commands/swarm';\r\n\r\n  const batchToolsGuide = `# Batch Tools Coordination Guide\r\n\r\n## Overview\r\nThis guide explains how to use Claude Code's batch tools effectively for swarm orchestration and parallel task execution.\r\n\r\n## Core Batch Tools\r\n\r\n### TodoWrite/TodoRead - Task Coordination Engine\r\nThe foundation of all swarm operations - manages task distribution, progress tracking, and coordination.\r\n\r\n#### TodoWrite Usage\r\n\\`\\`\\`javascript\r\n// Create comprehensive task breakdown\r\nTodoWrite([\r\n  {\r\n    id: \"research_phase\",\r\n    content: \"Research cloud architecture patterns\",\r\n    status: \"pending\",\r\n    priority: \"high\",\r\n    dependencies: [],\r\n    estimatedTime: \"30min\",\r\n    assignedAgent: \"research_specialist\"\r\n  },\r\n  {\r\n    id: \"analysis_phase\", \r\n    content: \"Analyze performance requirements\",\r\n    status: \"pending\",\r\n    priority: \"medium\",\r\n    dependencies: [\"research_phase\"],\r\n    estimatedTime: \"45min\",\r\n    assignedAgent: \"performance_analyst\"\r\n  },\r\n  {\r\n    id: \"implementation_phase\",\r\n    content: \"Implement optimized solution\",\r\n    status: \"pending\", \r\n    priority: \"high\",\r\n    dependencies: [\"research_phase\", \"analysis_phase\"],\r\n    estimatedTime: \"90min\",\r\n    assignedAgent: \"implementation_specialist\"\r\n  }\r\n]);\r\n\\`\\`\\`\r\n\r\n#### TodoRead Monitoring\r\n\\`\\`\\`javascript\r\n// Regular progress checks\r\nconst progress = TodoRead();\r\nconsole.log(\"Current progress:\", progress);\r\n\r\n// Check specific task status\r\nconst researchStatus = TodoRead().find(task => task.id === \"research_phase\");\r\nif (researchStatus.status === \"completed\") {\r\n  // Trigger dependent tasks\r\n  updateTaskStatus(\"analysis_phase\", \"in_progress\");\r\n}\r\n\\`\\`\\`\r\n\r\n### Task Tool - Parallel Agent Orchestration\r\nLaunches multiple specialized agents simultaneously for maximum efficiency.\r\n\r\n#### Basic Agent Launching\r\n\\`\\`\\`javascript\r\n// Launch specialized agents for different domains\r\nTask(\"Architecture Research\", \r\n     \"Research microservices architecture patterns and best practices for scalable systems\");\r\n\r\nTask(\"Performance Analysis\", \r\n     \"Analyze current system performance and identify optimization opportunities\");\r\n\r\nTask(\"Security Assessment\", \r\n     \"Conduct security analysis and identify potential vulnerabilities\");\r\n\\`\\`\\`\r\n\r\n#### Coordinated Agent Launching\r\n\\`\\`\\`javascript\r\n// Launch agents with coordination instructions\r\nTask(\"Frontend Development Team\", \\`\r\n  Develop React components for user dashboard:\r\n  - Use TodoWrite to track component development progress\r\n  - Store component specifications in Memory under 'frontend_specs'\r\n  - Coordinate with backend team through Memory shared state\r\n  - Use batch Read operations for existing component analysis\r\n\\`);\r\n\r\nTask(\"Backend Development Team\", \\`\r\n  Develop API services for dashboard:\r\n  - Check Memory 'frontend_specs' for component requirements\r\n  - Use TodoWrite to track API endpoint development\r\n  - Store API documentation in Memory under 'api_specs'\r\n  - Coordinate database changes with data team\r\n\\`);\r\n\\`\\`\\`\r\n\r\n### Memory Tool - Cross-Agent Knowledge Sharing\r\nEnables persistent knowledge sharing and coordination across all agents.\r\n\r\n#### Knowledge Storage Patterns\r\n\\`\\`\\`javascript\r\n// Store research findings for other agents\r\nMemory.store(\"architecture_research\", {\r\n  patterns: {\r\n    microservices: {\r\n      benefits: [\"scalability\", \"maintainability\", \"technology_diversity\"],\r\n      challenges: [\"complexity\", \"network_latency\", \"data_consistency\"],\r\n      recommendations: [\"use_api_gateway\", \"implement_circuit_breakers\"]\r\n    },\r\n    serverless: {\r\n      benefits: [\"cost_efficiency\", \"auto_scaling\", \"reduced_ops\"],\r\n      challenges: [\"cold_starts\", \"vendor_lock_in\", \"debugging\"],\r\n      recommendations: [\"warm_up_functions\", \"multi_cloud_strategy\"]\r\n    }\r\n  },\r\n  performance_requirements: {\r\n    response_time: \"< 200ms\",\r\n    throughput: \"> 1000 rps\", \r\n    availability: \"99.9%\"\r\n  },\r\n  timestamp: Date.now(),\r\n  source: \"research_specialist\"\r\n});\r\n\r\n// Store analysis results\r\nMemory.store(\"performance_analysis\", {\r\n  current_metrics: {\r\n    avg_response_time: \"450ms\",\r\n    peak_throughput: \"750 rps\",\r\n    bottlenecks: [\"database_queries\", \"external_api_calls\"]\r\n  },\r\n  optimization_opportunities: [\r\n    {area: \"database\", impact: \"high\", effort: \"medium\"},\r\n    {area: \"caching\", impact: \"high\", effort: \"low\"},\r\n    {area: \"cdn\", impact: \"medium\", effort: \"low\"}\r\n  ],\r\n  recommendations: {\r\n    immediate: [\"implement_redis_cache\", \"optimize_queries\"],\r\n    medium_term: [\"add_cdn\", \"database_indexing\"],\r\n    long_term: [\"microservices_migration\", \"auto_scaling\"]\r\n  }\r\n});\r\n\\`\\`\\`\r\n\r\n#### Cross-Agent Coordination\r\n\\`\\`\\`javascript\r\n// Implementation agent retrieves and uses research/analysis\r\nconst architectureData = Memory.retrieve(\"architecture_research\");\r\nconst performanceData = Memory.retrieve(\"performance_analysis\");\r\n\r\n// Use combined knowledge for implementation\r\nconst implementationPlan = {\r\n  architecture: architectureData.patterns.microservices,\r\n  performance_targets: architectureData.performance_requirements,\r\n  optimizations: performanceData.recommendations.immediate,\r\n  implementation_order: [\r\n    \"setup_redis_cache\",\r\n    \"optimize_database_queries\", \r\n    \"implement_api_gateway\",\r\n    \"add_circuit_breakers\"\r\n  ]\r\n};\r\n\r\nMemory.store(\"implementation_plan\", implementationPlan);\r\n\\`\\`\\`\r\n\r\n### Batch File Operations - Efficient I/O Management\r\nMaximize efficiency by batching file operations and searches.\r\n\r\n#### Parallel File Reading\r\n\\`\\`\\`javascript\r\n// Read multiple configuration files simultaneously\r\nRead(\"config/database.json\");\r\nRead(\"config/api.json\");\r\nRead(\"config/cache.json\");\r\nRead(\"config/monitoring.json\");\r\n\r\n// Read source code for analysis\r\nRead(\"src/services/user-service.ts\");\r\nRead(\"src/services/order-service.ts\");\r\nRead(\"src/services/payment-service.ts\");\r\nRead(\"src/middleware/auth.ts\");\r\nRead(\"src/middleware/validation.ts\");\r\n\\`\\`\\`\r\n\r\n#### Batch Search Operations\r\n\\`\\`\\`javascript\r\n// Search for different patterns simultaneously\r\nGlob(\"**/*.ts\");           // All TypeScript files\r\nGlob(\"**/*.test.ts\");      // All test files\r\nGlob(\"**/package.json\");   // All package definitions\r\nGlob(\"**/*.env*\");         // All environment files\r\n\r\n// Search for code patterns\r\nGrep(\"TODO|FIXME|HACK\", \"**/*.ts\");     // Code comments\r\nGrep(\"console\\\\.log\", \"**/*.ts\");        // Debug statements\r\nGrep(\"any\\\\s\", \"**/*.ts\");               // TypeScript any usage\r\nGrep(\"fetch\\\\(|axios\", \"**/*.ts\");       // API calls\r\n\\`\\`\\`\r\n\r\n#### Coordinated File Modifications\r\n\\`\\`\\`javascript\r\n// Edit multiple files with coordination\r\nEdit(\"src/config/database.ts\", oldConfig, optimizedConfig);\r\nEdit(\"src/services/cache.ts\", oldCacheLogic, newCacheLogic);\r\nEdit(\"src/middleware/performance.ts\", oldMiddleware, optimizedMiddleware);\r\n\r\n// Write new files as part of coordinated implementation\r\nWrite(\"src/services/redis-cache.ts\", redisCacheImplementation);\r\nWrite(\"src/monitoring/performance-metrics.ts\", metricsImplementation);\r\nWrite(\"docs/performance-optimization.md\", optimizationDocumentation);\r\n\\`\\`\\`\r\n\r\n## Advanced Coordination Patterns\r\n\r\n### Research Swarm Pattern\r\n\\`\\`\\`javascript\r\n// 1. Initialize research coordination\r\nTodoWrite([\r\n  {id: \"domain_research\", content: \"Research domain-specific patterns\", status: \"pending\", priority: \"high\"},\r\n  {id: \"competitive_analysis\", content: \"Analyze competitor solutions\", status: \"pending\", priority: \"medium\"},\r\n  {id: \"technology_evaluation\", content: \"Evaluate technology options\", status: \"pending\", priority: \"high\"},\r\n  {id: \"synthesis\", content: \"Synthesize findings into recommendations\", status: \"pending\", priority: \"high\"}\r\n]);\r\n\r\n// 2. Launch parallel research agents\r\nTask(\"Domain Expert\", \"Research best practices and patterns for the specific domain\");\r\nTask(\"Competitive Analyst\", \"Analyze competitor solutions and market approaches\");\r\nTask(\"Technology Evaluator\", \"Evaluate and compare technology options\");\r\n\r\n// 3. Agents store findings in Memory with structured keys\r\n// Each agent uses Memory.store() with domain-specific keys\r\n\r\n// 4. Synthesis agent combines all findings\r\nTask(\"Research Synthesizer\", \\`\r\n  Retrieve all research findings from Memory:\r\n  - domain_research findings\r\n  - competitive_analysis results\r\n  - technology_evaluation data\r\n  \r\n  Synthesize into comprehensive recommendations and store final results\r\n\\`);\r\n\\`\\`\\`\r\n\r\n### Development Swarm Pattern\r\n\\`\\`\\`javascript\r\n// 1. Create development roadmap\r\nTodoWrite([\r\n  {id: \"architecture_design\", content: \"Design system architecture\", status: \"pending\", priority: \"high\"},\r\n  {id: \"frontend_development\", content: \"Develop frontend components\", status: \"pending\", priority: \"medium\"},\r\n  {id: \"backend_development\", content: \"Develop backend services\", status: \"pending\", priority: \"medium\"},\r\n  {id: \"integration_testing\", content: \"Integration and testing\", status: \"pending\", priority: \"high\"},\r\n  {id: \"deployment_setup\", content: \"Setup deployment pipeline\", status: \"pending\", priority: \"medium\"}\r\n]);\r\n\r\n// 2. Architecture phase\r\nTask(\"System Architect\", \\`\r\n  Design system architecture:\r\n  - Use Memory to retrieve research findings\r\n  - Create component specifications\r\n  - Define API contracts\r\n  - Store architecture decisions in Memory\r\n\\`);\r\n\r\n// 3. Parallel development (after architecture)\r\nTask(\"Frontend Team\", \\`\r\n  Develop frontend components:\r\n  - Retrieve architecture specs from Memory\r\n  - Use batch Read operations for existing code analysis\r\n  - Implement components using batch Write/Edit operations\r\n  - Store component documentation in Memory\r\n\\`);\r\n\r\nTask(\"Backend Team\", \\`\r\n  Develop backend services:\r\n  - Retrieve architecture and API specs from Memory\r\n  - Implement services using batch file operations\r\n  - Store service documentation and test results\r\n\\`);\r\n\r\n// 4. Integration and testing\r\nTask(\"Integration Team\", \\`\r\n  Integration and testing:\r\n  - Retrieve all component specifications from Memory\r\n  - Use batch testing operations\r\n  - Coordinate deployment with DevOps team\r\n\\`);\r\n\\`\\`\\`\r\n\r\n### Analysis Swarm Pattern\r\n\\`\\`\\`javascript\r\n// 1. Analysis task breakdown\r\nTodoWrite([\r\n  {id: \"data_collection\", content: \"Collect and prepare data\", status: \"pending\", priority: \"high\"},\r\n  {id: \"statistical_analysis\", content: \"Perform statistical analysis\", status: \"pending\", priority: \"medium\"},\r\n  {id: \"pattern_detection\", content: \"Detect patterns and anomalies\", status: \"pending\", priority: \"medium\"},\r\n  {id: \"visualization\", content: \"Create visualizations and reports\", status: \"pending\", priority: \"low\"},\r\n  {id: \"insights_synthesis\", content: \"Synthesize insights and recommendations\", status: \"pending\", priority: \"high\"}\r\n]);\r\n\r\n// 2. Data collection and preparation\r\nTask(\"Data Collector\", \\`\r\n  Collect and prepare data:\r\n  - Use batch Read operations for data files\r\n  - Clean and structure data\r\n  - Store prepared datasets in Memory\r\n\\`);\r\n\r\n// 3. Parallel analysis agents\r\nTask(\"Statistical Analyst\", \"Perform statistical analysis on prepared data\");\r\nTask(\"Pattern Detection Specialist\", \"Detect patterns, trends, and anomalies\");\r\nTask(\"Visualization Specialist\", \"Create charts, graphs, and dashboards\");\r\n\r\n// 4. Insights synthesis\r\nTask(\"Analysis Synthesizer\", \\`\r\n  Synthesize analysis results:\r\n  - Retrieve all analysis results from Memory\r\n  - Combine statistical findings with pattern detection\r\n  - Generate comprehensive insights and recommendations\r\n\\`);\r\n\\`\\`\\`\r\n\r\n## Performance Optimization Guidelines\r\n\r\n### Efficient Task Distribution\r\n- Break down complex tasks into independent subtasks\r\n- Use TodoWrite to define clear dependencies\r\n- Launch parallel agents only for truly independent work\r\n- Coordinate through Memory rather than sequential communication\r\n\r\n### Memory Usage Optimization\r\n- Use structured keys for easy retrieval\r\n- Store intermediate results for reuse across agents\r\n- Clean up memory after task completion\r\n- Use namespacing for complex operations\r\n\r\n### Batch Operation Efficiency\r\n- Group similar file operations together\r\n- Use parallel Read operations for multiple files\r\n- Batch search operations with similar patterns\r\n- Coordinate file modifications to avoid conflicts\r\n\r\n### Resource Management\r\n- Monitor system resources during execution\r\n- Adjust agent count based on available resources\r\n- Use appropriate coordination modes for task complexity\r\n- Implement graceful degradation for resource constraints\r\n\r\n## Error Handling and Recovery\r\n\r\n### Robust Task Planning\r\n\\`\\`\\`javascript\r\nTodoWrite([\r\n  {id: \"main_task\", content: \"Primary objective\", status: \"pending\", priority: \"high\"},\r\n  {id: \"validation_task\", content: \"Validate results\", status: \"pending\", priority: \"high\"},\r\n  {id: \"error_recovery\", content: \"Handle errors and recovery\", status: \"pending\", priority: \"medium\"},\r\n  {id: \"rollback_plan\", content: \"Rollback procedure if needed\", status: \"pending\", priority: \"low\"}\r\n]);\r\n\\`\\`\\`\r\n\r\n### Error State Management\r\n\\`\\`\\`javascript\r\n// Store error states for debugging and recovery\r\nMemory.store(\"error_state\", {\r\n  task_id: \"failed_task\",\r\n  error_type: \"api_timeout\",\r\n  error_message: \"Connection timeout after 30 seconds\",\r\n  recovery_options: [\"retry_with_backoff\", \"use_alternative_api\", \"manual_intervention\"],\r\n  timestamp: Date.now()\r\n});\r\n\\`\\`\\`\r\n\r\n### Graceful Degradation\r\n- Implement fallback strategies for critical operations\r\n- Use Memory to store partial results for recovery\r\n- Plan rollback procedures in TodoWrite tasks\r\n- Monitor agent health and implement recovery procedures\r\n\r\nThis guide provides the foundation for effective batch tool coordination in Claude-Flow swarm operations.\r\n`;\r\n\r\n  await fs.writeFile(path.join(batchToolsDir, 'batch-tools-guide.md'), batchToolsGuide);\r\n  console.log('  âœ… Created batch-tools-guide.md');\r\n}\r\n"],"names":["createBatchToolsGuide","fs","path","batchToolsDir","batchToolsGuide","writeFile","join","console","log"],"mappings":"AACA,OAAO,eAAeA;IACpB,MAAMC,KAAK,MAAM,MAAM,CAAC;IACxB,MAAMC,OAAO,MAAM,MAAM,CAAC;IAE1B,MAAMC,gBAAgB;IAEtB,MAAMC,kBAAkB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyX3B,CAAC;IAEC,MAAMH,GAAGI,SAAS,CAACH,KAAKI,IAAI,CAACH,eAAe,yBAAyBC;IACrEG,QAAQC,GAAG,CAAC;AACd"}