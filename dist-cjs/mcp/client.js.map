{
  "version": 3,
  "sources": ["../../src/mcp/client.ts"],
  "sourcesContent": ["/**\n * MCP Client for Model Context Protocol\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ITransport } from './transports/base.js';\nimport { logger } from '../core/logger.js';\nimport type { MCPRequest, MCPResponse, MCPNotification, MCPConfig } from '../utils/types.js';\nimport { RecoveryManager, RecoveryConfig } from './recovery/index.js';\n\nexport interface MCPClientConfig {\n  transport: ITransport;\n  timeout?: number;\n  enableRecovery?: boolean;\n  recoveryConfig?: RecoveryConfig;\n  mcpConfig?: MCPConfig;\n}\n\nexport class MCPClient extends EventEmitter {\n  private transport: ITransport;\n  private timeout: number;\n  private connected = false;\n  private recoveryManager?: RecoveryManager;\n  private pendingRequests = new Map<\n    string,\n    { resolve: Function; reject: Function; timer: NodeJS.Timeout }\n  >();\n\n  constructor(config: MCPClientConfig) {\n    super();\n    this.transport = config.transport;\n    this.timeout = config.timeout || 30000;\n\n    // Initialize recovery manager if enabled\n    if (config.enableRecovery) {\n      this.recoveryManager = new RecoveryManager(\n        this,\n        config.mcpConfig || {},\n        logger,\n        config.recoveryConfig,\n      );\n      this.setupRecoveryHandlers();\n    }\n  }\n\n  async connect(): Promise<void> {\n    try {\n      await this.transport.connect();\n      this.connected = true;\n      logger.info('MCP Client connected');\n\n      // Start recovery manager if enabled\n      if (this.recoveryManager) {\n        await this.recoveryManager.start();\n      }\n\n      this.emit('connected');\n    } catch (error) {\n      logger.error('Failed to connect MCP client', error);\n      this.connected = false;\n\n      // Trigger recovery if enabled\n      if (this.recoveryManager) {\n        await this.recoveryManager.forceRecovery();\n      }\n\n      throw error;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.connected) {\n      // Stop recovery manager first\n      if (this.recoveryManager) {\n        await this.recoveryManager.stop();\n      }\n\n      await this.transport.disconnect();\n      this.connected = false;\n      logger.info('MCP Client disconnected');\n\n      this.emit('disconnected');\n    }\n  }\n\n  async request(method: string, params?: unknown): Promise<unknown> {\n    const request: MCPRequest = {\n      jsonrpc: '2.0' as const,\n      method,\n      params,\n      id: Math.random().toString(36).slice(2),\n    };\n\n    // If recovery manager is enabled, let it handle the request\n    if (this.recoveryManager && !this.connected) {\n      await this.recoveryManager.handleRequest(request);\n    }\n\n    if (!this.connected) {\n      throw new Error('Client not connected');\n    }\n\n    // Create promise for tracking the request\n    const requestPromise = new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        this.pendingRequests.delete(request.id!);\n        reject(new Error(`Request timeout: ${method}`));\n      }, this.timeout);\n\n      this.pendingRequests.set(request.id!, { resolve, reject, timer });\n    });\n\n    try {\n      const response = await this.transport.sendRequest(request);\n\n      // Clear pending request\n      const pending = this.pendingRequests.get(request.id!);\n      if (pending) {\n        clearTimeout(pending.timer);\n        this.pendingRequests.delete(request.id!);\n      }\n\n      if ('error' in response) {\n        throw new Error(response.error);\n      }\n\n      return response.result;\n    } catch (error) {\n      // Clear pending request on error\n      const pending = this.pendingRequests.get(request.id!);\n      if (pending) {\n        clearTimeout(pending.timer);\n        this.pendingRequests.delete(request.id!);\n      }\n\n      throw error;\n    }\n  }\n\n  async notify(method: string, params?: unknown): Promise<void> {\n    // Special handling for heartbeat notifications\n    if (method === 'heartbeat') {\n      // Always allow heartbeat notifications for recovery\n      const notification: MCPNotification = {\n        jsonrpc: '2.0' as const,\n        method,\n        params,\n      };\n\n      if (this.transport.sendNotification) {\n        await this.transport.sendNotification(notification);\n      }\n      return;\n    }\n\n    if (!this.connected) {\n      throw new Error('Client not connected');\n    }\n\n    const notification: MCPNotification = {\n      jsonrpc: '2.0' as const,\n      method,\n      params,\n    };\n\n    if (this.transport.sendNotification) {\n      await this.transport.sendNotification(notification);\n    } else {\n      throw new Error('Transport does not support notifications');\n    }\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Get recovery status if recovery is enabled\n   */\n  getRecoveryStatus() {\n    return this.recoveryManager?.getStatus();\n  }\n\n  /**\n   * Force a recovery attempt\n   */\n  async forceRecovery(): Promise<boolean> {\n    if (!this.recoveryManager) {\n      throw new Error('Recovery not enabled');\n    }\n    return this.recoveryManager.forceRecovery();\n  }\n\n  private setupRecoveryHandlers(): void {\n    if (!this.recoveryManager) {\n      return;\n    }\n\n    // Handle recovery events\n    this.recoveryManager.on('recoveryStart', ({ trigger }) => {\n      logger.info('Recovery started', { trigger });\n      this.emit('recoveryStart', { trigger });\n    });\n\n    this.recoveryManager.on('recoveryComplete', ({ success, duration }) => {\n      if (success) {\n        logger.info('Recovery completed successfully', { duration });\n        this.connected = true;\n        this.emit('recoverySuccess', { duration });\n      } else {\n        logger.error('Recovery failed');\n        this.emit('recoveryFailed', { duration });\n      }\n    });\n\n    this.recoveryManager.on('fallbackActivated', (state) => {\n      logger.warn('Fallback mode activated', state);\n      this.emit('fallbackActivated', state);\n    });\n\n    this.recoveryManager.on('healthChange', (newStatus, oldStatus) => {\n      this.emit('healthChange', newStatus, oldStatus);\n    });\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    // Clear all pending requests\n    for (const [id, pending] of this.pendingRequests) {\n      clearTimeout(pending.timer);\n      pending.reject(new Error('Client cleanup'));\n    }\n    this.pendingRequests.clear();\n\n    // Cleanup recovery manager\n    if (this.recoveryManager) {\n      await this.recoveryManager.cleanup();\n    }\n\n    // Disconnect if connected\n    await this.disconnect();\n  }\n}\n"],
  "mappings": "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",
  "names": ["notification"]
}
