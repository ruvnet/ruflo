{"version":3,"sources":["../../../src/utils/helpers.ts"],"sourcesContent":["/**\r\n * Utility helper functions for Claude-Flow\r\n */\r\n\r\nimport { promisify } from 'util';\r\nimport { exec } from 'child_process';\r\n\r\n// Utility helper functions\r\n\r\n/**\r\n * Executes a command asynchronously and returns the result\r\n */\r\nexport const execAsync = promisify(exec);\r\n\r\n/**\r\n * Simple calculator function that adds two numbers\r\n */\r\nexport function add(a: number, b: number): number {\r\n  return a + b;\r\n}\r\n\r\n/**\r\n * Simple hello world function\r\n */\r\nexport function helloWorld(): string {\r\n  return 'Hello, World!';\r\n}\r\n\r\n/**\r\n * Generates a unique identifier\r\n */\r\nexport function generateId(prefix?: string): string {\r\n  const timestamp = Date.now().toString(36);\r\n  const random = Math.random().toString(36).substr(2, 9);\r\n  return prefix ? `${prefix}_${timestamp}_${random}` : `${timestamp}_${random}`;\r\n}\r\n\r\n/**\r\n * Creates a timeout promise that rejects after the specified time\r\n */\r\nexport function timeout<T>(promise: Promise<T>, ms: number, message?: string): Promise<T> {\r\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\r\n  let completed = false;\r\n\r\n  const timeoutPromise = new Promise<never>((_, reject) => {\r\n    timeoutId = setTimeout(() => {\r\n      if (!completed) {\r\n        completed = true;\r\n        reject(new Error(message || 'Operation timed out'));\r\n      }\r\n    }, ms);\r\n  });\r\n\r\n  const wrappedPromise = promise.then(\r\n    (result) => {\r\n      completed = true;\r\n      if (timeoutId !== undefined) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      return result;\r\n    },\r\n    (error) => {\r\n      completed = true;\r\n      if (timeoutId !== undefined) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      throw error;\r\n    },\r\n  );\r\n\r\n  return Promise.race([wrappedPromise, timeoutPromise]);\r\n}\r\n\r\n/**\r\n * Delays execution for specified milliseconds\r\n */\r\nexport function delay(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Retries a function with exponential backoff\r\n */\r\nexport async function retry<T>(\r\n  fn: () => Promise<T>,\r\n  options: {\r\n    maxAttempts?: number;\r\n    initialDelay?: number;\r\n    maxDelay?: number;\r\n    factor?: number;\r\n    onRetry?: (attempt: number, error: Error) => void;\r\n  } = {},\r\n): Promise<T> {\r\n  const { maxAttempts = 3, initialDelay = 1000, maxDelay = 30000, factor = 2, onRetry } = options;\r\n\r\n  let lastError: Error;\r\n  let delayMs = initialDelay;\r\n\r\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      lastError = error instanceof Error ? error : new Error(String(error));\r\n\r\n      if (attempt === maxAttempts) {\r\n        throw lastError;\r\n      }\r\n\r\n      if (onRetry) {\r\n        onRetry(attempt, lastError);\r\n      }\r\n\r\n      await delay(Math.min(delayMs, maxDelay));\r\n      delayMs *= factor;\r\n    }\r\n  }\r\n\r\n  throw lastError!;\r\n}\r\n\r\n/**\r\n * Debounces a function\r\n */\r\nexport function debounce<T extends (...args: unknown[]) => unknown>(\r\n  fn: T,\r\n  delayMs: number,\r\n): (...args: Parameters<T>) => void {\r\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\r\n\r\n  return (...args: Parameters<T>) => {\r\n    if (timeoutId !== undefined) {\r\n      clearTimeout(timeoutId);\r\n    }\r\n\r\n    timeoutId = setTimeout(() => {\r\n      fn(...args);\r\n      timeoutId = undefined;\r\n    }, delayMs);\r\n  };\r\n}\r\n\r\n/**\r\n * Throttles a function\r\n */\r\nexport function throttle<T extends (...args: unknown[]) => unknown>(\r\n  fn: T,\r\n  limitMs: number,\r\n): (...args: Parameters<T>) => void {\r\n  let inThrottle = false;\r\n  let lastArgs: Parameters<T> | null = null;\r\n\r\n  return (...args: Parameters<T>) => {\r\n    if (!inThrottle) {\r\n      fn(...args);\r\n      inThrottle = true;\r\n\r\n      setTimeout(() => {\r\n        inThrottle = false;\r\n        if (lastArgs !== null) {\r\n          fn(...lastArgs);\r\n          lastArgs = null;\r\n        }\r\n      }, limitMs);\r\n    } else {\r\n      lastArgs = args;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Deep clones an object\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (obj === null || typeof obj !== 'object') {\r\n    return obj;\r\n  }\r\n\r\n  if (obj instanceof Date) {\r\n    return new Date(obj.getTime()) as T;\r\n  }\r\n\r\n  if (obj instanceof Array) {\r\n    return obj.map((item) => deepClone(item)) as T;\r\n  }\r\n\r\n  if (obj instanceof Map) {\r\n    const map = new Map();\r\n    obj.forEach((value, key) => {\r\n      map.set(key, deepClone(value));\r\n    });\r\n    return map as T;\r\n  }\r\n\r\n  if (obj instanceof Set) {\r\n    const set = new Set();\r\n    obj.forEach((value) => {\r\n      set.add(deepClone(value));\r\n    });\r\n    return set as T;\r\n  }\r\n\r\n  const cloned = {} as T;\r\n  for (const key in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      cloned[key] = deepClone(obj[key]);\r\n    }\r\n  }\r\n\r\n  return cloned;\r\n}\r\n\r\n/**\r\n * Merges multiple objects deeply\r\n */\r\nexport function deepMerge<T extends Record<string, unknown>>(\r\n  target: T,\r\n  ...sources: Partial<T>[]\r\n): T {\r\n  // Create a deep clone of the target to avoid mutation\r\n  const result = deepClone(target);\r\n\r\n  if (!sources.length) return result;\r\n\r\n  const source = sources.shift();\r\n  if (!source) return result;\r\n\r\n  for (const key in source) {\r\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n      const sourceValue = source[key];\r\n      const resultValue = result[key];\r\n\r\n      if (isObject(resultValue) && isObject(sourceValue)) {\r\n        result[key] = deepMerge(\r\n          resultValue as Record<string, unknown>,\r\n          sourceValue as Record<string, unknown>,\r\n        ) as T[Extract<keyof T, string>];\r\n      } else {\r\n        result[key] = sourceValue as T[Extract<keyof T, string>];\r\n      }\r\n    }\r\n  }\r\n\r\n  return deepMerge(result, ...sources);\r\n}\r\n\r\n/**\r\n * Checks if a value is a plain object\r\n */\r\nfunction isObject(value: unknown): value is Record<string, unknown> {\r\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\r\n}\r\n\r\n/**\r\n * Creates a typed event emitter\r\n */\r\nexport class TypedEventEmitter<T extends Record<string, unknown>> {\r\n  private listeners = new Map<keyof T, Set<(data: unknown) => void>>();\r\n\r\n  on<K extends keyof T>(event: K, handler: (data: T[K]) => void): void {\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, new Set());\r\n    }\r\n    this.listeners.get(event)!.add(handler as (data: unknown) => void);\r\n  }\r\n\r\n  off<K extends keyof T>(event: K, handler: (data: T[K]) => void): void {\r\n    const handlers = this.listeners.get(event);\r\n    if (handlers) {\r\n      handlers.delete(handler as (data: unknown) => void);\r\n    }\r\n  }\r\n\r\n  emit<K extends keyof T>(event: K, data: T[K]): void {\r\n    const handlers = this.listeners.get(event);\r\n    if (handlers) {\r\n      handlers.forEach((handler) => handler(data));\r\n    }\r\n  }\r\n\r\n  once<K extends keyof T>(event: K, handler: (data: T[K]) => void): void {\r\n    const onceHandler = (data: T[K]) => {\r\n      handler(data);\r\n      this.off(event, onceHandler);\r\n    };\r\n    this.on(event, onceHandler);\r\n  }\r\n\r\n  removeAllListeners(event?: keyof T): void {\r\n    if (event) {\r\n      this.listeners.delete(event);\r\n    } else {\r\n      this.listeners.clear();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Formats bytes to human-readable string\r\n */\r\nexport function formatBytes(bytes: number, decimals = 2): string {\r\n  if (bytes === 0) return '0 Bytes';\r\n\r\n  const k = 1024;\r\n  const dm = decimals < 0 ? 0 : decimals;\r\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\r\n\r\n  // Handle negative numbers\r\n  const absBytes = Math.abs(bytes);\r\n  const i = Math.floor(Math.log(absBytes) / Math.log(k));\r\n\r\n  const value = parseFloat((absBytes / Math.pow(k, i)).toFixed(dm));\r\n  const sign = bytes < 0 ? '-' : '';\r\n\r\n  return sign + value + ' ' + sizes[i];\r\n}\r\n\r\n/**\r\n * Parses duration string to milliseconds\r\n */\r\nexport function parseDuration(duration: string): number {\r\n  const match = duration.match(/^(\\d+)(ms|s|m|h|d)$/);\r\n  if (!match) {\r\n    throw new Error(`Invalid duration format: ${duration}`);\r\n  }\r\n\r\n  const value = parseInt(match[1], 10);\r\n  const unit = match[2];\r\n\r\n  switch (unit) {\r\n    case 'ms':\r\n      return value;\r\n    case 's':\r\n      return value * 1000;\r\n    case 'm':\r\n      return value * 60 * 1000;\r\n    case 'h':\r\n      return value * 60 * 60 * 1000;\r\n    case 'd':\r\n      return value * 24 * 60 * 60 * 1000;\r\n    default:\r\n      throw new Error(`Unknown duration unit: ${unit}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Ensures a value is an array\r\n */\r\nexport function ensureArray<T>(value: T | T[]): T[] {\r\n  return Array.isArray(value) ? value : [value];\r\n}\r\n\r\n/**\r\n * Groups an array by a key function\r\n */\r\nexport function groupBy<T, K extends string | number | symbol>(\r\n  items: T[],\r\n  keyFn: (item: T) => K,\r\n): Record<K, T[]> {\r\n  return items.reduce(\r\n    (groups, item) => {\r\n      const key = keyFn(item);\r\n      if (!groups[key]) {\r\n        groups[key] = [];\r\n      }\r\n      groups[key].push(item);\r\n      return groups;\r\n    },\r\n    {} as Record<K, T[]>,\r\n  );\r\n}\r\n\r\n/**\r\n * Creates a promise that can be resolved/rejected externally\r\n */\r\nexport function createDeferred<T>(): {\r\n  promise: Promise<T>;\r\n  resolve: (value: T) => void;\r\n  reject: (reason?: unknown) => void;\r\n} {\r\n  let resolve: (value: T) => void;\r\n  let reject: (reason?: unknown) => void;\r\n\r\n  const promise = new Promise<T>((res, rej) => {\r\n    resolve = res;\r\n    reject = rej;\r\n  });\r\n\r\n  return { promise, resolve: resolve!, reject: reject! };\r\n}\r\n\r\n/**\r\n * Safely parses JSON with error handling\r\n */\r\nexport function safeParseJSON<T>(json: string, fallback?: T): T | undefined {\r\n  try {\r\n    return JSON.parse(json) as T;\r\n  } catch {\r\n    return fallback;\r\n  }\r\n}\r\n\r\n/**\r\n * Circuit breaker state\r\n */\r\nexport interface CircuitBreakerState {\r\n  failureCount: number;\r\n  lastFailureTime: number;\r\n  state: 'closed' | 'open' | 'half-open';\r\n}\r\n\r\n/**\r\n * Circuit breaker options\r\n */\r\nexport interface CircuitBreakerOptions {\r\n  threshold: number;\r\n  timeout: number;\r\n  resetTimeout: number;\r\n}\r\n\r\n/**\r\n * Circuit breaker interface\r\n */\r\nexport interface CircuitBreaker {\r\n  execute<T>(fn: () => Promise<T>): Promise<T>;\r\n  getState(): CircuitBreakerState;\r\n  reset(): void;\r\n}\r\n\r\n/**\r\n * Simple calculator function with basic operations\r\n */\r\nexport function calculator(\r\n  a: number,\r\n  b: number,\r\n  operation: '+' | '-' | '*' | '/' | '^' | '%',\r\n): number {\r\n  switch (operation) {\r\n    case '+':\r\n      return a + b;\r\n    case '-':\r\n      return a - b;\r\n    case '*':\r\n      return a * b;\r\n    case '/':\r\n      if (b === 0) {\r\n        throw new Error('Division by zero');\r\n      }\r\n      return a / b;\r\n    case '^':\r\n      return Math.pow(a, b);\r\n    case '%':\r\n      if (b === 0) {\r\n        throw new Error('Modulo by zero');\r\n      }\r\n      return a % b;\r\n    default:\r\n      throw new Error(`Invalid operation: ${operation}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a circuit breaker\r\n */\r\nexport function circuitBreaker(name: string, options: CircuitBreakerOptions): CircuitBreaker {\r\n  const state: CircuitBreakerState = {\r\n    failureCount: 0,\r\n    lastFailureTime: 0,\r\n    state: 'closed',\r\n  };\r\n\r\n  const isOpen = (): boolean => {\r\n    if (state.state === 'open') {\r\n      const now = Date.now();\r\n      if (now - state.lastFailureTime >= options.resetTimeout) {\r\n        state.state = 'half-open';\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const recordSuccess = (): void => {\r\n    state.failureCount = 0;\r\n    state.state = 'closed';\r\n  };\r\n\r\n  const recordFailure = (): void => {\r\n    state.failureCount++;\r\n    state.lastFailureTime = Date.now();\r\n\r\n    if (state.failureCount >= options.threshold) {\r\n      state.state = 'open';\r\n    }\r\n  };\r\n\r\n  return {\r\n    async execute<T>(fn: () => Promise<T>): Promise<T> {\r\n      if (isOpen()) {\r\n        throw new Error(`Circuit breaker ${name} is open`);\r\n      }\r\n\r\n      try {\r\n        const result = await timeout(fn(), options.timeout);\r\n        recordSuccess();\r\n        return result;\r\n      } catch (error) {\r\n        recordFailure();\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    getState(): CircuitBreakerState {\r\n      return { ...state };\r\n    },\r\n\r\n    reset(): void {\r\n      state.failureCount = 0;\r\n      state.lastFailureTime = 0;\r\n      state.state = 'closed';\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Greeting function that returns a personalized greeting\r\n */\r\nexport function greeting(\r\n  name?: string,\r\n  options?: {\r\n    timeOfDay?: boolean;\r\n    formal?: boolean;\r\n    locale?: 'en' | 'es' | 'fr' | 'de' | 'it' | 'pt' | 'ja' | 'zh';\r\n  },\r\n): string {\r\n  const opts = {\r\n    timeOfDay: false,\r\n    formal: false,\r\n    locale: 'en' as const,\r\n    ...options,\r\n  };\r\n\r\n  // Determine time-based greeting\r\n  const getTimeGreeting = (): string => {\r\n    const hour = new Date().getHours();\r\n    if (hour < 12) return 'Good morning';\r\n    if (hour < 17) return 'Good afternoon';\r\n    if (hour < 21) return 'Good evening';\r\n    return 'Good night';\r\n  };\r\n\r\n  // Get greeting by locale\r\n  const getLocaleGreeting = (): string => {\r\n    const greetings: Record<string, { informal: string; formal: string }> = {\r\n      en: { informal: 'Hello', formal: 'Greetings' },\r\n      es: { informal: 'Hola', formal: 'Saludos' },\r\n      fr: { informal: 'Salut', formal: 'Bonjour' },\r\n      de: { informal: 'Hallo', formal: 'Guten Tag' },\r\n      it: { informal: 'Ciao', formal: 'Salve' },\r\n      pt: { informal: 'Olá', formal: 'Saudações' },\r\n      ja: { informal: 'こんにちは', formal: 'ご挨拶' },\r\n      zh: { informal: '你好', formal: '您好' },\r\n    };\r\n\r\n    const localeGreeting = greetings[opts.locale] || greetings.en;\r\n    return opts.formal ? localeGreeting.formal : localeGreeting.informal;\r\n  };\r\n\r\n  // Build the greeting\r\n  let greetingText = opts.timeOfDay ? getTimeGreeting() : getLocaleGreeting();\r\n\r\n  if (name) {\r\n    greetingText += `, ${name}`;\r\n  }\r\n\r\n  greetingText += '!';\r\n\r\n  return greetingText;\r\n}\r\n"],"names":["promisify","exec","execAsync","add","a","b","helloWorld","generateId","prefix","timestamp","Date","now","toString","random","Math","substr","timeout","promise","ms","message","timeoutId","completed","timeoutPromise","Promise","_","reject","setTimeout","Error","wrappedPromise","then","result","undefined","clearTimeout","error","race","delay","resolve","retry","fn","options","maxAttempts","initialDelay","maxDelay","factor","onRetry","lastError","delayMs","attempt","String","min","debounce","args","throttle","limitMs","inThrottle","lastArgs","deepClone","obj","getTime","Array","map","item","Map","forEach","value","key","set","Set","cloned","Object","prototype","hasOwnProperty","call","deepMerge","target","sources","length","source","shift","sourceValue","resultValue","isObject","isArray","TypedEventEmitter","listeners","on","event","handler","has","get","off","handlers","delete","emit","data","once","onceHandler","removeAllListeners","clear","formatBytes","bytes","decimals","k","dm","sizes","absBytes","abs","i","floor","log","parseFloat","pow","toFixed","sign","parseDuration","duration","match","parseInt","unit","ensureArray","groupBy","items","keyFn","reduce","groups","push","createDeferred","res","rej","safeParseJSON","json","fallback","JSON","parse","calculator","operation","circuitBreaker","name","state","failureCount","lastFailureTime","isOpen","resetTimeout","recordSuccess","recordFailure","threshold","execute","getState","reset","greeting","opts","timeOfDay","formal","locale","getTimeGreeting","hour","getHours","getLocaleGreeting","greetings","en","informal","es","fr","de","it","pt","ja","zh","localeGreeting","greetingText"],"mappings":"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"}