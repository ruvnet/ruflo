{
  "version": 3,
  "sources": ["../../../src/mcp/transports/http.ts"],
  "sourcesContent": ["/**\n * HTTP transport for MCP\n */\n\nimport express, { Express, Request, Response } from 'express';\nimport { createServer, Server } from 'node:http';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { join, dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport type { ITransport, RequestHandler, NotificationHandler } from './base.js';\nimport type { MCPRequest, MCPResponse, MCPNotification, MCPConfig } from '../../utils/types.js';\nimport type { ILogger } from '../../core/logger.js';\nimport { MCPTransportError } from '../../utils/errors.js';\n\n/**\n * HTTP transport implementation\n */\nexport class HttpTransport implements ITransport {\n  private requestHandler?: RequestHandler;\n  private notificationHandler?: NotificationHandler;\n  private app: Express;\n  private server?: Server;\n  private wss?: WebSocketServer;\n  private messageCount = 0;\n  private notificationCount = 0;\n  private running = false;\n  private connections = new Set<WebSocket>();\n  private activeWebSockets = new Set<WebSocket>();\n\n  constructor(\n    private host: string,\n    private port: number,\n    private tlsEnabled: boolean,\n    private logger: ILogger,\n    private config?: MCPConfig,\n  ) {\n    this.app = express();\n    this.setupMiddleware();\n    this.setupRoutes();\n  }\n\n  async start(): Promise<void> {\n    if (this.running) {\n      throw new MCPTransportError('Transport already running');\n    }\n\n    this.logger.info('Starting HTTP transport', {\n      host: this.host,\n      port: this.port,\n      tls: this.tlsEnabled,\n    });\n\n    try {\n      // Create HTTP server\n      this.server = createServer(this.app);\n\n      // Create WebSocket server\n      this.wss = new WebSocketServer({\n        server: this.server,\n        path: '/ws',\n      });\n\n      this.setupWebSocketHandlers();\n\n      // Start server\n      await new Promise<void>((resolve, reject) => {\n        this.server!.listen(this.port, this.host, () => {\n          this.logger.info(`HTTP server listening on ${this.host}:${this.port}`);\n          resolve();\n        });\n\n        this.server!.on('error', reject);\n      });\n\n      this.running = true;\n      this.logger.info('HTTP transport started');\n    } catch (error) {\n      throw new MCPTransportError('Failed to start HTTP transport', { error });\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.running) {\n      return;\n    }\n\n    this.logger.info('Stopping HTTP transport');\n\n    this.running = false;\n\n    // Close all WebSocket connections\n    for (const ws of this.activeWebSockets) {\n      try {\n        ws.close();\n      } catch {\n        // Ignore errors\n      }\n    }\n    this.activeWebSockets.clear();\n    this.connections.clear();\n\n    // Close WebSocket server\n    if (this.wss) {\n      this.wss.close();\n      this.wss = undefined;\n    }\n\n    // Shutdown HTTP server\n    if (this.server) {\n      await new Promise<void>((resolve) => {\n        this.server!.close(() => resolve());\n      });\n      this.server = undefined;\n    }\n\n    this.logger.info('HTTP transport stopped');\n  }\n\n  onRequest(handler: RequestHandler): void {\n    this.requestHandler = handler;\n  }\n\n  onNotification(handler: NotificationHandler): void {\n    this.notificationHandler = handler;\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    return {\n      healthy: this.running,\n      metrics: {\n        messagesReceived: this.messageCount,\n        notificationsSent: this.notificationCount,\n        activeConnections: this.connections.size,\n        activeWebSockets: this.activeWebSockets.size,\n      },\n    };\n  }\n\n  private setupMiddleware(): void {\n    // Security middleware\n    this.app.use(helmet());\n\n    // CORS middleware\n    if (this.config?.corsEnabled) {\n      const origins = this.config.corsOrigins || ['*'];\n      this.app.use(\n        cors({\n          origin: origins,\n          credentials: true,\n          maxAge: 86400, // 24 hours\n        }),\n      );\n    }\n\n    // Body parsing middleware\n    this.app.use(express.json({ limit: '10mb' }));\n    this.app.use(express.text());\n  }\n\n  private setupRoutes(): void {\n    // Get current file directory for static files\n    const __filename =\n      typeof import.meta?.url !== 'undefined'\n        ? fileURLToPath(import.meta.url)\n        : __filename || __dirname + '/http.ts';\n    const __dirname = dirname(__filename);\n    const consoleDir = join(__dirname, '../../ui/console');\n\n    // Serve static files for the web console\n    this.app.use('/console', express.static(consoleDir));\n\n    // Web console route\n    this.app.get('/', (req, res) => {\n      res.redirect('/console');\n    });\n\n    this.app.get('/console', (req, res) => {\n      res.sendFile(join(consoleDir, 'index.html'));\n    });\n\n    // Health check endpoint\n    this.app.get('/health', (req, res) => {\n      res.json({ status: 'ok', timestamp: new Date().toISOString() });\n    });\n\n    // MCP JSON-RPC endpoint\n    this.app.post('/rpc', async (req, res) => {\n      await this.handleJsonRpcRequest(req, res);\n    });\n\n    // Handle preflight requests\n    this.app.options('*', (req, res) => {\n      res.status(204).end();\n    });\n\n    // 404 handler\n    this.app.use((req, res) => {\n      res.status(404).json({ error: 'Not found' });\n    });\n\n    // Error handler\n    this.app.use(\n      (err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n        this.logger.error('Express error', err);\n        res.status(500).json({\n          error: 'Internal server error',\n          message: err.message,\n        });\n      },\n    );\n  }\n\n  private setupWebSocketHandlers(): void {\n    if (!this.wss) return;\n\n    this.wss.on('connection', (ws: WebSocket, req) => {\n      this.activeWebSockets.add(ws);\n      this.logger.info('WebSocket client connected', {\n        totalClients: this.activeWebSockets.size,\n      });\n\n      ws.on('close', () => {\n        this.activeWebSockets.delete(ws);\n        this.logger.info('WebSocket client disconnected', {\n          totalClients: this.activeWebSockets.size,\n        });\n      });\n\n      ws.on('error', (error) => {\n        this.logger.error('WebSocket error', error);\n        this.activeWebSockets.delete(ws);\n      });\n\n      ws.on('message', async (data) => {\n        try {\n          const message = JSON.parse(data.toString());\n\n          if (message.id === undefined) {\n            // Notification from client\n            await this.handleNotificationMessage(message as MCPNotification);\n          } else {\n            // Request from client\n            const response = await this.handleRequestMessage(message as MCPRequest);\n            ws.send(JSON.stringify(response));\n          }\n        } catch (error) {\n          this.logger.error('Error processing WebSocket message', error);\n\n          // Send error response if it was a request\n          try {\n            const parsed = JSON.parse(data.toString());\n            if (parsed.id !== undefined) {\n              ws.send(\n                JSON.stringify({\n                  jsonrpc: '2.0',\n                  id: parsed.id,\n                  error: {\n                    code: -32603,\n                    message: 'Internal error',\n                  },\n                }),\n              );\n            }\n          } catch {\n            // Ignore parse errors for error responses\n          }\n        }\n      });\n    });\n  }\n\n  private async handleJsonRpcRequest(req: Request, res: Response): Promise<void> {\n    // Check content type\n    if (!req.is('application/json')) {\n      res.status(400).json({\n        jsonrpc: '2.0',\n        id: null,\n        error: {\n          code: -32600,\n          message: 'Invalid content type - expected application/json',\n        },\n      });\n      return;\n    }\n\n    // Check authorization if authentication is enabled\n    if (this.config?.auth?.enabled) {\n      const authResult = await this.validateAuth(req);\n      if (!authResult.valid) {\n        res.status(401).json({\n          error: authResult.error || 'Unauthorized',\n        });\n        return;\n      }\n    }\n\n    try {\n      const mcpMessage = req.body;\n\n      // Validate JSON-RPC format\n      if (!mcpMessage.jsonrpc || mcpMessage.jsonrpc !== '2.0') {\n        res.status(400).json({\n          jsonrpc: '2.0',\n          id: mcpMessage.id || null,\n          error: {\n            code: -32600,\n            message: 'Invalid request - missing or invalid jsonrpc version',\n          },\n        });\n        return;\n      }\n\n      if (!mcpMessage.method) {\n        res.status(400).json({\n          jsonrpc: '2.0',\n          id: mcpMessage.id || null,\n          error: {\n            code: -32600,\n            message: 'Invalid request - missing method',\n          },\n        });\n        return;\n      }\n\n      this.messageCount++;\n\n      // Check if this is a notification (no id) or request\n      if (mcpMessage.id === undefined) {\n        // Handle notification\n        await this.handleNotificationMessage(mcpMessage as MCPNotification);\n        // Notifications don't get responses\n        res.status(204).end();\n      } else {\n        // Handle request\n        const response = await this.handleRequestMessage(mcpMessage as MCPRequest);\n        res.json(response);\n      }\n    } catch (error) {\n      this.logger.error('Error handling JSON-RPC request', error);\n\n      res.status(500).json({\n        jsonrpc: '2.0',\n        id: null,\n        error: {\n          code: -32603,\n          message: 'Internal error',\n          data: error instanceof Error ? error.message : String(error),\n        },\n      });\n    }\n  }\n\n  private async handleRequestMessage(request: MCPRequest): Promise<MCPResponse> {\n    if (!this.requestHandler) {\n      return {\n        jsonrpc: '2.0',\n        id: request.id,\n        error: {\n          code: -32603,\n          message: 'No request handler registered',\n        },\n      };\n    }\n\n    try {\n      return await this.requestHandler(request);\n    } catch (error) {\n      this.logger.error('Request handler error', { request, error });\n\n      return {\n        jsonrpc: '2.0',\n        id: request.id,\n        error: {\n          code: -32603,\n          message: 'Internal error',\n          data: error instanceof Error ? error.message : String(error),\n        },\n      };\n    }\n  }\n\n  private async handleNotificationMessage(notification: MCPNotification): Promise<void> {\n    if (!this.notificationHandler) {\n      this.logger.warn('Received notification but no handler registered', {\n        method: notification.method,\n      });\n      return;\n    }\n\n    try {\n      await this.notificationHandler(notification);\n    } catch (error) {\n      this.logger.error('Notification handler error', { notification, error });\n      // Notifications don't send error responses\n    }\n  }\n\n  private async validateAuth(req: Request): Promise<{ valid: boolean; error?: string }> {\n    const auth = req.headers.authorization;\n\n    if (!auth) {\n      return { valid: false, error: 'Authorization header required' };\n    }\n\n    // Extract token from Authorization header\n    const tokenMatch = auth.match(/^Bearer\\s+(.+)$/i);\n    if (!tokenMatch) {\n      return { valid: false, error: 'Invalid authorization format - use Bearer token' };\n    }\n\n    const token = tokenMatch[1];\n\n    // Validate against configured tokens\n    if (this.config?.auth?.tokens && this.config.auth.tokens.length > 0) {\n      const isValid = this.config.auth.tokens.includes(token);\n      if (!isValid) {\n        return { valid: false, error: 'Invalid token' };\n      }\n    }\n\n    return { valid: true };\n  }\n\n  async connect(): Promise<void> {\n    // For HTTP transport, connect is handled by start()\n    if (!this.running) {\n      await this.start();\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    // For HTTP transport, disconnect is handled by stop()\n    await this.stop();\n  }\n\n  async sendRequest(request: MCPRequest): Promise<MCPResponse> {\n    // HTTP transport is server-side, it doesn't send requests\n    throw new Error('HTTP transport does not support sending requests');\n  }\n\n  async sendNotification(notification: MCPNotification): Promise<void> {\n    // Broadcast notification to all connected WebSocket clients\n    const message = JSON.stringify(notification);\n\n    for (const ws of this.activeWebSockets) {\n      try {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(message);\n        }\n      } catch (error) {\n        this.logger.error('Failed to send notification to WebSocket', error);\n      }\n    }\n\n    this.notificationCount++;\n  }\n}\n"],
  "mappings": "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",
  "names": ["express", "helmet", "cors"]
}
