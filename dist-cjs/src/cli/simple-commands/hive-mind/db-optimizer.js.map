{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/db-optimizer.js"],"sourcesContent":["/**\r\n * Hive Mind Database Optimizer\r\n *\r\n * Safe, backward-compatible database optimization for existing deployments\r\n * Adds indexes, performance improvements, and new features without breaking changes\r\n */\r\n\r\nimport Database from 'better-sqlite3';\r\nimport { existsSync, mkdirSync } from 'fs';\r\nimport { writeFile, readFile } from 'fs/promises';\r\nimport path from 'path';\r\nimport chalk from 'chalk';\r\nimport ora from 'ora';\r\n\r\n/**\r\n * Optimize existing hive mind database with backward compatibility\r\n */\r\nexport async function optimizeHiveMindDatabase(dbPath, options = {}) {\r\n  const spinner = ora('Optimizing Hive Mind database...').start();\r\n\r\n  try {\r\n    // Open database with write-ahead logging for better performance\r\n    const db = new Database(dbPath, {\r\n      verbose: options.verbose ? console.log : null,\r\n    });\r\n\r\n    // Enable WAL mode for better concurrency\r\n    db.pragma('journal_mode = WAL');\r\n    db.pragma('synchronous = NORMAL');\r\n\r\n    // Get current schema version\r\n    const schemaVersion = getSchemaVersion(db);\r\n    spinner.text = `Current schema version: ${schemaVersion}`;\r\n\r\n    // Apply optimizations based on version\r\n    let optimizationsApplied = [];\r\n\r\n    // Version 1.0 -> 1.1: Add basic indexes\r\n    if (schemaVersion < 1.1) {\r\n      spinner.text = 'Applying performance indexes...';\r\n      applyBasicIndexes(db);\r\n      optimizationsApplied.push('Basic performance indexes');\r\n    }\r\n\r\n    // Version 1.1 -> 1.2: Add advanced indexes and analyze\r\n    if (schemaVersion < 1.2) {\r\n      spinner.text = 'Applying advanced indexes...';\r\n      applyAdvancedIndexes(db);\r\n      optimizationsApplied.push('Advanced query optimization');\r\n    }\r\n\r\n    // Version 1.2 -> 1.3: Add performance tracking tables\r\n    if (schemaVersion < 1.3) {\r\n      spinner.text = 'Adding performance tracking...';\r\n      addPerformanceTracking(db);\r\n      optimizationsApplied.push('Performance monitoring tables');\r\n    }\r\n\r\n    // Version 1.3 -> 1.4: Add memory optimization\r\n    if (schemaVersion < 1.4) {\r\n      spinner.text = 'Optimizing memory management...';\r\n      addMemoryOptimization(db);\r\n      optimizationsApplied.push('Memory optimization features');\r\n    }\r\n\r\n    // Version 1.4 -> 1.5: Add behavioral tracking\r\n    if (schemaVersion < 1.5) {\r\n      spinner.text = 'Adding behavioral analysis...';\r\n      addBehavioralTracking(db);\r\n      optimizationsApplied.push('Behavioral pattern tracking');\r\n    }\r\n\r\n    // Run ANALYZE to update query planner statistics\r\n    spinner.text = 'Updating query statistics...';\r\n    db.exec('ANALYZE');\r\n\r\n    // Vacuum if requested (requires exclusive access)\r\n    if (options.vacuum) {\r\n      spinner.text = 'Vacuuming database...';\r\n      db.exec('VACUUM');\r\n      optimizationsApplied.push('Database vacuumed');\r\n    }\r\n\r\n    // Update schema version\r\n    updateSchemaVersion(db, 1.5);\r\n\r\n    // Close database\r\n    db.close();\r\n\r\n    spinner.succeed('Database optimization complete!');\r\n\r\n    if (optimizationsApplied.length > 0) {\r\n      console.log('\\n' + chalk.green('✓') + ' Optimizations applied:');\r\n      optimizationsApplied.forEach((opt) => {\r\n        console.log('  - ' + opt);\r\n      });\r\n    } else {\r\n      console.log('\\n' + chalk.yellow('ℹ') + ' Database already optimized');\r\n    }\r\n\r\n    return { success: true, optimizations: optimizationsApplied };\r\n  } catch (error) {\r\n    spinner.fail('Database optimization failed');\r\n    console.error(chalk.red('Error:'), error.message);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Get current schema version\r\n */\r\nfunction getSchemaVersion(db) {\r\n  try {\r\n    // Check if schema_version table exists\r\n    const tableExists = db\r\n      .prepare(\r\n        `\r\n      SELECT name FROM sqlite_master \r\n      WHERE type='table' AND name='schema_version'\r\n    `,\r\n      )\r\n      .get();\r\n\r\n    if (!tableExists) {\r\n      // Create schema version table\r\n      db.exec(`\r\n        CREATE TABLE schema_version (\r\n          version REAL PRIMARY KEY,\r\n          applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n          description TEXT\r\n        )\r\n      `);\r\n\r\n      // Insert initial version\r\n      db.prepare(\r\n        `\r\n        INSERT INTO schema_version (version, description) \r\n        VALUES (1.0, 'Initial schema')\r\n      `,\r\n      ).run();\r\n\r\n      return 1.0;\r\n    }\r\n\r\n    // Get latest version\r\n    const result = db\r\n      .prepare(\r\n        `\r\n      SELECT version FROM schema_version \r\n      ORDER BY version DESC LIMIT 1\r\n    `,\r\n      )\r\n      .get();\r\n\r\n    return result ? result.version : 1.0;\r\n  } catch (error) {\r\n    // If any error, assume version 1.0\r\n    return 1.0;\r\n  }\r\n}\r\n\r\n/**\r\n * Update schema version\r\n */\r\nfunction updateSchemaVersion(db, version, description = '') {\r\n  db.prepare(\r\n    `\r\n    INSERT OR REPLACE INTO schema_version (version, description) \r\n    VALUES (?, ?)\r\n  `,\r\n  ).run(version, description || `Updated to version ${version}`);\r\n}\r\n\r\n/**\r\n * Apply basic performance indexes\r\n */\r\nfunction applyBasicIndexes(db) {\r\n  // First ensure all required columns exist\r\n  ensureRequiredColumns(db);\r\n\r\n  // Check which tables exist before creating indexes\r\n  const tables = db\r\n    .prepare(\r\n      `\r\n    SELECT name FROM sqlite_master \r\n    WHERE type='table' AND name NOT LIKE 'sqlite_%'\r\n  `,\r\n    )\r\n    .all()\r\n    .map((row) => row.name);\r\n\r\n  const tableSet = new Set(tables);\r\n\r\n  const indexes = [];\r\n\r\n  // Only create indexes for tables that exist\r\n  if (tableSet.has('swarms')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_swarms_status ON swarms(status)',\r\n      'CREATE INDEX IF NOT EXISTS idx_swarms_created ON swarms(created_at)',\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('agents')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_agents_swarm ON agents(swarm_id)',\r\n      'CREATE INDEX IF NOT EXISTS idx_agents_type ON agents(type)',\r\n      'CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status)',\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('tasks')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_tasks_swarm ON tasks(swarm_id)',\r\n      'CREATE INDEX IF NOT EXISTS idx_tasks_agent ON tasks(agent_id)',\r\n      'CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)',\r\n      'CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority DESC)',\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('collective_memory')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_memory_swarm ON collective_memory(swarm_id)',\r\n      'CREATE INDEX IF NOT EXISTS idx_memory_key ON collective_memory(key)',\r\n      'CREATE INDEX IF NOT EXISTS idx_memory_type ON collective_memory(type)',\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('consensus_decisions')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_consensus_swarm ON consensus_decisions(swarm_id)',\r\n      'CREATE INDEX IF NOT EXISTS idx_consensus_created ON consensus_decisions(created_at)',\r\n    );\r\n  }\r\n\r\n  indexes.forEach((sql) => {\r\n    try {\r\n      db.exec(sql);\r\n    } catch (error) {\r\n      console.warn(`Warning: Could not create index: ${error.message}`);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Ensure all required columns exist\r\n */\r\nfunction ensureRequiredColumns(db) {\r\n  // First check which tables exist\r\n  const tables = db\r\n    .prepare(\r\n      `\r\n    SELECT name FROM sqlite_master \r\n    WHERE type='table' AND name NOT LIKE 'sqlite_%'\r\n  `,\r\n    )\r\n    .all()\r\n    .map((row) => row.name);\r\n\r\n  const tableSet = new Set(tables);\r\n\r\n  // Only check columns for tables that exist\r\n  if (tableSet.has('tasks')) {\r\n    // Check and add priority column to tasks table\r\n    const hasPriority = db\r\n      .prepare(\r\n        `\r\n      SELECT COUNT(*) as count FROM pragma_table_info('tasks') \r\n      WHERE name = 'priority'\r\n    `,\r\n      )\r\n      .get();\r\n\r\n    if (!hasPriority || hasPriority.count === 0) {\r\n      try {\r\n        db.exec('ALTER TABLE tasks ADD COLUMN priority INTEGER DEFAULT 5');\r\n        console.log('Added missing priority column to tasks table');\r\n      } catch (error) {\r\n        if (\r\n          !error.message.includes('duplicate column') &&\r\n          !error.message.includes('no such table')\r\n        ) {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check and add completed_at column to tasks table\r\n    const hasCompletedAt = db\r\n      .prepare(\r\n        `\r\n      SELECT COUNT(*) as count FROM pragma_table_info('tasks') \r\n      WHERE name = 'completed_at'\r\n    `,\r\n      )\r\n      .get();\r\n\r\n    if (!hasCompletedAt || hasCompletedAt.count === 0) {\r\n      try {\r\n        db.exec('ALTER TABLE tasks ADD COLUMN completed_at DATETIME');\r\n        console.log('Added missing completed_at column to tasks table');\r\n      } catch (error) {\r\n        if (\r\n          !error.message.includes('duplicate column') &&\r\n          !error.message.includes('no such table')\r\n        ) {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check and add result column to tasks table\r\n    const hasResult = db\r\n      .prepare(\r\n        `\r\n      SELECT COUNT(*) as count FROM pragma_table_info('tasks') \r\n      WHERE name = 'result'\r\n    `,\r\n      )\r\n      .get();\r\n\r\n    if (!hasResult || hasResult.count === 0) {\r\n      try {\r\n        db.exec('ALTER TABLE tasks ADD COLUMN result TEXT');\r\n        console.log('Added missing result column to tasks table');\r\n      } catch (error) {\r\n        if (\r\n          !error.message.includes('duplicate column') &&\r\n          !error.message.includes('no such table')\r\n        ) {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (tableSet.has('swarms')) {\r\n    // Check and add updated_at column to swarms table\r\n    const hasUpdatedAt = db\r\n      .prepare(\r\n        `\r\n      SELECT COUNT(*) as count FROM pragma_table_info('swarms') \r\n      WHERE name = 'updated_at'\r\n    `,\r\n      )\r\n      .get();\r\n\r\n    if (!hasUpdatedAt || hasUpdatedAt.count === 0) {\r\n      try {\r\n        db.exec('ALTER TABLE swarms ADD COLUMN updated_at DATETIME');\r\n        console.log('Added missing updated_at column to swarms table');\r\n      } catch (error) {\r\n        if (\r\n          !error.message.includes('duplicate column') &&\r\n          !error.message.includes('no such table')\r\n        ) {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Apply advanced performance indexes\r\n */\r\nfunction applyAdvancedIndexes(db) {\r\n  // Check which tables exist\r\n  const tables = db\r\n    .prepare(\r\n      `\r\n    SELECT name FROM sqlite_master \r\n    WHERE type='table' AND name NOT LIKE 'sqlite_%'\r\n  `,\r\n    )\r\n    .all()\r\n    .map((row) => row.name);\r\n\r\n  const tableSet = new Set(tables);\r\n  const indexes = [];\r\n\r\n  // Composite indexes for common queries\r\n  if (tableSet.has('tasks')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_tasks_swarm_status ON tasks(swarm_id, status)',\r\n      'CREATE INDEX IF NOT EXISTS idx_tasks_full ON tasks(swarm_id, agent_id, status, priority)',\r\n      \"CREATE INDEX IF NOT EXISTS idx_tasks_pending ON tasks(swarm_id, priority) WHERE status = 'pending'\",\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('agents')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_agents_swarm_type ON agents(swarm_id, type)',\r\n      'CREATE INDEX IF NOT EXISTS idx_agents_full ON agents(swarm_id, type, status, role)',\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('collective_memory')) {\r\n    indexes.push(\r\n      'CREATE INDEX IF NOT EXISTS idx_memory_swarm_key ON collective_memory(swarm_id, key)',\r\n    );\r\n  }\r\n\r\n  if (tableSet.has('swarms')) {\r\n    indexes.push(\r\n      \"CREATE INDEX IF NOT EXISTS idx_swarms_active ON swarms(id, name) WHERE status = 'active'\",\r\n    );\r\n  }\r\n\r\n  indexes.forEach((sql) => {\r\n    try {\r\n      db.exec(sql);\r\n    } catch (error) {\r\n      console.warn(`Warning: Could not create index: ${error.message}`);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Add performance tracking tables\r\n */\r\nfunction addPerformanceTracking(db) {\r\n  // Agent performance metrics\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS agent_performance (\r\n      agent_id TEXT PRIMARY KEY,\r\n      tasks_completed INTEGER DEFAULT 0,\r\n      tasks_failed INTEGER DEFAULT 0,\r\n      avg_completion_time REAL,\r\n      success_rate REAL,\r\n      last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      FOREIGN KEY (agent_id) REFERENCES agents(id)\r\n    )\r\n  `);\r\n\r\n  // Swarm performance metrics\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS swarm_performance (\r\n      swarm_id TEXT PRIMARY KEY,\r\n      total_tasks INTEGER DEFAULT 0,\r\n      completed_tasks INTEGER DEFAULT 0,\r\n      avg_consensus_time REAL,\r\n      memory_efficiency REAL,\r\n      last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      FOREIGN KEY (swarm_id) REFERENCES swarms(id)\r\n    )\r\n  `);\r\n\r\n  // Create triggers to update performance metrics\r\n  db.exec(`\r\n    CREATE TRIGGER IF NOT EXISTS update_agent_performance\r\n    AFTER UPDATE OF status ON tasks\r\n    WHEN NEW.status = 'completed' OR NEW.status = 'failed'\r\n    BEGIN\r\n      INSERT OR REPLACE INTO agent_performance (agent_id, tasks_completed, tasks_failed)\r\n      VALUES (\r\n        NEW.agent_id,\r\n        COALESCE((SELECT tasks_completed FROM agent_performance WHERE agent_id = NEW.agent_id), 0) + \r\n          CASE WHEN NEW.status = 'completed' THEN 1 ELSE 0 END,\r\n        COALESCE((SELECT tasks_failed FROM agent_performance WHERE agent_id = NEW.agent_id), 0) + \r\n          CASE WHEN NEW.status = 'failed' THEN 1 ELSE 0 END\r\n      );\r\n    END\r\n  `);\r\n}\r\n\r\n/**\r\n * Add memory optimization features\r\n */\r\nfunction addMemoryOptimization(db) {\r\n  // Check if collective_memory table exists\r\n  const tables = db\r\n    .prepare(\r\n      `\r\n    SELECT name FROM sqlite_master \r\n    WHERE type='table' AND name = 'collective_memory'\r\n  `,\r\n    )\r\n    .all();\r\n\r\n  if (tables.length === 0) {\r\n    console.log('collective_memory table does not exist, skipping memory optimization');\r\n    return;\r\n  }\r\n\r\n  // Check and add access_count column\r\n  const hasAccessCount = db\r\n    .prepare(\r\n      `\r\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \r\n    WHERE name = 'access_count'\r\n  `,\r\n    )\r\n    .get();\r\n\r\n  if (!hasAccessCount || hasAccessCount.count === 0) {\r\n    try {\r\n      db.exec(`\r\n        ALTER TABLE collective_memory \r\n        ADD COLUMN access_count INTEGER DEFAULT 0\r\n      `);\r\n      console.log('Added access_count column to collective_memory table');\r\n    } catch (error) {\r\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check and add accessed_at column (not last_accessed)\r\n  const hasAccessedAt = db\r\n    .prepare(\r\n      `\r\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \r\n    WHERE name = 'accessed_at'\r\n  `,\r\n    )\r\n    .get();\r\n\r\n  if (!hasAccessedAt || hasAccessedAt.count === 0) {\r\n    try {\r\n      db.exec(`\r\n        ALTER TABLE collective_memory \r\n        ADD COLUMN accessed_at DATETIME\r\n      `);\r\n      console.log('Added accessed_at column to collective_memory table');\r\n    } catch (error) {\r\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add compressed and size columns if missing\r\n  const hasCompressed = db\r\n    .prepare(\r\n      `\r\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \r\n    WHERE name = 'compressed'\r\n  `,\r\n    )\r\n    .get();\r\n\r\n  if (!hasCompressed || hasCompressed.count === 0) {\r\n    try {\r\n      db.exec(`\r\n        ALTER TABLE collective_memory \r\n        ADD COLUMN compressed INTEGER DEFAULT 0\r\n      `);\r\n    } catch (error) {\r\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  const hasSize = db\r\n    .prepare(\r\n      `\r\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \r\n    WHERE name = 'size'\r\n  `,\r\n    )\r\n    .get();\r\n\r\n  if (!hasSize || hasSize.count === 0) {\r\n    try {\r\n      db.exec(`\r\n        ALTER TABLE collective_memory \r\n        ADD COLUMN size INTEGER DEFAULT 0\r\n      `);\r\n    } catch (error) {\r\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create memory usage summary view\r\n  db.exec(`\r\n    CREATE VIEW IF NOT EXISTS memory_usage_summary AS\r\n    SELECT \r\n      swarm_id,\r\n      COUNT(*) as total_entries,\r\n      SUM(LENGTH(value)) as total_size,\r\n      AVG(access_count) as avg_access_count,\r\n      COUNT(CASE WHEN access_count = 0 THEN 1 END) as unused_entries\r\n    FROM collective_memory\r\n    GROUP BY swarm_id\r\n  `);\r\n\r\n  // Add memory cleanup tracking\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS memory_cleanup_log (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      swarm_id TEXT,\r\n      entries_removed INTEGER,\r\n      space_reclaimed INTEGER,\r\n      cleanup_type TEXT,\r\n      performed_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n    )\r\n  `);\r\n}\r\n\r\n/**\r\n * Add behavioral tracking features\r\n */\r\nfunction addBehavioralTracking(db) {\r\n  // Agent interaction patterns\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS agent_interactions (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      from_agent_id TEXT,\r\n      to_agent_id TEXT,\r\n      interaction_type TEXT,\r\n      swarm_id TEXT,\r\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      FOREIGN KEY (from_agent_id) REFERENCES agents(id),\r\n      FOREIGN KEY (to_agent_id) REFERENCES agents(id),\r\n      FOREIGN KEY (swarm_id) REFERENCES swarms(id)\r\n    )\r\n  `);\r\n\r\n  // Behavioral patterns\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS behavioral_patterns (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      swarm_id TEXT,\r\n      pattern_type TEXT,\r\n      pattern_data TEXT, -- JSON\r\n      confidence REAL,\r\n      first_observed DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      last_observed DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      occurrence_count INTEGER DEFAULT 1,\r\n      FOREIGN KEY (swarm_id) REFERENCES swarms(id)\r\n    )\r\n  `);\r\n\r\n  // Create indexes for behavioral analysis\r\n  db.exec(`\r\n    CREATE INDEX IF NOT EXISTS idx_interactions_swarm ON agent_interactions(swarm_id);\r\n    CREATE INDEX IF NOT EXISTS idx_interactions_agents ON agent_interactions(from_agent_id, to_agent_id);\r\n    CREATE INDEX IF NOT EXISTS idx_patterns_swarm_type ON behavioral_patterns(swarm_id, pattern_type);\r\n  `);\r\n}\r\n\r\n/**\r\n * Database maintenance utilities\r\n */\r\nexport async function performMaintenance(dbPath, options = {}) {\r\n  const spinner = ora('Performing database maintenance...').start();\r\n\r\n  try {\r\n    const db = new Database(dbPath);\r\n\r\n    // Clean up old memory entries\r\n    if (options.cleanMemory) {\r\n      // Check if collective_memory table exists\r\n      const hasMemoryTable = db\r\n        .prepare(\r\n          `\r\n        SELECT name FROM sqlite_master \r\n        WHERE type='table' AND name='collective_memory'\r\n      `,\r\n        )\r\n        .get();\r\n\r\n      if (hasMemoryTable) {\r\n        spinner.text = 'Cleaning old memory entries...';\r\n        const cutoffDate = new Date();\r\n        cutoffDate.setDate(cutoffDate.getDate() - (options.memoryRetentionDays || 30));\r\n\r\n        try {\r\n          const result = db\r\n            .prepare(\r\n              `\r\n            DELETE FROM collective_memory \r\n            WHERE accessed_at < ? AND access_count < 5\r\n          `,\r\n            )\r\n            .run(cutoffDate.toISOString());\r\n\r\n          console.log(chalk.green(`✓ Removed ${result.changes} old memory entries`));\r\n        } catch (error) {\r\n          console.warn(chalk.yellow(`⚠ Could not clean memory entries: ${error.message}`));\r\n        }\r\n      } else {\r\n        console.log(chalk.yellow('⚠ collective_memory table not found, skipping memory cleanup'));\r\n      }\r\n    }\r\n\r\n    // Archive completed tasks\r\n    if (options.archiveTasks) {\r\n      spinner.text = 'Archiving completed tasks...';\r\n\r\n      // Create archive table if not exists\r\n      db.exec(`\r\n        CREATE TABLE IF NOT EXISTS tasks_archive AS \r\n        SELECT * FROM tasks WHERE 1=0\r\n      `);\r\n\r\n      // Check if completed_at column exists\r\n      const hasCompletedAt = db\r\n        .prepare(\r\n          `\r\n        SELECT COUNT(*) as count FROM pragma_table_info('tasks') \r\n        WHERE name = 'completed_at'\r\n      `,\r\n        )\r\n        .get();\r\n\r\n      let archived = { changes: 0 };\r\n\r\n      if (hasCompletedAt && hasCompletedAt.count > 0) {\r\n        // Move old completed tasks using completed_at\r\n        const archiveCutoff = new Date();\r\n        archiveCutoff.setDate(archiveCutoff.getDate() - (options.taskRetentionDays || 7));\r\n\r\n        db.exec(`\r\n          INSERT INTO tasks_archive \r\n          SELECT * FROM tasks \r\n          WHERE status = 'completed' AND completed_at < '${archiveCutoff.toISOString()}'\r\n        `);\r\n\r\n        archived = db\r\n          .prepare(\r\n            `\r\n          DELETE FROM tasks \r\n          WHERE status = 'completed' AND completed_at < ?\r\n        `,\r\n          )\r\n          .run(archiveCutoff.toISOString());\r\n      } else {\r\n        // Use created_at as fallback\r\n        const archiveCutoff = new Date();\r\n        archiveCutoff.setDate(archiveCutoff.getDate() - (options.taskRetentionDays || 7));\r\n\r\n        db.exec(`\r\n          INSERT INTO tasks_archive \r\n          SELECT * FROM tasks \r\n          WHERE status = 'completed' AND created_at < '${archiveCutoff.toISOString()}'\r\n        `);\r\n\r\n        archived = db\r\n          .prepare(\r\n            `\r\n          DELETE FROM tasks \r\n          WHERE status = 'completed' AND created_at < ?\r\n        `,\r\n          )\r\n          .run(archiveCutoff.toISOString());\r\n      }\r\n\r\n      console.log(chalk.green(`✓ Archived ${archived.changes} completed tasks`));\r\n    }\r\n\r\n    // Update statistics\r\n    spinner.text = 'Updating database statistics...';\r\n    db.exec('ANALYZE');\r\n\r\n    // Check integrity\r\n    if (options.checkIntegrity) {\r\n      spinner.text = 'Checking database integrity...';\r\n      const integrityCheck = db.prepare('PRAGMA integrity_check').get();\r\n      if (integrityCheck.integrity_check === 'ok') {\r\n        console.log(chalk.green('✓ Database integrity check passed'));\r\n      } else {\r\n        console.log(chalk.yellow('⚠ Database integrity issues detected'));\r\n      }\r\n    }\r\n\r\n    db.close();\r\n    spinner.succeed('Database maintenance complete!');\r\n  } catch (error) {\r\n    spinner.fail('Database maintenance failed');\r\n    console.error(chalk.red('Error:'), error.message);\r\n  }\r\n}\r\n\r\n/**\r\n * Generate optimization report\r\n */\r\nexport async function generateOptimizationReport(dbPath) {\r\n  try {\r\n    const db = new Database(dbPath, { readonly: true });\r\n\r\n    const report = {\r\n      schemaVersion: getSchemaVersion(db),\r\n      tables: {},\r\n      indexes: [],\r\n      performance: {},\r\n    };\r\n\r\n    // Get table statistics\r\n    const tables = db\r\n      .prepare(\r\n        `\r\n      SELECT name FROM sqlite_master WHERE type='table'\r\n    `,\r\n      )\r\n      .all();\r\n\r\n    for (const table of tables) {\r\n      const count = db.prepare(`SELECT COUNT(*) as count FROM ${table.name}`).get();\r\n      const size = db\r\n        .prepare(\r\n          `\r\n        SELECT SUM(pgsize) as size FROM dbstat WHERE name=?\r\n      `,\r\n        )\r\n        .get(table.name);\r\n\r\n      report.tables[table.name] = {\r\n        rowCount: count.count,\r\n        sizeBytes: size?.size || 0,\r\n      };\r\n    }\r\n\r\n    // Get index information\r\n    report.indexes = db\r\n      .prepare(\r\n        `\r\n      SELECT name, tbl_name FROM sqlite_master WHERE type='index'\r\n    `,\r\n      )\r\n      .all();\r\n\r\n    // Get performance metrics (check if completed_at column exists)\r\n    let avgTaskTime = { avg_minutes: 0 };\r\n    try {\r\n      // First check if completed_at column exists\r\n      const hasCompletedAt = db\r\n        .prepare(\r\n          `\r\n        SELECT COUNT(*) as count FROM pragma_table_info('tasks') \r\n        WHERE name = 'completed_at'\r\n      `,\r\n        )\r\n        .get();\r\n\r\n      if (hasCompletedAt && hasCompletedAt.count > 0) {\r\n        avgTaskTime = db\r\n          .prepare(\r\n            `\r\n          SELECT AVG(julianday(completed_at) - julianday(created_at)) * 24 * 60 as avg_minutes\r\n          FROM tasks WHERE completed_at IS NOT NULL\r\n        `,\r\n          )\r\n          .get();\r\n      }\r\n    } catch (error) {\r\n      // If error, just use default value\r\n      console.warn('Could not calculate average task time:', error.message);\r\n    }\r\n\r\n    report.performance.avgTaskCompletionMinutes = avgTaskTime?.avg_minutes || 0;\r\n\r\n    db.close();\r\n\r\n    return report;\r\n  } catch (error) {\r\n    console.error('Error generating report:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Export for use in CLI\r\nexport default {\r\n  optimizeHiveMindDatabase,\r\n  performMaintenance,\r\n  generateOptimizationReport,\r\n};\r\n"],"names":["Database","chalk","ora","optimizeHiveMindDatabase","dbPath","options","spinner","start","db","verbose","console","log","pragma","schemaVersion","getSchemaVersion","text","optimizationsApplied","applyBasicIndexes","push","applyAdvancedIndexes","addPerformanceTracking","addMemoryOptimization","addBehavioralTracking","exec","vacuum","updateSchemaVersion","close","succeed","length","green","forEach","opt","yellow","success","optimizations","error","fail","red","message","tableExists","prepare","get","run","result","version","description","ensureRequiredColumns","tables","all","map","row","name","tableSet","Set","indexes","has","sql","warn","hasPriority","count","includes","hasCompletedAt","hasResult","hasUpdatedAt","hasAccessCount","hasAccessedAt","hasCompressed","hasSize","performMaintenance","cleanMemory","hasMemoryTable","cutoffDate","Date","setDate","getDate","memoryRetentionDays","toISOString","changes","archiveTasks","archived","archiveCutoff","taskRetentionDays","checkIntegrity","integrityCheck","integrity_check","generateOptimizationReport","readonly","report","performance","table","size","rowCount","sizeBytes","avgTaskTime","avg_minutes","avgTaskCompletionMinutes"],"mappings":"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"}