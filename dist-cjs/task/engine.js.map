{
  "version": 3,
  "sources": ["../../src/task/engine.ts"],
  "sourcesContent": ["/**\n * Task Engine Core - Comprehensive task management with orchestration features\n * Integrates with TodoWrite/TodoRead for coordination and Memory for persistence\n */\n\nimport { EventEmitter } from 'events';\nimport type { Task, TaskStatus, AgentProfile, Resource } from '../utils/types.js';\nimport type { TaskMetadata } from './types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface TaskDependency {\n  taskId: string;\n  type: 'finish-to-start' | 'start-to-start' | 'finish-to-finish' | 'start-to-finish';\n  lag?: number; // delay in milliseconds\n}\n\nexport interface ResourceRequirement {\n  resourceId: string;\n  type: 'cpu' | 'memory' | 'disk' | 'network' | 'custom';\n  amount: number;\n  unit: string;\n  exclusive?: boolean;\n  priority?: number;\n}\n\nexport interface TaskSchedule {\n  startTime?: Date;\n  endTime?: Date;\n  deadline?: Date;\n  recurring?: {\n    interval: 'daily' | 'weekly' | 'monthly';\n    count?: number;\n    until?: Date;\n  };\n  timezone?: string;\n}\n\nexport interface WorkflowTask extends Omit<Task, 'dependencies' | 'metadata'> {\n  dependencies: TaskDependency[];\n  resourceRequirements: ResourceRequirement[];\n  schedule?: TaskSchedule;\n  retryPolicy?: {\n    maxAttempts: number;\n    backoffMs: number;\n    backoffMultiplier: number;\n  };\n  timeout?: number;\n  tags: string[];\n  estimatedDurationMs?: number;\n  actualDurationMs?: number;\n  progressPercentage: number;\n  checkpoints: TaskCheckpoint[];\n  rollbackStrategy?: 'previous-checkpoint' | 'initial-state' | 'custom';\n  customRollbackHandler?: string;\n  metadata: TaskMetadata;\n}\n\nexport interface TaskCheckpoint {\n  id: string;\n  timestamp: Date;\n  description: string;\n  state: Record<string, unknown>;\n  artifacts: string[];\n}\n\nexport interface TaskExecution {\n  id: string;\n  taskId: string;\n  agentId: string;\n  startedAt: Date;\n  completedAt?: Date;\n  status: TaskStatus;\n  progress: number;\n  metrics: TaskMetrics;\n  logs: TaskLog[];\n}\n\nexport interface TaskMetrics {\n  cpuUsage: number;\n  memoryUsage: number;\n  diskIO: number;\n  networkIO: number;\n  customMetrics: Record<string, number>;\n}\n\nexport interface TaskLog {\n  timestamp: Date;\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface Workflow {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  tasks: WorkflowTask[];\n  variables: Record<string, unknown>;\n  parallelism: {\n    maxConcurrent: number;\n    strategy: 'breadth-first' | 'depth-first' | 'priority-based';\n  };\n  errorHandling: {\n    strategy: 'fail-fast' | 'continue-on-error' | 'retry-failed';\n    maxRetries: number;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n  createdBy: string;\n}\n\nexport interface TaskFilter {\n  status?: TaskStatus[];\n  assignedAgent?: string[];\n  priority?: { min?: number; max?: number };\n  tags?: string[];\n  createdAfter?: Date;\n  createdBefore?: Date;\n  dueBefore?: Date;\n  search?: string;\n}\n\nexport interface TaskSort {\n  field: 'createdAt' | 'priority' | 'deadline' | 'status' | 'estimatedDuration';\n  direction: 'asc' | 'desc';\n}\n\nexport class TaskEngine extends EventEmitter {\n  private tasks = new Map<string, WorkflowTask>();\n  private executions = new Map<string, TaskExecution>();\n  private workflows = new Map<string, Workflow>();\n  private resources = new Map<string, Resource>();\n  private dependencyGraph = new Map<string, Set<string>>();\n  private readyQueue: string[] = [];\n  private runningTasks = new Set<string>();\n  private cancelledTasks = new Set<string>();\n  private taskState = new Map<string, Record<string, unknown>>();\n\n  constructor(\n    private maxConcurrent: number = 10,\n    private memoryManager?: any, // Memory interface for persistence\n  ) {\n    super();\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.on('task:created', this.handleTaskCreated.bind(this));\n    this.on('task:completed', this.handleTaskCompleted.bind(this));\n    this.on('task:failed', this.handleTaskFailed.bind(this));\n    this.on('task:cancelled', this.handleTaskCancelled.bind(this));\n  }\n\n  /**\n   * Create a new task with comprehensive options\n   */\n  async createTask(taskData: Partial<WorkflowTask>): Promise<WorkflowTask> {\n    const task: WorkflowTask = {\n      id: taskData.id || generateId('task'),\n      type: taskData.type || 'general',\n      description: taskData.description || '',\n      priority: taskData.priority || 0,\n      status: 'pending',\n      input: taskData.input || {},\n      createdAt: new Date(),\n      dependencies: taskData.dependencies || [],\n      resourceRequirements: taskData.resourceRequirements || [],\n      schedule: taskData.schedule,\n      retryPolicy: taskData.retryPolicy || {\n        maxAttempts: 3,\n        backoffMs: 1000,\n        backoffMultiplier: 2,\n      },\n      timeout: taskData.timeout || 300000, // 5 minutes default\n      tags: taskData.tags || [],\n      estimatedDurationMs: taskData.estimatedDurationMs,\n      progressPercentage: 0,\n      checkpoints: [],\n      rollbackStrategy: taskData.rollbackStrategy || 'previous-checkpoint',\n      metadata: taskData.metadata || {},\n    };\n\n    this.tasks.set(task.id, task);\n    this.updateDependencyGraph(task);\n\n    // Store in memory if manager available\n    if (this.memoryManager) {\n      await this.memoryManager.store(`task:${task.id}`, task);\n    }\n\n    this.emit('task:created', { task });\n    this.scheduleTask(task);\n\n    return task;\n  }\n\n  /**\n   * List tasks with filtering and sorting\n   */\n  async listTasks(\n    filter?: TaskFilter,\n    sort?: TaskSort,\n    limit?: number,\n    offset?: number,\n  ): Promise<{ tasks: WorkflowTask[]; total: number; hasMore: boolean }> {\n    let filteredTasks = Array.from(this.tasks.values());\n\n    // Apply filters\n    if (filter) {\n      filteredTasks = filteredTasks.filter((task) => {\n        if (filter.status && !filter.status.includes(task.status)) return false;\n        if (filter.assignedAgent && !filter.assignedAgent.includes(task.assignedAgent || ''))\n          return false;\n        if (filter.priority) {\n          if (filter.priority.min !== undefined && task.priority < filter.priority.min)\n            return false;\n          if (filter.priority.max !== undefined && task.priority > filter.priority.max)\n            return false;\n        }\n        if (filter.tags && !filter.tags.some((tag) => task.tags.includes(tag))) return false;\n        if (filter.createdAfter && task.createdAt < filter.createdAfter) return false;\n        if (filter.createdBefore && task.createdAt > filter.createdBefore) return false;\n        if (\n          filter.dueBefore &&\n          task.schedule?.deadline &&\n          task.schedule.deadline > filter.dueBefore\n        )\n          return false;\n        if (filter.search && !this.matchesSearch(task, filter.search)) return false;\n        return true;\n      });\n    }\n\n    // Apply sorting\n    if (sort) {\n      filteredTasks.sort((a, b) => {\n        const direction = sort.direction === 'desc' ? -1 : 1;\n        switch (sort.field) {\n          case 'createdAt':\n            return direction * (a.createdAt.getTime() - b.createdAt.getTime());\n          case 'priority':\n            return direction * (a.priority - b.priority);\n          case 'deadline':\n            const aDeadline = a.schedule?.deadline?.getTime() || 0;\n            const bDeadline = b.schedule?.deadline?.getTime() || 0;\n            return direction * (aDeadline - bDeadline);\n          case 'estimatedDuration':\n            return direction * ((a.estimatedDurationMs || 0) - (b.estimatedDurationMs || 0));\n          default:\n            return 0;\n        }\n      });\n    }\n\n    const total = filteredTasks.length;\n    const startIndex = offset || 0;\n    const endIndex = limit ? startIndex + limit : filteredTasks.length;\n    const tasks = filteredTasks.slice(startIndex, endIndex);\n\n    return {\n      tasks,\n      total,\n      hasMore: endIndex < total,\n    };\n  }\n\n  /**\n   * Get detailed task status with progress and metrics\n   */\n  async getTaskStatus(taskId: string): Promise<{\n    task: WorkflowTask;\n    execution?: TaskExecution;\n    dependencies: { task: WorkflowTask; satisfied: boolean }[];\n    dependents: WorkflowTask[];\n    resourceStatus: { required: ResourceRequirement; available: boolean; allocated: boolean }[];\n  } | null> {\n    const task = this.tasks.get(taskId);\n    if (!task) return null;\n\n    const execution = this.executions.get(taskId);\n\n    // Get dependency status\n    const dependencies = await Promise.all(\n      task.dependencies.map(async (dep) => {\n        const depTask = this.tasks.get(dep.taskId);\n        if (!depTask) throw new Error(`Dependency task ${dep.taskId} not found`);\n        const satisfied = this.isDependencySatisfied(dep, depTask);\n        return { task: depTask, satisfied };\n      }),\n    );\n\n    // Get dependent tasks\n    const dependents = Array.from(this.tasks.values()).filter((t) =>\n      t.dependencies.some((dep) => dep.taskId === taskId),\n    );\n\n    // Get resource status\n    const resourceStatus = task.resourceRequirements.map((req) => {\n      const resource = this.resources.get(req.resourceId);\n      return {\n        required: req,\n        available: !!resource,\n        allocated: resource?.lockedBy === taskId,\n      };\n    });\n\n    return {\n      task,\n      execution,\n      dependencies,\n      dependents,\n      resourceStatus,\n    };\n  }\n\n  /**\n   * Cancel task with rollback and cleanup\n   */\n  async cancelTask(\n    taskId: string,\n    reason: string = 'User requested',\n    rollback: boolean = true,\n  ): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} not found`);\n\n    if (task.status === 'completed') {\n      throw new Error(`Cannot cancel completed task ${taskId}`);\n    }\n\n    this.cancelledTasks.add(taskId);\n\n    // Stop running execution\n    if (this.runningTasks.has(taskId)) {\n      this.runningTasks.delete(taskId);\n      const execution = this.executions.get(taskId);\n      if (execution) {\n        execution.status = 'cancelled';\n        execution.completedAt = new Date();\n      }\n    }\n\n    // Release resources\n    await this.releaseTaskResources(taskId);\n\n    // Perform rollback if requested\n    if (rollback && task.checkpoints.length > 0) {\n      await this.rollbackTask(task);\n    }\n\n    // Update task status\n    task.status = 'cancelled';\n    task.metadata = {\n      ...task.metadata,\n      cancellationReason: reason,\n      cancelledAt: new Date(),\n    };\n\n    // Update memory\n    if (this.memoryManager) {\n      await this.memoryManager.store(`task:${taskId}`, task);\n    }\n\n    this.emit('task:cancelled', { taskId, reason });\n\n    // Cancel dependent tasks if configured\n    const dependents = Array.from(this.tasks.values()).filter((t) =>\n      t.dependencies.some((dep) => dep.taskId === taskId),\n    );\n\n    for (const dependent of dependents) {\n      if (dependent.status === 'pending' || dependent.status === 'queued') {\n        await this.cancelTask(dependent.id, `Dependency ${taskId} was cancelled`);\n      }\n    }\n  }\n\n  /**\n   * Execute workflow with parallel processing\n   */\n  async executeWorkflow(workflow: Workflow): Promise<void> {\n    this.workflows.set(workflow.id, workflow);\n\n    // Add all workflow tasks\n    for (const task of workflow.tasks) {\n      this.tasks.set(task.id, task);\n      this.updateDependencyGraph(task);\n    }\n\n    // Start execution with parallel processing\n    await this.processWorkflow(workflow);\n  }\n\n  /**\n   * Create workflow from tasks\n   */\n  async createWorkflow(workflowData: Partial<Workflow>): Promise<Workflow> {\n    const workflow: Workflow = {\n      id: workflowData.id || generateId('workflow'),\n      name: workflowData.name || 'Unnamed Workflow',\n      description: workflowData.description || '',\n      version: workflowData.version || '1.0.0',\n      tasks: workflowData.tasks || [],\n      variables: workflowData.variables || {},\n      parallelism: workflowData.parallelism || {\n        maxConcurrent: this.maxConcurrent,\n        strategy: 'priority-based',\n      },\n      errorHandling: workflowData.errorHandling || {\n        strategy: 'fail-fast',\n        maxRetries: 3,\n      },\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      createdBy: workflowData.createdBy || 'system',\n    };\n\n    this.workflows.set(workflow.id, workflow);\n\n    if (this.memoryManager) {\n      await this.memoryManager.store(`workflow:${workflow.id}`, workflow);\n    }\n\n    return workflow;\n  }\n\n  /**\n   * Get dependency visualization\n   */\n  getDependencyGraph(): { nodes: any[]; edges: any[] } {\n    const nodes = Array.from(this.tasks.values()).map((task) => ({\n      id: task.id,\n      label: task.description,\n      status: task.status,\n      priority: task.priority,\n      progress: task.progressPercentage,\n      estimatedDuration: task.estimatedDurationMs,\n      tags: task.tags,\n    }));\n\n    const edges: any[] = [];\n    for (const task of Array.from(this.tasks.values())) {\n      for (const dep of task.dependencies) {\n        edges.push({\n          from: dep.taskId,\n          to: task.id,\n          type: dep.type,\n          lag: dep.lag,\n        });\n      }\n    }\n\n    return { nodes, edges };\n  }\n\n  // Private helper methods\n\n  private updateDependencyGraph(task: WorkflowTask): void {\n    if (!this.dependencyGraph.has(task.id)) {\n      this.dependencyGraph.set(task.id, new Set());\n    }\n\n    for (const dep of task.dependencies) {\n      if (!this.dependencyGraph.has(dep.taskId)) {\n        this.dependencyGraph.set(dep.taskId, new Set());\n      }\n      this.dependencyGraph.get(dep.taskId)!.add(task.id);\n    }\n  }\n\n  private scheduleTask(task: WorkflowTask): void {\n    if (this.areTaskDependenciesSatisfied(task)) {\n      this.readyQueue.push(task.id);\n      this.processReadyQueue();\n    }\n  }\n\n  private areTaskDependenciesSatisfied(task: WorkflowTask): boolean {\n    return task.dependencies.every((dep) => {\n      const depTask = this.tasks.get(dep.taskId);\n      return depTask && this.isDependencySatisfied(dep, depTask);\n    });\n  }\n\n  private isDependencySatisfied(dependency: TaskDependency, depTask: WorkflowTask): boolean {\n    switch (dependency.type) {\n      case 'finish-to-start':\n        return depTask.status === 'completed';\n      case 'start-to-start':\n        return depTask.status !== 'pending';\n      case 'finish-to-finish':\n        return depTask.status === 'completed';\n      case 'start-to-finish':\n        return depTask.status !== 'pending';\n      default:\n        return depTask.status === 'completed';\n    }\n  }\n\n  private async processReadyQueue(): Promise<void> {\n    while (this.readyQueue.length > 0 && this.runningTasks.size < this.maxConcurrent) {\n      const taskId = this.readyQueue.shift()!;\n      if (this.cancelledTasks.has(taskId)) continue;\n\n      const task = this.tasks.get(taskId);\n      if (!task) continue;\n\n      await this.executeTask(task);\n    }\n  }\n\n  private async executeTask(task: WorkflowTask): Promise<void> {\n    if (!(await this.acquireTaskResources(task))) {\n      // Resources not available, put back in queue\n      this.readyQueue.unshift(task.id);\n      return;\n    }\n\n    const execution: TaskExecution = {\n      id: generateId('execution'),\n      taskId: task.id,\n      agentId: task.assignedAgent || 'system',\n      startedAt: new Date(),\n      status: 'running',\n      progress: 0,\n      metrics: {\n        cpuUsage: 0,\n        memoryUsage: 0,\n        diskIO: 0,\n        networkIO: 0,\n        customMetrics: {},\n      },\n      logs: [],\n    };\n\n    this.executions.set(task.id, execution);\n    this.runningTasks.add(task.id);\n    task.status = 'running';\n    task.startedAt = new Date();\n\n    this.emit('task:started', { taskId: task.id, agentId: execution.agentId });\n\n    try {\n      // Simulate task execution - in real implementation, this would delegate to agents\n      await this.simulateTaskExecution(task, execution);\n\n      task.status = 'completed';\n      task.completedAt = new Date();\n      task.progressPercentage = 100;\n      execution.status = 'completed';\n      execution.completedAt = new Date();\n\n      this.emit('task:completed', { taskId: task.id, result: task.output });\n    } catch (error) {\n      task.status = 'failed';\n      task.error = error as Error;\n      execution.status = 'failed';\n      execution.completedAt = new Date();\n\n      this.emit('task:failed', { taskId: task.id, error });\n    } finally {\n      this.runningTasks.delete(task.id);\n      await this.releaseTaskResources(task.id);\n\n      if (this.memoryManager) {\n        await this.memoryManager.store(`task:${task.id}`, task);\n        await this.memoryManager.store(`execution:${execution.id}`, execution);\n      }\n    }\n  }\n\n  private async simulateTaskExecution(task: WorkflowTask, execution: TaskExecution): Promise<void> {\n    // Simulate work with progress updates\n    const steps = 10;\n    for (let i = 0; i <= steps; i++) {\n      if (this.cancelledTasks.has(task.id)) {\n        throw new Error('Task was cancelled');\n      }\n\n      task.progressPercentage = (i / steps) * 100;\n      execution.progress = task.progressPercentage;\n\n      // Create checkpoint every 25%\n      if (i % Math.ceil(steps / 4) === 0) {\n        await this.createCheckpoint(task, `Step ${i} completed`);\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n\n    task.output = { result: 'Task completed successfully', timestamp: new Date() };\n  }\n\n  private async createCheckpoint(task: WorkflowTask, description: string): Promise<void> {\n    const checkpoint: TaskCheckpoint = {\n      id: generateId('checkpoint'),\n      timestamp: new Date(),\n      description,\n      state: { ...(this.taskState.get(task.id) || {}) },\n      artifacts: [],\n    };\n\n    task.checkpoints.push(checkpoint);\n\n    if (this.memoryManager) {\n      await this.memoryManager.store(`checkpoint:${checkpoint.id}`, checkpoint);\n    }\n  }\n\n  private async rollbackTask(task: WorkflowTask): Promise<void> {\n    if (task.checkpoints.length === 0) return;\n\n    const targetCheckpoint =\n      task.rollbackStrategy === 'initial-state'\n        ? task.checkpoints[0]\n        : task.checkpoints[task.checkpoints.length - 1];\n\n    // Restore state from checkpoint\n    this.taskState.set(task.id, { ...targetCheckpoint.state });\n\n    // Remove checkpoints after the target\n    const targetIndex = task.checkpoints.findIndex((cp) => cp.id === targetCheckpoint.id);\n    task.checkpoints = task.checkpoints.slice(0, targetIndex + 1);\n\n    task.progressPercentage = Math.max(0, task.progressPercentage - 25);\n  }\n\n  private async acquireTaskResources(task: WorkflowTask): Promise<boolean> {\n    for (const requirement of task.resourceRequirements) {\n      const resource = this.resources.get(requirement.resourceId);\n      if (!resource) return false;\n\n      if (resource.locked && requirement.exclusive) return false;\n\n      resource.locked = true;\n      resource.lockedBy = task.id;\n      resource.lockedAt = new Date();\n    }\n    return true;\n  }\n\n  private async releaseTaskResources(taskId: string): Promise<void> {\n    for (const resource of Array.from(this.resources.values())) {\n      if (resource.lockedBy === taskId) {\n        resource.locked = false;\n        resource.lockedBy = undefined;\n        resource.lockedAt = undefined;\n      }\n    }\n  }\n\n  private matchesSearch(task: WorkflowTask, search: string): boolean {\n    const searchLower = search.toLowerCase();\n    return (\n      task.description.toLowerCase().includes(searchLower) ||\n      task.type.toLowerCase().includes(searchLower) ||\n      task.tags.some((tag) => tag.toLowerCase().includes(searchLower)) ||\n      (task.assignedAgent ? task.assignedAgent.toLowerCase().includes(searchLower) : false)\n    );\n  }\n\n  private async processWorkflow(workflow: Workflow): Promise<void> {\n    // Implementation would manage workflow execution based on parallelism settings\n    // This is a simplified version\n    for (const task of workflow.tasks) {\n      this.scheduleTask(task);\n    }\n  }\n\n  private handleTaskCreated(data: { task: WorkflowTask }): void {\n    // Handle task creation events\n  }\n\n  private handleTaskCompleted(data: { taskId: string; result: unknown }): void {\n    // Schedule dependent tasks\n    const dependents = Array.from(this.tasks.values()).filter((task) =>\n      task.dependencies.some((dep) => dep.taskId === data.taskId),\n    );\n\n    for (const dependent of dependents) {\n      if (this.areTaskDependenciesSatisfied(dependent)) {\n        this.readyQueue.push(dependent.id);\n      }\n    }\n\n    this.processReadyQueue();\n  }\n\n  private handleTaskFailed(data: { taskId: string; error: Error }): void {\n    // Handle task failure, potentially retry or fail dependents\n    const task = this.tasks.get(data.taskId);\n    if (!task) return;\n\n    // Implement retry logic based on retryPolicy\n    if (task.retryPolicy && (task.metadata.retryCount || 0) < task.retryPolicy.maxAttempts) {\n      const currentRetryCount = task.metadata.retryCount || 0;\n      task.metadata = {\n        ...task.metadata,\n        retryCount: currentRetryCount + 1,\n        lastRetryAt: new Date(),\n      };\n      task.status = 'pending';\n\n      // Schedule retry with backoff\n      setTimeout(\n        () => {\n          this.scheduleTask(task);\n        },\n        task.retryPolicy!.backoffMs *\n          Math.pow(task.retryPolicy!.backoffMultiplier, currentRetryCount),\n      );\n    }\n  }\n\n  private handleTaskCancelled(data: { taskId: string; reason: string }): void {\n    // Handle task cancellation\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
