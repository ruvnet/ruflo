{"version":3,"sources":["../../../src/api/database-service.ts"],"sourcesContent":["/**\r\n * Database service for swarm coordination system\r\n * Provides data access layer with support for multiple database engines\r\n */\r\n\r\nimport { ILogger } from '../core/logger.js';\r\nimport { DatabaseError } from '../utils/errors.js';\r\nimport { nanoid } from 'nanoid';\r\n\r\nexport interface DatabaseConfig {\r\n  type: 'sqlite' | 'mysql' | 'postgresql';\r\n  host?: string;\r\n  port?: number;\r\n  database: string;\r\n  username?: string;\r\n  password?: string;\r\n  ssl?: boolean;\r\n  poolSize?: number;\r\n  timeout?: number;\r\n  retryAttempts?: number;\r\n}\r\n\r\nexport interface SwarmRecord {\r\n  id: string;\r\n  name: string;\r\n  topology: 'hierarchical' | 'mesh' | 'ring' | 'star';\r\n  maxAgents: number;\r\n  strategy: 'balanced' | 'specialized' | 'adaptive';\r\n  status: 'initializing' | 'active' | 'paused' | 'destroyed';\r\n  config?: Record<string, unknown>;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  destroyedAt?: Date;\r\n}\r\n\r\nexport interface AgentRecord {\r\n  id: string;\r\n  swarmId: string;\r\n  type: string;\r\n  name?: string;\r\n  status: 'spawning' | 'idle' | 'busy' | 'error' | 'terminated';\r\n  capabilities?: string[];\r\n  config?: Record<string, unknown>;\r\n  metadata?: Record<string, unknown>;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  terminatedAt?: Date;\r\n}\r\n\r\nexport interface TaskRecord {\r\n  id: string;\r\n  swarmId: string;\r\n  description: string;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  strategy: 'parallel' | 'sequential' | 'adaptive';\r\n  status: 'pending' | 'assigned' | 'running' | 'completed' | 'failed' | 'cancelled';\r\n  maxAgents?: number;\r\n  requirements?: string[];\r\n  metadata?: Record<string, unknown>;\r\n  result?: unknown;\r\n  errorMessage?: string;\r\n  assignedTo?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  startedAt?: Date;\r\n  completedAt?: Date;\r\n}\r\n\r\nexport interface MetricRecord {\r\n  id: string;\r\n  swarmId?: string;\r\n  agentId?: string;\r\n  metricType: string;\r\n  metricName: string;\r\n  metricValue: number;\r\n  unit?: string;\r\n  timestamp: Date;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\nexport interface EventRecord {\r\n  id: string;\r\n  swarmId?: string;\r\n  agentId?: string;\r\n  eventType: string;\r\n  eventName: string;\r\n  eventData?: Record<string, unknown>;\r\n  severity: 'debug' | 'info' | 'warning' | 'error' | 'critical';\r\n  createdAt: Date;\r\n}\r\n\r\n/**\r\n * Database service implementation\r\n */\r\nexport class DatabaseService {\r\n  private db: any; // Database connection instance\r\n  private initialized = false;\r\n\r\n  constructor(\r\n    private config: DatabaseConfig,\r\n    private logger: ILogger,\r\n  ) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.initialized) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.info('Initializing database service', {\r\n        type: this.config.type,\r\n        database: this.config.database,\r\n      });\r\n\r\n      // Initialize database connection based on type\r\n      switch (this.config.type) {\r\n        case 'sqlite':\r\n          await this.initializeSQLite();\r\n          break;\r\n        case 'mysql':\r\n          await this.initializeMySQL();\r\n          break;\r\n        case 'postgresql':\r\n          await this.initializePostgreSQL();\r\n          break;\r\n        default:\r\n          throw new DatabaseError(`Unsupported database type: ${this.config.type}`);\r\n      }\r\n\r\n      // Run migrations if needed\r\n      await this.runMigrations();\r\n\r\n      this.initialized = true;\r\n      this.logger.info('Database service initialized successfully');\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize database service', error);\r\n      throw new DatabaseError('Database initialization failed', { error });\r\n    }\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    if (!this.initialized || !this.db) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (this.config.type === 'sqlite') {\r\n        await this.db.close();\r\n      } else {\r\n        await this.db.end();\r\n      }\r\n      this.initialized = false;\r\n      this.logger.info('Database service shutdown complete');\r\n    } catch (error) {\r\n      this.logger.error('Error shutting down database service', error);\r\n    }\r\n  }\r\n\r\n  // Swarm operations\r\n  async createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<SwarmRecord> {\r\n    const id = `swarm_${Date.now()}_${nanoid(10)}`;\r\n    const now = new Date();\r\n\r\n    const record: SwarmRecord = {\r\n      id,\r\n      ...swarm,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n\r\n    try {\r\n      const query = `\r\n        INSERT INTO swarms (id, name, topology, max_agents, strategy, status, config, created_at, updated_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `;\r\n      const values = [\r\n        record.id,\r\n        record.name,\r\n        record.topology,\r\n        record.maxAgents,\r\n        record.strategy,\r\n        record.status,\r\n        JSON.stringify(record.config),\r\n        record.createdAt,\r\n        record.updatedAt,\r\n      ];\r\n\r\n      await this.execute(query, values);\r\n      return record;\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to create swarm', { error, swarmId: id });\r\n    }\r\n  }\r\n\r\n  async getSwarm(id: string): Promise<SwarmRecord | null> {\r\n    try {\r\n      const query = 'SELECT * FROM swarms WHERE id = ?';\r\n      const rows = await this.query(query, [id]);\r\n      \r\n      if (rows.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      return this.mapSwarmRow(rows[0]);\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to get swarm', { error, swarmId: id });\r\n    }\r\n  }\r\n\r\n  async updateSwarm(id: string, updates: Partial<SwarmRecord>): Promise<void> {\r\n    try {\r\n      const setClause = Object.keys(updates)\r\n        .filter(key => key !== 'id' && key !== 'createdAt')\r\n        .map(key => `${this.camelToSnake(key)} = ?`)\r\n        .join(', ');\r\n      \r\n      const values = Object.entries(updates)\r\n        .filter(([key]) => key !== 'id' && key !== 'createdAt')\r\n        .map(([key, value]) => {\r\n          if (key === 'config' && typeof value === 'object') {\r\n            return JSON.stringify(value);\r\n          }\r\n          return value;\r\n        });\r\n      \r\n      values.push(new Date()); // updated_at\r\n      values.push(id);\r\n\r\n      const query = `UPDATE swarms SET ${setClause}, updated_at = ? WHERE id = ?`;\r\n      await this.execute(query, values);\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to update swarm', { error, swarmId: id });\r\n    }\r\n  }\r\n\r\n  async deleteSwarm(id: string): Promise<void> {\r\n    try {\r\n      const query = 'UPDATE swarms SET status = ?, destroyed_at = ? WHERE id = ?';\r\n      await this.execute(query, ['destroyed', new Date(), id]);\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to delete swarm', { error, swarmId: id });\r\n    }\r\n  }\r\n\r\n  async listSwarms(filter?: { status?: string }): Promise<SwarmRecord[]> {\r\n    try {\r\n      let query = 'SELECT * FROM swarms';\r\n      const values: any[] = [];\r\n\r\n      if (filter?.status) {\r\n        query += ' WHERE status = ?';\r\n        values.push(filter.status);\r\n      }\r\n\r\n      query += ' ORDER BY created_at DESC';\r\n      const rows = await this.query(query, values);\r\n      \r\n      return rows.map(row => this.mapSwarmRow(row));\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to list swarms', { error });\r\n    }\r\n  }\r\n\r\n  // Agent operations\r\n  async createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<AgentRecord> {\r\n    const id = `agent_${Date.now()}_${nanoid(10)}`;\r\n    const now = new Date();\r\n\r\n    const record: AgentRecord = {\r\n      id,\r\n      ...agent,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n\r\n    try {\r\n      const query = `\r\n        INSERT INTO agents (id, swarm_id, type, name, status, capabilities, config, metadata, created_at, updated_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `;\r\n      const values = [\r\n        record.id,\r\n        record.swarmId,\r\n        record.type,\r\n        record.name,\r\n        record.status,\r\n        JSON.stringify(record.capabilities),\r\n        JSON.stringify(record.config),\r\n        JSON.stringify(record.metadata),\r\n        record.createdAt,\r\n        record.updatedAt,\r\n      ];\r\n\r\n      await this.execute(query, values);\r\n      return record;\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to create agent', { error, agentId: id });\r\n    }\r\n  }\r\n\r\n  async getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]> {\r\n    try {\r\n      const query = 'SELECT * FROM agents WHERE swarm_id = ? AND status != ? ORDER BY created_at';\r\n      const rows = await this.query(query, [swarmId, 'terminated']);\r\n      \r\n      return rows.map(row => this.mapAgentRow(row));\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to get agents by swarm', { error, swarmId });\r\n    }\r\n  }\r\n\r\n  async updateAgent(id: string, updates: Partial<AgentRecord>): Promise<void> {\r\n    try {\r\n      const setClause = Object.keys(updates)\r\n        .filter(key => key !== 'id' && key !== 'createdAt')\r\n        .map(key => `${this.camelToSnake(key)} = ?`)\r\n        .join(', ');\r\n      \r\n      const values = Object.entries(updates)\r\n        .filter(([key]) => key !== 'id' && key !== 'createdAt')\r\n        .map(([key, value]) => {\r\n          if (['capabilities', 'config', 'metadata'].includes(key) && typeof value === 'object') {\r\n            return JSON.stringify(value);\r\n          }\r\n          return value;\r\n        });\r\n      \r\n      values.push(new Date()); // updated_at\r\n      values.push(id);\r\n\r\n      const query = `UPDATE agents SET ${setClause}, updated_at = ? WHERE id = ?`;\r\n      await this.execute(query, values);\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to update agent', { error, agentId: id });\r\n    }\r\n  }\r\n\r\n  // Task operations\r\n  async createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<TaskRecord> {\r\n    const id = `task_${Date.now()}_${nanoid(10)}`;\r\n    const now = new Date();\r\n\r\n    const record: TaskRecord = {\r\n      id,\r\n      ...task,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n\r\n    try {\r\n      const query = `\r\n        INSERT INTO tasks (id, swarm_id, description, priority, strategy, status, max_agents, requirements, metadata, created_at, updated_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `;\r\n      const values = [\r\n        record.id,\r\n        record.swarmId,\r\n        record.description,\r\n        record.priority,\r\n        record.strategy,\r\n        record.status,\r\n        record.maxAgents,\r\n        JSON.stringify(record.requirements),\r\n        JSON.stringify(record.metadata),\r\n        record.createdAt,\r\n        record.updatedAt,\r\n      ];\r\n\r\n      await this.execute(query, values);\r\n      return record;\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to create task', { error, taskId: id });\r\n    }\r\n  }\r\n\r\n  async getTasksBySwarm(swarmId: string): Promise<TaskRecord[]> {\r\n    try {\r\n      const query = 'SELECT * FROM tasks WHERE swarm_id = ? ORDER BY created_at DESC';\r\n      const rows = await this.query(query, [swarmId]);\r\n      \r\n      return rows.map(row => this.mapTaskRow(row));\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to get tasks by swarm', { error, swarmId });\r\n    }\r\n  }\r\n\r\n  async updateTask(id: string, updates: Partial<TaskRecord>): Promise<void> {\r\n    try {\r\n      const setClause = Object.keys(updates)\r\n        .filter(key => key !== 'id' && key !== 'createdAt')\r\n        .map(key => `${this.camelToSnake(key)} = ?`)\r\n        .join(', ');\r\n      \r\n      const values = Object.entries(updates)\r\n        .filter(([key]) => key !== 'id' && key !== 'createdAt')\r\n        .map(([key, value]) => {\r\n          if (['requirements', 'metadata', 'result'].includes(key) && typeof value === 'object') {\r\n            return JSON.stringify(value);\r\n          }\r\n          return value;\r\n        });\r\n      \r\n      values.push(new Date()); // updated_at\r\n      values.push(id);\r\n\r\n      const query = `UPDATE tasks SET ${setClause}, updated_at = ? WHERE id = ?`;\r\n      await this.execute(query, values);\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to update task', { error, taskId: id });\r\n    }\r\n  }\r\n\r\n  // Metrics operations\r\n  async recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<void> {\r\n    const id = `metric_${Date.now()}_${nanoid(8)}`;\r\n    const record = {\r\n      id,\r\n      ...metric,\r\n      timestamp: new Date(),\r\n    };\r\n\r\n    try {\r\n      const query = `\r\n        INSERT INTO performance_metrics (id, swarm_id, agent_id, metric_type, metric_name, metric_value, unit, timestamp, metadata)\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `;\r\n      const values = [\r\n        record.id,\r\n        record.swarmId,\r\n        record.agentId,\r\n        record.metricType,\r\n        record.metricName,\r\n        record.metricValue,\r\n        record.unit,\r\n        record.timestamp,\r\n        JSON.stringify(record.metadata),\r\n      ];\r\n\r\n      await this.execute(query, values);\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to record metric', { error, metricId: id });\r\n    }\r\n  }\r\n\r\n  async getMetrics(filter: {\r\n    swarmId?: string;\r\n    agentId?: string;\r\n    metricType?: string;\r\n    startTime?: Date;\r\n    endTime?: Date;\r\n    limit?: number;\r\n  }): Promise<MetricRecord[]> {\r\n    try {\r\n      let query = 'SELECT * FROM performance_metrics WHERE 1=1';\r\n      const values: any[] = [];\r\n\r\n      if (filter.swarmId) {\r\n        query += ' AND swarm_id = ?';\r\n        values.push(filter.swarmId);\r\n      }\r\n      if (filter.agentId) {\r\n        query += ' AND agent_id = ?';\r\n        values.push(filter.agentId);\r\n      }\r\n      if (filter.metricType) {\r\n        query += ' AND metric_type = ?';\r\n        values.push(filter.metricType);\r\n      }\r\n      if (filter.startTime) {\r\n        query += ' AND timestamp >= ?';\r\n        values.push(filter.startTime);\r\n      }\r\n      if (filter.endTime) {\r\n        query += ' AND timestamp <= ?';\r\n        values.push(filter.endTime);\r\n      }\r\n\r\n      query += ' ORDER BY timestamp DESC';\r\n      \r\n      if (filter.limit) {\r\n        query += ' LIMIT ?';\r\n        values.push(filter.limit);\r\n      }\r\n\r\n      const rows = await this.query(query, values);\r\n      return rows.map(row => this.mapMetricRow(row));\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to get metrics', { error });\r\n    }\r\n  }\r\n\r\n  // Event logging\r\n  async recordEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<void> {\r\n    const id = `event_${Date.now()}_${nanoid(8)}`;\r\n    const record = {\r\n      id,\r\n      ...event,\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      const query = `\r\n        INSERT INTO events (id, swarm_id, agent_id, event_type, event_name, event_data, severity, created_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\r\n      `;\r\n      const values = [\r\n        record.id,\r\n        record.swarmId,\r\n        record.agentId,\r\n        record.eventType,\r\n        record.eventName,\r\n        JSON.stringify(record.eventData),\r\n        record.severity,\r\n        record.createdAt,\r\n      ];\r\n\r\n      await this.execute(query, values);\r\n    } catch (error) {\r\n      // Don't throw for event logging failures, just log the error\r\n      this.logger.error('Failed to record event', { error, event: record });\r\n    }\r\n  }\r\n\r\n  // Health check\r\n  async getHealthStatus(): Promise<{\r\n    healthy: boolean;\r\n    error?: string;\r\n    metrics?: Record<string, number>;\r\n  }> {\r\n    try {\r\n      const query = 'SELECT 1 as test';\r\n      await this.query(query);\r\n      \r\n      // Get basic metrics\r\n      const swarmCount = await this.query('SELECT COUNT(*) as count FROM swarms WHERE status != ?', ['destroyed']);\r\n      const agentCount = await this.query('SELECT COUNT(*) as count FROM agents WHERE status != ?', ['terminated']);\r\n      const activeTaskCount = await this.query('SELECT COUNT(*) as count FROM tasks WHERE status IN (?, ?, ?)', ['pending', 'assigned', 'running']);\r\n\r\n      return {\r\n        healthy: true,\r\n        metrics: {\r\n          totalSwarms: swarmCount[0]?.count || 0,\r\n          totalAgents: agentCount[0]?.count || 0,\r\n          activeTasks: activeTaskCount[0]?.count || 0,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        error: error instanceof Error ? error.message : 'Unknown database error',\r\n      };\r\n    }\r\n  }\r\n\r\n  // Private helper methods\r\n  private async initializeSQLite(): Promise<void> {\r\n    try {\r\n      // Import better-sqlite3 dynamically\r\n      const Database = (await import('better-sqlite3')).default;\r\n      this.db = new Database(this.config.database);\r\n      \r\n      // Enable WAL mode for better concurrency\r\n      this.db.pragma('journal_mode = WAL');\r\n      this.db.pragma('synchronous = NORMAL');\r\n      this.db.pragma('cache_size = 1000');\r\n      this.db.pragma('temp_store = memory');\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to initialize SQLite', { error });\r\n    }\r\n  }\r\n\r\n  private async initializeMySQL(): Promise<void> {\r\n    // MySQL initialization would go here\r\n    throw new DatabaseError('MySQL support not implemented yet');\r\n  }\r\n\r\n  private async initializePostgreSQL(): Promise<void> {\r\n    // PostgreSQL initialization would go here\r\n    throw new DatabaseError('PostgreSQL support not implemented yet');\r\n  }\r\n\r\n  private async runMigrations(): Promise<void> {\r\n    try {\r\n      // Check if migrations table exists\r\n      const migrationQuery = this.config.type === 'sqlite'\r\n        ? \"SELECT name FROM sqlite_master WHERE type='table' AND name='migrations'\"\r\n        : \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'migrations'\";\r\n      \r\n      const migrationTable = await this.query(migrationQuery);\r\n      \r\n      if (migrationTable.length === 0) {\r\n        // Create migrations table and run initial schema\r\n        await this.execute(`\r\n          CREATE TABLE migrations (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            filename VARCHAR(255) NOT NULL,\r\n            executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n          )\r\n        `);\r\n        \r\n        // Run schema creation (simplified for demo)\r\n        await this.createTables();\r\n        \r\n        await this.execute(\r\n          \"INSERT INTO migrations (filename) VALUES (?)\",\r\n          ['001_initial_schema.sql']\r\n        );\r\n      }\r\n    } catch (error) {\r\n      throw new DatabaseError('Failed to run migrations', { error });\r\n    }\r\n  }\r\n\r\n  private async createTables(): Promise<void> {\r\n    const tables = [\r\n      // Swarms table\r\n      `CREATE TABLE IF NOT EXISTS swarms (\r\n        id TEXT PRIMARY KEY,\r\n        name TEXT NOT NULL,\r\n        topology TEXT NOT NULL,\r\n        max_agents INTEGER DEFAULT 8,\r\n        strategy TEXT DEFAULT 'balanced',\r\n        status TEXT DEFAULT 'initializing',\r\n        config TEXT,\r\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        destroyed_at TEXT\r\n      )`,\r\n      \r\n      // Agents table\r\n      `CREATE TABLE IF NOT EXISTS agents (\r\n        id TEXT PRIMARY KEY,\r\n        swarm_id TEXT NOT NULL,\r\n        type TEXT NOT NULL,\r\n        name TEXT,\r\n        status TEXT DEFAULT 'spawning',\r\n        capabilities TEXT,\r\n        config TEXT,\r\n        metadata TEXT,\r\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        terminated_at TEXT,\r\n        FOREIGN KEY (swarm_id) REFERENCES swarms(id)\r\n      )`,\r\n      \r\n      // Tasks table\r\n      `CREATE TABLE IF NOT EXISTS tasks (\r\n        id TEXT PRIMARY KEY,\r\n        swarm_id TEXT NOT NULL,\r\n        description TEXT NOT NULL,\r\n        priority TEXT DEFAULT 'medium',\r\n        strategy TEXT DEFAULT 'adaptive',\r\n        status TEXT DEFAULT 'pending',\r\n        max_agents INTEGER,\r\n        requirements TEXT,\r\n        metadata TEXT,\r\n        result TEXT,\r\n        error_message TEXT,\r\n        assigned_to TEXT,\r\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        started_at TEXT,\r\n        completed_at TEXT,\r\n        FOREIGN KEY (swarm_id) REFERENCES swarms(id)\r\n      )`,\r\n      \r\n      // Performance metrics table\r\n      `CREATE TABLE IF NOT EXISTS performance_metrics (\r\n        id TEXT PRIMARY KEY,\r\n        swarm_id TEXT,\r\n        agent_id TEXT,\r\n        metric_type TEXT NOT NULL,\r\n        metric_name TEXT NOT NULL,\r\n        metric_value REAL NOT NULL,\r\n        unit TEXT,\r\n        timestamp TEXT DEFAULT CURRENT_TIMESTAMP,\r\n        metadata TEXT\r\n      )`,\r\n      \r\n      // Events table\r\n      `CREATE TABLE IF NOT EXISTS events (\r\n        id TEXT PRIMARY KEY,\r\n        swarm_id TEXT,\r\n        agent_id TEXT,\r\n        event_type TEXT NOT NULL,\r\n        event_name TEXT NOT NULL,\r\n        event_data TEXT,\r\n        severity TEXT DEFAULT 'info',\r\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP\r\n      )`,\r\n    ];\r\n\r\n    for (const table of tables) {\r\n      await this.execute(table);\r\n    }\r\n  }\r\n\r\n  private async query(sql: string, params: any[] = []): Promise<any[]> {\r\n    if (this.config.type === 'sqlite') {\r\n      const stmt = this.db.prepare(sql);\r\n      return stmt.all(...params);\r\n    }\r\n    \r\n    // Other database types would be handled here\r\n    throw new DatabaseError('Unsupported database operation');\r\n  }\r\n\r\n  private async execute(sql: string, params: any[] = []): Promise<any> {\r\n    if (this.config.type === 'sqlite') {\r\n      const stmt = this.db.prepare(sql);\r\n      return stmt.run(...params);\r\n    }\r\n    \r\n    // Other database types would be handled here\r\n    throw new DatabaseError('Unsupported database operation');\r\n  }\r\n\r\n  private camelToSnake(str: string): string {\r\n    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\r\n  }\r\n\r\n  private mapSwarmRow(row: any): SwarmRecord {\r\n    return {\r\n      id: row.id,\r\n      name: row.name,\r\n      topology: row.topology,\r\n      maxAgents: row.max_agents,\r\n      strategy: row.strategy,\r\n      status: row.status,\r\n      config: row.config ? JSON.parse(row.config) : undefined,\r\n      createdAt: new Date(row.created_at),\r\n      updatedAt: new Date(row.updated_at),\r\n      destroyedAt: row.destroyed_at ? new Date(row.destroyed_at) : undefined,\r\n    };\r\n  }\r\n\r\n  private mapAgentRow(row: any): AgentRecord {\r\n    return {\r\n      id: row.id,\r\n      swarmId: row.swarm_id,\r\n      type: row.type,\r\n      name: row.name,\r\n      status: row.status,\r\n      capabilities: row.capabilities ? JSON.parse(row.capabilities) : undefined,\r\n      config: row.config ? JSON.parse(row.config) : undefined,\r\n      metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\r\n      createdAt: new Date(row.created_at),\r\n      updatedAt: new Date(row.updated_at),\r\n      terminatedAt: row.terminated_at ? new Date(row.terminated_at) : undefined,\r\n    };\r\n  }\r\n\r\n  private mapTaskRow(row: any): TaskRecord {\r\n    return {\r\n      id: row.id,\r\n      swarmId: row.swarm_id,\r\n      description: row.description,\r\n      priority: row.priority,\r\n      strategy: row.strategy,\r\n      status: row.status,\r\n      maxAgents: row.max_agents,\r\n      requirements: row.requirements ? JSON.parse(row.requirements) : undefined,\r\n      metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\r\n      result: row.result ? JSON.parse(row.result) : undefined,\r\n      errorMessage: row.error_message,\r\n      assignedTo: row.assigned_to,\r\n      createdAt: new Date(row.created_at),\r\n      updatedAt: new Date(row.updated_at),\r\n      startedAt: row.started_at ? new Date(row.started_at) : undefined,\r\n      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,\r\n    };\r\n  }\r\n\r\n  private mapMetricRow(row: any): MetricRecord {\r\n    return {\r\n      id: row.id,\r\n      swarmId: row.swarm_id,\r\n      agentId: row.agent_id,\r\n      metricType: row.metric_type,\r\n      metricName: row.metric_name,\r\n      metricValue: row.metric_value,\r\n      unit: row.unit,\r\n      timestamp: new Date(row.timestamp),\r\n      metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\r\n    };\r\n  }\r\n}"],"names":["DatabaseError","nanoid","DatabaseService","db","initialized","config","logger","initialize","info","type","database","initializeSQLite","initializeMySQL","initializePostgreSQL","runMigrations","error","shutdown","close","end","createSwarm","swarm","id","Date","now","record","createdAt","updatedAt","query","values","name","topology","maxAgents","strategy","status","JSON","stringify","execute","swarmId","getSwarm","rows","length","mapSwarmRow","updateSwarm","updates","setClause","Object","keys","filter","key","map","camelToSnake","join","entries","value","push","deleteSwarm","listSwarms","row","createAgent","agent","capabilities","metadata","agentId","getAgentsBySwarm","mapAgentRow","updateAgent","includes","createTask","task","description","priority","requirements","taskId","getTasksBySwarm","mapTaskRow","updateTask","recordMetric","metric","timestamp","metricType","metricName","metricValue","unit","metricId","getMetrics","startTime","endTime","limit","mapMetricRow","recordEvent","event","eventType","eventName","eventData","severity","getHealthStatus","swarmCount","agentCount","activeTaskCount","healthy","metrics","totalSwarms","count","totalAgents","activeTasks","Error","message","Database","default","pragma","migrationQuery","migrationTable","createTables","tables","table","sql","params","stmt","prepare","all","run","str","replace","letter","toLowerCase","max_agents","parse","undefined","created_at","updated_at","destroyedAt","destroyed_at","swarm_id","terminatedAt","terminated_at","result","errorMessage","error_message","assignedTo","assigned_to","startedAt","started_at","completedAt","completed_at","agent_id","metric_type","metric_name","metric_value"],"mappings":"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"}