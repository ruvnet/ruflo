{
  "version": 3,
  "sources": ["../../src/agents/agent-registry.ts"],
  "sourcesContent": ["/**\n * Agent Registry with Memory Integration\n * Provides persistent storage and coordination for agent management\n */\n\nimport type { DistributedMemorySystem } from '../memory/distributed-memory.js';\nimport type { AgentState, AgentId, AgentType, AgentStatus } from '../swarm/types.js';\nimport { EventEmitter } from 'node:events';\n\nexport interface AgentRegistryEntry {\n  agent: AgentState;\n  createdAt: Date;\n  lastUpdated: Date;\n  tags: string[];\n  metadata: Record<string, any>;\n}\n\nexport interface AgentQuery {\n  type?: AgentType;\n  status?: AgentStatus;\n  tags?: string[];\n  healthThreshold?: number;\n  namePattern?: string;\n  createdAfter?: Date;\n  lastActiveAfter?: Date;\n}\n\nexport interface AgentStatistics {\n  totalAgents: number;\n  byType: Record<AgentType, number>;\n  byStatus: Record<AgentStatus, number>;\n  averageHealth: number;\n  activeAgents: number;\n  totalUptime: number;\n  tasksCompleted: number;\n  successRate: number;\n}\n\n/**\n * Centralized agent registry with persistent storage\n */\nexport class AgentRegistry extends EventEmitter {\n  private memory: DistributedMemorySystem;\n  private namespace: string;\n  private cache = new Map<string, AgentRegistryEntry>();\n  private cacheExpiry = 60000; // 1 minute\n  private lastCacheUpdate = 0;\n\n  constructor(memory: DistributedMemorySystem, namespace: string = 'agents') {\n    super();\n    this.memory = memory;\n    this.namespace = namespace;\n  }\n\n  async initialize(): Promise<void> {\n    await this.loadFromMemory();\n    this.emit('registry:initialized');\n  }\n\n  /**\n   * Register a new agent in the registry\n   */\n  async registerAgent(agent: AgentState, tags: string[] = []): Promise<void> {\n    const entry: AgentRegistryEntry = {\n      agent,\n      createdAt: new Date(),\n      lastUpdated: new Date(),\n      tags: [...tags, agent.type, agent.status],\n      metadata: {\n        registeredBy: 'agent-manager',\n        version: '1.0.0',\n      },\n    };\n\n    // Store in memory\n    const key = this.getAgentKey(agent.id.id);\n    await this.memory.store(key, entry, {\n      type: 'agent-registry',\n      tags: entry.tags,\n      partition: this.namespace,\n    });\n\n    // Update cache\n    this.cache.set(agent.id.id, entry);\n\n    this.emit('agent:registered', { agentId: agent.id.id, agent });\n  }\n\n  /**\n   * Update agent information in registry\n   */\n  async updateAgent(agentId: string, updates: Partial<AgentState>): Promise<void> {\n    const entry = await this.getAgentEntry(agentId);\n    if (!entry) {\n      throw new Error(`Agent ${agentId} not found in registry`);\n    }\n\n    // Merge updates\n    entry.agent = { ...entry.agent, ...updates };\n    entry.lastUpdated = new Date();\n    entry.tags = [\n      entry.agent.type,\n      entry.agent.status,\n      ...entry.tags.filter((t) => t !== entry.agent.type && t !== entry.agent.status),\n    ];\n\n    // Store updated entry\n    const key = this.getAgentKey(agentId);\n    await this.memory.store(key, entry, {\n      type: 'agent-registry',\n      tags: entry.tags,\n      partition: this.namespace,\n    });\n\n    // Update cache\n    this.cache.set(agentId, entry);\n\n    this.emit('agent:updated', { agentId, agent: entry.agent });\n  }\n\n  /**\n   * Remove agent from registry\n   */\n  async unregisterAgent(agentId: string, preserveHistory: boolean = true): Promise<void> {\n    const entry = await this.getAgentEntry(agentId);\n    if (!entry) {\n      return; // Already removed\n    }\n\n    if (preserveHistory) {\n      // Move to archived partition\n      const archiveKey = this.getArchiveKey(agentId);\n      await this.memory.store(\n        archiveKey,\n        {\n          ...entry,\n          archivedAt: new Date(),\n          reason: 'agent_removed',\n        },\n        {\n          type: 'agent-archive',\n          tags: [...entry.tags, 'archived'],\n          partition: 'archived',\n        },\n      );\n    }\n\n    // Remove from active registry\n    const key = this.getAgentKey(agentId);\n    await this.memory.deleteEntry(key);\n\n    // Remove from cache\n    this.cache.delete(agentId);\n\n    this.emit('agent:unregistered', { agentId, preserved: preserveHistory });\n  }\n\n  /**\n   * Get agent by ID\n   */\n  async getAgent(agentId: string): Promise<AgentState | null> {\n    const entry = await this.getAgentEntry(agentId);\n    return entry?.agent || null;\n  }\n\n  /**\n   * Get agent entry with metadata\n   */\n  async getAgentEntry(agentId: string): Promise<AgentRegistryEntry | null> {\n    // Check cache first\n    if (this.cache.has(agentId) && this.isCacheValid()) {\n      return this.cache.get(agentId) || null;\n    }\n\n    // Load from memory\n    const key = this.getAgentKey(agentId);\n    const memoryEntry = await this.memory.retrieve(key);\n\n    if (memoryEntry && memoryEntry.value) {\n      // Convert MemoryEntry to AgentRegistryEntry\n      const registryEntry: AgentRegistryEntry = memoryEntry.value as AgentRegistryEntry;\n      this.cache.set(agentId, registryEntry);\n      return registryEntry;\n    }\n\n    return null;\n  }\n\n  /**\n   * Query agents by criteria\n   */\n  async queryAgents(query: AgentQuery = {}): Promise<AgentState[]> {\n    await this.refreshCacheIfNeeded();\n\n    let agents = Array.from(this.cache.values()).map((entry) => entry.agent);\n\n    // Apply filters\n    if (query.type) {\n      agents = agents.filter((agent) => agent.type === query.type);\n    }\n\n    if (query.status) {\n      agents = agents.filter((agent) => agent.status === query.status);\n    }\n\n    if (query.healthThreshold !== undefined) {\n      agents = agents.filter((agent) => agent.health >= query.healthThreshold!);\n    }\n\n    if (query.namePattern) {\n      const pattern = new RegExp(query.namePattern, 'i');\n      agents = agents.filter((agent) => pattern.test(agent.name));\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      const entries = Array.from(this.cache.values());\n      const matchingEntries = entries.filter((entry) =>\n        query.tags!.some((tag) => entry.tags.includes(tag)),\n      );\n      agents = matchingEntries.map((entry) => entry.agent);\n    }\n\n    if (query.createdAfter) {\n      const entries = Array.from(this.cache.values());\n      const matchingEntries = entries.filter((entry) => entry.createdAt >= query.createdAfter!);\n      agents = matchingEntries.map((entry) => entry.agent);\n    }\n\n    if (query.lastActiveAfter) {\n      agents = agents.filter((agent) => agent.metrics.lastActivity >= query.lastActiveAfter!);\n    }\n\n    return agents;\n  }\n\n  /**\n   * Get all registered agents\n   */\n  async getAllAgents(): Promise<AgentState[]> {\n    return this.queryAgents();\n  }\n\n  /**\n   * Get agents by type\n   */\n  async getAgentsByType(type: AgentType): Promise<AgentState[]> {\n    return this.queryAgents({ type });\n  }\n\n  /**\n   * Get agents by status\n   */\n  async getAgentsByStatus(status: AgentStatus): Promise<AgentState[]> {\n    return this.queryAgents({ status });\n  }\n\n  /**\n   * Get healthy agents\n   */\n  async getHealthyAgents(threshold: number = 0.7): Promise<AgentState[]> {\n    return this.queryAgents({ healthThreshold: threshold });\n  }\n\n  /**\n   * Get registry statistics\n   */\n  async getStatistics(): Promise<AgentStatistics> {\n    const agents = await this.getAllAgents();\n\n    const stats: AgentStatistics = {\n      totalAgents: agents.length,\n      byType: {} as Record<AgentType, number>,\n      byStatus: {} as Record<AgentStatus, number>,\n      averageHealth: 0,\n      activeAgents: 0,\n      totalUptime: 0,\n      tasksCompleted: 0,\n      successRate: 0,\n    };\n\n    if (agents.length === 0) {\n      return stats;\n    }\n\n    // Count by type and status\n    for (const agent of agents) {\n      stats.byType[agent.type] = (stats.byType[agent.type] || 0) + 1;\n      stats.byStatus[agent.status] = (stats.byStatus[agent.status] || 0) + 1;\n\n      if (agent.status === 'idle' || agent.status === 'busy') {\n        stats.activeAgents++;\n      }\n\n      stats.totalUptime += agent.metrics.totalUptime;\n      stats.tasksCompleted += agent.metrics.tasksCompleted;\n    }\n\n    // Calculate averages\n    stats.averageHealth = agents.reduce((sum, agent) => sum + agent.health, 0) / agents.length;\n\n    const totalTasks = agents.reduce(\n      (sum, agent) => sum + agent.metrics.tasksCompleted + agent.metrics.tasksFailed,\n      0,\n    );\n\n    if (totalTasks > 0) {\n      stats.successRate = stats.tasksCompleted / totalTasks;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Search agents by capabilities\n   */\n  async searchByCapabilities(requiredCapabilities: string[]): Promise<AgentState[]> {\n    const agents = await this.getAllAgents();\n\n    return agents.filter((agent) => {\n      const capabilities = [\n        ...agent.capabilities.languages,\n        ...agent.capabilities.frameworks,\n        ...agent.capabilities.domains,\n        ...agent.capabilities.tools,\n      ];\n\n      return requiredCapabilities.every((required) =>\n        capabilities.some((cap) => cap.toLowerCase().includes(required.toLowerCase())),\n      );\n    });\n  }\n\n  /**\n   * Find best agent for task\n   */\n  async findBestAgent(\n    taskType: string,\n    requiredCapabilities: string[] = [],\n    preferredAgent?: string,\n  ): Promise<AgentState | null> {\n    let candidates = await this.getHealthyAgents(0.5);\n\n    // Filter by capabilities if specified\n    if (requiredCapabilities.length > 0) {\n      candidates = await this.searchByCapabilities(requiredCapabilities);\n    }\n\n    // Prefer specific agent if available and healthy\n    if (preferredAgent) {\n      const preferred = candidates.find(\n        (agent) => agent.id.id === preferredAgent || agent.name === preferredAgent,\n      );\n      if (preferred) return preferred;\n    }\n\n    // Filter by availability\n    candidates = candidates.filter(\n      (agent) =>\n        agent.status === 'idle' &&\n        agent.workload < 0.8 &&\n        agent.capabilities.maxConcurrentTasks > 0,\n    );\n\n    if (candidates.length === 0) return null;\n\n    // Score candidates\n    const scored = candidates.map((agent) => ({\n      agent,\n      score: this.calculateAgentScore(agent, taskType, requiredCapabilities),\n    }));\n\n    // Sort by score (highest first)\n    scored.sort((a, b) => b.score - a.score);\n\n    return scored[0]?.agent || null;\n  }\n\n  /**\n   * Store agent coordination data\n   */\n  async storeCoordinationData(agentId: string, data: any): Promise<void> {\n    const key = `coordination:${agentId}`;\n    await this.memory.store(\n      key,\n      {\n        agentId,\n        data,\n        timestamp: new Date(),\n      },\n      {\n        type: 'agent-coordination',\n        tags: ['coordination', agentId],\n        partition: this.namespace,\n      },\n    );\n  }\n\n  /**\n   * Retrieve agent coordination data\n   */\n  async getCoordinationData(agentId: string): Promise<any> {\n    const key = `coordination:${agentId}`;\n    const result = await this.memory.retrieve(key);\n    return result?.value || null;\n  }\n\n  // === PRIVATE METHODS ===\n\n  private async loadFromMemory(): Promise<void> {\n    try {\n      const entries = await this.memory.query({\n        type: 'state' as const,\n        namespace: this.namespace,\n      });\n\n      this.cache.clear();\n      for (const entry of entries) {\n        if (entry.value && entry.value.agent) {\n          this.cache.set(entry.value.agent.id.id, entry.value);\n        }\n      }\n\n      this.lastCacheUpdate = Date.now();\n    } catch (error) {\n      console.warn('Failed to load agent registry from memory:', error);\n    }\n  }\n\n  private async refreshCacheIfNeeded(): Promise<void> {\n    if (!this.isCacheValid()) {\n      await this.loadFromMemory();\n    }\n  }\n\n  private isCacheValid(): boolean {\n    return Date.now() - this.lastCacheUpdate < this.cacheExpiry;\n  }\n\n  private getAgentKey(agentId: string): string {\n    return `agent:${agentId}`;\n  }\n\n  private getArchiveKey(agentId: string): string {\n    return `archived:${agentId}:${Date.now()}`;\n  }\n\n  private calculateAgentScore(\n    agent: AgentState,\n    taskType: string,\n    requiredCapabilities: string[],\n  ): number {\n    let score = 0;\n\n    // Base health score (0-40 points)\n    score += agent.health * 40;\n\n    // Success rate score (0-30 points)\n    score += agent.metrics.successRate * 30;\n\n    // Availability score (0-20 points)\n    const availability = 1 - agent.workload;\n    score += availability * 20;\n\n    // Capability match score (0-10 points)\n    if (requiredCapabilities.length > 0) {\n      const agentCaps = [\n        ...agent.capabilities.languages,\n        ...agent.capabilities.frameworks,\n        ...agent.capabilities.domains,\n        ...agent.capabilities.tools,\n      ];\n\n      const matches = requiredCapabilities.filter((required) =>\n        agentCaps.some((cap) => cap.toLowerCase().includes(required.toLowerCase())),\n      );\n\n      score += (matches.length / requiredCapabilities.length) * 10;\n    }\n\n    return score;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
