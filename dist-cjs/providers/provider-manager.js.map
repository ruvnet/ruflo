{
  "version": 3,
  "sources": ["../../src/providers/provider-manager.ts"],
  "sourcesContent": ["/**\n * Provider Manager - Central orchestration for multi-LLM providers\n * Handles provider selection, fallback, load balancing, and cost optimization\n */\n\nimport { EventEmitter } from 'events';\nimport { ILogger } from '../core/logger.js';\nimport { ConfigManager } from '../config/config-manager.js';\nimport {\n  ILLMProvider,\n  LLMProvider,\n  LLMProviderConfig,\n  LLMRequest,\n  LLMResponse,\n  LLMStreamEvent,\n  LLMModel,\n  FallbackStrategy,\n  FallbackRule,\n  LoadBalancer,\n  ProviderMetrics,\n  CostOptimizer,\n  CostConstraints,\n  OptimizationResult,\n  RateLimiter,\n  ProviderMonitor,\n  CacheConfig,\n  LLMProviderError,\n  RateLimitError,\n  isRateLimitError,\n} from './types.js';\n\n// Import providers\nimport { AnthropicProvider } from './anthropic-provider.js';\nimport { OpenAIProvider } from './openai-provider.js';\nimport { GoogleProvider } from './google-provider.js';\nimport { CohereProvider } from './cohere-provider.js';\nimport { OllamaProvider } from './ollama-provider.js';\n\nexport interface ProviderManagerConfig {\n  providers: Record<LLMProvider, LLMProviderConfig>;\n  defaultProvider: LLMProvider;\n  fallbackStrategy?: FallbackStrategy;\n  loadBalancing?: {\n    enabled: boolean;\n    strategy: 'round-robin' | 'least-loaded' | 'latency-based' | 'cost-based';\n  };\n  costOptimization?: {\n    enabled: boolean;\n    maxCostPerRequest?: number;\n    preferredProviders?: LLMProvider[];\n  };\n  caching?: CacheConfig;\n  monitoring?: {\n    enabled: boolean;\n    metricsInterval: number;\n  };\n}\n\nexport class ProviderManager extends EventEmitter {\n  private providers: Map<LLMProvider, ILLMProvider> = new Map();\n  private logger: ILogger;\n  private config: ProviderManagerConfig;\n  private requestCount: Map<LLMProvider, number> = new Map();\n  private lastUsed: Map<LLMProvider, Date> = new Map();\n  private providerMetrics: Map<LLMProvider, ProviderMetrics[]> = new Map();\n  private cache: Map<string, { response: LLMResponse; timestamp: Date }> = new Map();\n  private currentProviderIndex = 0;\n\n  constructor(logger: ILogger, configManager: ConfigManager, config: ProviderManagerConfig) {\n    super();\n    this.logger = logger;\n    this.config = config;\n\n    // Initialize providers\n    this.initializeProviders();\n\n    // Start monitoring if enabled\n    if (config.monitoring?.enabled) {\n      this.startMonitoring();\n    }\n  }\n\n  /**\n   * Initialize all configured providers\n   */\n  private async initializeProviders(): Promise<void> {\n    for (const [providerName, providerConfig] of Object.entries(this.config.providers)) {\n      try {\n        const provider = await this.createProvider(providerName as LLMProvider, providerConfig);\n        if (provider) {\n          this.providers.set(providerName as LLMProvider, provider);\n          this.requestCount.set(providerName as LLMProvider, 0);\n          this.logger.info(`Initialized ${providerName} provider`);\n        }\n      } catch (error) {\n        this.logger.error(`Failed to initialize ${providerName} provider`, error);\n      }\n    }\n\n    if (this.providers.size === 0) {\n      throw new Error('No providers could be initialized');\n    }\n  }\n\n  /**\n   * Create a provider instance\n   */\n  private async createProvider(name: LLMProvider, config: LLMProviderConfig): Promise<ILLMProvider | null> {\n    const providerOptions = {\n      logger: this.logger,\n      config,\n    };\n\n    try {\n      let provider: ILLMProvider;\n\n      switch (name) {\n        case 'anthropic':\n          provider = new AnthropicProvider(providerOptions);\n          break;\n        case 'openai':\n          provider = new OpenAIProvider(providerOptions);\n          break;\n        case 'google':\n          provider = new GoogleProvider(providerOptions);\n          break;\n        case 'cohere':\n          provider = new CohereProvider(providerOptions);\n          break;\n        case 'ollama':\n          provider = new OllamaProvider(providerOptions);\n          break;\n        default:\n          this.logger.warn(`Unknown provider: ${name}`);\n          return null;\n      }\n\n      await provider.initialize();\n      \n      // Set up event listeners\n      provider.on('response', (data) => this.handleProviderResponse(name, data));\n      provider.on('error', (error) => this.handleProviderError(name, error));\n      provider.on('health_check', (result) => this.handleHealthCheck(name, result));\n\n      return provider;\n    } catch (error) {\n      this.logger.error(`Failed to create ${name} provider`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Complete a request using the appropriate provider\n   */\n  async complete(request: LLMRequest): Promise<LLMResponse> {\n    // Check cache first\n    if (this.config.caching?.enabled) {\n      const cached = this.checkCache(request);\n      if (cached) {\n        this.logger.debug('Returning cached response');\n        return cached;\n      }\n    }\n\n    // Select provider based on strategy\n    const provider = await this.selectProvider(request);\n    \n    try {\n      const response = await provider.complete(request);\n      \n      // Cache successful response\n      if (this.config.caching?.enabled) {\n        this.cacheResponse(request, response);\n      }\n      \n      // Update metrics\n      this.updateProviderMetrics(provider.name, {\n        success: true,\n        latency: response.latency || 0,\n        cost: response.cost?.totalCost || 0,\n      });\n      \n      return response;\n    } catch (error) {\n      // Handle error and potentially fallback\n      return this.handleRequestError(error, request, provider);\n    }\n  }\n\n  /**\n   * Stream complete a request\n   */\n  async *streamComplete(request: LLMRequest): AsyncIterable<LLMStreamEvent> {\n    const provider = await this.selectProvider(request);\n    \n    try {\n      yield* provider.streamComplete(request);\n      \n      // Update metrics\n      this.updateProviderMetrics(provider.name, {\n        success: true,\n        latency: 0, // Will be updated by stream events\n        cost: 0, // Will be updated by stream events\n      });\n    } catch (error) {\n      // Handle error and potentially fallback\n      const fallbackProvider = await this.getFallbackProvider(error, provider);\n      if (fallbackProvider) {\n        this.logger.info(`Falling back to ${fallbackProvider.name} provider`);\n        yield* fallbackProvider.streamComplete(request);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Select the best provider for a request\n   */\n  private async selectProvider(request: LLMRequest): Promise<ILLMProvider> {\n    // If specific provider requested\n    if (request.providerOptions?.preferredProvider) {\n      const provider = this.providers.get(request.providerOptions.preferredProvider);\n      if (provider && this.isProviderAvailable(provider)) {\n        return provider;\n      }\n    }\n\n    // Cost optimization\n    if (this.config.costOptimization?.enabled && request.costConstraints) {\n      const optimized = await this.selectOptimalProvider(request);\n      if (optimized) {\n        return optimized;\n      }\n    }\n\n    // Load balancing\n    if (this.config.loadBalancing?.enabled) {\n      return this.selectLoadBalancedProvider();\n    }\n\n    // Default provider\n    const defaultProvider = this.providers.get(this.config.defaultProvider);\n    if (defaultProvider && this.isProviderAvailable(defaultProvider)) {\n      return defaultProvider;\n    }\n\n    // First available provider\n    for (const provider of this.providers.values()) {\n      if (this.isProviderAvailable(provider)) {\n        return provider;\n      }\n    }\n\n    throw new Error('No available providers');\n  }\n\n  /**\n   * Select provider based on cost optimization\n   */\n  private async selectOptimalProvider(request: LLMRequest): Promise<ILLMProvider | null> {\n    let bestProvider: ILLMProvider | null = null;\n    let bestCost = Infinity;\n\n    for (const provider of this.providers.values()) {\n      if (!this.isProviderAvailable(provider)) continue;\n\n      try {\n        const estimate = await provider.estimateCost(request);\n        \n        if (estimate.estimatedCost.total < bestCost &&\n            (!request.costConstraints?.maxCostPerRequest || \n             estimate.estimatedCost.total <= request.costConstraints.maxCostPerRequest)) {\n          bestCost = estimate.estimatedCost.total;\n          bestProvider = provider;\n        }\n      } catch (error) {\n        this.logger.warn(`Failed to estimate cost for ${provider.name}`, error);\n      }\n    }\n\n    return bestProvider;\n  }\n\n  /**\n   * Select provider using load balancing\n   */\n  private selectLoadBalancedProvider(): ILLMProvider {\n    const availableProviders = Array.from(this.providers.values()).filter(p => \n      this.isProviderAvailable(p)\n    );\n\n    if (availableProviders.length === 0) {\n      throw new Error('No available providers');\n    }\n\n    switch (this.config.loadBalancing?.strategy) {\n      case 'round-robin':\n        return this.roundRobinSelect(availableProviders);\n        \n      case 'least-loaded':\n        return this.leastLoadedSelect(availableProviders);\n        \n      case 'latency-based':\n        return this.latencyBasedSelect(availableProviders);\n        \n      case 'cost-based':\n        return this.costBasedSelect(availableProviders);\n        \n      default:\n        return availableProviders[0];\n    }\n  }\n\n  /**\n   * Round-robin provider selection\n   */\n  private roundRobinSelect(providers: ILLMProvider[]): ILLMProvider {\n    const provider = providers[this.currentProviderIndex % providers.length];\n    this.currentProviderIndex++;\n    return provider;\n  }\n\n  /**\n   * Select least loaded provider\n   */\n  private leastLoadedSelect(providers: ILLMProvider[]): ILLMProvider {\n    let minLoad = Infinity;\n    let selectedProvider = providers[0];\n\n    for (const provider of providers) {\n      const status = provider.getStatus();\n      if (status.currentLoad < minLoad) {\n        minLoad = status.currentLoad;\n        selectedProvider = provider;\n      }\n    }\n\n    return selectedProvider;\n  }\n\n  /**\n   * Select provider with lowest latency\n   */\n  private latencyBasedSelect(providers: ILLMProvider[]): ILLMProvider {\n    let minLatency = Infinity;\n    let selectedProvider = providers[0];\n\n    for (const provider of providers) {\n      const metrics = this.providerMetrics.get(provider.name);\n      if (metrics && metrics.length > 0) {\n        const avgLatency = metrics.reduce((sum, m) => sum + m.latency, 0) / metrics.length;\n        if (avgLatency < minLatency) {\n          minLatency = avgLatency;\n          selectedProvider = provider;\n        }\n      }\n    }\n\n    return selectedProvider;\n  }\n\n  /**\n   * Select provider with lowest cost\n   */\n  private costBasedSelect(providers: ILLMProvider[]): ILLMProvider {\n    let minCost = Infinity;\n    let selectedProvider = providers[0];\n\n    for (const provider of providers) {\n      const metrics = this.providerMetrics.get(provider.name);\n      if (metrics && metrics.length > 0) {\n        const avgCost = metrics.reduce((sum, m) => sum + m.cost, 0) / metrics.length;\n        if (avgCost < minCost) {\n          minCost = avgCost;\n          selectedProvider = provider;\n        }\n      }\n    }\n\n    return selectedProvider;\n  }\n\n  /**\n   * Check if provider is available\n   */\n  private isProviderAvailable(provider: ILLMProvider): boolean {\n    const status = provider.getStatus();\n    return status.available;\n  }\n\n  /**\n   * Handle request error with fallback\n   */\n  private async handleRequestError(\n    error: unknown,\n    request: LLMRequest,\n    failedProvider: ILLMProvider\n  ): Promise<LLMResponse> {\n    this.logger.error(`Provider ${failedProvider.name} failed`, error);\n    \n    // Update metrics\n    this.updateProviderMetrics(failedProvider.name, {\n      success: false,\n      latency: 0,\n      cost: 0,\n    });\n\n    // Try fallback\n    const fallbackProvider = await this.getFallbackProvider(error, failedProvider);\n    if (fallbackProvider) {\n      this.logger.info(`Falling back to ${fallbackProvider.name} provider`);\n      return fallbackProvider.complete(request);\n    }\n\n    throw error;\n  }\n\n  /**\n   * Get fallback provider based on error\n   */\n  private async getFallbackProvider(\n    error: unknown,\n    failedProvider: ILLMProvider\n  ): Promise<ILLMProvider | null> {\n    if (!this.config.fallbackStrategy?.enabled) {\n      return null;\n    }\n\n    const errorCondition = this.getErrorCondition(error);\n    const fallbackRule = this.config.fallbackStrategy.rules.find(rule => \n      rule.condition === errorCondition\n    );\n\n    if (!fallbackRule) {\n      return null;\n    }\n\n    // Find first available fallback provider\n    for (const providerName of fallbackRule.fallbackProviders) {\n      const provider = this.providers.get(providerName);\n      if (provider && provider !== failedProvider && this.isProviderAvailable(provider)) {\n        return provider;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine error condition for fallback\n   */\n  private getErrorCondition(error: unknown): FallbackRule['condition'] {\n    if (isRateLimitError(error)) {\n      return 'rate_limit';\n    }\n    \n    if (error instanceof LLMProviderError) {\n      if (error.statusCode === 503) {\n        return 'unavailable';\n      }\n      if (error.code === 'TIMEOUT') {\n        return 'timeout';\n      }\n    }\n    \n    return 'error';\n  }\n\n  /**\n   * Cache management\n   */\n  private checkCache(request: LLMRequest): LLMResponse | null {\n    const cacheKey = this.generateCacheKey(request);\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached) {\n      const age = Date.now() - cached.timestamp.getTime();\n      if (age < (this.config.caching?.ttl || 3600) * 1000) {\n        return cached.response;\n      }\n      // Remove expired entry\n      this.cache.delete(cacheKey);\n    }\n    \n    return null;\n  }\n\n  private cacheResponse(request: LLMRequest, response: LLMResponse): void {\n    const cacheKey = this.generateCacheKey(request);\n    this.cache.set(cacheKey, {\n      response,\n      timestamp: new Date(),\n    });\n    \n    // Cleanup old cache entries\n    if (this.cache.size > 1000) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n  }\n\n  private generateCacheKey(request: LLMRequest): string {\n    return JSON.stringify({\n      model: request.model,\n      messages: request.messages,\n      temperature: request.temperature,\n      maxTokens: request.maxTokens,\n    });\n  }\n\n  /**\n   * Update provider metrics\n   */\n  private updateProviderMetrics(\n    provider: LLMProvider,\n    metrics: { success: boolean; latency: number; cost: number }\n  ): void {\n    const count = this.requestCount.get(provider) || 0;\n    this.requestCount.set(provider, count + 1);\n    this.lastUsed.set(provider, new Date());\n\n    const providerMetricsList = this.providerMetrics.get(provider) || [];\n    const errorRate = metrics.success ? 0 : 1;\n    const successRate = metrics.success ? 1 : 0;\n\n    providerMetricsList.push({\n      provider,\n      timestamp: new Date(),\n      latency: metrics.latency,\n      errorRate,\n      successRate,\n      load: this.providers.get(provider)?.getStatus().currentLoad || 0,\n      cost: metrics.cost,\n      availability: this.providers.get(provider)?.getStatus().available ? 1 : 0,\n    });\n\n    // Keep only recent metrics (last 100)\n    if (providerMetricsList.length > 100) {\n      providerMetricsList.shift();\n    }\n\n    this.providerMetrics.set(provider, providerMetricsList);\n  }\n\n  /**\n   * Event handlers\n   */\n  private handleProviderResponse(provider: LLMProvider, data: any): void {\n    this.emit('provider_response', { provider, ...data });\n  }\n\n  private handleProviderError(provider: LLMProvider, error: any): void {\n    this.emit('provider_error', { provider, error });\n  }\n\n  private handleHealthCheck(provider: LLMProvider, result: any): void {\n    this.emit('health_check', { provider, result });\n  }\n\n  /**\n   * Start monitoring\n   */\n  private startMonitoring(): void {\n    setInterval(() => {\n      this.emitMetrics();\n    }, this.config.monitoring?.metricsInterval || 60000);\n  }\n\n  /**\n   * Emit aggregated metrics\n   */\n  private emitMetrics(): void {\n    const metrics = {\n      providers: {} as Record<LLMProvider, any>,\n      totalRequests: 0,\n      totalCost: 0,\n      averageLatency: 0,\n    };\n\n    for (const [provider, count] of this.requestCount.entries()) {\n      const providerMetricsList = this.providerMetrics.get(provider) || [];\n      const avgLatency = providerMetricsList.length > 0\n        ? providerMetricsList.reduce((sum, m) => sum + m.latency, 0) / providerMetricsList.length\n        : 0;\n      const totalCost = providerMetricsList.reduce((sum, m) => sum + m.cost, 0);\n\n      metrics.providers[provider] = {\n        requests: count,\n        averageLatency: avgLatency,\n        totalCost,\n        lastUsed: this.lastUsed.get(provider),\n        available: this.providers.get(provider)?.getStatus().available,\n      };\n\n      metrics.totalRequests += count;\n      metrics.totalCost += totalCost;\n    }\n\n    if (metrics.totalRequests > 0) {\n      let totalLatency = 0;\n      let latencyCount = 0;\n      \n      for (const providerMetricsList of this.providerMetrics.values()) {\n        for (const metric of providerMetricsList) {\n          totalLatency += metric.latency;\n          latencyCount++;\n        }\n      }\n      \n      metrics.averageLatency = latencyCount > 0 ? totalLatency / latencyCount : 0;\n    }\n\n    this.emit('metrics', metrics);\n  }\n\n  /**\n   * Get available providers\n   */\n  getAvailableProviders(): LLMProvider[] {\n    return Array.from(this.providers.keys()).filter(name => {\n      const provider = this.providers.get(name);\n      return provider && this.isProviderAvailable(provider);\n    });\n  }\n\n  /**\n   * Get provider by name\n   */\n  getProvider(name: LLMProvider): ILLMProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  /**\n   * Get all providers\n   */\n  getAllProviders(): Map<LLMProvider, ILLMProvider> {\n    return new Map(this.providers);\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    for (const provider of this.providers.values()) {\n      provider.destroy();\n    }\n    \n    this.providers.clear();\n    this.cache.clear();\n    this.providerMetrics.clear();\n    this.removeAllListeners();\n  }\n}"],
  "mappings": "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",
  "names": []
}
