{"version":3,"sources":["../../../src/hive-mind/memory.js"],"sourcesContent":["/**\r\n * Hive Mind Collective Memory System\r\n * \r\n * Provides distributed, persistent memory with intelligent caching,\r\n * pattern recognition, and cross-agent knowledge sharing\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport { generateId } from '../utils/helpers.js';\r\nimport fs from 'node:fs/promises';\r\nimport path from 'node:path';\r\n\r\nexport class CollectiveMemory extends EventEmitter {\r\n  constructor(config = {}) {\r\n    super();\r\n    \r\n    this.config = {\r\n      persistenceDir: config.persistenceDir || './data/hive-memory',\r\n      maxMemorySize: config.maxMemorySize || 100 * 1024 * 1024, // 100MB\r\n      compressionThreshold: config.compressionThreshold || 10 * 1024, // 10KB\r\n      syncInterval: config.syncInterval || 30000, // 30 seconds\r\n      defaultTTL: config.defaultTTL || 7 * 24 * 60 * 60 * 1000, // 7 days\r\n      maxCacheSize: config.maxCacheSize || 1000,\r\n      enableCompression: config.enableCompression !== false,\r\n      enablePatternDetection: config.enablePatternDetection !== false,\r\n      shardCount: config.shardCount || 16,\r\n      ...config\r\n    };\r\n    \r\n    // Memory storage\r\n    this.memory = new Map(); // In-memory cache\r\n    this.memoryIndex = new Map(); // Search index\r\n    this.accessLog = new Map(); // Access patterns\r\n    this.shards = new Map(); // Distributed shards\r\n    \r\n    // Pattern detection\r\n    this.patterns = new Map();\r\n    this.relationships = new Map(); // Key relationships\r\n    this.hotKeys = new Set();\r\n    this.coldKeys = new Set();\r\n    \r\n    // Persistence\r\n    this.persistenceQueue = [];\r\n    this.lastSync = 0;\r\n    this.isDirty = false;\r\n    \r\n    // Statistics\r\n    this.stats = {\r\n      totalKeys: 0,\r\n      totalSize: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      patternDetections: 0,\r\n      compressionSaved: 0,\r\n      lastCleanup: 0\r\n    };\r\n    \r\n    this.initialized = false;\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * Initialize the memory system\r\n   */\r\n  async init() {\r\n    try {\r\n      // Create persistence directory\r\n      await fs.mkdir(this.config.persistenceDir, { recursive: true });\r\n      \r\n      // Load existing memory\r\n      await this.loadFromDisk();\r\n      \r\n      // Initialize shards\r\n      this.initializeShards();\r\n      \r\n      // Start background tasks\r\n      this.startBackgroundTasks();\r\n      \r\n      this.initialized = true;\r\n      this.emit('initialized');\r\n      \r\n      console.log(`Collective memory initialized with ${this.memory.size} entries`);\r\n    } catch (error) {\r\n      console.error('Failed to initialize collective memory:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize distributed shards\r\n   */\r\n  initializeShards() {\r\n    for (let i = 0; i < this.config.shardCount; i++) {\r\n      this.shards.set(i, {\r\n        id: i,\r\n        keys: new Set(),\r\n        size: 0,\r\n        lastAccess: Date.now(),\r\n        hotness: 0\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get shard for a key\r\n   */\r\n  getShardForKey(key) {\r\n    const hash = this.hashKey(key);\r\n    return hash % this.config.shardCount;\r\n  }\r\n\r\n  /**\r\n   * Simple hash function for key distribution\r\n   */\r\n  hashKey(key) {\r\n    let hash = 0;\r\n    for (let i = 0; i < key.length; i++) {\r\n      const char = key.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32bit integer\r\n    }\r\n    return Math.abs(hash);\r\n  }\r\n\r\n  /**\r\n   * Store data in collective memory\r\n   */\r\n  async store(key, value, options = {}) {\r\n    if (!this.initialized) {\r\n      throw new Error('Memory system not initialized');\r\n    }\r\n\r\n    const namespace = options.namespace || 'default';\r\n    const ttl = options.ttl || this.config.defaultTTL;\r\n    const agent = options.agent || 'system';\r\n    const tags = options.tags || [];\r\n    const priority = options.priority || 'normal';\r\n    const compression = options.compression !== false && this.config.enableCompression;\r\n    \r\n    const fullKey = `${namespace}:${key}`;\r\n    const serializedValue = JSON.stringify(value);\r\n    const originalSize = Buffer.byteLength(serializedValue, 'utf8');\r\n    \r\n    let storedValue = serializedValue;\r\n    let compressed = false;\r\n    let compressionRatio = 1;\r\n    \r\n    // Apply compression if beneficial\r\n    if (compression && originalSize > this.config.compressionThreshold) {\r\n      const compressedValue = await this.compressData(serializedValue);\r\n      if (compressedValue.length < originalSize * 0.8) {\r\n        storedValue = compressedValue;\r\n        compressed = true;\r\n        compressionRatio = originalSize / compressedValue.length;\r\n        this.stats.compressionSaved += originalSize - compressedValue.length;\r\n      }\r\n    }\r\n    \r\n    const entry = {\r\n      key: fullKey,\r\n      value: storedValue,\r\n      originalValue: value, // Keep uncompressed for cache\r\n      size: Buffer.byteLength(storedValue, 'utf8'),\r\n      originalSize,\r\n      compressed,\r\n      compressionRatio,\r\n      namespace,\r\n      agent,\r\n      tags: new Set(tags),\r\n      priority,\r\n      \r\n      // Metadata\r\n      createdAt: Date.now(),\r\n      updatedAt: Date.now(),\r\n      expiresAt: ttl ? Date.now() + ttl : null,\r\n      version: 1,\r\n      \r\n      // Access tracking\r\n      accessCount: 0,\r\n      lastAccessed: Date.now(),\r\n      accessHistory: [],\r\n      \r\n      // Relationships\r\n      relationships: new Set(),\r\n      derivedFrom: options.derivedFrom ? new Set([options.derivedFrom]) : new Set(),\r\n      \r\n      // Flags\r\n      persistent: options.persistent !== false,\r\n      shareable: options.shareable !== false,\r\n      cacheable: options.cacheable !== false\r\n    };\r\n    \r\n    // Update existing entry or create new\r\n    const existingEntry = this.memory.get(fullKey);\r\n    if (existingEntry) {\r\n      entry.version = existingEntry.version + 1;\r\n      entry.createdAt = existingEntry.createdAt;\r\n      entry.accessCount = existingEntry.accessCount;\r\n      entry.accessHistory = existingEntry.accessHistory;\r\n      entry.relationships = existingEntry.relationships;\r\n    }\r\n    \r\n    // Store in memory\r\n    this.memory.set(fullKey, entry);\r\n    this.updateIndex(fullKey, entry);\r\n    this.updateShard(fullKey, entry);\r\n    \r\n    // Update statistics\r\n    this.stats.totalKeys = this.memory.size;\r\n    this.stats.totalSize += entry.size;\r\n    if (existingEntry) {\r\n      this.stats.totalSize -= existingEntry.size;\r\n    }\r\n    \r\n    // Mark as dirty for persistence\r\n    this.isDirty = true;\r\n    this.queueForPersistence(entry);\r\n    \r\n    // Detect patterns if enabled\r\n    if (this.config.enablePatternDetection) {\r\n      this.detectPatterns(entry);\r\n    }\r\n    \r\n    // Update relationships\r\n    this.updateRelationships(fullKey, entry);\r\n    \r\n    this.emit('stored', {\r\n      key: fullKey,\r\n      size: entry.size,\r\n      compressed,\r\n      agent,\r\n      namespace\r\n    });\r\n    \r\n    // Cleanup if memory is getting full\r\n    if (this.memory.size > this.config.maxCacheSize) {\r\n      await this.cleanup();\r\n    }\r\n    \r\n    return fullKey;\r\n  }\r\n\r\n  /**\r\n   * Retrieve data from memory\r\n   */\r\n  async retrieve(key, options = {}) {\r\n    const namespace = options.namespace || 'default';\r\n    const fullKey = `${namespace}:${key}`;\r\n    const agent = options.agent || 'system';\r\n    const decompress = options.decompress !== false;\r\n    \r\n    let entry = this.memory.get(fullKey);\r\n    \r\n    if (entry) {\r\n      this.stats.cacheHits++;\r\n    } else {\r\n      this.stats.cacheMisses++;\r\n      \r\n      // Try to load from disk\r\n      entry = await this.loadFromDisk(fullKey);\r\n      if (entry) {\r\n        this.memory.set(fullKey, entry);\r\n      }\r\n    }\r\n    \r\n    if (!entry) {\r\n      return null;\r\n    }\r\n    \r\n    // Check expiration\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      await this.delete(key, { namespace });\r\n      return null;\r\n    }\r\n    \r\n    // Update access tracking\r\n    entry.accessCount++;\r\n    entry.lastAccessed = Date.now();\r\n    entry.accessHistory.push({\r\n      agent,\r\n      timestamp: Date.now(),\r\n      operation: 'read'\r\n    });\r\n    \r\n    // Keep recent access history limited\r\n    if (entry.accessHistory.length > 100) {\r\n      entry.accessHistory = entry.accessHistory.slice(-50);\r\n    }\r\n    \r\n    // Update hotness tracking\r\n    this.updateHotness(fullKey, entry);\r\n    \r\n    // Log access pattern\r\n    this.logAccess(fullKey, agent, 'read');\r\n    \r\n    this.emit('retrieved', {\r\n      key: fullKey,\r\n      agent,\r\n      accessCount: entry.accessCount\r\n    });\r\n    \r\n    // Return decompressed value if needed\r\n    if (entry.compressed && decompress) {\r\n      if (entry.originalValue) {\r\n        return entry.originalValue;\r\n      }\r\n      try {\r\n        const decompressed = await this.decompressData(entry.value);\r\n        const parsed = JSON.parse(decompressed);\r\n        entry.originalValue = parsed; // Cache for future access\r\n        return parsed;\r\n      } catch (error) {\r\n        console.error(`Failed to decompress data for key ${fullKey}:`, error);\r\n        return null;\r\n      }\r\n    }\r\n    \r\n    if (entry.originalValue) {\r\n      return entry.originalValue;\r\n    }\r\n    \r\n    try {\r\n      return JSON.parse(entry.value);\r\n    } catch (error) {\r\n      console.error(`Failed to parse data for key ${fullKey}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete data from memory\r\n   */\r\n  async delete(key, options = {}) {\r\n    const namespace = options.namespace || 'default';\r\n    const fullKey = `${namespace}:${key}`;\r\n    \r\n    const entry = this.memory.get(fullKey);\r\n    if (!entry) {\r\n      return false;\r\n    }\r\n    \r\n    // Remove from memory\r\n    this.memory.delete(fullKey);\r\n    this.removeFromIndex(fullKey);\r\n    this.removeFromShard(fullKey);\r\n    \r\n    // Update statistics\r\n    this.stats.totalKeys = this.memory.size;\r\n    this.stats.totalSize -= entry.size;\r\n    \r\n    // Remove relationships\r\n    this.removeRelationships(fullKey);\r\n    \r\n    // Mark for persistence cleanup\r\n    this.queueForDeletion(fullKey);\r\n    \r\n    this.emit('deleted', { key: fullKey });\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Search memory entries\r\n   */\r\n  async search(query, options = {}) {\r\n    const namespace = options.namespace;\r\n    const tags = options.tags;\r\n    const agent = options.agent;\r\n    const limit = options.limit || 100;\r\n    const sortBy = options.sortBy || 'relevance';\r\n    \r\n    let results = [];\r\n    \r\n    // Search through memory entries\r\n    for (const [key, entry] of this.memory) {\r\n      if (namespace && entry.namespace !== namespace) continue;\r\n      if (agent && entry.agent !== agent) continue;\r\n      \r\n      let score = 0;\r\n      \r\n      // Key matching\r\n      if (key.toLowerCase().includes(query.toLowerCase())) {\r\n        score += 10;\r\n      }\r\n      \r\n      // Tag matching\r\n      if (tags && tags.length > 0) {\r\n        const matchingTags = tags.filter(tag => entry.tags.has(tag));\r\n        score += matchingTags.length * 5;\r\n      }\r\n      \r\n      // Content search (basic)\r\n      if (entry.originalValue) {\r\n        const content = JSON.stringify(entry.originalValue).toLowerCase();\r\n        if (content.includes(query.toLowerCase())) {\r\n          score += 3;\r\n        }\r\n      }\r\n      \r\n      if (score > 0) {\r\n        results.push({\r\n          key,\r\n          entry,\r\n          score,\r\n          relevance: score\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Sort results\r\n    switch (sortBy) {\r\n      case 'relevance':\r\n        results.sort((a, b) => b.score - a.score);\r\n        break;\r\n      case 'recent':\r\n        results.sort((a, b) => b.entry.lastAccessed - a.entry.lastAccessed);\r\n        break;\r\n      case 'created':\r\n        results.sort((a, b) => b.entry.createdAt - a.entry.createdAt);\r\n        break;\r\n      case 'access':\r\n        results.sort((a, b) => b.entry.accessCount - a.entry.accessCount);\r\n        break;\r\n    }\r\n    \r\n    return results.slice(0, limit).map(r => ({\r\n      key: r.key,\r\n      value: r.entry.originalValue || JSON.parse(r.entry.value),\r\n      score: r.score,\r\n      metadata: {\r\n        namespace: r.entry.namespace,\r\n        agent: r.entry.agent,\r\n        tags: Array.from(r.entry.tags),\r\n        accessCount: r.entry.accessCount,\r\n        lastAccessed: r.entry.lastAccessed,\r\n        createdAt: r.entry.createdAt\r\n      }\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get related keys\r\n   */\r\n  getRelatedKeys(key, options = {}) {\r\n    const namespace = options.namespace || 'default';\r\n    const fullKey = `${namespace}:${key}`;\r\n    const maxResults = options.limit || 10;\r\n    \r\n    const relationships = this.relationships.get(fullKey);\r\n    if (!relationships) {\r\n      return [];\r\n    }\r\n    \r\n    return Array.from(relationships.entries())\r\n      .map(([relatedKey, strength]) => ({\r\n        key: relatedKey,\r\n        strength,\r\n        entry: this.memory.get(relatedKey)\r\n      }))\r\n      .filter(r => r.entry)\r\n      .sort((a, b) => b.strength - a.strength)\r\n      .slice(0, maxResults);\r\n  }\r\n\r\n  /**\r\n   * Share memory between agents\r\n   */\r\n  async shareMemory(fromAgent, toAgent, keys, options = {}) {\r\n    const shared = [];\r\n    const namespace = options.namespace || 'default';\r\n    \r\n    for (const key of keys) {\r\n      const fullKey = `${namespace}:${key}`;\r\n      const entry = this.memory.get(fullKey);\r\n      \r\n      if (!entry || !entry.shareable) {\r\n        continue;\r\n      }\r\n      \r\n      // Create shared copy\r\n      const sharedKey = `shared:${toAgent}:${key}`;\r\n      await this.store(sharedKey, entry.originalValue || JSON.parse(entry.value), {\r\n        namespace: 'shared',\r\n        agent: toAgent,\r\n        derivedFrom: fullKey,\r\n        tags: [...entry.tags, 'shared', 'from:' + fromAgent],\r\n        ttl: options.ttl || entry.expiresAt ? entry.expiresAt - Date.now() : undefined\r\n      });\r\n      \r\n      shared.push({\r\n        originalKey: fullKey,\r\n        sharedKey: `shared:${sharedKey}`,\r\n        agent: toAgent\r\n      });\r\n    }\r\n    \r\n    this.emit('memory:shared', {\r\n      fromAgent,\r\n      toAgent,\r\n      keys: shared.length\r\n    });\r\n    \r\n    return shared;\r\n  }\r\n\r\n  /**\r\n   * Pattern detection\r\n   */\r\n  detectPatterns(entry) {\r\n    // Co-access patterns\r\n    this.detectCoAccessPatterns(entry);\r\n    \r\n    // Temporal patterns\r\n    this.detectTemporalPatterns(entry);\r\n    \r\n    // Content similarity patterns\r\n    this.detectContentPatterns(entry);\r\n    \r\n    // Agent behavior patterns\r\n    this.detectAgentPatterns(entry);\r\n  }\r\n\r\n  /**\r\n   * Detect co-access patterns\r\n   */\r\n  detectCoAccessPatterns(entry) {\r\n    const recentAccesses = Array.from(this.accessLog.entries())\r\n      .filter(([_, log]) => Date.now() - log.timestamp < 3600000) // Last hour\r\n      .map(([key, log]) => key);\r\n    \r\n    if (recentAccesses.length < 2) return;\r\n    \r\n    for (const accessedKey of recentAccesses) {\r\n      if (accessedKey === entry.key) continue;\r\n      \r\n      const pattern = this.patterns.get(`co-access:${entry.key}:${accessedKey}`) || {\r\n        type: 'co-access',\r\n        keys: [entry.key, accessedKey],\r\n        frequency: 0,\r\n        confidence: 0,\r\n        lastSeen: 0\r\n      };\r\n      \r\n      pattern.frequency++;\r\n      pattern.lastSeen = Date.now();\r\n      pattern.confidence = Math.min(1.0, pattern.frequency / 10);\r\n      \r\n      this.patterns.set(`co-access:${entry.key}:${accessedKey}`, pattern);\r\n      \r\n      if (pattern.confidence > 0.7) {\r\n        this.updateRelationship(entry.key, accessedKey, pattern.confidence);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect temporal access patterns\r\n   */\r\n  detectTemporalPatterns(entry) {\r\n    if (entry.accessHistory.length < 5) return;\r\n    \r\n    const intervals = [];\r\n    for (let i = 1; i < entry.accessHistory.length; i++) {\r\n      intervals.push(entry.accessHistory[i].timestamp - entry.accessHistory[i-1].timestamp);\r\n    }\r\n    \r\n    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\r\n    const variance = intervals.reduce((sum, interval) => \r\n      sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;\r\n    \r\n    if (variance < avgInterval * 0.2) { // Low variance indicates pattern\r\n      const pattern = {\r\n        type: 'temporal',\r\n        key: entry.key,\r\n        avgInterval,\r\n        confidence: 1 - (variance / avgInterval),\r\n        nextPredicted: entry.lastAccessed + avgInterval\r\n      };\r\n      \r\n      this.patterns.set(`temporal:${entry.key}`, pattern);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update key relationships\r\n   */\r\n  updateRelationship(key1, key2, strength) {\r\n    if (!this.relationships.has(key1)) {\r\n      this.relationships.set(key1, new Map());\r\n    }\r\n    if (!this.relationships.has(key2)) {\r\n      this.relationships.set(key2, new Map());\r\n    }\r\n    \r\n    this.relationships.get(key1).set(key2, strength);\r\n    this.relationships.get(key2).set(key1, strength);\r\n  }\r\n\r\n  /**\r\n   * Update memory index for search\r\n   */\r\n  updateIndex(key, entry) {\r\n    // Index by tags\r\n    for (const tag of entry.tags) {\r\n      if (!this.memoryIndex.has(`tag:${tag}`)) {\r\n        this.memoryIndex.set(`tag:${tag}`, new Set());\r\n      }\r\n      this.memoryIndex.get(`tag:${tag}`).add(key);\r\n    }\r\n    \r\n    // Index by agent\r\n    if (!this.memoryIndex.has(`agent:${entry.agent}`)) {\r\n      this.memoryIndex.set(`agent:${entry.agent}`, new Set());\r\n    }\r\n    this.memoryIndex.get(`agent:${entry.agent}`).add(key);\r\n    \r\n    // Index by namespace\r\n    if (!this.memoryIndex.has(`namespace:${entry.namespace}`)) {\r\n      this.memoryIndex.set(`namespace:${entry.namespace}`, new Set());\r\n    }\r\n    this.memoryIndex.get(`namespace:${entry.namespace}`).add(key);\r\n  }\r\n\r\n  /**\r\n   * Update shard information\r\n   */\r\n  updateShard(key, entry) {\r\n    const shardId = this.getShardForKey(key);\r\n    const shard = this.shards.get(shardId);\r\n    \r\n    if (!shard.keys.has(key)) {\r\n      shard.keys.add(key);\r\n      shard.size += entry.size;\r\n    }\r\n    \r\n    shard.lastAccess = Date.now();\r\n    shard.hotness = Math.min(10, shard.hotness + 0.1);\r\n  }\r\n\r\n  /**\r\n   * Update hotness tracking\r\n   */\r\n  updateHotness(key, entry) {\r\n    const now = Date.now();\r\n    const recentAccesses = entry.accessHistory.filter(\r\n      access => now - access.timestamp < 3600000 // Last hour\r\n    ).length;\r\n    \r\n    if (recentAccesses > 5) {\r\n      this.hotKeys.add(key);\r\n      this.coldKeys.delete(key);\r\n    } else if (recentAccesses === 0 && now - entry.lastAccessed > 86400000) {\r\n      this.coldKeys.add(key);\r\n      this.hotKeys.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log access pattern\r\n   */\r\n  logAccess(key, agent, operation) {\r\n    this.accessLog.set(key, {\r\n      key,\r\n      agent,\r\n      operation,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Limit access log size\r\n    if (this.accessLog.size > 10000) {\r\n      const entries = Array.from(this.accessLog.entries())\r\n        .sort(([,a], [,b]) => b.timestamp - a.timestamp)\r\n        .slice(0, 5000);\r\n      \r\n      this.accessLog.clear();\r\n      for (const [key, log] of entries) {\r\n        this.accessLog.set(key, log);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compress data\r\n   */\r\n  async compressData(data) {\r\n    // Simple compression - in production, use actual compression library\r\n    return Buffer.from(data).toString('base64');\r\n  }\r\n\r\n  /**\r\n   * Decompress data\r\n   */\r\n  async decompressData(data) {\r\n    // Simple decompression - in production, use actual compression library\r\n    return Buffer.from(data, 'base64').toString();\r\n  }\r\n\r\n  /**\r\n   * Queue entry for persistence\r\n   */\r\n  queueForPersistence(entry) {\r\n    this.persistenceQueue.push({\r\n      action: 'store',\r\n      entry\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queue key for deletion\r\n   */\r\n  queueForDeletion(key) {\r\n    this.persistenceQueue.push({\r\n      action: 'delete',\r\n      key\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save memory to disk\r\n   */\r\n  async saveToDisk() {\r\n    if (!this.isDirty && this.persistenceQueue.length === 0) {\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      // Process persistence queue\r\n      for (const item of this.persistenceQueue) {\r\n        if (item.action === 'store') {\r\n          const filename = path.join(\r\n            this.config.persistenceDir,\r\n            `${item.entry.namespace}_${this.hashKey(item.entry.key) % 100}.json`\r\n          );\r\n          \r\n          let data = {};\r\n          try {\r\n            const existing = await fs.readFile(filename, 'utf8');\r\n            data = JSON.parse(existing);\r\n          } catch (error) {\r\n            // File doesn't exist, start with empty object\r\n          }\r\n          \r\n          data[item.entry.key] = {\r\n            ...item.entry,\r\n            accessHistory: [], // Don't persist full history\r\n            originalValue: undefined // Don't persist cached value\r\n          };\r\n          \r\n          await fs.writeFile(filename, JSON.stringify(data, null, 2));\r\n        } else if (item.action === 'delete') {\r\n          // Handle deletion from disk\r\n          const namespace = item.key.split(':')[0];\r\n          const filename = path.join(\r\n            this.config.persistenceDir,\r\n            `${namespace}_${this.hashKey(item.key) % 100}.json`\r\n          );\r\n          \r\n          try {\r\n            const existing = await fs.readFile(filename, 'utf8');\r\n            const data = JSON.parse(existing);\r\n            delete data[item.key];\r\n            await fs.writeFile(filename, JSON.stringify(data, null, 2));\r\n          } catch (error) {\r\n            // File doesn't exist or other error - ignore\r\n          }\r\n        }\r\n      }\r\n      \r\n      this.persistenceQueue = [];\r\n      this.isDirty = false;\r\n      this.lastSync = Date.now();\r\n      \r\n      this.emit('persisted', { entries: this.memory.size });\r\n    } catch (error) {\r\n      console.error('Failed to save memory to disk:', error);\r\n      this.emit('persistence:error', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load memory from disk\r\n   */\r\n  async loadFromDisk(specificKey = null) {\r\n    try {\r\n      const files = await fs.readdir(this.config.persistenceDir);\r\n      \r\n      for (const file of files) {\r\n        if (!file.endsWith('.json')) continue;\r\n        \r\n        const filepath = path.join(this.config.persistenceDir, file);\r\n        const data = JSON.parse(await fs.readFile(filepath, 'utf8'));\r\n        \r\n        for (const [key, entry] of Object.entries(data)) {\r\n          if (specificKey && key !== specificKey) continue;\r\n          \r\n          // Restore entry\r\n          entry.tags = new Set(entry.tags || []);\r\n          entry.relationships = new Set(entry.relationships || []);\r\n          entry.derivedFrom = new Set(entry.derivedFrom || []);\r\n          entry.accessHistory = [];\r\n          entry.originalValue = undefined;\r\n          \r\n          this.memory.set(key, entry);\r\n          this.updateIndex(key, entry);\r\n          this.updateShard(key, entry);\r\n          \r\n          if (specificKey === key) {\r\n            return entry;\r\n          }\r\n        }\r\n      }\r\n      \r\n      return specificKey ? null : true;\r\n    } catch (error) {\r\n      console.error('Failed to load memory from disk:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start background maintenance tasks\r\n   */\r\n  startBackgroundTasks() {\r\n    // Sync to disk periodically\r\n    setInterval(() => {\r\n      this.saveToDisk();\r\n    }, this.config.syncInterval);\r\n    \r\n    // Cleanup expired entries\r\n    setInterval(() => {\r\n      this.cleanup();\r\n    }, 60000); // Every minute\r\n    \r\n    // Update statistics\r\n    setInterval(() => {\r\n      this.updateStatistics();\r\n    }, 10000); // Every 10 seconds\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired entries and optimize memory\r\n   */\r\n  async cleanup() {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n    \r\n    for (const [key, entry] of this.memory) {\r\n      // Remove expired entries\r\n      if (entry.expiresAt && now > entry.expiresAt) {\r\n        await this.delete(key.split(':')[1], { namespace: entry.namespace });\r\n        cleaned++;\r\n        continue;\r\n      }\r\n      \r\n      // Remove old, rarely accessed entries if memory is full\r\n      if (this.memory.size > this.config.maxCacheSize * 0.9) {\r\n        const daysSinceAccess = (now - entry.lastAccessed) / 86400000;\r\n        if (daysSinceAccess > 7 && entry.accessCount < 2) {\r\n          await this.delete(key.split(':')[1], { namespace: entry.namespace });\r\n          cleaned++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    this.stats.lastCleanup = now;\r\n    \r\n    if (cleaned > 0) {\r\n      this.emit('cleanup:completed', { entriesRemoved: cleaned });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update internal statistics\r\n   */\r\n  updateStatistics() {\r\n    this.stats.totalKeys = this.memory.size;\r\n    this.stats.totalSize = Array.from(this.memory.values())\r\n      .reduce((sum, entry) => sum + entry.size, 0);\r\n  }\r\n\r\n  /**\r\n   * Get memory statistics\r\n   */\r\n  getStatistics() {\r\n    const hitRate = this.stats.cacheHits + this.stats.cacheMisses > 0 ?\r\n      this.stats.cacheHits / (this.stats.cacheHits + this.stats.cacheMisses) : 0;\r\n    \r\n    return {\r\n      ...this.stats,\r\n      hitRate,\r\n      hotKeys: this.hotKeys.size,\r\n      coldKeys: this.coldKeys.size,\r\n      patterns: this.patterns.size,\r\n      relationships: this.relationships.size,\r\n      shards: Array.from(this.shards.values()).map(s => ({\r\n        id: s.id,\r\n        keyCount: s.keys.size,\r\n        size: s.size,\r\n        hotness: s.hotness\r\n      })),\r\n      memoryUsage: {\r\n        used: this.stats.totalSize,\r\n        max: this.config.maxMemorySize,\r\n        percentage: (this.stats.totalSize / this.config.maxMemorySize) * 100\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Remove entry from index\r\n   */\r\n  removeFromIndex(key) {\r\n    for (const [indexKey, keys] of this.memoryIndex) {\r\n      if (keys.has(key)) {\r\n        keys.delete(key);\r\n        if (keys.size === 0) {\r\n          this.memoryIndex.delete(indexKey);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove entry from shard\r\n   */\r\n  removeFromShard(key) {\r\n    const shardId = this.getShardForKey(key);\r\n    const shard = this.shards.get(shardId);\r\n    \r\n    if (shard && shard.keys.has(key)) {\r\n      shard.keys.delete(key);\r\n      const entry = this.memory.get(key);\r\n      if (entry) {\r\n        shard.size -= entry.size;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove relationships for a key\r\n   */\r\n  removeRelationships(key) {\r\n    const relationships = this.relationships.get(key);\r\n    if (relationships) {\r\n      for (const relatedKey of relationships.keys()) {\r\n        const relatedRels = this.relationships.get(relatedKey);\r\n        if (relatedRels) {\r\n          relatedRels.delete(key);\r\n          if (relatedRels.size === 0) {\r\n            this.relationships.delete(relatedKey);\r\n          }\r\n        }\r\n      }\r\n      this.relationships.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shutdown memory system\r\n   */\r\n  async shutdown() {\r\n    console.log('Shutting down collective memory...');\r\n    \r\n    // Save all pending changes\r\n    await this.saveToDisk();\r\n    \r\n    this.emit('shutdown');\r\n    this.removeAllListeners();\r\n  }\r\n}"],"names":["EventEmitter","fs","path","CollectiveMemory","config","persistenceDir","maxMemorySize","compressionThreshold","syncInterval","defaultTTL","maxCacheSize","enableCompression","enablePatternDetection","shardCount","memory","Map","memoryIndex","accessLog","shards","patterns","relationships","hotKeys","Set","coldKeys","persistenceQueue","lastSync","isDirty","stats","totalKeys","totalSize","cacheHits","cacheMisses","patternDetections","compressionSaved","lastCleanup","initialized","init","mkdir","recursive","loadFromDisk","initializeShards","startBackgroundTasks","emit","console","log","size","error","i","set","id","keys","lastAccess","Date","now","hotness","getShardForKey","key","hash","hashKey","length","char","charCodeAt","Math","abs","store","value","options","Error","namespace","ttl","agent","tags","priority","compression","fullKey","serializedValue","JSON","stringify","originalSize","Buffer","byteLength","storedValue","compressed","compressionRatio","compressedValue","compressData","entry","originalValue","createdAt","updatedAt","expiresAt","version","accessCount","lastAccessed","accessHistory","derivedFrom","persistent","shareable","cacheable","existingEntry","get","updateIndex","updateShard","queueForPersistence","detectPatterns","updateRelationships","cleanup","retrieve","decompress","delete","push","timestamp","operation","slice","updateHotness","logAccess","decompressed","decompressData","parsed","parse","removeFromIndex","removeFromShard","removeRelationships","queueForDeletion","search","query","limit","sortBy","results","score","toLowerCase","includes","matchingTags","filter","tag","has","content","relevance","sort","a","b","map","r","metadata","Array","from","getRelatedKeys","maxResults","entries","relatedKey","strength","shareMemory","fromAgent","toAgent","shared","sharedKey","undefined","originalKey","detectCoAccessPatterns","detectTemporalPatterns","detectContentPatterns","detectAgentPatterns","recentAccesses","_","accessedKey","pattern","type","frequency","confidence","lastSeen","min","updateRelationship","intervals","avgInterval","reduce","sum","interval","variance","pow","nextPredicted","key1","key2","add","shardId","shard","access","clear","data","toString","action","saveToDisk","item","filename","join","existing","readFile","writeFile","split","specificKey","files","readdir","file","endsWith","filepath","Object","setInterval","updateStatistics","cleaned","daysSinceAccess","entriesRemoved","values","getStatistics","hitRate","s","keyCount","memoryUsage","used","max","percentage","indexKey","relatedRels","shutdown","removeAllListeners"],"mappings":"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"}