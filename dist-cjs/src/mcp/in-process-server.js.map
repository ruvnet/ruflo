{"version":3,"sources":["../../../src/mcp/in-process-server.ts"],"sourcesContent":["/**\r\n * In-Process MCP Server Implementation\r\n *\r\n * Provides 10-100x performance improvement by eliminating IPC overhead.\r\n * Uses Claude Code SDK's in-process server API for direct tool registration.\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\r\nimport type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';\r\nimport { logger } from '../core/logger.js';\r\nimport type { MCPTool, MCPContext } from '../utils/types.js';\r\n\r\nexport interface InProcessServerConfig {\r\n  name: string;\r\n  version?: string;\r\n  tools?: MCPTool[];\r\n  enableMetrics?: boolean;\r\n  enableCaching?: boolean;\r\n}\r\n\r\nexport interface ToolCallMetrics {\r\n  toolName: string;\r\n  duration: number;\r\n  success: boolean;\r\n  timestamp: number;\r\n  transport: 'in-process' | 'stdio' | 'sse';\r\n}\r\n\r\n/**\r\n * In-Process MCP Server\r\n * Registers Claude-Flow tools directly in the SDK process to eliminate IPC overhead\r\n */\r\nexport class InProcessMCPServer extends EventEmitter {\r\n  private name: string;\r\n  private version: string;\r\n  private tools: Map<string, MCPTool>;\r\n  private metrics: ToolCallMetrics[];\r\n  private context?: MCPContext;\r\n  private enableMetrics: boolean;\r\n  private enableCaching: boolean;\r\n  private cache: Map<string, { result: any; timestamp: number; ttl: number }>;\r\n\r\n  constructor(config: InProcessServerConfig) {\r\n    super();\r\n    this.name = config.name;\r\n    this.version = config.version || '1.0.0';\r\n    this.tools = new Map();\r\n    this.metrics = [];\r\n    this.enableMetrics = config.enableMetrics !== false;\r\n    this.enableCaching = config.enableCaching !== false;\r\n    this.cache = new Map();\r\n\r\n    if (config.tools) {\r\n      config.tools.forEach(tool => this.registerTool(tool));\r\n    }\r\n\r\n    logger.info('InProcessMCPServer initialized', {\r\n      name: this.name,\r\n      version: this.version,\r\n      toolCount: this.tools.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Register a tool for in-process execution\r\n   */\r\n  registerTool(tool: MCPTool): void {\r\n    if (this.tools.has(tool.name)) {\r\n      logger.warn('Tool already registered, overwriting', { name: tool.name });\r\n    }\r\n\r\n    this.tools.set(tool.name, tool);\r\n    logger.debug('Tool registered', { name: tool.name });\r\n    this.emit('toolRegistered', tool.name);\r\n  }\r\n\r\n  /**\r\n   * Unregister a tool\r\n   */\r\n  unregisterTool(name: string): boolean {\r\n    const deleted = this.tools.delete(name);\r\n    if (deleted) {\r\n      logger.debug('Tool unregistered', { name });\r\n      this.emit('toolUnregistered', name);\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  /**\r\n   * Get all registered tool names\r\n   */\r\n  getToolNames(): string[] {\r\n    return Array.from(this.tools.keys());\r\n  }\r\n\r\n  /**\r\n   * Get tool metadata\r\n   */\r\n  getTool(name: string): MCPTool | undefined {\r\n    return this.tools.get(name);\r\n  }\r\n\r\n  /**\r\n   * Execute a tool call in-process\r\n   */\r\n  async callTool(\r\n    name: string,\r\n    args: Record<string, unknown>,\r\n    context?: MCPContext\r\n  ): Promise<CallToolResult> {\r\n    const startTime = performance.now();\r\n    let success = false;\r\n\r\n    try {\r\n      // Check cache first\r\n      if (this.enableCaching) {\r\n        const cached = this.checkCache(name, args);\r\n        if (cached) {\r\n          logger.debug('Cache hit for tool', { name });\r\n          success = true;\r\n          return cached;\r\n        }\r\n      }\r\n\r\n      const tool = this.tools.get(name);\r\n      if (!tool) {\r\n        throw new Error(`Tool not found: ${name}`);\r\n      }\r\n\r\n      logger.debug('Executing tool in-process', { name, args });\r\n\r\n      // Merge context\r\n      const execContext: MCPContext = {\r\n        ...this.context,\r\n        ...context,\r\n      };\r\n\r\n      // Execute tool handler directly (in-process, no IPC!)\r\n      const result = await tool.handler(args, execContext);\r\n\r\n      // Cache result if applicable\r\n      if (this.enableCaching && this.isCacheable(name)) {\r\n        this.cacheResult(name, args, result);\r\n      }\r\n\r\n      success = true;\r\n\r\n      // Return in MCP CallToolResult format\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: typeof result === 'string' ? result : JSON.stringify(result, null, 2),\r\n          },\r\n        ],\r\n        isError: false,\r\n      };\r\n    } catch (error) {\r\n      logger.error('Tool execution failed', { name, error });\r\n      success = false;\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: 'text',\r\n            text: `Error: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n        isError: true,\r\n      };\r\n    } finally {\r\n      // Record metrics\r\n      if (this.enableMetrics) {\r\n        const duration = performance.now() - startTime;\r\n        this.recordMetric({\r\n          toolName: name,\r\n          duration,\r\n          success,\r\n          timestamp: Date.now(),\r\n          transport: 'in-process',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set execution context (orchestrator, session, etc.)\r\n   */\r\n  setContext(context: MCPContext): void {\r\n    this.context = context;\r\n    logger.debug('Context updated', { sessionId: context.sessionId });\r\n  }\r\n\r\n  /**\r\n   * Get performance metrics\r\n   */\r\n  getMetrics(): ToolCallMetrics[] {\r\n    return [...this.metrics];\r\n  }\r\n\r\n  /**\r\n   * Get performance statistics\r\n   */\r\n  getStats() {\r\n    const stats: Record<\r\n      string,\r\n      {\r\n        totalCalls: number;\r\n        successRate: number;\r\n        avgDuration: number;\r\n        minDuration: number;\r\n        maxDuration: number;\r\n      }\r\n    > = {};\r\n\r\n    // Group by tool name\r\n    const grouped = new Map<string, ToolCallMetrics[]>();\r\n    for (const metric of this.metrics) {\r\n      if (!grouped.has(metric.toolName)) {\r\n        grouped.set(metric.toolName, []);\r\n      }\r\n      grouped.get(metric.toolName)!.push(metric);\r\n    }\r\n\r\n    // Calculate statistics\r\n    for (const [toolName, metrics] of grouped) {\r\n      const totalCalls = metrics.length;\r\n      const successfulCalls = metrics.filter(m => m.success).length;\r\n      const durations = metrics.map(m => m.duration);\r\n      const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;\r\n      const minDuration = Math.min(...durations);\r\n      const maxDuration = Math.max(...durations);\r\n\r\n      stats[toolName] = {\r\n        totalCalls,\r\n        successRate: successfulCalls / totalCalls,\r\n        avgDuration,\r\n        minDuration,\r\n        maxDuration,\r\n      };\r\n    }\r\n\r\n    return {\r\n      toolStats: stats,\r\n      totalCalls: this.metrics.length,\r\n      averageDuration:\r\n        this.metrics.reduce((sum, m) => sum + m.duration, 0) / this.metrics.length || 0,\r\n      cacheHitRate: this.getCacheHitRate(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear metrics\r\n   */\r\n  clearMetrics(): void {\r\n    this.metrics = [];\r\n    logger.debug('Metrics cleared');\r\n  }\r\n\r\n  /**\r\n   * Clear cache\r\n   */\r\n  clearCache(): void {\r\n    this.cache.clear();\r\n    logger.debug('Cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get server info\r\n   */\r\n  getInfo() {\r\n    return {\r\n      name: this.name,\r\n      version: this.version,\r\n      toolCount: this.tools.size,\r\n      tools: this.getToolNames(),\r\n      metrics: {\r\n        totalCalls: this.metrics.length,\r\n        cacheSize: this.cache.size,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Record a metric\r\n   */\r\n  private recordMetric(metric: ToolCallMetrics): void {\r\n    this.metrics.push(metric);\r\n    this.emit('metricRecorded', metric);\r\n\r\n    // Keep only last 1000 metrics\r\n    if (this.metrics.length > 1000) {\r\n      this.metrics = this.metrics.slice(-1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check cache for a tool call result\r\n   */\r\n  private checkCache(\r\n    name: string,\r\n    args: Record<string, unknown>\r\n  ): CallToolResult | undefined {\r\n    const cacheKey = this.getCacheKey(name, args);\r\n    const cached = this.cache.get(cacheKey);\r\n\r\n    if (cached) {\r\n      const now = Date.now();\r\n      if (now - cached.timestamp < cached.ttl) {\r\n        return {\r\n          content: [\r\n            {\r\n              type: 'text',\r\n              text: typeof cached.result === 'string'\r\n                ? cached.result\r\n                : JSON.stringify(cached.result, null, 2),\r\n            },\r\n          ],\r\n          isError: false,\r\n        };\r\n      } else {\r\n        // Expired, remove from cache\r\n        this.cache.delete(cacheKey);\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Cache a tool result\r\n   */\r\n  private cacheResult(name: string, args: Record<string, unknown>, result: any): void {\r\n    const cacheKey = this.getCacheKey(name, args);\r\n    const ttl = this.getCacheTTL(name);\r\n\r\n    this.cache.set(cacheKey, {\r\n      result,\r\n      timestamp: Date.now(),\r\n      ttl,\r\n    });\r\n\r\n    // Limit cache size\r\n    if (this.cache.size > 100) {\r\n      const firstKey = this.cache.keys().next().value;\r\n      if (firstKey) {\r\n        this.cache.delete(firstKey);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate cache key\r\n   */\r\n  private getCacheKey(name: string, args: Record<string, unknown>): string {\r\n    return `${name}:${JSON.stringify(args)}`;\r\n  }\r\n\r\n  /**\r\n   * Determine if a tool is cacheable\r\n   */\r\n  private isCacheable(name: string): boolean {\r\n    // Only cache read-only operations\r\n    const cacheableTools = [\r\n      'agents/list',\r\n      'agents/info',\r\n      'tasks/list',\r\n      'tasks/status',\r\n      'system/status',\r\n      'system/metrics',\r\n      'config/get',\r\n      'workflow/list',\r\n      'terminal/list',\r\n    ];\r\n\r\n    return cacheableTools.includes(name);\r\n  }\r\n\r\n  /**\r\n   * Get cache TTL for a tool\r\n   */\r\n  private getCacheTTL(name: string): number {\r\n    // Different TTLs for different tools\r\n    const ttls: Record<string, number> = {\r\n      'agents/list': 5000, // 5 seconds\r\n      'agents/info': 10000, // 10 seconds\r\n      'system/status': 2000, // 2 seconds\r\n      'config/get': 30000, // 30 seconds\r\n    };\r\n\r\n    return ttls[name] || 10000; // Default 10 seconds\r\n  }\r\n\r\n  /**\r\n   * Calculate cache hit rate\r\n   */\r\n  private getCacheHitRate(): number {\r\n    // Simple estimation based on cache size vs total calls\r\n    if (this.metrics.length === 0) return 0;\r\n\r\n    const cacheableMetrics = this.metrics.filter(m => this.isCacheable(m.toolName));\r\n    if (cacheableMetrics.length === 0) return 0;\r\n\r\n    // Estimate: assume cache hits are very fast (< 1ms)\r\n    const likelyCacheHits = cacheableMetrics.filter(m => m.duration < 1).length;\r\n    return likelyCacheHits / cacheableMetrics.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create an in-process MCP server\r\n */\r\nexport function createInProcessServer(config: InProcessServerConfig): InProcessMCPServer {\r\n  return new InProcessMCPServer(config);\r\n}"],"names":["EventEmitter","logger","InProcessMCPServer","name","version","tools","metrics","context","enableMetrics","enableCaching","cache","config","Map","forEach","tool","registerTool","info","toolCount","size","has","warn","set","debug","emit","unregisterTool","deleted","delete","getToolNames","Array","from","keys","getTool","get","callTool","args","startTime","performance","now","success","cached","checkCache","Error","execContext","result","handler","isCacheable","cacheResult","content","type","text","JSON","stringify","isError","error","message","String","duration","recordMetric","toolName","timestamp","Date","transport","setContext","sessionId","getMetrics","getStats","stats","grouped","metric","push","totalCalls","length","successfulCalls","filter","m","durations","map","avgDuration","reduce","a","b","minDuration","Math","min","maxDuration","max","successRate","toolStats","averageDuration","sum","cacheHitRate","getCacheHitRate","clearMetrics","clearCache","clear","getInfo","cacheSize","slice","cacheKey","getCacheKey","ttl","undefined","getCacheTTL","firstKey","next","value","cacheableTools","includes","ttls","cacheableMetrics","likelyCacheHits","createInProcessServer"],"mappings":"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"}