{"version":3,"sources":["../../../src/resources/resource-manager.ts"],"sourcesContent":["/**\r\n * Comprehensive resource management system for swarm operations\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport type { IEventBus } from '../core/event-bus.js';\r\nimport type { AgentId, TaskId } from '../swarm/types.js';\r\nimport { generateId } from '../utils/helpers.js';\r\n\r\nexport interface ResourceManagerConfig {\r\n  enableResourcePooling: boolean;\r\n  enableResourceMonitoring: boolean;\r\n  enableAutoScaling: boolean;\r\n  enableQoS: boolean;\r\n  monitoringInterval: number;\r\n  cleanupInterval: number;\r\n  defaultLimits: ResourceLimits;\r\n  reservationTimeout: number;\r\n  allocationStrategy: 'first-fit' | 'best-fit' | 'worst-fit' | 'balanced';\r\n  priorityWeights: PriorityWeights;\r\n  enablePredictiveAllocation: boolean;\r\n  enableResourceSharing: boolean;\r\n  debugMode: boolean;\r\n}\r\n\r\nexport interface ResourceLimits {\r\n  cpu: number; // CPU cores\r\n  memory: number; // Bytes\r\n  disk: number; // Bytes\r\n  network: number; // Bytes per second\r\n  gpu?: number; // GPU units\r\n  custom: Record<string, number>;\r\n}\r\n\r\nexport interface PriorityWeights {\r\n  critical: number;\r\n  high: number;\r\n  normal: number;\r\n  low: number;\r\n  background: number;\r\n}\r\n\r\nexport interface Resource {\r\n  id: string;\r\n  type: ResourceType;\r\n  name: string;\r\n  description: string;\r\n  capacity: ResourceLimits;\r\n  allocated: ResourceLimits;\r\n  available: ResourceLimits;\r\n  status: ResourceStatus;\r\n  metadata: ResourceMetadata;\r\n  reservations: ResourceReservation[];\r\n  allocations: ResourceAllocation[];\r\n  sharable: boolean;\r\n  persistent: boolean;\r\n  cost: number;\r\n  location?: string;\r\n  tags: string[];\r\n}\r\n\r\nexport interface ResourcePool {\r\n  id: string;\r\n  name: string;\r\n  type: ResourceType;\r\n  resources: string[]; // Resource IDs\r\n  strategy: PoolStrategy;\r\n  loadBalancing: LoadBalancingStrategy;\r\n  scaling: ScalingConfig;\r\n  qos: QoSConfig;\r\n  statistics: PoolStatistics;\r\n  filters: ResourceFilter[];\r\n}\r\n\r\nexport interface ResourceReservation {\r\n  id: string;\r\n  resourceId: string;\r\n  agentId: AgentId;\r\n  taskId?: TaskId;\r\n  requirements: ResourceRequirements;\r\n  status: ReservationStatus;\r\n  priority: ResourcePriority;\r\n  createdAt: Date;\r\n  expiresAt?: Date;\r\n  activatedAt?: Date;\r\n  releasedAt?: Date;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface ResourceAllocation {\r\n  id: string;\r\n  reservationId: string;\r\n  resourceId: string;\r\n  agentId: AgentId;\r\n  taskId?: TaskId;\r\n  allocated: ResourceLimits;\r\n  actualUsage: ResourceUsage;\r\n  efficiency: number;\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  status: AllocationStatus;\r\n  qosViolations: QoSViolation[];\r\n}\r\n\r\nexport interface ResourceRequirements {\r\n  cpu?: ResourceSpec;\r\n  memory?: ResourceSpec;\r\n  disk?: ResourceSpec;\r\n  network?: ResourceSpec;\r\n  gpu?: ResourceSpec;\r\n  custom?: Record<string, ResourceSpec>;\r\n  constraints?: ResourceConstraints;\r\n  preferences?: ResourcePreferences;\r\n}\r\n\r\nexport interface ResourceSpec {\r\n  min: number;\r\n  max?: number;\r\n  preferred?: number;\r\n  unit: string;\r\n  shared?: boolean;\r\n  exclusive?: boolean;\r\n}\r\n\r\nexport interface ResourceConstraints {\r\n  location?: string[];\r\n  excludeLocation?: string[];\r\n  nodeAffinity?: NodeAffinity[];\r\n  antiAffinity?: AntiAffinity[];\r\n  timeWindow?: TimeWindow;\r\n  dependencies?: string[];\r\n  maxCost?: number;\r\n}\r\n\r\nexport interface ResourcePreferences {\r\n  location?: string;\r\n  performanceClass?: 'high' | 'medium' | 'low';\r\n  costOptimized?: boolean;\r\n  energyEfficient?: boolean;\r\n  highAvailability?: boolean;\r\n}\r\n\r\nexport interface ResourceUsage {\r\n  cpu: number;\r\n  memory: number;\r\n  disk: number;\r\n  network: number;\r\n  gpu?: number;\r\n  custom: Record<string, number>;\r\n  timestamp: Date;\r\n  duration: number;\r\n}\r\n\r\nexport interface ResourceMetadata {\r\n  provider: string;\r\n  region?: string;\r\n  zone?: string;\r\n  instance?: string;\r\n  capabilities: string[];\r\n  performance: PerformanceMetrics;\r\n  reliability: ReliabilityMetrics;\r\n  cost: CostMetrics;\r\n  lastUpdated: Date;\r\n}\r\n\r\nexport interface PerformanceMetrics {\r\n  cpuScore: number;\r\n  memoryBandwidth: number;\r\n  diskIOPS: number;\r\n  networkBandwidth: number;\r\n  gpuScore?: number;\r\n  benchmarkResults: Record<string, number>;\r\n}\r\n\r\nexport interface ReliabilityMetrics {\r\n  uptime: number;\r\n  meanTimeBetweenFailures: number;\r\n  errorRate: number;\r\n  lastFailure?: Date;\r\n  failureHistory: FailureRecord[];\r\n}\r\n\r\nexport interface CostMetrics {\r\n  hourlyRate: number;\r\n  dataTransferCost: number;\r\n  storageCost: number;\r\n  spotPricing?: boolean;\r\n  billing: BillingModel;\r\n}\r\n\r\nexport interface FailureRecord {\r\n  timestamp: Date;\r\n  type: string;\r\n  duration: number;\r\n  impact: 'low' | 'medium' | 'high' | 'critical';\r\n  resolved: boolean;\r\n}\r\n\r\nexport interface QoSConfig {\r\n  guarantees: QoSGuarantee[];\r\n  objectives: QoSObjective[];\r\n  violations: QoSViolationPolicy;\r\n}\r\n\r\nexport interface QoSGuarantee {\r\n  metric: string;\r\n  threshold: number;\r\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\r\n  priority: ResourcePriority;\r\n  penalty?: number;\r\n}\r\n\r\nexport interface QoSObjective {\r\n  metric: string;\r\n  target: number;\r\n  weight: number;\r\n  tolerance: number;\r\n}\r\n\r\nexport interface QoSViolation {\r\n  timestamp: Date;\r\n  metric: string;\r\n  expected: number;\r\n  actual: number;\r\n  severity: 'low' | 'medium' | 'high' | 'critical';\r\n  duration: number;\r\n  resolved: boolean;\r\n}\r\n\r\nexport interface QoSViolationPolicy {\r\n  autoRemediation: boolean;\r\n  escalationThreshold: number;\r\n  penaltyFunction: string;\r\n  notificationEnabled: boolean;\r\n}\r\n\r\nexport interface ScalingConfig {\r\n  enabled: boolean;\r\n  minResources: number;\r\n  maxResources: number;\r\n  scaleUpThreshold: number;\r\n  scaleDownThreshold: number;\r\n  cooldownPeriod: number;\r\n  metrics: ScalingMetric[];\r\n}\r\n\r\nexport interface ScalingMetric {\r\n  name: string;\r\n  weight: number;\r\n  threshold: number;\r\n  aggregation: 'avg' | 'max' | 'min' | 'sum';\r\n}\r\n\r\nexport interface PoolStatistics {\r\n  totalResources: number;\r\n  availableResources: number;\r\n  utilizationRate: number;\r\n  allocationSuccessRate: number;\r\n  averageWaitTime: number;\r\n  throughput: number;\r\n  efficiency: number;\r\n  costPerHour: number;\r\n  qosScore: number;\r\n}\r\n\r\nexport interface NodeAffinity {\r\n  key: string;\r\n  operator: 'in' | 'notin' | 'exists' | 'notexists';\r\n  values?: string[];\r\n}\r\n\r\nexport interface AntiAffinity {\r\n  type: 'agent' | 'task' | 'resource';\r\n  scope: 'node' | 'zone' | 'region';\r\n  weight: number;\r\n}\r\n\r\nexport interface TimeWindow {\r\n  start: Date;\r\n  end: Date;\r\n  timezone?: string;\r\n}\r\n\r\nexport interface ResourceFilter {\r\n  id: string;\r\n  name: string;\r\n  enabled: boolean;\r\n  conditions: FilterCondition[];\r\n  action: 'include' | 'exclude' | 'prioritize' | 'deprioritize';\r\n}\r\n\r\nexport interface FilterCondition {\r\n  field: string;\r\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches';\r\n  value: any;\r\n}\r\n\r\nexport type ResourceType = 'compute' | 'storage' | 'network' | 'memory' | 'gpu' | 'custom';\r\nexport type ResourceStatus =\r\n  | 'available'\r\n  | 'allocated'\r\n  | 'reserved'\r\n  | 'maintenance'\r\n  | 'failed'\r\n  | 'offline';\r\nexport type ResourcePriority = 'critical' | 'high' | 'normal' | 'low' | 'background';\r\nexport type ReservationStatus =\r\n  | 'pending'\r\n  | 'confirmed'\r\n  | 'active'\r\n  | 'expired'\r\n  | 'cancelled'\r\n  | 'failed';\r\nexport type AllocationStatus = 'active' | 'completed' | 'failed' | 'terminated' | 'suspended';\r\nexport type PoolStrategy = 'round-robin' | 'least-loaded' | 'performance-based' | 'cost-optimized';\r\nexport type LoadBalancingStrategy =\r\n  | 'round-robin'\r\n  | 'weighted'\r\n  | 'least-connections'\r\n  | 'resource-based';\r\nexport type BillingModel = 'hourly' | 'per-usage' | 'reserved' | 'spot' | 'hybrid';\r\n\r\n/**\r\n * Comprehensive resource management with allocation, monitoring, and optimization\r\n */\r\nexport class ResourceManager extends EventEmitter {\r\n  private logger: ILogger;\r\n  private eventBus: IEventBus;\r\n  private config: ResourceManagerConfig;\r\n\r\n  // Resource tracking\r\n  private resources = new Map<string, Resource>();\r\n  private pools = new Map<string, ResourcePool>();\r\n  private reservations = new Map<string, ResourceReservation>();\r\n  private allocations = new Map<string, ResourceAllocation>();\r\n\r\n  // Monitoring and optimization\r\n  private usageHistory = new Map<string, ResourceUsage[]>();\r\n  private predictions = new Map<string, ResourcePrediction>();\r\n  private optimizer: ResourceOptimizer;\r\n\r\n  // Scheduling and cleanup\r\n  private monitoringInterval?: NodeJS.Timeout;\r\n  private cleanupInterval?: NodeJS.Timeout;\r\n  private scalingInterval?: NodeJS.Timeout;\r\n\r\n  // Performance tracking\r\n  private metrics: ResourceManagerMetrics;\r\n\r\n  constructor(config: Partial<ResourceManagerConfig>, logger: ILogger, eventBus: IEventBus) {\r\n    super();\r\n    this.logger = logger;\r\n    this.eventBus = eventBus;\r\n\r\n    this.config = {\r\n      enableResourcePooling: true,\r\n      enableResourceMonitoring: true,\r\n      enableAutoScaling: true,\r\n      enableQoS: true,\r\n      monitoringInterval: 30000,\r\n      cleanupInterval: 300000,\r\n      defaultLimits: {\r\n        cpu: 4.0,\r\n        memory: 8 * 1024 * 1024 * 1024, // 8GB\r\n        disk: 100 * 1024 * 1024 * 1024, // 100GB\r\n        network: 1024 * 1024 * 1024, // 1Gbps\r\n        custom: {},\r\n      },\r\n      reservationTimeout: 300000, // 5 minutes\r\n      allocationStrategy: 'best-fit',\r\n      priorityWeights: {\r\n        critical: 1.0,\r\n        high: 0.8,\r\n        normal: 0.6,\r\n        low: 0.4,\r\n        background: 0.2,\r\n      },\r\n      enablePredictiveAllocation: true,\r\n      enableResourceSharing: true,\r\n      debugMode: false,\r\n      ...config,\r\n    };\r\n\r\n    this.optimizer = new ResourceOptimizer(this.config, this.logger);\r\n    this.metrics = new ResourceManagerMetrics();\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.eventBus.on('agent:resource-request', (data) => {\r\n      this.handleResourceRequest(data);\r\n    });\r\n\r\n    this.eventBus.on('agent:resource-release', (data) => {\r\n      this.handleResourceRelease(data);\r\n    });\r\n\r\n    this.eventBus.on('resource:usage-update', (data) => {\r\n      this.updateResourceUsage(data.resourceId, data.usage);\r\n    });\r\n\r\n    this.eventBus.on('resource:failure', (data) => {\r\n      this.handleResourceFailure(data);\r\n    });\r\n\r\n    this.eventBus.on('scaling:trigger', (data) => {\r\n      this.handleScalingTrigger(data);\r\n    });\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing resource manager', {\r\n      pooling: this.config.enableResourcePooling,\r\n      monitoring: this.config.enableResourceMonitoring,\r\n      autoScaling: this.config.enableAutoScaling,\r\n    });\r\n\r\n    // Initialize optimizer\r\n    await this.optimizer.initialize();\r\n\r\n    // Create default resource pools\r\n    await this.createDefaultPools();\r\n\r\n    // Start monitoring\r\n    if (this.config.enableResourceMonitoring) {\r\n      this.startMonitoring();\r\n    }\r\n\r\n    // Start cleanup\r\n    this.startCleanup();\r\n\r\n    // Start auto-scaling\r\n    if (this.config.enableAutoScaling) {\r\n      this.startAutoScaling();\r\n    }\r\n\r\n    this.emit('resource-manager:initialized');\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down resource manager');\r\n\r\n    // Stop intervals\r\n    if (this.monitoringInterval) clearInterval(this.monitoringInterval);\r\n    if (this.cleanupInterval) clearInterval(this.cleanupInterval);\r\n    if (this.scalingInterval) clearInterval(this.scalingInterval);\r\n\r\n    // Release all active allocations\r\n    await this.releaseAllAllocations();\r\n\r\n    // Shutdown optimizer\r\n    await this.optimizer.shutdown();\r\n\r\n    this.emit('resource-manager:shutdown');\r\n  }\r\n\r\n  // === RESOURCE MANAGEMENT ===\r\n\r\n  async registerResource(\r\n    type: ResourceType,\r\n    name: string,\r\n    capacity: ResourceLimits,\r\n    metadata: Partial<ResourceMetadata> = {},\r\n  ): Promise<string> {\r\n    const resourceId = generateId('resource');\r\n\r\n    const resource: Resource = {\r\n      id: resourceId,\r\n      type,\r\n      name,\r\n      description: `${type} resource: ${name}`,\r\n      capacity,\r\n      allocated: this.createEmptyLimits(),\r\n      available: { ...capacity },\r\n      status: 'available',\r\n      metadata: {\r\n        provider: 'local',\r\n        capabilities: [],\r\n        performance: this.createDefaultPerformanceMetrics(),\r\n        reliability: this.createDefaultReliabilityMetrics(),\r\n        cost: this.createDefaultCostMetrics(),\r\n        lastUpdated: new Date(),\r\n        ...metadata,\r\n      },\r\n      reservations: [],\r\n      allocations: [],\r\n      sharable: this.config.enableResourceSharing,\r\n      persistent: true,\r\n      cost: 1.0,\r\n      tags: [],\r\n    };\r\n\r\n    this.resources.set(resourceId, resource);\r\n\r\n    this.logger.info('Resource registered', {\r\n      resourceId,\r\n      type,\r\n      name,\r\n      capacity,\r\n    });\r\n\r\n    this.emit('resource:registered', { resource });\r\n\r\n    return resourceId;\r\n  }\r\n\r\n  async unregisterResource(resourceId: string): Promise<void> {\r\n    const resource = this.resources.get(resourceId);\r\n    if (!resource) {\r\n      throw new Error(`Resource ${resourceId} not found`);\r\n    }\r\n\r\n    // Check for active allocations\r\n    if (resource.allocations.length > 0) {\r\n      throw new Error(`Cannot unregister resource ${resourceId}: has active allocations`);\r\n    }\r\n\r\n    // Cancel pending reservations\r\n    for (const reservation of resource.reservations) {\r\n      await this.cancelReservation(reservation.id, 'resource_unregistered');\r\n    }\r\n\r\n    this.resources.delete(resourceId);\r\n\r\n    this.logger.info('Resource unregistered', { resourceId });\r\n    this.emit('resource:unregistered', { resourceId });\r\n  }\r\n\r\n  // === RESOURCE ALLOCATION ===\r\n\r\n  async requestResources(\r\n    agentId: AgentId,\r\n    requirements: ResourceRequirements,\r\n    options: {\r\n      taskId?: TaskId;\r\n      priority?: ResourcePriority;\r\n      timeout?: number;\r\n      preemptible?: boolean;\r\n    } = {},\r\n  ): Promise<string> {\r\n    const reservationId = generateId('reservation');\r\n    const now = new Date();\r\n\r\n    const reservation: ResourceReservation = {\r\n      id: reservationId,\r\n      resourceId: '', // Will be set when resource is found\r\n      agentId,\r\n      taskId: options.taskId,\r\n      requirements,\r\n      status: 'pending',\r\n      priority: options.priority || 'normal',\r\n      createdAt: now,\r\n      expiresAt: options.timeout\r\n        ? new Date(now.getTime() + options.timeout)\r\n        : new Date(now.getTime() + this.config.reservationTimeout),\r\n      metadata: {\r\n        preemptible: options.preemptible || false,\r\n      },\r\n    };\r\n\r\n    this.reservations.set(reservationId, reservation);\r\n\r\n    try {\r\n      // Find suitable resource\r\n      const resource = await this.findSuitableResource(requirements, reservation.priority);\r\n\r\n      if (!resource) {\r\n        reservation.status = 'failed';\r\n        throw new Error('No suitable resource available');\r\n      }\r\n\r\n      // Reserve resource\r\n      reservation.resourceId = resource.id;\r\n      resource.reservations.push(reservation);\r\n\r\n      // Update availability\r\n      this.updateResourceAvailability(resource);\r\n\r\n      reservation.status = 'confirmed';\r\n\r\n      this.logger.info('Resource reservation created', {\r\n        reservationId,\r\n        resourceId: resource.id,\r\n        agentId: agentId.id,\r\n        requirements,\r\n      });\r\n\r\n      this.emit('reservation:created', { reservation });\r\n\r\n      // Auto-activate if possible\r\n      if (this.canActivateReservation(reservation)) {\r\n        await this.activateReservation(reservationId);\r\n      }\r\n\r\n      return reservationId;\r\n    } catch (error) {\r\n      reservation.status = 'failed';\r\n      this.logger.error('Resource reservation failed', {\r\n        reservationId,\r\n        agentId: agentId.id,\r\n        error,\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async activateReservation(reservationId: string): Promise<string> {\r\n    const reservation = this.reservations.get(reservationId);\r\n    if (!reservation) {\r\n      throw new Error(`Reservation ${reservationId} not found`);\r\n    }\r\n\r\n    if (reservation.status !== 'confirmed') {\r\n      throw new Error(`Reservation ${reservationId} is not confirmed`);\r\n    }\r\n\r\n    const resource = this.resources.get(reservation.resourceId);\r\n    if (!resource) {\r\n      throw new Error(`Resource ${reservation.resourceId} not found`);\r\n    }\r\n\r\n    // Create allocation\r\n    const allocationId = generateId('allocation');\r\n\r\n    const allocation: ResourceAllocation = {\r\n      id: allocationId,\r\n      reservationId,\r\n      resourceId: resource.id,\r\n      agentId: reservation.agentId,\r\n      taskId: reservation.taskId,\r\n      allocated: this.calculateAllocation(reservation.requirements, resource),\r\n      actualUsage: this.createEmptyUsage(),\r\n      efficiency: 1.0,\r\n      startTime: new Date(),\r\n      status: 'active',\r\n      qosViolations: [],\r\n    };\r\n\r\n    this.allocations.set(allocationId, allocation);\r\n    resource.allocations.push(allocation);\r\n\r\n    // Update resource allocated amounts\r\n    this.addToResourceLimits(resource.allocated, allocation.allocated);\r\n    this.updateResourceAvailability(resource);\r\n\r\n    // Update reservation status\r\n    reservation.status = 'active';\r\n    reservation.activatedAt = new Date();\r\n\r\n    this.logger.info('Resource allocation activated', {\r\n      allocationId,\r\n      reservationId,\r\n      resourceId: resource.id,\r\n      agentId: reservation.agentId.id,\r\n      allocated: allocation.allocated,\r\n    });\r\n\r\n    this.emit('allocation:activated', { allocation });\r\n\r\n    return allocationId;\r\n  }\r\n\r\n  async releaseResources(allocationId: string, reason: string = 'completed'): Promise<void> {\r\n    const allocation = this.allocations.get(allocationId);\r\n    if (!allocation) {\r\n      throw new Error(`Allocation ${allocationId} not found`);\r\n    }\r\n\r\n    const resource = this.resources.get(allocation.resourceId);\r\n    if (!resource) {\r\n      throw new Error(`Resource ${allocation.resourceId} not found`);\r\n    }\r\n\r\n    // Update allocation status\r\n    allocation.status = 'completed';\r\n    allocation.endTime = new Date();\r\n\r\n    // Calculate final efficiency\r\n    allocation.efficiency = this.calculateEfficiency(allocation);\r\n\r\n    // Remove from resource allocated amounts\r\n    this.subtractFromResourceLimits(resource.allocated, allocation.allocated);\r\n\r\n    // Remove allocation from resource\r\n    resource.allocations = resource.allocations.filter((a) => a.id !== allocationId);\r\n\r\n    // Update resource availability\r\n    this.updateResourceAvailability(resource);\r\n\r\n    // Update reservation if exists\r\n    const reservation = this.reservations.get(allocation.reservationId);\r\n    if (reservation) {\r\n      reservation.releasedAt = new Date();\r\n    }\r\n\r\n    this.logger.info('Resource allocation released', {\r\n      allocationId,\r\n      resourceId: resource.id,\r\n      agentId: allocation.agentId.id,\r\n      reason,\r\n      efficiency: allocation.efficiency,\r\n    });\r\n\r\n    this.emit('allocation:released', { allocation, reason });\r\n\r\n    // Update metrics\r\n    this.metrics.recordAllocationReleased(allocation);\r\n  }\r\n\r\n  async cancelReservation(reservationId: string, reason: string = 'cancelled'): Promise<void> {\r\n    const reservation = this.reservations.get(reservationId);\r\n    if (!reservation) {\r\n      throw new Error(`Reservation ${reservationId} not found`);\r\n    }\r\n\r\n    // If reservation is active, release the allocation first\r\n    if (reservation.status === 'active') {\r\n      const allocation = Array.from(this.allocations.values()).find(\r\n        (a) => a.reservationId === reservationId,\r\n      );\r\n\r\n      if (allocation) {\r\n        await this.releaseResources(allocation.id, reason);\r\n      }\r\n    }\r\n\r\n    // Update reservation status\r\n    reservation.status = 'cancelled';\r\n\r\n    // Remove from resource if it was reserved\r\n    if (reservation.resourceId) {\r\n      const resource = this.resources.get(reservation.resourceId);\r\n      if (resource) {\r\n        resource.reservations = resource.reservations.filter((r) => r.id !== reservationId);\r\n        this.updateResourceAvailability(resource);\r\n      }\r\n    }\r\n\r\n    this.logger.info('Resource reservation cancelled', {\r\n      reservationId,\r\n      reason,\r\n    });\r\n\r\n    this.emit('reservation:cancelled', { reservation, reason });\r\n  }\r\n\r\n  // === RESOURCE POOLS ===\r\n\r\n  async createResourcePool(\r\n    name: string,\r\n    type: ResourceType,\r\n    resourceIds: string[],\r\n    strategy: PoolStrategy = 'least-loaded',\r\n  ): Promise<string> {\r\n    const poolId = generateId('pool');\r\n\r\n    // Validate resources exist and are of correct type\r\n    for (const resourceId of resourceIds) {\r\n      const resource = this.resources.get(resourceId);\r\n      if (!resource) {\r\n        throw new Error(`Resource ${resourceId} not found`);\r\n      }\r\n      if (resource.type !== type) {\r\n        throw new Error(\r\n          `Resource ${resourceId} type mismatch: expected ${type}, got ${resource.type}`,\r\n        );\r\n      }\r\n    }\r\n\r\n    const pool: ResourcePool = {\r\n      id: poolId,\r\n      name,\r\n      type,\r\n      resources: [...resourceIds],\r\n      strategy,\r\n      loadBalancing: 'least-connections',\r\n      scaling: {\r\n        enabled: this.config.enableAutoScaling,\r\n        minResources: Math.max(1, resourceIds.length),\r\n        maxResources: resourceIds.length * 3,\r\n        scaleUpThreshold: 0.8,\r\n        scaleDownThreshold: 0.3,\r\n        cooldownPeriod: 300000,\r\n        metrics: [\r\n          { name: 'utilization', weight: 1.0, threshold: 0.8, aggregation: 'avg' },\r\n          { name: 'queue_depth', weight: 0.5, threshold: 10, aggregation: 'max' },\r\n        ],\r\n      },\r\n      qos: {\r\n        guarantees: [],\r\n        objectives: [],\r\n        violations: {\r\n          autoRemediation: true,\r\n          escalationThreshold: 3,\r\n          penaltyFunction: 'linear',\r\n          notificationEnabled: true,\r\n        },\r\n      },\r\n      statistics: this.createPoolStatistics(),\r\n      filters: [],\r\n    };\r\n\r\n    this.pools.set(poolId, pool);\r\n\r\n    this.logger.info('Resource pool created', {\r\n      poolId,\r\n      name,\r\n      type,\r\n      resourceCount: resourceIds.length,\r\n    });\r\n\r\n    this.emit('pool:created', { pool });\r\n\r\n    return poolId;\r\n  }\r\n\r\n  async addResourceToPool(poolId: string, resourceId: string): Promise<void> {\r\n    const pool = this.pools.get(poolId);\r\n    if (!pool) {\r\n      throw new Error(`Pool ${poolId} not found`);\r\n    }\r\n\r\n    const resource = this.resources.get(resourceId);\r\n    if (!resource) {\r\n      throw new Error(`Resource ${resourceId} not found`);\r\n    }\r\n\r\n    if (resource.type !== pool.type) {\r\n      throw new Error(\r\n        `Resource type mismatch: pool expects ${pool.type}, resource is ${resource.type}`,\r\n      );\r\n    }\r\n\r\n    if (!pool.resources.includes(resourceId)) {\r\n      pool.resources.push(resourceId);\r\n      this.updatePoolStatistics(pool);\r\n    }\r\n\r\n    this.logger.info('Resource added to pool', { poolId, resourceId });\r\n    this.emit('pool:resource-added', { poolId, resourceId });\r\n  }\r\n\r\n  async removeResourceFromPool(poolId: string, resourceId: string): Promise<void> {\r\n    const pool = this.pools.get(poolId);\r\n    if (!pool) {\r\n      throw new Error(`Pool ${poolId} not found`);\r\n    }\r\n\r\n    if (pool.resources.length <= pool.scaling.minResources) {\r\n      throw new Error(`Cannot remove resource: pool would go below minimum size`);\r\n    }\r\n\r\n    pool.resources = pool.resources.filter((id) => id !== resourceId);\r\n    this.updatePoolStatistics(pool);\r\n\r\n    this.logger.info('Resource removed from pool', { poolId, resourceId });\r\n    this.emit('pool:resource-removed', { poolId, resourceId });\r\n  }\r\n\r\n  // === RESOURCE DISCOVERY AND ALLOCATION ===\r\n\r\n  private async findSuitableResource(\r\n    requirements: ResourceRequirements,\r\n    priority: ResourcePriority,\r\n  ): Promise<Resource | null> {\r\n    const candidates: Array<{ resource: Resource; score: number }> = [];\r\n\r\n    for (const resource of this.resources.values()) {\r\n      if (resource.status !== 'available') continue;\r\n\r\n      const score = this.calculateResourceScore(resource, requirements, priority);\r\n      if (score > 0) {\r\n        candidates.push({ resource, score });\r\n      }\r\n    }\r\n\r\n    if (candidates.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Sort by score (highest first)\r\n    candidates.sort((a, b) => b.score - a.score);\r\n\r\n    // Apply allocation strategy\r\n    return this.selectResourceByStrategy(candidates, requirements);\r\n  }\r\n\r\n  private calculateResourceScore(\r\n    resource: Resource,\r\n    requirements: ResourceRequirements,\r\n    priority: ResourcePriority,\r\n  ): number {\r\n    let score = 0;\r\n\r\n    // Check if resource can satisfy requirements\r\n    if (!this.canSatisfyRequirements(resource, requirements)) {\r\n      return 0;\r\n    }\r\n\r\n    // Base score from resource utilization (prefer less utilized)\r\n    const utilization = this.calculateResourceUtilization(resource);\r\n    score += (1 - utilization) * 100;\r\n\r\n    // Performance score\r\n    score += resource.metadata.performance.cpuScore * 10;\r\n\r\n    // Reliability score\r\n    score += resource.metadata.reliability.uptime * 50;\r\n\r\n    // Cost efficiency (lower cost is better)\r\n    score += (1 / resource.cost) * 20;\r\n\r\n    // Priority adjustment\r\n    const priorityWeight = this.config.priorityWeights[priority] || 1.0;\r\n    score *= priorityWeight;\r\n\r\n    return score;\r\n  }\r\n\r\n  private canSatisfyRequirements(resource: Resource, requirements: ResourceRequirements): boolean {\r\n    // Check CPU\r\n    if (requirements.cpu && requirements.cpu.min > resource.available.cpu) {\r\n      return false;\r\n    }\r\n\r\n    // Check memory\r\n    if (requirements.memory && requirements.memory.min > resource.available.memory) {\r\n      return false;\r\n    }\r\n\r\n    // Check disk\r\n    if (requirements.disk && requirements.disk.min > resource.available.disk) {\r\n      return false;\r\n    }\r\n\r\n    // Check network\r\n    if (requirements.network && requirements.network.min > resource.available.network) {\r\n      return false;\r\n    }\r\n\r\n    // Check custom resources\r\n    if (requirements.custom) {\r\n      for (const [name, spec] of Object.entries(requirements.custom)) {\r\n        const available = resource.available.custom[name] || 0;\r\n        if (spec.min > available) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check constraints\r\n    if (requirements.constraints) {\r\n      if (!this.checkConstraints(resource, requirements.constraints)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private checkConstraints(resource: Resource, constraints: ResourceConstraints): boolean {\r\n    // Location constraints\r\n    if (constraints.location && constraints.location.length > 0) {\r\n      if (!constraints.location.includes(resource.location || '')) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (constraints.excludeLocation && constraints.excludeLocation.length > 0) {\r\n      if (constraints.excludeLocation.includes(resource.location || '')) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Cost constraints\r\n    if (constraints.maxCost && resource.cost > constraints.maxCost) {\r\n      return false;\r\n    }\r\n\r\n    // Time window constraints\r\n    if (constraints.timeWindow) {\r\n      const now = new Date();\r\n      if (now < constraints.timeWindow.start || now > constraints.timeWindow.end) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private selectResourceByStrategy(\r\n    candidates: Array<{ resource: Resource; score: number }>,\r\n    requirements: ResourceRequirements,\r\n  ): Resource {\r\n    switch (this.config.allocationStrategy) {\r\n      case 'first-fit':\r\n        return candidates[0].resource;\r\n\r\n      case 'best-fit':\r\n        // Find resource with smallest waste\r\n        return candidates.reduce((best, current) => {\r\n          const bestWaste = this.calculateWaste(best.resource, requirements);\r\n          const currentWaste = this.calculateWaste(current.resource, requirements);\r\n          return currentWaste < bestWaste ? current : best;\r\n        }).resource;\r\n\r\n      case 'worst-fit':\r\n        // Find resource with largest waste (for fragmentation avoidance)\r\n        return candidates.reduce((worst, current) => {\r\n          const worstWaste = this.calculateWaste(worst.resource, requirements);\r\n          const currentWaste = this.calculateWaste(current.resource, requirements);\r\n          return currentWaste > worstWaste ? current : worst;\r\n        }).resource;\r\n\r\n      case 'balanced':\r\n      default:\r\n        // Use highest score (balanced approach)\r\n        return candidates[0].resource;\r\n    }\r\n  }\r\n\r\n  private calculateWaste(resource: Resource, requirements: ResourceRequirements): number {\r\n    let waste = 0;\r\n\r\n    if (requirements.cpu) {\r\n      waste += Math.max(0, resource.available.cpu - requirements.cpu.min);\r\n    }\r\n\r\n    if (requirements.memory) {\r\n      waste += Math.max(0, resource.available.memory - requirements.memory.min);\r\n    }\r\n\r\n    return waste;\r\n  }\r\n\r\n  private calculateAllocation(\r\n    requirements: ResourceRequirements,\r\n    resource: Resource,\r\n  ): ResourceLimits {\r\n    const allocation: ResourceLimits = {\r\n      cpu: 0,\r\n      memory: 0,\r\n      disk: 0,\r\n      network: 0,\r\n      custom: {},\r\n    };\r\n\r\n    if (requirements.cpu) {\r\n      allocation.cpu = Math.min(\r\n        requirements.cpu.preferred || requirements.cpu.min,\r\n        resource.available.cpu,\r\n      );\r\n    }\r\n\r\n    if (requirements.memory) {\r\n      allocation.memory = Math.min(\r\n        requirements.memory.preferred || requirements.memory.min,\r\n        resource.available.memory,\r\n      );\r\n    }\r\n\r\n    if (requirements.disk) {\r\n      allocation.disk = Math.min(\r\n        requirements.disk.preferred || requirements.disk.min,\r\n        resource.available.disk,\r\n      );\r\n    }\r\n\r\n    if (requirements.network) {\r\n      allocation.network = Math.min(\r\n        requirements.network.preferred || requirements.network.min,\r\n        resource.available.network,\r\n      );\r\n    }\r\n\r\n    if (requirements.custom) {\r\n      for (const [name, spec] of Object.entries(requirements.custom)) {\r\n        const available = resource.available.custom[name] || 0;\r\n        allocation.custom[name] = Math.min(spec.preferred || spec.min, available);\r\n      }\r\n    }\r\n\r\n    return allocation;\r\n  }\r\n\r\n  // === MONITORING AND OPTIMIZATION ===\r\n\r\n  private startMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performMonitoring();\r\n    }, this.config.monitoringInterval);\r\n\r\n    this.logger.info('Started resource monitoring', {\r\n      interval: this.config.monitoringInterval,\r\n    });\r\n  }\r\n\r\n  private startCleanup(): void {\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.performCleanup();\r\n    }, this.config.cleanupInterval);\r\n\r\n    this.logger.info('Started resource cleanup', {\r\n      interval: this.config.cleanupInterval,\r\n    });\r\n  }\r\n\r\n  private startAutoScaling(): void {\r\n    this.scalingInterval = setInterval(() => {\r\n      this.evaluateScaling();\r\n    }, 60000); // Every minute\r\n\r\n    this.logger.info('Started auto-scaling');\r\n  }\r\n\r\n  private async performMonitoring(): Promise<void> {\r\n    try {\r\n      // Update resource statistics\r\n      for (const resource of this.resources.values()) {\r\n        await this.updateResourceStatistics(resource);\r\n      }\r\n\r\n      // Update pool statistics\r\n      for (const pool of this.pools.values()) {\r\n        this.updatePoolStatistics(pool);\r\n      }\r\n\r\n      // Check QoS violations\r\n      if (this.config.enableQoS) {\r\n        await this.checkQoSViolations();\r\n      }\r\n\r\n      // Predictive analysis\r\n      if (this.config.enablePredictiveAllocation) {\r\n        await this.updatePredictions();\r\n      }\r\n\r\n      // Emit monitoring update\r\n      this.emit('monitoring:updated', {\r\n        resources: this.resources.size,\r\n        pools: this.pools.size,\r\n        allocations: this.allocations.size,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Monitoring failed', error);\r\n    }\r\n  }\r\n\r\n  private async performCleanup(): Promise<void> {\r\n    const now = new Date();\r\n\r\n    // Clean up expired reservations\r\n    const expiredReservations = Array.from(this.reservations.values()).filter(\r\n      (r) => r.expiresAt && r.expiresAt < now && r.status === 'pending',\r\n    );\r\n\r\n    for (const reservation of expiredReservations) {\r\n      await this.cancelReservation(reservation.id, 'expired');\r\n    }\r\n\r\n    // Clean up old usage history\r\n    const cutoff = new Date(now.getTime() - 86400000); // 24 hours\r\n    for (const [resourceId, history] of this.usageHistory) {\r\n      this.usageHistory.set(\r\n        resourceId,\r\n        history.filter((usage) => usage.timestamp > cutoff),\r\n      );\r\n    }\r\n\r\n    this.logger.debug('Cleanup completed', {\r\n      expiredReservations: expiredReservations.length,\r\n    });\r\n  }\r\n\r\n  private async evaluateScaling(): Promise<void> {\r\n    for (const pool of this.pools.values()) {\r\n      if (!pool.scaling.enabled) continue;\r\n\r\n      const metrics = this.calculatePoolMetrics(pool);\r\n      const shouldScale = this.shouldScale(pool, metrics);\r\n\r\n      if (shouldScale.action === 'scale-up') {\r\n        await this.scalePoolUp(pool);\r\n      } else if (shouldScale.action === 'scale-down') {\r\n        await this.scalePoolDown(pool);\r\n      }\r\n    }\r\n  }\r\n\r\n  // === UTILITY METHODS ===\r\n\r\n  private canActivateReservation(reservation: ResourceReservation): boolean {\r\n    const resource = this.resources.get(reservation.resourceId);\r\n    if (!resource) return false;\r\n\r\n    return this.canSatisfyRequirements(resource, reservation.requirements);\r\n  }\r\n\r\n  private calculateResourceUtilization(resource: Resource): number {\r\n    let totalCapacity = 0;\r\n    let totalAllocated = 0;\r\n\r\n    // CPU utilization\r\n    totalCapacity += resource.capacity.cpu;\r\n    totalAllocated += resource.allocated.cpu;\r\n\r\n    // Memory utilization\r\n    totalCapacity += resource.capacity.memory / (1024 * 1024); // Convert to MB for comparison\r\n    totalAllocated += resource.allocated.memory / (1024 * 1024);\r\n\r\n    return totalCapacity > 0 ? totalAllocated / totalCapacity : 0;\r\n  }\r\n\r\n  private calculateEfficiency(allocation: ResourceAllocation): number {\r\n    if (!allocation.endTime) return 0;\r\n\r\n    const duration = allocation.endTime.getTime() - allocation.startTime.getTime();\r\n    if (duration <= 0) return 0;\r\n\r\n    // Calculate efficiency based on actual usage vs allocated\r\n    let efficiencySum = 0;\r\n    let factors = 0;\r\n\r\n    if (allocation.allocated.cpu > 0) {\r\n      efficiencySum += allocation.actualUsage.cpu / allocation.allocated.cpu;\r\n      factors++;\r\n    }\r\n\r\n    if (allocation.allocated.memory > 0) {\r\n      efficiencySum += allocation.actualUsage.memory / allocation.allocated.memory;\r\n      factors++;\r\n    }\r\n\r\n    return factors > 0 ? efficiencySum / factors : 1.0;\r\n  }\r\n\r\n  private updateResourceAvailability(resource: Resource): void {\r\n    resource.available = {\r\n      cpu: Math.max(0, resource.capacity.cpu - resource.allocated.cpu),\r\n      memory: Math.max(0, resource.capacity.memory - resource.allocated.memory),\r\n      disk: Math.max(0, resource.capacity.disk - resource.allocated.disk),\r\n      network: Math.max(0, resource.capacity.network - resource.allocated.network),\r\n      custom: {},\r\n    };\r\n\r\n    // Update custom resources\r\n    for (const [name, capacity] of Object.entries(resource.capacity.custom)) {\r\n      const allocated = resource.allocated.custom[name] || 0;\r\n      resource.available.custom[name] = Math.max(0, capacity - allocated);\r\n    }\r\n  }\r\n\r\n  private addToResourceLimits(target: ResourceLimits, source: ResourceLimits): void {\r\n    target.cpu += source.cpu;\r\n    target.memory += source.memory;\r\n    target.disk += source.disk;\r\n    target.network += source.network;\r\n\r\n    for (const [name, value] of Object.entries(source.custom)) {\r\n      target.custom[name] = (target.custom[name] || 0) + value;\r\n    }\r\n  }\r\n\r\n  private subtractFromResourceLimits(target: ResourceLimits, source: ResourceLimits): void {\r\n    target.cpu = Math.max(0, target.cpu - source.cpu);\r\n    target.memory = Math.max(0, target.memory - source.memory);\r\n    target.disk = Math.max(0, target.disk - source.disk);\r\n    target.network = Math.max(0, target.network - source.network);\r\n\r\n    for (const [name, value] of Object.entries(source.custom)) {\r\n      target.custom[name] = Math.max(0, (target.custom[name] || 0) - value);\r\n    }\r\n  }\r\n\r\n  private createEmptyLimits(): ResourceLimits {\r\n    return {\r\n      cpu: 0,\r\n      memory: 0,\r\n      disk: 0,\r\n      network: 0,\r\n      custom: {},\r\n    };\r\n  }\r\n\r\n  private createEmptyUsage(): ResourceUsage {\r\n    return {\r\n      cpu: 0,\r\n      memory: 0,\r\n      disk: 0,\r\n      network: 0,\r\n      custom: {},\r\n      timestamp: new Date(),\r\n      duration: 0,\r\n    };\r\n  }\r\n\r\n  private createDefaultPerformanceMetrics(): PerformanceMetrics {\r\n    return {\r\n      cpuScore: 1.0,\r\n      memoryBandwidth: 1000000000, // 1GB/s\r\n      diskIOPS: 1000,\r\n      networkBandwidth: 1000000000, // 1Gbps\r\n      benchmarkResults: {},\r\n    };\r\n  }\r\n\r\n  private createDefaultReliabilityMetrics(): ReliabilityMetrics {\r\n    return {\r\n      uptime: 0.99,\r\n      meanTimeBetweenFailures: 8760, // 1 year in hours\r\n      errorRate: 0.01,\r\n      failureHistory: [],\r\n    };\r\n  }\r\n\r\n  private createDefaultCostMetrics(): CostMetrics {\r\n    return {\r\n      hourlyRate: 1.0,\r\n      dataTransferCost: 0.1,\r\n      storageCost: 0.1,\r\n      billing: 'hourly',\r\n    };\r\n  }\r\n\r\n  private createPoolStatistics(): PoolStatistics {\r\n    return {\r\n      totalResources: 0,\r\n      availableResources: 0,\r\n      utilizationRate: 0,\r\n      allocationSuccessRate: 100,\r\n      averageWaitTime: 0,\r\n      throughput: 0,\r\n      efficiency: 1.0,\r\n      costPerHour: 0,\r\n      qosScore: 100,\r\n    };\r\n  }\r\n\r\n  private async createDefaultPools(): Promise<void> {\r\n    // Create default compute pool if we have compute resources\r\n    const computeResources = Array.from(this.resources.values())\r\n      .filter((r) => r.type === 'compute')\r\n      .map((r) => r.id);\r\n\r\n    if (computeResources.length > 0) {\r\n      await this.createResourcePool('default-compute', 'compute', computeResources);\r\n    }\r\n  }\r\n\r\n  private updateResourceUsage(resourceId: string, usage: ResourceUsage): void {\r\n    const resource = this.resources.get(resourceId);\r\n    if (!resource) return;\r\n\r\n    // Store usage history\r\n    const history = this.usageHistory.get(resourceId) || [];\r\n    history.push(usage);\r\n\r\n    // Keep only last 1000 entries\r\n    if (history.length > 1000) {\r\n      history.shift();\r\n    }\r\n\r\n    this.usageHistory.set(resourceId, history);\r\n\r\n    // Update active allocations with actual usage\r\n    for (const allocation of resource.allocations) {\r\n      if (allocation.status === 'active') {\r\n        allocation.actualUsage = usage;\r\n        allocation.efficiency = this.calculateEfficiency(allocation);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async updateResourceStatistics(resource: Resource): Promise<void> {\r\n    // Update utilization\r\n    const utilization = this.calculateResourceUtilization(resource);\r\n\r\n    // Update performance metrics based on usage history\r\n    const history = this.usageHistory.get(resource.id) || [];\r\n    if (history.length > 0) {\r\n      const recent = history.slice(-10); // Last 10 measurements\r\n      const avgCpu = recent.reduce((sum, h) => sum + h.cpu, 0) / recent.length;\r\n\r\n      // Update performance score based on load\r\n      resource.metadata.performance.cpuScore = Math.max(0.1, 1.0 - avgCpu / 100);\r\n    }\r\n\r\n    resource.metadata.lastUpdated = new Date();\r\n  }\r\n\r\n  private updatePoolStatistics(pool: ResourcePool): void {\r\n    const resources = pool.resources\r\n      .map((id) => this.resources.get(id))\r\n      .filter(Boolean) as Resource[];\r\n\r\n    pool.statistics.totalResources = resources.length;\r\n    pool.statistics.availableResources = resources.filter((r) => r.status === 'available').length;\r\n\r\n    if (resources.length > 0) {\r\n      const totalUtilization = resources.reduce(\r\n        (sum, r) => sum + this.calculateResourceUtilization(r),\r\n        0,\r\n      );\r\n      pool.statistics.utilizationRate = totalUtilization / resources.length;\r\n\r\n      const totalCost = resources.reduce((sum, r) => sum + r.cost, 0);\r\n      pool.statistics.costPerHour = totalCost;\r\n    }\r\n  }\r\n\r\n  private async checkQoSViolations(): Promise<void> {\r\n    // Check QoS for all active allocations\r\n    for (const allocation of this.allocations.values()) {\r\n      if (allocation.status !== 'active') continue;\r\n\r\n      const resource = this.resources.get(allocation.resourceId);\r\n      if (!resource) continue;\r\n\r\n      // Find applicable pools\r\n      const pools = Array.from(this.pools.values()).filter((p) =>\r\n        p.resources.includes(resource.id),\r\n      );\r\n\r\n      for (const pool of pools) {\r\n        await this.checkPoolQoS(pool, allocation);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async checkPoolQoS(pool: ResourcePool, allocation: ResourceAllocation): Promise<void> {\r\n    for (const guarantee of pool.qos.guarantees) {\r\n      const value = this.getMetricValue(allocation, guarantee.metric);\r\n      const violated = this.evaluateQoSCondition(value, guarantee.operator, guarantee.threshold);\r\n\r\n      if (violated) {\r\n        const violation: QoSViolation = {\r\n          timestamp: new Date(),\r\n          metric: guarantee.metric,\r\n          expected: guarantee.threshold,\r\n          actual: value,\r\n          severity: this.calculateViolationSeverity(guarantee, value),\r\n          duration: 0, // Will be calculated over time\r\n          resolved: false,\r\n        };\r\n\r\n        allocation.qosViolations.push(violation);\r\n\r\n        this.logger.warn('QoS violation detected', {\r\n          allocationId: allocation.id,\r\n          metric: guarantee.metric,\r\n          expected: guarantee.threshold,\r\n          actual: value,\r\n        });\r\n\r\n        this.emit('qos:violation', { allocation, violation });\r\n\r\n        // Auto-remediation if enabled\r\n        if (pool.qos.violations.autoRemediation) {\r\n          await this.remediateQoSViolation(allocation, violation);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async updatePredictions(): Promise<void> {\r\n    for (const resource of this.resources.values()) {\r\n      const history = this.usageHistory.get(resource.id) || [];\r\n      if (history.length < 10) continue; // Need minimum history\r\n\r\n      const prediction = await this.optimizer.predictUsage(resource, history);\r\n      this.predictions.set(resource.id, prediction);\r\n    }\r\n  }\r\n\r\n  private calculatePoolMetrics(pool: ResourcePool): Record<string, number> {\r\n    const resources = pool.resources\r\n      .map((id) => this.resources.get(id))\r\n      .filter(Boolean) as Resource[];\r\n    const metrics: Record<string, number> = {};\r\n\r\n    if (resources.length === 0) return metrics;\r\n\r\n    // Calculate utilization\r\n    const totalUtilization = resources.reduce(\r\n      (sum, r) => sum + this.calculateResourceUtilization(r),\r\n      0,\r\n    );\r\n    metrics.utilization = totalUtilization / resources.length;\r\n\r\n    // Calculate queue depth (simplified)\r\n    const totalReservations = resources.reduce((sum, r) => sum + r.reservations.length, 0);\r\n    metrics.queue_depth = totalReservations;\r\n\r\n    return metrics;\r\n  }\r\n\r\n  private shouldScale(\r\n    pool: ResourcePool,\r\n    metrics: Record<string, number>,\r\n  ): { action: 'scale-up' | 'scale-down' | 'none'; reason: string } {\r\n    const scaling = pool.scaling;\r\n\r\n    // Check scale-up conditions\r\n    for (const metric of scaling.metrics) {\r\n      const value = metrics[metric.name] || 0;\r\n\r\n      if (metric.aggregation === 'avg' && value > metric.threshold) {\r\n        if (pool.resources.length < scaling.maxResources) {\r\n          return { action: 'scale-up', reason: `${metric.name} threshold exceeded` };\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check scale-down conditions\r\n    for (const metric of scaling.metrics) {\r\n      const value = metrics[metric.name] || 0;\r\n\r\n      if (metric.aggregation === 'avg' && value < scaling.scaleDownThreshold) {\r\n        if (pool.resources.length > scaling.minResources) {\r\n          return { action: 'scale-down', reason: `${metric.name} below threshold` };\r\n        }\r\n      }\r\n    }\r\n\r\n    return { action: 'none', reason: 'No scaling needed' };\r\n  }\r\n\r\n  private async scalePoolUp(pool: ResourcePool): Promise<void> {\r\n    this.logger.info('Scaling pool up', { poolId: pool.id });\r\n    // Implementation would add new resources to the pool\r\n    this.emit('pool:scaled-up', { pool });\r\n  }\r\n\r\n  private async scalePoolDown(pool: ResourcePool): Promise<void> {\r\n    this.logger.info('Scaling pool down', { poolId: pool.id });\r\n    // Implementation would remove underutilized resources from the pool\r\n    this.emit('pool:scaled-down', { pool });\r\n  }\r\n\r\n  private getMetricValue(allocation: ResourceAllocation, metric: string): number {\r\n    switch (metric) {\r\n      case 'cpu':\r\n        return allocation.actualUsage.cpu;\r\n      case 'memory':\r\n        return allocation.actualUsage.memory;\r\n      case 'efficiency':\r\n        return allocation.efficiency;\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  private evaluateQoSCondition(value: number, operator: string, threshold: number): boolean {\r\n    switch (operator) {\r\n      case 'gt':\r\n        return value > threshold;\r\n      case 'lt':\r\n        return value < threshold;\r\n      case 'eq':\r\n        return value === threshold;\r\n      case 'gte':\r\n        return value >= threshold;\r\n      case 'lte':\r\n        return value <= threshold;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private calculateViolationSeverity(\r\n    guarantee: QoSGuarantee,\r\n    actualValue: number,\r\n  ): 'low' | 'medium' | 'high' | 'critical' {\r\n    const deviation = Math.abs(actualValue - guarantee.threshold) / guarantee.threshold;\r\n\r\n    if (deviation > 0.5) return 'critical';\r\n    if (deviation > 0.3) return 'high';\r\n    if (deviation > 0.1) return 'medium';\r\n    return 'low';\r\n  }\r\n\r\n  private async remediateQoSViolation(\r\n    allocation: ResourceAllocation,\r\n    violation: QoSViolation,\r\n  ): Promise<void> {\r\n    this.logger.info('Attempting QoS violation remediation', {\r\n      allocationId: allocation.id,\r\n      metric: violation.metric,\r\n      severity: violation.severity,\r\n    });\r\n\r\n    // Simple remediation strategies\r\n    switch (violation.metric) {\r\n      case 'cpu':\r\n        // Could migrate to a less loaded resource\r\n        break;\r\n      case 'memory':\r\n        // Could increase memory allocation if available\r\n        break;\r\n      case 'efficiency':\r\n        // Could provide optimization recommendations\r\n        break;\r\n    }\r\n\r\n    this.emit('qos:remediation-attempted', { allocation, violation });\r\n  }\r\n\r\n  private async releaseAllAllocations(): Promise<void> {\r\n    const activeAllocations = Array.from(this.allocations.values()).filter(\r\n      (a) => a.status === 'active',\r\n    );\r\n\r\n    for (const allocation of activeAllocations) {\r\n      await this.releaseResources(allocation.id, 'system_shutdown');\r\n    }\r\n  }\r\n\r\n  private handleResourceRequest(data: any): void {\r\n    // Handle resource requests from agents\r\n    this.emit('resource:request-received', data);\r\n  }\r\n\r\n  private handleResourceRelease(data: any): void {\r\n    // Handle resource releases from agents\r\n    this.emit('resource:release-received', data);\r\n  }\r\n\r\n  private handleResourceFailure(data: any): void {\r\n    const resource = this.resources.get(data.resourceId);\r\n    if (resource) {\r\n      resource.status = 'failed';\r\n\r\n      // Record failure\r\n      resource.metadata.reliability.failureHistory.push({\r\n        timestamp: new Date(),\r\n        type: data.type || 'unknown',\r\n        duration: data.duration || 0,\r\n        impact: data.impact || 'medium',\r\n        resolved: false,\r\n      });\r\n\r\n      this.logger.error('Resource failure detected', {\r\n        resourceId: data.resourceId,\r\n        type: data.type,\r\n      });\r\n\r\n      this.emit('resource:failed', { resource, failure: data });\r\n    }\r\n  }\r\n\r\n  private handleScalingTrigger(data: any): void {\r\n    // Handle scaling triggers from monitoring system\r\n    this.emit('scaling:triggered', data);\r\n  }\r\n\r\n  // === PUBLIC API ===\r\n\r\n  getResource(resourceId: string): Resource | undefined {\r\n    return this.resources.get(resourceId);\r\n  }\r\n\r\n  getAllResources(): Resource[] {\r\n    return Array.from(this.resources.values());\r\n  }\r\n\r\n  getResourcesByType(type: ResourceType): Resource[] {\r\n    return Array.from(this.resources.values()).filter((r) => r.type === type);\r\n  }\r\n\r\n  getPool(poolId: string): ResourcePool | undefined {\r\n    return this.pools.get(poolId);\r\n  }\r\n\r\n  getAllPools(): ResourcePool[] {\r\n    return Array.from(this.pools.values());\r\n  }\r\n\r\n  getReservation(reservationId: string): ResourceReservation | undefined {\r\n    return this.reservations.get(reservationId);\r\n  }\r\n\r\n  getAllReservations(): ResourceReservation[] {\r\n    return Array.from(this.reservations.values());\r\n  }\r\n\r\n  getAllocation(allocationId: string): ResourceAllocation | undefined {\r\n    return this.allocations.get(allocationId);\r\n  }\r\n\r\n  getAllAllocations(): ResourceAllocation[] {\r\n    return Array.from(this.allocations.values());\r\n  }\r\n\r\n  getResourceUsageHistory(resourceId: string): ResourceUsage[] {\r\n    return this.usageHistory.get(resourceId) || [];\r\n  }\r\n\r\n  getResourcePrediction(resourceId: string): ResourcePrediction | undefined {\r\n    return this.predictions.get(resourceId);\r\n  }\r\n\r\n  getManagerStatistics(): {\r\n    resources: number;\r\n    pools: number;\r\n    reservations: number;\r\n    allocations: number;\r\n    utilization: number;\r\n    efficiency: number;\r\n  } {\r\n    const resources = Array.from(this.resources.values());\r\n    const allocations = Array.from(this.allocations.values());\r\n\r\n    const totalCapacity = resources.reduce((sum, r) => sum + r.capacity.cpu, 0);\r\n    const totalAllocated = resources.reduce((sum, r) => sum + r.allocated.cpu, 0);\r\n\r\n    const activeAllocations = allocations.filter((a) => a.status === 'active');\r\n    const avgEfficiency =\r\n      activeAllocations.length > 0\r\n        ? activeAllocations.reduce((sum, a) => sum + a.efficiency, 0) / activeAllocations.length\r\n        : 1.0;\r\n\r\n    return {\r\n      resources: this.resources.size,\r\n      pools: this.pools.size,\r\n      reservations: this.reservations.size,\r\n      allocations: this.allocations.size,\r\n      utilization: totalCapacity > 0 ? totalAllocated / totalCapacity : 0,\r\n      efficiency: avgEfficiency,\r\n    };\r\n  }\r\n}\r\n\r\n// === HELPER CLASSES ===\r\n\r\ninterface ResourcePrediction {\r\n  resourceId: string;\r\n  predictions: Array<{\r\n    timestamp: Date;\r\n    predictedUsage: ResourceUsage;\r\n    confidence: number;\r\n  }>;\r\n  trends: {\r\n    cpu: 'increasing' | 'decreasing' | 'stable';\r\n    memory: 'increasing' | 'decreasing' | 'stable';\r\n    disk: 'increasing' | 'decreasing' | 'stable';\r\n  };\r\n  recommendations: string[];\r\n}\r\n\r\nclass ResourceOptimizer {\r\n  constructor(\r\n    private config: ResourceManagerConfig,\r\n    private logger: ILogger,\r\n  ) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    this.logger.debug('Resource optimizer initialized');\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.debug('Resource optimizer shutdown');\r\n  }\r\n\r\n  async predictUsage(resource: Resource, history: ResourceUsage[]): Promise<ResourcePrediction> {\r\n    // Simple linear trend analysis\r\n    const predictions: Array<{\r\n      timestamp: Date;\r\n      predictedUsage: ResourceUsage;\r\n      confidence: number;\r\n    }> = [];\r\n\r\n    // Calculate trends\r\n    const cpuTrend = this.calculateTrend(history.map((h) => h.cpu));\r\n    const memoryTrend = this.calculateTrend(history.map((h) => h.memory));\r\n    const diskTrend = this.calculateTrend(history.map((h) => h.disk));\r\n\r\n    // Generate predictions for next 24 hours\r\n    for (let i = 1; i <= 24; i++) {\r\n      const futureTime = new Date(Date.now() + i * 3600000); // i hours from now\r\n\r\n      predictions.push({\r\n        timestamp: futureTime,\r\n        predictedUsage: {\r\n          cpu: Math.max(0, Math.min(100, this.extrapolateTrend(cpuTrend, i))),\r\n          memory: Math.max(0, this.extrapolateTrend(memoryTrend, i)),\r\n          disk: Math.max(0, this.extrapolateTrend(diskTrend, i)),\r\n          network: 0, // Simplified\r\n          custom: {},\r\n          timestamp: futureTime,\r\n          duration: 3600000, // 1 hour\r\n        },\r\n        confidence: Math.max(0.1, 1.0 - i * 0.05), // Decreasing confidence over time\r\n      });\r\n    }\r\n\r\n    return {\r\n      resourceId: resource.id,\r\n      predictions,\r\n      trends: {\r\n        cpu: this.categorizeTrend(cpuTrend),\r\n        memory: this.categorizeTrend(memoryTrend),\r\n        disk: this.categorizeTrend(diskTrend),\r\n      },\r\n      recommendations: this.generateRecommendations(resource, history),\r\n    };\r\n  }\r\n\r\n  private calculateTrend(values: number[]): { slope: number; intercept: number; r2: number } {\r\n    if (values.length < 2) {\r\n      return { slope: 0, intercept: values[0] || 0, r2: 0 };\r\n    }\r\n\r\n    const n = values.length;\r\n    const sumX = values.reduce((sum, _, i) => sum + i, 0);\r\n    const sumY = values.reduce((sum, val) => sum + val, 0);\r\n    const sumXY = values.reduce((sum, val, i) => sum + i * val, 0);\r\n    const sumXX = values.reduce((sum, _, i) => sum + i * i, 0);\r\n\r\n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\r\n    const intercept = (sumY - slope * sumX) / n;\r\n\r\n    // Calculate R\r\n    const meanY = sumY / n;\r\n    const ssTotal = values.reduce((sum, val) => sum + Math.pow(val - meanY, 2), 0);\r\n    const ssRes = values.reduce((sum, val, i) => {\r\n      const predicted = slope * i + intercept;\r\n      return sum + Math.pow(val - predicted, 2);\r\n    }, 0);\r\n\r\n    const r2 = 1 - ssRes / ssTotal;\r\n\r\n    return { slope, intercept, r2 };\r\n  }\r\n\r\n  private extrapolateTrend(trend: { slope: number; intercept: number }, steps: number): number {\r\n    return trend.slope * steps + trend.intercept;\r\n  }\r\n\r\n  private categorizeTrend(trend: { slope: number }): 'increasing' | 'decreasing' | 'stable' {\r\n    const threshold = 0.1;\r\n    if (trend.slope > threshold) return 'increasing';\r\n    if (trend.slope < -threshold) return 'decreasing';\r\n    return 'stable';\r\n  }\r\n\r\n  private generateRecommendations(resource: Resource, history: ResourceUsage[]): string[] {\r\n    const recommendations: string[] = [];\r\n\r\n    if (history.length === 0) {\r\n      return recommendations;\r\n    }\r\n\r\n    const recent = history.slice(-10);\r\n    const avgCpu = recent.reduce((sum, h) => sum + h.cpu, 0) / recent.length;\r\n    const avgMemory = recent.reduce((sum, h) => sum + h.memory, 0) / recent.length;\r\n\r\n    // CPU recommendations\r\n    if (avgCpu > 80) {\r\n      recommendations.push('High CPU usage detected. Consider scaling up or optimizing workloads.');\r\n    } else if (avgCpu < 20) {\r\n      recommendations.push('Low CPU usage. Consider scaling down to reduce costs.');\r\n    }\r\n\r\n    // Memory recommendations\r\n    const memoryUtilization = avgMemory / resource.capacity.memory;\r\n    if (memoryUtilization > 0.9) {\r\n      recommendations.push('High memory usage. Consider increasing memory allocation.');\r\n    } else if (memoryUtilization < 0.3) {\r\n      recommendations.push('Low memory usage. Consider reducing memory allocation.');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n}\r\n\r\nclass ResourceManagerMetrics {\r\n  private allocationsCreated = 0;\r\n  private allocationsReleased = 0;\r\n  private reservationsFailed = 0;\r\n  private qosViolations = 0;\r\n\r\n  recordAllocationCreated(): void {\r\n    this.allocationsCreated++;\r\n  }\r\n\r\n  recordAllocationReleased(allocation: ResourceAllocation): void {\r\n    this.allocationsReleased++;\r\n  }\r\n\r\n  recordReservationFailed(): void {\r\n    this.reservationsFailed++;\r\n  }\r\n\r\n  recordQoSViolation(): void {\r\n    this.qosViolations++;\r\n  }\r\n\r\n  getMetrics(): any {\r\n    return {\r\n      allocationsCreated: this.allocationsCreated,\r\n      allocationsReleased: this.allocationsReleased,\r\n      reservationsFailed: this.reservationsFailed,\r\n      qosViolations: this.qosViolations,\r\n      successRate:\r\n        this.allocationsCreated > 0\r\n          ? ((this.allocationsCreated - this.reservationsFailed) / this.allocationsCreated) * 100\r\n          : 100,\r\n    };\r\n  }\r\n}\r\n"],"names":["EventEmitter","generateId","ResourceManager","logger","eventBus","config","resources","Map","pools","reservations","allocations","usageHistory","predictions","optimizer","monitoringInterval","cleanupInterval","scalingInterval","metrics","enableResourcePooling","enableResourceMonitoring","enableAutoScaling","enableQoS","defaultLimits","cpu","memory","disk","network","custom","reservationTimeout","allocationStrategy","priorityWeights","critical","high","normal","low","background","enablePredictiveAllocation","enableResourceSharing","debugMode","ResourceOptimizer","ResourceManagerMetrics","setupEventHandlers","on","data","handleResourceRequest","handleResourceRelease","updateResourceUsage","resourceId","usage","handleResourceFailure","handleScalingTrigger","initialize","info","pooling","monitoring","autoScaling","createDefaultPools","startMonitoring","startCleanup","startAutoScaling","emit","shutdown","clearInterval","releaseAllAllocations","registerResource","type","name","capacity","metadata","resource","id","description","allocated","createEmptyLimits","available","status","provider","capabilities","performance","createDefaultPerformanceMetrics","reliability","createDefaultReliabilityMetrics","cost","createDefaultCostMetrics","lastUpdated","Date","sharable","persistent","tags","set","unregisterResource","get","Error","length","reservation","cancelReservation","delete","requestResources","agentId","requirements","options","reservationId","now","taskId","priority","createdAt","expiresAt","timeout","getTime","preemptible","findSuitableResource","push","updateResourceAvailability","canActivateReservation","activateReservation","error","allocationId","allocation","calculateAllocation","actualUsage","createEmptyUsage","efficiency","startTime","qosViolations","addToResourceLimits","activatedAt","releaseResources","reason","endTime","calculateEfficiency","subtractFromResourceLimits","filter","a","releasedAt","recordAllocationReleased","Array","from","values","find","r","createResourcePool","resourceIds","strategy","poolId","pool","loadBalancing","scaling","enabled","minResources","Math","max","maxResources","scaleUpThreshold","scaleDownThreshold","cooldownPeriod","weight","threshold","aggregation","qos","guarantees","objectives","violations","autoRemediation","escalationThreshold","penaltyFunction","notificationEnabled","statistics","createPoolStatistics","filters","resourceCount","addResourceToPool","includes","updatePoolStatistics","removeResourceFromPool","candidates","score","calculateResourceScore","sort","b","selectResourceByStrategy","canSatisfyRequirements","utilization","calculateResourceUtilization","cpuScore","uptime","priorityWeight","min","spec","Object","entries","constraints","checkConstraints","location","excludeLocation","maxCost","timeWindow","start","end","reduce","best","current","bestWaste","calculateWaste","currentWaste","worst","worstWaste","waste","preferred","setInterval","performMonitoring","interval","performCleanup","evaluateScaling","updateResourceStatistics","checkQoSViolations","updatePredictions","size","expiredReservations","cutoff","history","timestamp","debug","calculatePoolMetrics","shouldScale","action","scalePoolUp","scalePoolDown","totalCapacity","totalAllocated","duration","efficiencySum","factors","target","source","value","memoryBandwidth","diskIOPS","networkBandwidth","benchmarkResults","meanTimeBetweenFailures","errorRate","failureHistory","hourlyRate","dataTransferCost","storageCost","billing","totalResources","availableResources","utilizationRate","allocationSuccessRate","averageWaitTime","throughput","costPerHour","qosScore","computeResources","map","shift","recent","slice","avgCpu","sum","h","Boolean","totalUtilization","totalCost","p","checkPoolQoS","guarantee","getMetricValue","metric","violated","evaluateQoSCondition","operator","violation","expected","actual","severity","calculateViolationSeverity","resolved","warn","remediateQoSViolation","prediction","predictUsage","totalReservations","queue_depth","actualValue","deviation","abs","activeAllocations","impact","failure","getResource","getAllResources","getResourcesByType","getPool","getAllPools","getReservation","getAllReservations","getAllocation","getAllAllocations","getResourceUsageHistory","getResourcePrediction","getManagerStatistics","avgEfficiency","cpuTrend","calculateTrend","memoryTrend","diskTrend","i","futureTime","predictedUsage","extrapolateTrend","confidence","trends","categorizeTrend","recommendations","generateRecommendations","slope","intercept","r2","n","sumX","_","sumY","val","sumXY","sumXX","meanY","ssTotal","pow","ssRes","predicted","trend","steps","avgMemory","memoryUtilization","allocationsCreated","allocationsReleased","reservationsFailed","recordAllocationCreated","recordReservationFailed","recordQoSViolation","getMetrics","successRate"],"mappings":"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"}