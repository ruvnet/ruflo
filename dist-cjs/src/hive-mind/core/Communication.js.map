{"version":3,"sources":["../../../../src/hive-mind/core/Communication.ts"],"sourcesContent":["/**\r\n * Communication Class\r\n *\r\n * Manages inter-agent messaging, broadcasts, and communication protocols\r\n * within the Hive Mind swarm.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { DatabaseManager } from './DatabaseManager.js';\r\nimport { Agent } from './Agent.js';\r\nimport {\r\n  Message,\r\n  MessageType,\r\n  MessagePriority,\r\n  CommunicationStats,\r\n  CommunicationChannel,\r\n} from '../types.js';\r\n\r\nexport class Communication extends EventEmitter {\r\n  private swarmId: string;\r\n  private db: DatabaseManager;\r\n  private agents: Map<string, Agent>;\r\n  private channels: Map<string, CommunicationChannel>;\r\n  private messageQueue: Map<MessagePriority, Message[]>;\r\n  private stats: CommunicationStats;\r\n  private isActive: boolean = false;\r\n\r\n  constructor(swarmId: string) {\r\n    super();\r\n    this.swarmId = swarmId;\r\n    this.agents = new Map();\r\n    this.channels = new Map();\r\n    this.messageQueue = new Map([\r\n      ['urgent', []],\r\n      ['high', []],\r\n      ['normal', []],\r\n      ['low', []],\r\n    ]);\r\n\r\n    this.stats = {\r\n      totalMessages: 0,\r\n      avgLatency: 0,\r\n      activeChannels: 0,\r\n      messagesByType: {},\r\n      throughput: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize communication system\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.db = await DatabaseManager.getInstance();\r\n\r\n    // Set up default channels\r\n    this.setupDefaultChannels();\r\n\r\n    // Start message processing\r\n    this.startMessageProcessor();\r\n    this.startLatencyMonitor();\r\n    this.startStatsCollector();\r\n\r\n    this.isActive = true;\r\n    this.emit('initialized');\r\n  }\r\n\r\n  /**\r\n   * Add an agent to the communication network\r\n   */\r\n  addAgent(agent: Agent): void {\r\n    this.agents.set(agent.id, agent);\r\n\r\n    // Create agent-specific channels\r\n    this.createAgentChannels(agent);\r\n\r\n    // Subscribe agent to relevant channels\r\n    this.subscribeAgentToChannels(agent);\r\n\r\n    this.emit('agentAdded', { agentId: agent.id });\r\n  }\r\n\r\n  /**\r\n   * Remove an agent from the communication network\r\n   */\r\n  removeAgent(agentId: string): void {\r\n    this.agents.delete(agentId);\r\n\r\n    // Remove agent from channels\r\n    this.channels.forEach((channel) => {\r\n      channel.subscribers = channel.subscribers.filter((id) => id !== agentId);\r\n    });\r\n\r\n    this.emit('agentRemoved', { agentId });\r\n  }\r\n\r\n  /**\r\n   * Send a message\r\n   */\r\n  async sendMessage(message: Message): Promise<void> {\r\n    // Store in database\r\n    await this.db.createCommunication({\r\n      from_agent_id: message.fromAgentId,\r\n      to_agent_id: message.toAgentId,\r\n      swarm_id: this.swarmId,\r\n      message_type: message.type,\r\n      content: JSON.stringify(message.content),\r\n      priority: message.priority || 'normal',\r\n      requires_response: message.requiresResponse || false,\r\n    });\r\n\r\n    // Add to queue\r\n    const priority = message.priority || 'normal';\r\n    this.messageQueue.get(priority)!.push(message);\r\n\r\n    // Update stats\r\n    this.stats.totalMessages++;\r\n    this.stats.messagesByType[message.type] = (this.stats.messagesByType[message.type] || 0) + 1;\r\n\r\n    this.emit('messageSent', message);\r\n  }\r\n\r\n  /**\r\n   * Broadcast a message to all agents\r\n   */\r\n  async broadcast(\r\n    fromAgentId: string,\r\n    type: MessageType,\r\n    content: any,\r\n    priority: MessagePriority = 'normal',\r\n  ): Promise<void> {\r\n    const message: Message = {\r\n      id: this.generateMessageId(),\r\n      fromAgentId,\r\n      toAgentId: null, // null indicates broadcast\r\n      swarmId: this.swarmId,\r\n      type,\r\n      content,\r\n      priority,\r\n      timestamp: new Date(),\r\n      requiresResponse: false,\r\n    };\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Send a message to a specific channel\r\n   */\r\n  async sendToChannel(\r\n    channelName: string,\r\n    fromAgentId: string,\r\n    content: any,\r\n    priority: MessagePriority = 'normal',\r\n  ): Promise<void> {\r\n    const channel = this.channels.get(channelName);\r\n    if (!channel) {\r\n      throw new Error(`Channel ${channelName} not found`);\r\n    }\r\n\r\n    // Send to all subscribers\r\n    for (const subscriberId of channel.subscribers) {\r\n      if (subscriberId !== fromAgentId) {\r\n        const message: Message = {\r\n          id: this.generateMessageId(),\r\n          fromAgentId,\r\n          toAgentId: subscriberId,\r\n          swarmId: this.swarmId,\r\n          type: 'channel',\r\n          content: {\r\n            channel: channelName,\r\n            data: content,\r\n          },\r\n          priority,\r\n          timestamp: new Date(),\r\n          requiresResponse: false,\r\n        };\r\n\r\n        await this.sendMessage(message);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Request response from an agent\r\n   */\r\n  async requestResponse(\r\n    fromAgentId: string,\r\n    toAgentId: string,\r\n    query: any,\r\n    timeout: number = 5000,\r\n  ): Promise<any> {\r\n    const message: Message = {\r\n      id: this.generateMessageId(),\r\n      fromAgentId,\r\n      toAgentId,\r\n      swarmId: this.swarmId,\r\n      type: 'query',\r\n      content: query,\r\n      priority: 'high',\r\n      timestamp: new Date(),\r\n      requiresResponse: true,\r\n    };\r\n\r\n    await this.sendMessage(message);\r\n\r\n    // Wait for response\r\n    return new Promise((resolve, reject) => {\r\n      const timer = setTimeout(() => {\r\n        reject(new Error('Response timeout'));\r\n      }, timeout);\r\n\r\n      const responseHandler = (response: Message) => {\r\n        if (response.content.queryId === message.id) {\r\n          clearTimeout(timer);\r\n          this.off('messageReceived', responseHandler);\r\n          resolve(response.content.response);\r\n        }\r\n      };\r\n\r\n      this.on('messageReceived', responseHandler);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a new communication channel\r\n   */\r\n  createChannel(name: string, description: string, type: 'public' | 'private' = 'public'): void {\r\n    if (this.channels.has(name)) {\r\n      throw new Error(`Channel ${name} already exists`);\r\n    }\r\n\r\n    const channel: CommunicationChannel = {\r\n      name,\r\n      description,\r\n      type,\r\n      subscribers: [],\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    this.channels.set(name, channel);\r\n    this.stats.activeChannels++;\r\n\r\n    this.emit('channelCreated', { channel });\r\n  }\r\n\r\n  /**\r\n   * Subscribe an agent to a channel\r\n   */\r\n  subscribeToChannel(agentId: string, channelName: string): void {\r\n    const channel = this.channels.get(channelName);\r\n    if (!channel) {\r\n      throw new Error(`Channel ${channelName} not found`);\r\n    }\r\n\r\n    if (!channel.subscribers.includes(agentId)) {\r\n      channel.subscribers.push(agentId);\r\n      this.emit('channelSubscribed', { agentId, channelName });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe an agent from a channel\r\n   */\r\n  unsubscribeFromChannel(agentId: string, channelName: string): void {\r\n    const channel = this.channels.get(channelName);\r\n    if (!channel) {\r\n      return;\r\n    }\r\n\r\n    channel.subscribers = channel.subscribers.filter((id) => id !== agentId);\r\n    this.emit('channelUnsubscribed', { agentId, channelName });\r\n  }\r\n\r\n  /**\r\n   * Get communication statistics\r\n   */\r\n  async getStats(): Promise<CommunicationStats> {\r\n    // Calculate throughput\r\n    const recentMessages = await this.db.getRecentMessages(this.swarmId, 60000); // Last minute\r\n    this.stats.throughput = recentMessages.length;\r\n\r\n    return { ...this.stats };\r\n  }\r\n\r\n  /**\r\n   * Get pending messages for an agent\r\n   */\r\n  async getPendingMessages(agentId: string): Promise<Message[]> {\r\n    const messages = await this.db.getPendingMessages(agentId);\r\n\r\n    return messages.map((msg) => ({\r\n      id: msg.id.toString(),\r\n      fromAgentId: msg.from_agent_id,\r\n      toAgentId: msg.to_agent_id,\r\n      swarmId: msg.swarm_id,\r\n      type: msg.message_type as MessageType,\r\n      content: JSON.parse(msg.content),\r\n      priority: msg.priority as MessagePriority,\r\n      timestamp: new Date(msg.timestamp),\r\n      requiresResponse: msg.requires_response,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Mark message as delivered\r\n   */\r\n  async markDelivered(messageId: string): Promise<void> {\r\n    await this.db.markMessageDelivered(messageId);\r\n  }\r\n\r\n  /**\r\n   * Mark message as read\r\n   */\r\n  async markRead(messageId: string): Promise<void> {\r\n    await this.db.markMessageRead(messageId);\r\n  }\r\n\r\n  /**\r\n   * Setup default communication channels\r\n   */\r\n  private setupDefaultChannels(): void {\r\n    // System channels\r\n    this.createChannel('system', 'System-wide notifications and alerts');\r\n    this.createChannel('coordination', 'Task coordination messages');\r\n    this.createChannel('consensus', 'Consensus voting and decisions');\r\n    this.createChannel('monitoring', 'Performance and health monitoring');\r\n\r\n    // Agent type channels\r\n    this.createChannel('coordinators', 'Coordinator agent communications');\r\n    this.createChannel('researchers', 'Researcher agent communications');\r\n    this.createChannel('coders', 'Coder agent communications');\r\n    this.createChannel('analysts', 'Analyst agent communications');\r\n  }\r\n\r\n  /**\r\n   * Create channels for a specific agent\r\n   */\r\n  private createAgentChannels(agent: Agent): void {\r\n    // Direct message channel\r\n    this.createChannel(`agent-${agent.id}`, `Direct messages for ${agent.name}`, 'private');\r\n\r\n    // Team channel if agent is coordinator\r\n    if (agent.type === 'coordinator') {\r\n      this.createChannel(`team-${agent.id}`, `Team channel led by ${agent.name}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe agent to relevant channels\r\n   */\r\n  private subscribeAgentToChannels(agent: Agent): void {\r\n    // Subscribe to system channels\r\n    this.subscribeToChannel(agent.id, 'system');\r\n    this.subscribeToChannel(agent.id, 'coordination');\r\n\r\n    // Subscribe to type-specific channel\r\n    const typeChannel = `${agent.type}s`;\r\n    if (this.channels.has(typeChannel)) {\r\n      this.subscribeToChannel(agent.id, typeChannel);\r\n    }\r\n\r\n    // Subscribe to own direct channel\r\n    this.subscribeToChannel(agent.id, `agent-${agent.id}`);\r\n\r\n    // Special subscriptions based on capabilities\r\n    if (agent.capabilities.includes('consensus_building')) {\r\n      this.subscribeToChannel(agent.id, 'consensus');\r\n    }\r\n\r\n    if (agent.capabilities.includes('system_monitoring')) {\r\n      this.subscribeToChannel(agent.id, 'monitoring');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start message processor\r\n   */\r\n  private startMessageProcessor(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      // Process messages by priority\r\n      for (const [priority, messages] of this.messageQueue) {\r\n        if (messages.length === 0) continue;\r\n\r\n        // Process batch of messages\r\n        const batch = messages.splice(0, 10); // Process up to 10 messages\r\n\r\n        for (const message of batch) {\r\n          await this.processMessage(message);\r\n        }\r\n      }\r\n    }, 100); // Every 100ms\r\n  }\r\n\r\n  /**\r\n   * Process a single message\r\n   */\r\n  private async processMessage(message: Message): Promise<void> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      if (message.toAgentId) {\r\n        // Direct message\r\n        const agent = this.agents.get(message.toAgentId);\r\n        if (agent) {\r\n          await agent.receiveMessage(message);\r\n          await this.markDelivered(message.id);\r\n        }\r\n      } else {\r\n        // Broadcast message\r\n        for (const agent of this.agents.values()) {\r\n          if (agent.id !== message.fromAgentId) {\r\n            await agent.receiveMessage(message);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Update latency stats\r\n      const latency = Date.now() - startTime;\r\n      this.updateLatencyStats(latency);\r\n\r\n      this.emit('messageProcessed', { message, latency });\r\n    } catch (error) {\r\n      this.emit('messageError', { message, error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update latency statistics\r\n   */\r\n  private updateLatencyStats(latency: number): void {\r\n    // Simple moving average\r\n    this.stats.avgLatency = this.stats.avgLatency * 0.9 + latency * 0.1;\r\n  }\r\n\r\n  /**\r\n   * Start latency monitor\r\n   */\r\n  private startLatencyMonitor(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      // Check for high latency\r\n      if (this.stats.avgLatency > 1000) {\r\n        this.emit('highLatency', { avgLatency: this.stats.avgLatency });\r\n      }\r\n    }, 5000); // Every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Start statistics collector\r\n   */\r\n  private startStatsCollector(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      // Store stats in database\r\n      await this.db.storePerformanceMetric({\r\n        swarm_id: this.swarmId,\r\n        metric_type: 'communication_throughput',\r\n        metric_value: this.stats.throughput,\r\n      });\r\n\r\n      await this.db.storePerformanceMetric({\r\n        swarm_id: this.swarmId,\r\n        metric_type: 'communication_latency',\r\n        metric_value: this.stats.avgLatency,\r\n      });\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * Generate unique message ID\r\n   */\r\n  private generateMessageId(): string {\r\n    return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Shutdown communication system\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    this.isActive = false;\r\n\r\n    // Clear queues\r\n    this.messageQueue.forEach((queue) => (queue.length = 0));\r\n\r\n    // Clear channels\r\n    this.channels.clear();\r\n\r\n    this.emit('shutdown');\r\n  }\r\n}\r\n"],"names":["EventEmitter","DatabaseManager","Communication","swarmId","db","agents","channels","messageQueue","stats","isActive","Map","totalMessages","avgLatency","activeChannels","messagesByType","throughput","initialize","getInstance","setupDefaultChannels","startMessageProcessor","startLatencyMonitor","startStatsCollector","emit","addAgent","agent","set","id","createAgentChannels","subscribeAgentToChannels","agentId","removeAgent","delete","forEach","channel","subscribers","filter","sendMessage","message","createCommunication","from_agent_id","fromAgentId","to_agent_id","toAgentId","swarm_id","message_type","type","content","JSON","stringify","priority","requires_response","requiresResponse","get","push","broadcast","generateMessageId","timestamp","Date","sendToChannel","channelName","Error","subscriberId","data","requestResponse","query","timeout","Promise","resolve","reject","timer","setTimeout","responseHandler","response","queryId","clearTimeout","off","on","createChannel","name","description","has","createdAt","subscribeToChannel","includes","unsubscribeFromChannel","getStats","recentMessages","getRecentMessages","length","getPendingMessages","messages","map","msg","toString","parse","markDelivered","messageId","markMessageDelivered","markRead","markMessageRead","typeChannel","capabilities","setInterval","batch","splice","processMessage","startTime","now","receiveMessage","values","latency","updateLatencyStats","error","storePerformanceMetric","metric_type","metric_value","Math","random","substr","shutdown","queue","clear"],"mappings":"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"}