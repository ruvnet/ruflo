{
  "version": 3,
  "sources": ["../../src/memory/manager.ts"],
  "sourcesContent": ["/**\n * Memory manager interface and implementation\n */\n\nimport type { MemoryEntry, MemoryQuery, MemoryConfig } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MemoryError } from '../utils/errors.js';\nimport type { IMemoryBackend } from './backends/base.js';\nimport { SQLiteBackend } from './backends/sqlite.js';\nimport { MarkdownBackend } from './backends/markdown.js';\nimport { MemoryCache } from './cache.js';\nimport { MemoryIndexer } from './indexer.js';\n\nexport interface IMemoryManager {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  createBank(agentId: string): Promise<string>;\n  closeBank(bankId: string): Promise<void>;\n  store(entry: MemoryEntry): Promise<void>;\n  retrieve(id: string): Promise<MemoryEntry | undefined>;\n  query(query: MemoryQuery): Promise<MemoryEntry[]>;\n  update(id: string, updates: Partial<MemoryEntry>): Promise<void>;\n  delete(id: string): Promise<void>;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  performMaintenance(): Promise<void>;\n}\n\n/**\n * Memory bank for agent-specific storage\n */\ninterface MemoryBank {\n  id: string;\n  agentId: string;\n  createdAt: Date;\n  lastAccessed: Date;\n  entryCount: number;\n}\n\n/**\n * Memory manager implementation\n */\nexport class MemoryManager implements IMemoryManager {\n  private backend: IMemoryBackend;\n  private cache: MemoryCache;\n  private indexer: MemoryIndexer;\n  private banks = new Map<string, MemoryBank>();\n  private initialized = false;\n  private syncInterval?: number;\n\n  constructor(\n    private config: MemoryConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    // Initialize backend based on configuration\n    this.backend = this.createBackend();\n\n    // Initialize cache\n    this.cache = new MemoryCache(\n      this.config.cacheSizeMB * 1024 * 1024, // Convert MB to bytes\n      this.logger,\n    );\n\n    // Initialize indexer\n    this.indexer = new MemoryIndexer(this.logger);\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    this.logger.info('Initializing memory manager...');\n\n    try {\n      // Initialize backend\n      await this.backend.initialize();\n\n      // Initialize indexer with existing entries\n      const allEntries = await this.backend.getAllEntries();\n      await this.indexer.buildIndex(allEntries);\n\n      // Start sync interval\n      this.startSyncInterval();\n\n      this.initialized = true;\n      this.logger.info('Memory manager initialized');\n    } catch (error) {\n      this.logger.error('Failed to initialize memory manager', error);\n      throw new MemoryError('Memory manager initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down memory manager...');\n\n    try {\n      // Stop sync interval\n      if (this.syncInterval) {\n        clearInterval(this.syncInterval);\n      }\n\n      // Flush cache\n      await this.flushCache();\n\n      // Close all banks\n      const bankIds = Array.from(this.banks.keys());\n      await Promise.all(bankIds.map((id) => this.closeBank(id)));\n\n      // Shutdown backend\n      await this.backend.shutdown();\n\n      this.initialized = false;\n      this.logger.info('Memory manager shutdown complete');\n    } catch (error) {\n      this.logger.error('Error during memory manager shutdown', error);\n      throw error;\n    }\n  }\n\n  async createBank(agentId: string): Promise<string> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    const bank: MemoryBank = {\n      id: `bank_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      agentId,\n      createdAt: new Date(),\n      lastAccessed: new Date(),\n      entryCount: 0,\n    };\n\n    this.banks.set(bank.id, bank);\n\n    this.logger.info('Memory bank created', { bankId: bank.id, agentId });\n\n    return bank.id;\n  }\n\n  async closeBank(bankId: string): Promise<void> {\n    const bank = this.banks.get(bankId);\n    if (!bank) {\n      throw new MemoryError(`Memory bank not found: ${bankId}`);\n    }\n\n    // Flush any cached entries for this bank\n    const bankEntries = this.cache.getByPrefix(`${bank.agentId}:`);\n    for (const entry of bankEntries) {\n      await this.backend.store(entry);\n    }\n\n    this.banks.delete(bankId);\n\n    this.logger.info('Memory bank closed', { bankId });\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    this.logger.debug('Storing memory entry', {\n      id: entry.id,\n      type: entry.type,\n      agentId: entry.agentId,\n    });\n\n    try {\n      // Add to cache\n      this.cache.set(entry.id, entry);\n\n      // Add to index\n      this.indexer.addEntry(entry);\n\n      // Store in backend (async, don't wait)\n      this.backend.store(entry).catch((error) => {\n        this.logger.error('Failed to store entry in backend', {\n          id: entry.id,\n          error,\n        });\n      });\n\n      // Update bank stats\n      const bank = Array.from(this.banks.values()).find((b) => b.agentId === entry.agentId);\n      if (bank) {\n        bank.entryCount++;\n        bank.lastAccessed = new Date();\n      }\n\n      // Emit event\n      this.eventBus.emit('memory:created', { entry });\n    } catch (error) {\n      this.logger.error('Failed to store memory entry', error);\n      throw new MemoryError('Failed to store memory entry', { error });\n    }\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    // Check cache first\n    const cached = this.cache.get(id);\n    if (cached) {\n      return cached;\n    }\n\n    // Retrieve from backend\n    const entry = await this.backend.retrieve(id);\n    if (entry) {\n      // Add to cache\n      this.cache.set(id, entry);\n    }\n\n    return entry;\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    this.logger.debug('Querying memory', query);\n\n    try {\n      // Use index for fast querying\n      let results = this.indexer.search(query);\n\n      // Apply additional filters if needed\n      if (query.search) {\n        results = results.filter(\n          (entry) =>\n            entry.content.toLowerCase().includes(query.search!.toLowerCase()) ||\n            entry.tags.some((tag) => tag.toLowerCase().includes(query.search!.toLowerCase())),\n        );\n      }\n\n      // Apply time range filter\n      if (query.startTime || query.endTime) {\n        results = results.filter((entry) => {\n          const timestamp = entry.timestamp.getTime();\n          if (query.startTime && timestamp < query.startTime.getTime()) {\n            return false;\n          }\n          if (query.endTime && timestamp > query.endTime.getTime()) {\n            return false;\n          }\n          return true;\n        });\n      }\n\n      // Apply pagination\n      const start = query.offset || 0;\n      const limit = query.limit || 100;\n      results = results.slice(start, start + limit);\n\n      return results;\n    } catch (error) {\n      this.logger.error('Failed to query memory', error);\n      throw new MemoryError('Failed to query memory', { error });\n    }\n  }\n\n  async update(id: string, updates: Partial<MemoryEntry>): Promise<void> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    const existing = await this.retrieve(id);\n    if (!existing) {\n      throw new MemoryError(`Memory entry not found: ${id}`);\n    }\n\n    // Create updated entry\n    const updated: MemoryEntry = {\n      ...existing,\n      ...updates,\n      id: existing.id, // Ensure ID doesn't change\n      version: existing.version + 1,\n      timestamp: new Date(),\n    };\n\n    // Update in cache\n    this.cache.set(id, updated);\n\n    // Update in index\n    this.indexer.updateEntry(updated);\n\n    // Update in backend\n    await this.backend.update(id, updated);\n\n    // Emit event\n    this.eventBus.emit('memory:updated', {\n      entry: updated,\n      previousVersion: existing.version,\n    });\n  }\n\n  async delete(id: string): Promise<void> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    // Remove from cache\n    this.cache.delete(id);\n\n    // Remove from index\n    this.indexer.removeEntry(id);\n\n    // Delete from backend\n    await this.backend.delete(id);\n\n    // Emit event\n    this.eventBus.emit('memory:deleted', { entryId: id });\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const backendHealth = await this.backend.getHealthStatus();\n      const cacheMetrics = this.cache.getMetrics();\n      const indexMetrics = this.indexer.getMetrics();\n\n      const metrics = {\n        totalEntries: indexMetrics.totalEntries,\n        cacheSize: cacheMetrics.size,\n        cacheHitRate: cacheMetrics.hitRate,\n        activeBanks: this.banks.size,\n        ...backendHealth.metrics,\n      };\n\n      return {\n        healthy: backendHealth.healthy,\n        metrics,\n        ...(backendHealth.error && { error: backendHealth.error }),\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  async performMaintenance(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.debug('Performing memory manager maintenance');\n\n    try {\n      // Clean up old entries based on retention policy\n      if (this.config.retentionDays > 0) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - this.config.retentionDays);\n\n        const oldEntries = await this.query({\n          endTime: cutoffDate,\n        });\n\n        for (const entry of oldEntries) {\n          await this.delete(entry.id);\n        }\n\n        this.logger.info(`Cleaned up ${oldEntries.length} old memory entries`);\n      }\n\n      // Perform cache maintenance\n      this.cache.performMaintenance();\n\n      // Perform backend maintenance\n      if (this.backend.performMaintenance) {\n        await this.backend.performMaintenance();\n      }\n\n      // Update bank statistics\n      for (const bank of this.banks.values()) {\n        const entries = await this.query({ agentId: bank.agentId });\n        bank.entryCount = entries.length;\n        bank.lastAccessed = new Date();\n      }\n\n      this.logger.debug('Memory manager maintenance completed');\n    } catch (error) {\n      this.logger.error('Error during memory manager maintenance', error);\n    }\n  }\n\n  private createBackend(): IMemoryBackend {\n    switch (this.config.backend) {\n      case 'sqlite':\n        return new SQLiteBackend(this.config.sqlitePath || './claude-flow.db', this.logger);\n      case 'markdown':\n        return new MarkdownBackend(this.config.markdownDir || './memory', this.logger);\n      case 'hybrid':\n        // Use SQLite for structured data and Markdown for human-readable backup\n        return new HybridBackend(\n          new SQLiteBackend(this.config.sqlitePath || './claude-flow.db', this.logger),\n          new MarkdownBackend(this.config.markdownDir || './memory', this.logger),\n          this.logger,\n        );\n      default:\n        throw new MemoryError(`Unknown memory backend: ${this.config.backend}`);\n    }\n  }\n\n  private startSyncInterval(): void {\n    this.syncInterval = setInterval(async () => {\n      try {\n        await this.syncCache();\n      } catch (error) {\n        this.logger.error('Cache sync error', error);\n      }\n    }, this.config.syncInterval);\n  }\n\n  private async syncCache(): Promise<void> {\n    const dirtyEntries = this.cache.getDirtyEntries();\n\n    if (dirtyEntries.length === 0) {\n      return;\n    }\n\n    this.logger.debug('Syncing cache to backend', { count: dirtyEntries.length });\n\n    const promises = dirtyEntries.map((entry) =>\n      this.backend.store(entry).catch((error) => {\n        this.logger.error('Failed to sync entry', { id: entry.id, error });\n      }),\n    );\n\n    await Promise.all(promises);\n    this.cache.markClean(dirtyEntries.map((e) => e.id));\n\n    // Emit sync event\n    this.eventBus.emit('memory:synced', { entries: dirtyEntries });\n  }\n\n  private async flushCache(): Promise<void> {\n    const allEntries = this.cache.getAllEntries();\n\n    if (allEntries.length === 0) {\n      return;\n    }\n\n    this.logger.info('Flushing cache to backend', { count: allEntries.length });\n\n    const promises = allEntries.map((entry) =>\n      this.backend.store(entry).catch((error) => {\n        this.logger.error('Failed to flush entry', { id: entry.id, error });\n      }),\n    );\n\n    await Promise.all(promises);\n  }\n}\n\n/**\n * Hybrid backend that uses both SQLite and Markdown\n */\nclass HybridBackend implements IMemoryBackend {\n  constructor(\n    private primary: IMemoryBackend,\n    private secondary: IMemoryBackend,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    await Promise.all([this.primary.initialize(), this.secondary.initialize()]);\n  }\n\n  async shutdown(): Promise<void> {\n    await Promise.all([this.primary.shutdown(), this.secondary.shutdown()]);\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    // Store in both backends\n    await Promise.all([\n      this.primary.store(entry),\n      this.secondary.store(entry).catch((error) => {\n        this.logger.warn('Failed to store in secondary backend', { error });\n      }),\n    ]);\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    // Try primary first\n    const entry = await this.primary.retrieve(id);\n    if (entry) {\n      return entry;\n    }\n\n    // Fall back to secondary\n    return await this.secondary.retrieve(id);\n  }\n\n  async update(id: string, entry: MemoryEntry): Promise<void> {\n    await Promise.all([\n      this.primary.update(id, entry),\n      this.secondary.update(id, entry).catch((error) => {\n        this.logger.warn('Failed to update in secondary backend', { error });\n      }),\n    ]);\n  }\n\n  async delete(id: string): Promise<void> {\n    await Promise.all([\n      this.primary.delete(id),\n      this.secondary.delete(id).catch((error) => {\n        this.logger.warn('Failed to delete from secondary backend', { error });\n      }),\n    ]);\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    // Use primary for querying (faster)\n    return await this.primary.query(query);\n  }\n\n  async getAllEntries(): Promise<MemoryEntry[]> {\n    return await this.primary.getAllEntries();\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const [primaryHealth, secondaryHealth] = await Promise.all([\n      this.primary.getHealthStatus(),\n      this.secondary.getHealthStatus(),\n    ]);\n\n    const error = primaryHealth.error || secondaryHealth.error;\n    return {\n      healthy: primaryHealth.healthy && secondaryHealth.healthy,\n      ...(error && { error }),\n      metrics: {\n        ...primaryHealth.metrics,\n        ...secondaryHealth.metrics,\n      },\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
