{
  "version": 3,
  "sources": ["../../../src/mcp/recovery/fallback-coordinator.ts"],
  "sourcesContent": ["/**\n * Fallback Coordinator for MCP\n * Manages graceful degradation to CLI when MCP connection fails\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPRequest } from '../../utils/types.js';\nimport { exec } from 'node:child_process';\nimport { promisify } from 'node:util';\n\nconst execAsync = promisify(exec);\n\nexport interface FallbackOperation {\n  id: string;\n  type: 'tool' | 'resource' | 'notification';\n  method: string;\n  params: unknown;\n  timestamp: Date;\n  priority: 'high' | 'medium' | 'low';\n  retryable: boolean;\n}\n\nexport interface FallbackConfig {\n  enableFallback: boolean;\n  maxQueueSize: number;\n  queueTimeout: number;\n  cliPath: string;\n  fallbackNotificationInterval: number;\n}\n\nexport interface FallbackState {\n  isFallbackActive: boolean;\n  queuedOperations: number;\n  failedOperations: number;\n  successfulOperations: number;\n  lastFallbackActivation?: Date;\n}\n\nexport class FallbackCoordinator extends EventEmitter {\n  private operationQueue: FallbackOperation[] = [];\n  private state: FallbackState;\n  private notificationTimer?: NodeJS.Timeout;\n  private processingQueue = false;\n\n  private readonly defaultConfig: FallbackConfig = {\n    enableFallback: true,\n    maxQueueSize: 100,\n    queueTimeout: 300000, // 5 minutes\n    cliPath: 'npx ruv-swarm',\n    fallbackNotificationInterval: 30000, // 30 seconds\n  };\n\n  constructor(\n    private logger: ILogger,\n    config?: Partial<FallbackConfig>,\n  ) {\n    super();\n    this.config = { ...this.defaultConfig, ...config };\n\n    this.state = {\n      isFallbackActive: false,\n      queuedOperations: 0,\n      failedOperations: 0,\n      successfulOperations: 0,\n    };\n  }\n\n  private config: FallbackConfig;\n\n  /**\n   * Check if MCP is available\n   */\n  async isMCPAvailable(): Promise<boolean> {\n    try {\n      // Try to execute a simple MCP command\n      const { stdout } = await execAsync(`${this.config.cliPath} status --json`);\n      const status = JSON.parse(stdout);\n      return status.connected === true;\n    } catch (error) {\n      this.logger.debug('MCP availability check failed', error);\n      return false;\n    }\n  }\n\n  /**\n   * Enable CLI fallback mode\n   */\n  enableCLIFallback(): void {\n    if (this.state.isFallbackActive) {\n      this.logger.debug('Fallback already active');\n      return;\n    }\n\n    this.logger.warn('Enabling CLI fallback mode');\n\n    this.state.isFallbackActive = true;\n    this.state.lastFallbackActivation = new Date();\n\n    // Start notification timer\n    this.startNotificationTimer();\n\n    this.emit('fallbackEnabled', this.state);\n  }\n\n  /**\n   * Disable CLI fallback mode\n   */\n  disableCLIFallback(): void {\n    if (!this.state.isFallbackActive) {\n      return;\n    }\n\n    this.logger.info('Disabling CLI fallback mode');\n\n    this.state.isFallbackActive = false;\n\n    // Stop notification timer\n    this.stopNotificationTimer();\n\n    this.emit('fallbackDisabled', this.state);\n\n    // Process any queued operations\n    if (this.operationQueue.length > 0) {\n      this.processQueue().catch((error) => {\n        this.logger.error('Error processing queue after fallback disabled', error);\n      });\n    }\n  }\n\n  /**\n   * Queue an operation for later execution\n   */\n  queueOperation(operation: Omit<FallbackOperation, 'id' | 'timestamp'>): void {\n    if (!this.config.enableFallback) {\n      this.logger.debug('Fallback disabled, operation not queued');\n      return;\n    }\n\n    if (this.operationQueue.length >= this.config.maxQueueSize) {\n      this.logger.warn('Operation queue full, removing oldest operation');\n      this.operationQueue.shift();\n      this.state.failedOperations++;\n    }\n\n    const queuedOp: FallbackOperation = {\n      ...operation,\n      id: this.generateOperationId(),\n      timestamp: new Date(),\n    };\n\n    this.operationQueue.push(queuedOp);\n    this.state.queuedOperations = this.operationQueue.length;\n\n    this.logger.debug('Operation queued', {\n      id: queuedOp.id,\n      type: queuedOp.type,\n      method: queuedOp.method,\n      queueSize: this.operationQueue.length,\n    });\n\n    this.emit('operationQueued', queuedOp);\n\n    // If in fallback mode, try to execute via CLI\n    if (this.state.isFallbackActive && !this.processingQueue) {\n      this.executeViaCliFallback(queuedOp).catch((error) => {\n        this.logger.error('CLI fallback execution failed', { operation: queuedOp, error });\n      });\n    }\n  }\n\n  /**\n   * Process all queued operations\n   */\n  async processQueue(): Promise<void> {\n    if (this.processingQueue || this.operationQueue.length === 0) {\n      return;\n    }\n\n    this.processingQueue = true;\n    this.logger.info('Processing operation queue', {\n      queueSize: this.operationQueue.length,\n    });\n\n    this.emit('queueProcessingStart', this.operationQueue.length);\n\n    const results = {\n      successful: 0,\n      failed: 0,\n    };\n\n    // Process operations in order\n    while (this.operationQueue.length > 0) {\n      const operation = this.operationQueue.shift()!;\n\n      // Check if operation has expired\n      if (this.isOperationExpired(operation)) {\n        this.logger.warn('Operation expired', { id: operation.id });\n        results.failed++;\n        continue;\n      }\n\n      try {\n        await this.replayOperation(operation);\n        results.successful++;\n        this.state.successfulOperations++;\n      } catch (error) {\n        this.logger.error('Failed to replay operation', {\n          operation,\n          error,\n        });\n        results.failed++;\n        this.state.failedOperations++;\n\n        // Re-queue if retryable\n        if (operation.retryable) {\n          this.operationQueue.push(operation);\n        }\n      }\n    }\n\n    this.state.queuedOperations = this.operationQueue.length;\n    this.processingQueue = false;\n\n    this.logger.info('Queue processing complete', results);\n    this.emit('queueProcessingComplete', results);\n  }\n\n  /**\n   * Get current fallback state\n   */\n  getState(): FallbackState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get queued operations\n   */\n  getQueuedOperations(): FallbackOperation[] {\n    return [...this.operationQueue];\n  }\n\n  /**\n   * Clear operation queue\n   */\n  clearQueue(): void {\n    const clearedCount = this.operationQueue.length;\n    this.operationQueue = [];\n    this.state.queuedOperations = 0;\n\n    this.logger.info('Operation queue cleared', { clearedCount });\n    this.emit('queueCleared', clearedCount);\n  }\n\n  private async executeViaCliFallback(operation: FallbackOperation): Promise<void> {\n    this.logger.debug('Executing operation via CLI fallback', {\n      id: operation.id,\n      method: operation.method,\n    });\n\n    try {\n      // Map MCP operations to CLI commands\n      const cliCommand = this.mapOperationToCli(operation);\n\n      if (!cliCommand) {\n        throw new Error(`No CLI mapping for operation: ${operation.method}`);\n      }\n\n      const { stdout, stderr } = await execAsync(cliCommand);\n\n      if (stderr) {\n        this.logger.warn('CLI command stderr', { stderr });\n      }\n\n      this.logger.debug('CLI fallback execution successful', {\n        id: operation.id,\n        stdout: stdout.substring(0, 200), // Log first 200 chars\n      });\n\n      this.state.successfulOperations++;\n      this.emit('fallbackExecutionSuccess', { operation, result: stdout });\n    } catch (error) {\n      this.logger.error('CLI fallback execution failed', {\n        operation,\n        error,\n      });\n\n      this.state.failedOperations++;\n      this.emit('fallbackExecutionFailed', { operation, error });\n\n      // Re-queue if retryable\n      if (operation.retryable) {\n        this.queueOperation(operation);\n      }\n    }\n  }\n\n  private async replayOperation(operation: FallbackOperation): Promise<void> {\n    // This would typically use the MCP client to replay the operation\n    // For now, we'll log it\n    this.logger.info('Replaying operation', {\n      id: operation.id,\n      method: operation.method,\n    });\n\n    // Emit event for handling by the MCP client\n    this.emit('replayOperation', operation);\n  }\n\n  private mapOperationToCli(operation: FallbackOperation): string | null {\n    // Map common MCP operations to CLI commands\n    const mappings: Record<string, (params: any) => string> = {\n      // Tool operations\n      'tools/list': () => `${this.config.cliPath} tools list`,\n      'tools/call': (params) =>\n        `${this.config.cliPath} tools call ${params.name} '${JSON.stringify(params.arguments)}'`,\n\n      // Resource operations\n      'resources/list': () => `${this.config.cliPath} resources list`,\n      'resources/read': (params) => `${this.config.cliPath} resources read ${params.uri}`,\n\n      // Session operations\n      initialize: () => `${this.config.cliPath} session init`,\n      shutdown: () => `${this.config.cliPath} session shutdown`,\n\n      // Custom operations\n      heartbeat: () => `${this.config.cliPath} health check`,\n    };\n\n    const mapper = mappings[operation.method];\n    return mapper ? mapper(operation.params) : null;\n  }\n\n  private isOperationExpired(operation: FallbackOperation): boolean {\n    const age = Date.now() - operation.timestamp.getTime();\n    return age > this.config.queueTimeout;\n  }\n\n  private generateOperationId(): string {\n    return `op-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  }\n\n  private startNotificationTimer(): void {\n    if (this.notificationTimer) {\n      return;\n    }\n\n    this.notificationTimer = setInterval(() => {\n      if (this.state.isFallbackActive && this.operationQueue.length > 0) {\n        this.logger.info('Fallback mode active', {\n          queuedOperations: this.operationQueue.length,\n          duration: Date.now() - (this.state.lastFallbackActivation?.getTime() || 0),\n        });\n\n        this.emit('fallbackStatus', this.state);\n      }\n    }, this.config.fallbackNotificationInterval);\n  }\n\n  private stopNotificationTimer(): void {\n    if (this.notificationTimer) {\n      clearInterval(this.notificationTimer);\n      this.notificationTimer = undefined;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
