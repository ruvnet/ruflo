{"version":3,"sources":["../../../../src/swarm/strategies/auto.ts"],"sourcesContent":["// Extended TaskType for auto strategy (extends base TaskType)\r\nexport type ExtendedTaskType =\r\n  | 'data-analysis'\r\n  | 'performance-analysis'\r\n  | 'statistical-analysis'\r\n  | 'visualization'\r\n  | 'predictive-modeling'\r\n  | 'anomaly-detection'\r\n  | 'trend-analysis'\r\n  | 'business-intelligence'\r\n  | 'quality-analysis'\r\n  | 'system-design'\r\n  | 'architecture-review'\r\n  | 'api-design'\r\n  | 'cloud-architecture'\r\n  | 'microservices-design'\r\n  | 'security-architecture'\r\n  | 'scalability-design'\r\n  | 'database-architecture'\r\n  | 'code-generation'\r\n  | 'code-review'\r\n  | 'refactoring'\r\n  | 'debugging'\r\n  | 'api-development'\r\n  | 'database-design'\r\n  | 'performance-optimization'\r\n  | 'task-orchestration'\r\n  | 'progress-tracking'\r\n  | 'resource-allocation'\r\n  | 'workflow-management'\r\n  | 'team-coordination'\r\n  | 'status-reporting'\r\n  | 'fact-check'\r\n  | 'literature-review'\r\n  | 'market-analysis'\r\n  | 'unit-testing'\r\n  | 'integration-testing'\r\n  | 'e2e-testing'\r\n  | 'performance-testing'\r\n  | 'security-testing'\r\n  | 'api-testing'\r\n  | 'test-automation'\r\n  | 'test-analysis';\r\n\r\n/**\r\n * Optimized AUTO Strategy Implementation\r\n * Uses machine learning-inspired heuristics and intelligent task decomposition\r\n */\r\n\r\nimport { BaseStrategy } from './base.js';\r\nimport type { DecompositionResult, TaskBatch, AgentAllocation, TaskPattern } from './base.js';\r\nimport type {\r\n  SwarmObjective,\r\n  TaskDefinition,\r\n  AgentState,\r\n  TaskType,\r\n  TaskPriority,\r\n  TaskId,\r\n  AgentType,\r\n} from '../types.js';\r\nimport { generateId } from '../../utils/helpers.js';\r\n\r\ninterface MLHeuristics {\r\n  taskTypeWeights: Record<string, number>;\r\n  agentPerformanceHistory: Map<string, number>;\r\n  complexityFactors: Record<string, number>;\r\n  parallelismOpportunities: string[];\r\n}\r\n\r\ninterface PredictiveSchedule {\r\n  timeline: ScheduleSlot[];\r\n  resourceUtilization: Record<string, number>;\r\n  bottlenecks: string[];\r\n  optimizationSuggestions: string[];\r\n}\r\n\r\ninterface ScheduleSlot {\r\n  startTime: number;\r\n  endTime: number;\r\n  tasks: string[];\r\n  agents: string[];\r\n  dependencies: string[];\r\n}\r\n\r\nexport class AutoStrategy extends BaseStrategy {\r\n  private mlHeuristics: MLHeuristics;\r\n  private decompositionCache: Map<string, DecompositionResult>;\r\n  private patternCache: Map<string, TaskPattern[]>;\r\n  private performanceHistory: Map<string, number[]>;\r\n\r\n  constructor(config: any) {\r\n    super(config);\r\n    this.mlHeuristics = this.initializeMLHeuristics();\r\n    this.decompositionCache = new Map();\r\n    this.patternCache = new Map();\r\n    this.performanceHistory = new Map();\r\n  }\r\n\r\n  /**\r\n   * Enhanced objective decomposition with async processing and intelligent batching\r\n   */\r\n  override async decomposeObjective(objective: SwarmObjective): Promise<DecompositionResult> {\r\n    const startTime = Date.now();\r\n    const cacheKey = this.getCacheKey(objective);\r\n\r\n    // Check cache first\r\n    if (this.decompositionCache.has(cacheKey)) {\r\n      this.metrics.cacheHitRate = (this.metrics.cacheHitRate + 1) / 2;\r\n      return this.decompositionCache.get(cacheKey)!;\r\n    }\r\n\r\n    // Parallel pattern detection and task type analysis\r\n    const [detectedPatterns, taskTypes, complexity] = await Promise.all([\r\n      this.detectPatternsAsync(objective.description),\r\n      this.analyzeTaskTypesAsync(objective.description),\r\n      this.estimateComplexityAsync(objective.description),\r\n    ]);\r\n\r\n    // Generate tasks based on detected patterns and strategy\r\n    const tasks = await this.generateTasksWithBatching(\r\n      objective,\r\n      detectedPatterns,\r\n      taskTypes,\r\n      complexity,\r\n    );\r\n\r\n    // Analyze dependencies and create batches\r\n    const dependencies = this.analyzeDependencies(tasks);\r\n    const batchGroups = this.createTaskBatches(tasks, dependencies);\r\n\r\n    // Estimate total duration with parallel processing consideration\r\n    const estimatedDuration = this.calculateOptimizedDuration(batchGroups);\r\n\r\n    const result: DecompositionResult = {\r\n      tasks,\r\n      dependencies,\r\n      estimatedDuration,\r\n      recommendedStrategy: this.selectOptimalStrategy(objective, complexity),\r\n      complexity,\r\n      batchGroups,\r\n      timestamp: new Date(),\r\n      ttl: 1800000, // 30 minutes\r\n      accessCount: 0,\r\n      lastAccessed: new Date(),\r\n      data: { objectiveId: objective.id, strategy: 'auto' },\r\n    };\r\n\r\n    // Cache the result\r\n    this.decompositionCache.set(cacheKey, result);\r\n    this.updateMetrics(result, Date.now() - startTime);\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * ML-inspired agent selection with performance history consideration\r\n   */\r\n  override async selectAgentForTask(\r\n    task: TaskDefinition,\r\n    availableAgents: AgentState[],\r\n  ): Promise<string | null> {\r\n    if (availableAgents.length === 0) return null;\r\n\r\n    // Score agents using ML heuristics\r\n    const scoredAgents = await Promise.all(\r\n      availableAgents.map(async (agent) => ({\r\n        agent,\r\n        score: await this.calculateAgentScore(agent, task),\r\n      })),\r\n    );\r\n\r\n    // Sort by score and select best agent\r\n    scoredAgents.sort((a, b) => b.score - a.score);\r\n\r\n    // Update performance history\r\n    const selectedAgent = scoredAgents[0].agent;\r\n    this.updateAgentPerformanceHistory(selectedAgent.id.id, scoredAgents[0].score);\r\n\r\n    return selectedAgent.id.id;\r\n  }\r\n\r\n  /**\r\n   * Predictive task scheduling with dynamic agent allocation\r\n   */\r\n  override async optimizeTaskSchedule(\r\n    tasks: TaskDefinition[],\r\n    agents: AgentState[],\r\n  ): Promise<AgentAllocation[]> {\r\n    const schedule = await this.createPredictiveSchedule(tasks, agents);\r\n\r\n    return this.allocateAgentsOptimally(tasks, agents, schedule);\r\n  }\r\n\r\n  // Private implementation methods\r\n\r\n  private initializeMLHeuristics(): MLHeuristics {\r\n    return {\r\n      taskTypeWeights: {\r\n        development: 1.0,\r\n        testing: 0.8,\r\n        analysis: 0.9,\r\n        documentation: 0.6,\r\n        optimization: 1.1,\r\n        research: 0.7,\r\n      },\r\n      agentPerformanceHistory: new Map(),\r\n      complexityFactors: {\r\n        integration: 1.5,\r\n        system: 1.3,\r\n        api: 1.2,\r\n        database: 1.4,\r\n        ui: 1.1,\r\n        algorithm: 1.6,\r\n      },\r\n      parallelismOpportunities: [\r\n        'independent modules',\r\n        'separate components',\r\n        'different layers',\r\n        'parallel testing',\r\n        'concurrent analysis',\r\n      ],\r\n    };\r\n  }\r\n\r\n  private async detectPatternsAsync(description: string): Promise<TaskPattern[]> {\r\n    const cacheKey = `patterns-${description.slice(0, 50)}`;\r\n\r\n    if (this.patternCache.has(cacheKey)) {\r\n      return this.patternCache.get(cacheKey)!;\r\n    }\r\n\r\n    // Simulate async pattern detection with enhanced matching\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        const patterns = this.taskPatterns.filter((pattern) => pattern.pattern.test(description));\r\n\r\n        // Add dynamic patterns based on content analysis\r\n        const dynamicPatterns = this.generateDynamicPatterns(description);\r\n        const allPatterns = [...patterns, ...dynamicPatterns];\r\n\r\n        this.patternCache.set(cacheKey, allPatterns);\r\n        resolve(allPatterns);\r\n      }, 10); // Simulate async processing\r\n    });\r\n  }\r\n\r\n  private async analyzeTaskTypesAsync(description: string): Promise<string[]> {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        const types = [];\r\n\r\n        // Enhanced task type detection\r\n        if (/create|build|implement|develop|code/i.test(description)) {\r\n          types.push('development');\r\n        }\r\n        if (/test|verify|validate|check/i.test(description)) {\r\n          types.push('testing');\r\n        }\r\n        if (/analyze|research|investigate|study/i.test(description)) {\r\n          types.push('analysis');\r\n        }\r\n        if (/document|write|explain|describe/i.test(description)) {\r\n          types.push('documentation');\r\n        }\r\n        if (/optimize|improve|enhance|refactor/i.test(description)) {\r\n          types.push('optimization');\r\n        }\r\n        if (/deploy|install|configure|setup/i.test(description)) {\r\n          types.push('deployment');\r\n        }\r\n\r\n        resolve(types.length > 0 ? types : ['generic']);\r\n      }, 5);\r\n    });\r\n  }\r\n\r\n  private async estimateComplexityAsync(description: string): Promise<number> {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        let complexity = this.estimateComplexity(description);\r\n\r\n        // Apply ML heuristics for complexity adjustment\r\n        for (const [factor, weight] of Object.entries(this.mlHeuristics.complexityFactors)) {\r\n          if (description.toLowerCase().includes(factor)) {\r\n            complexity *= weight;\r\n          }\r\n        }\r\n\r\n        resolve(Math.min(Math.round(complexity), 5));\r\n      }, 5);\r\n    });\r\n  }\r\n\r\n  private generateDynamicPatterns(description: string): TaskPattern[] {\r\n    const patterns: TaskPattern[] = [];\r\n\r\n    // Generate patterns based on specific keywords and context\r\n    if (description.includes('API') || description.includes('endpoint')) {\r\n      patterns.push({\r\n        pattern: /api|endpoint|service/i,\r\n        type: 'api-development',\r\n        complexity: 3,\r\n        estimatedDuration: 20 * 60 * 1000,\r\n        requiredAgents: 2,\r\n        priority: 2,\r\n      });\r\n    }\r\n\r\n    if (description.includes('database') || description.includes('data')) {\r\n      patterns.push({\r\n        pattern: /database|data|storage/i,\r\n        type: 'data-management',\r\n        complexity: 3,\r\n        estimatedDuration: 18 * 60 * 1000,\r\n        requiredAgents: 2,\r\n        priority: 2,\r\n      });\r\n    }\r\n\r\n    return patterns;\r\n  }\r\n\r\n  private async generateTasksWithBatching(\r\n    objective: SwarmObjective,\r\n    patterns: TaskPattern[],\r\n    taskTypes: string[],\r\n    complexity: number,\r\n  ): Promise<TaskDefinition[]> {\r\n    const tasks: TaskDefinition[] = [];\r\n\r\n    // Determine strategy-specific task generation\r\n    if (objective.strategy === 'development') {\r\n      tasks.push(...(await this.generateDevelopmentTasks(objective, complexity)));\r\n    } else if (objective.strategy === 'analysis') {\r\n      tasks.push(...(await this.generateAnalysisTasks(objective, complexity)));\r\n    } else {\r\n      // Auto strategy - intelligent task generation based on patterns\r\n      tasks.push(...(await this.generateAutoTasks(objective, patterns, taskTypes, complexity)));\r\n    }\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private async generateDevelopmentTasks(\r\n    objective: SwarmObjective,\r\n    complexity: number,\r\n  ): Promise<TaskDefinition[]> {\r\n    const tasks: TaskDefinition[] = [];\r\n    const baseId = generateId('task');\r\n\r\n    // Analysis and Planning Phase\r\n    tasks.push(\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-analysis`,\r\n        type: 'analysis' as TaskType,\r\n        name: 'Requirements Analysis and Planning',\r\n        description: `Analyze requirements and create implementation plan for: ${objective.description}`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: Math.max(5 * 60 * 1000, complexity * 3 * 60 * 1000),\r\n        capabilities: ['analysis', 'documentation', 'research'],\r\n      }),\r\n    );\r\n\r\n    // Implementation Phase (can be parallelized)\r\n    const implementationTasks = this.createParallelImplementationTasks(\r\n      objective,\r\n      complexity,\r\n      baseId,\r\n    );\r\n    tasks.push(...implementationTasks);\r\n\r\n    // Testing Phase\r\n    tasks.push(\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-testing`,\r\n        type: 'testing' as TaskType,\r\n        name: 'Comprehensive Testing',\r\n        description: `Create and execute tests for the implementation`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: Math.max(8 * 60 * 1000, complexity * 4 * 60 * 1000),\r\n        capabilities: ['testing', 'code-generation'],\r\n        dependencies: implementationTasks.map((t) => t.id.id),\r\n      }),\r\n    );\r\n\r\n    // Documentation Phase\r\n    tasks.push(\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-documentation`,\r\n        type: 'documentation' as TaskType,\r\n        name: 'Documentation Creation',\r\n        description: `Create comprehensive documentation`,\r\n        priority: 'medium' as TaskPriority,\r\n        estimatedDuration: Math.max(5 * 60 * 1000, complexity * 2 * 60 * 1000),\r\n        capabilities: ['documentation'],\r\n        dependencies: implementationTasks.map((t) => t.id.id),\r\n      }),\r\n    );\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createParallelImplementationTasks(\r\n    objective: SwarmObjective,\r\n    complexity: number,\r\n    baseId: string,\r\n  ): TaskDefinition[] {\r\n    const tasks: TaskDefinition[] = [];\r\n\r\n    // Determine if we can split implementation into parallel tasks\r\n    const canParallelize = this.canParallelizeImplementation(objective.description);\r\n\r\n    if (canParallelize && complexity >= 3) {\r\n      // Create multiple parallel implementation tasks\r\n      const components = this.identifyComponents(objective.description);\r\n\r\n      components.forEach((component, index) => {\r\n        tasks.push(\r\n          this.createTaskDefinition({\r\n            id: `${baseId}-impl-${index}`,\r\n            type: 'coding' as TaskType,\r\n            name: `Implement ${component}`,\r\n            description: `Implement ${component} component for: ${objective.description}`,\r\n            priority: 'high' as TaskPriority,\r\n            estimatedDuration: Math.max(10 * 60 * 1000, complexity * 5 * 60 * 1000),\r\n            capabilities: ['code-generation', 'file-system'],\r\n            dependencies: [`${baseId}-analysis`],\r\n          }),\r\n        );\r\n      });\r\n    } else {\r\n      // Single implementation task\r\n      tasks.push(\r\n        this.createTaskDefinition({\r\n          id: `${baseId}-implementation`,\r\n          type: 'coding' as TaskType,\r\n          name: 'Core Implementation',\r\n          description: `Implement the solution for: ${objective.description}`,\r\n          priority: 'high' as TaskPriority,\r\n          estimatedDuration: Math.max(15 * 60 * 1000, complexity * 8 * 60 * 1000),\r\n          capabilities: ['code-generation', 'file-system'],\r\n          dependencies: [`${baseId}-analysis`],\r\n        }),\r\n      );\r\n    }\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private async generateAnalysisTasks(\r\n    objective: SwarmObjective,\r\n    complexity: number,\r\n  ): Promise<TaskDefinition[]> {\r\n    const tasks: TaskDefinition[] = [];\r\n    const baseId = generateId('task');\r\n\r\n    // Data Collection\r\n    tasks.push(\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-collection`,\r\n        type: 'research' as TaskType,\r\n        name: 'Data Collection and Research',\r\n        description: `Collect and research data for: ${objective.description}`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: Math.max(8 * 60 * 1000, complexity * 4 * 60 * 1000),\r\n        capabilities: ['research', 'analysis', 'web-search'],\r\n      }),\r\n    );\r\n\r\n    // Analysis\r\n    tasks.push(\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-analysis`,\r\n        type: 'analysis' as TaskType,\r\n        name: 'Data Analysis',\r\n        description: `Analyze collected data and generate insights`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: Math.max(10 * 60 * 1000, complexity * 5 * 60 * 1000),\r\n        capabilities: ['analysis', 'documentation'],\r\n        dependencies: [`${baseId}-collection`],\r\n      }),\r\n    );\r\n\r\n    // Reporting\r\n    tasks.push(\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-reporting`,\r\n        type: 'documentation' as TaskType,\r\n        name: 'Analysis Report',\r\n        description: `Create comprehensive analysis report`,\r\n        priority: 'medium' as TaskPriority,\r\n        estimatedDuration: Math.max(6 * 60 * 1000, complexity * 3 * 60 * 1000),\r\n        capabilities: ['documentation', 'analysis'],\r\n        dependencies: [`${baseId}-analysis`],\r\n      }),\r\n    );\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private async generateAutoTasks(\r\n    objective: SwarmObjective,\r\n    patterns: TaskPattern[],\r\n    taskTypes: string[],\r\n    complexity: number,\r\n  ): Promise<TaskDefinition[]> {\r\n    const tasks: TaskDefinition[] = [];\r\n    const baseId = generateId('task');\r\n\r\n    // Use ML heuristics to determine optimal task structure\r\n    const optimalStructure = this.determineOptimalTaskStructure(patterns, taskTypes, complexity);\r\n\r\n    if (optimalStructure.requiresAnalysis) {\r\n      tasks.push(\r\n        this.createTaskDefinition({\r\n          id: `${baseId}-analysis`,\r\n          type: 'analysis' as TaskType,\r\n          name: 'Intelligent Analysis',\r\n          description: `Analyze and understand: ${objective.description}`,\r\n          priority: 'high' as TaskPriority,\r\n          estimatedDuration: optimalStructure.analysisDuration,\r\n          capabilities: ['analysis', 'research'],\r\n        }),\r\n      );\r\n    }\r\n\r\n    if (optimalStructure.requiresImplementation) {\r\n      const implTasks = this.createOptimalImplementationTasks(objective, optimalStructure, baseId);\r\n      tasks.push(...implTasks);\r\n    }\r\n\r\n    if (optimalStructure.requiresTesting) {\r\n      tasks.push(\r\n        this.createTaskDefinition({\r\n          id: `${baseId}-testing`,\r\n          type: 'testing' as TaskType,\r\n          name: 'Intelligent Testing',\r\n          description: `Test and validate the solution`,\r\n          priority: 'high' as TaskPriority,\r\n          estimatedDuration: optimalStructure.testingDuration,\r\n          capabilities: ['testing', 'validation'],\r\n          dependencies: tasks.filter((t) => t.type === 'coding').map((t) => t.id.id),\r\n        }),\r\n      );\r\n    }\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createTaskDefinition(params: {\r\n    id: string;\r\n    type: TaskType;\r\n    name: string;\r\n    description: string;\r\n    priority: TaskPriority;\r\n    estimatedDuration: number;\r\n    capabilities: string[];\r\n    dependencies?: string[];\r\n  }): TaskDefinition {\r\n    const taskId: TaskId = {\r\n      id: params.id,\r\n      swarmId: 'auto-strategy',\r\n      sequence: 1,\r\n      priority: 1,\r\n    };\r\n\r\n    return {\r\n      id: taskId,\r\n      type: params.type,\r\n      name: params.name,\r\n      description: params.description,\r\n      instructions: params.description,\r\n      requirements: {\r\n        capabilities: params.capabilities,\r\n        tools: this.getRequiredTools(params.type),\r\n        permissions: ['read', 'write', 'execute'],\r\n      },\r\n      constraints: {\r\n        dependencies: (params.dependencies || []).map((dep) => ({\r\n          id: dep,\r\n          swarmId: 'auto-strategy',\r\n          sequence: 1,\r\n          priority: 1,\r\n        })),\r\n        dependents: [],\r\n        conflicts: [],\r\n        maxRetries: 3,\r\n        timeoutAfter: params.estimatedDuration,\r\n      },\r\n      priority: params.priority,\r\n      input: { description: params.description },\r\n      context: {},\r\n      examples: [],\r\n      status: 'created',\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      attempts: [],\r\n      statusHistory: [\r\n        {\r\n          timestamp: new Date(),\r\n          from: 'created',\r\n          to: 'created',\r\n          reason: 'Task created by AutoStrategy',\r\n          triggeredBy: 'system',\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  private getRequiredTools(type: TaskType): string[] {\r\n    const toolMap: Record<string, string[]> = {\r\n      coding: ['file-system', 'terminal', 'editor'],\r\n      testing: ['test-runner', 'file-system', 'terminal'],\r\n      analysis: ['analyst', 'file-system', 'web-search'],\r\n      documentation: ['editor', 'file-system'],\r\n      research: ['web-search', 'analyst', 'file-system'],\r\n      review: ['analyst', 'file-system'],\r\n      deployment: ['terminal', 'file-system', 'deployment-tools'],\r\n      monitoring: ['monitoring-tools', 'analyst'],\r\n      coordination: ['communication-tools'],\r\n      communication: ['communication-tools'],\r\n      maintenance: ['file-system', 'terminal', 'monitoring-tools'],\r\n      optimization: ['analyst', 'profiler', 'file-system'],\r\n      validation: ['validator', 'test-runner'],\r\n      integration: ['integration-tools', 'file-system', 'terminal'],\r\n      custom: ['file-system'],\r\n    };\r\n\r\n    return toolMap[type] || ['file-system'];\r\n  }\r\n\r\n  // Additional helper methods would continue here...\r\n  // (Truncated for brevity - the full implementation would include all helper methods)\r\n\r\n  private canParallelizeImplementation(description: string): boolean {\r\n    const parallelKeywords = ['components', 'modules', 'services', 'layers', 'parts'];\r\n    return parallelKeywords.some((keyword) => description.toLowerCase().includes(keyword));\r\n  }\r\n\r\n  private identifyComponents(description: string): string[] {\r\n    // Simple component identification - in a real implementation this would be more sophisticated\r\n    const components = ['Core Logic', 'User Interface', 'Data Layer'];\r\n\r\n    if (description.toLowerCase().includes('api')) {\r\n      components.push('API Layer');\r\n    }\r\n    if (description.toLowerCase().includes('database')) {\r\n      components.push('Database Integration');\r\n    }\r\n\r\n    return components.slice(0, 3); // Limit to 3 parallel components\r\n  }\r\n\r\n  private determineOptimalTaskStructure(\r\n    patterns: TaskPattern[],\r\n    taskTypes: string[],\r\n    complexity: number,\r\n  ) {\r\n    return {\r\n      requiresAnalysis: complexity >= 2 || taskTypes.includes('analysis'),\r\n      requiresImplementation: taskTypes.includes('development') || taskTypes.includes('coding'),\r\n      requiresTesting: complexity >= 2 || taskTypes.includes('testing'),\r\n      analysisDuration: Math.max(5 * 60 * 1000, complexity * 3 * 60 * 1000),\r\n      testingDuration: Math.max(5 * 60 * 1000, complexity * 4 * 60 * 1000),\r\n    };\r\n  }\r\n\r\n  private createOptimalImplementationTasks(\r\n    objective: SwarmObjective,\r\n    structure: any,\r\n    baseId: string,\r\n  ): TaskDefinition[] {\r\n    return [\r\n      this.createTaskDefinition({\r\n        id: `${baseId}-implementation`,\r\n        type: 'coding' as TaskType,\r\n        name: 'Optimal Implementation',\r\n        description: `Implement solution for: ${objective.description}`,\r\n        priority: 'high' as TaskPriority,\r\n        estimatedDuration: Math.max(15 * 60 * 1000, structure.complexity * 8 * 60 * 1000),\r\n        capabilities: ['code-generation', 'file-system'],\r\n        dependencies: structure.requiresAnalysis ? [`${baseId}-analysis`] : [],\r\n      }),\r\n    ];\r\n  }\r\n\r\n  private analyzeDependencies(tasks: TaskDefinition[]): Map<string, string[]> {\r\n    const dependencies = new Map<string, string[]>();\r\n\r\n    tasks.forEach((task) => {\r\n      if (task.constraints.dependencies.length > 0) {\r\n        dependencies.set(\r\n          task.id.id,\r\n          task.constraints.dependencies.map((dep) => dep.id),\r\n        );\r\n      }\r\n    });\r\n\r\n    return dependencies;\r\n  }\r\n\r\n  private createTaskBatches(\r\n    tasks: TaskDefinition[],\r\n    dependencies: Map<string, string[]>,\r\n  ): TaskBatch[] {\r\n    const batches: TaskBatch[] = [];\r\n    const processed = new Set<string>();\r\n    let batchIndex = 0;\r\n\r\n    while (processed.size < tasks.length) {\r\n      const batchTasks = tasks.filter(\r\n        (task) =>\r\n          !processed.has(task.id.id) &&\r\n          task.constraints.dependencies.every((dep) => processed.has(dep.id)),\r\n      );\r\n\r\n      if (batchTasks.length === 0) break; // Prevent infinite loop\r\n\r\n      const batch: TaskBatch = {\r\n        id: `batch-${batchIndex++}`,\r\n        tasks: batchTasks,\r\n        canRunInParallel: batchTasks.length > 1,\r\n        estimatedDuration: Math.max(...batchTasks.map((t) => t.constraints.timeoutAfter || 0)),\r\n        requiredResources: this.calculateBatchResources(batchTasks),\r\n      };\r\n\r\n      batches.push(batch);\r\n      batchTasks.forEach((task) => processed.add(task.id.id));\r\n    }\r\n\r\n    return batches;\r\n  }\r\n\r\n  private calculateBatchResources(tasks: TaskDefinition[]): Record<string, number> {\r\n    return {\r\n      agents: tasks.length,\r\n      memory: tasks.length * 512, // MB\r\n      cpu: tasks.length * 0.5, // CPU cores\r\n    };\r\n  }\r\n\r\n  private calculateOptimizedDuration(batches: TaskBatch[]): number {\r\n    return batches.reduce((total, batch) => total + batch.estimatedDuration, 0);\r\n  }\r\n\r\n  private selectOptimalStrategy(objective: SwarmObjective, complexity: number): string {\r\n    if (complexity >= 4) return 'development';\r\n    if (objective.description.toLowerCase().includes('analyze')) return 'analysis';\r\n    if (objective.description.toLowerCase().includes('test')) return 'testing';\r\n    return 'auto';\r\n  }\r\n\r\n  private async calculateAgentScore(agent: AgentState, task: TaskDefinition): Promise<number> {\r\n    let score = 0;\r\n\r\n    // Capability matching (40%)\r\n    const capabilityMatch = this.calculateCapabilityMatch(agent, task);\r\n    score += capabilityMatch * 0.4;\r\n\r\n    // Performance history (30%)\r\n    const performanceScore = this.getAgentPerformanceScore(agent.id.id);\r\n    score += performanceScore * 0.3;\r\n\r\n    // Current workload (20%)\r\n    const workloadScore = 1 - agent.workload;\r\n    score += workloadScore * 0.2;\r\n\r\n    // ML heuristics adjustment (10%)\r\n    const mlScore = this.applyMLHeuristics(agent, task);\r\n    score += mlScore * 0.1;\r\n\r\n    return score;\r\n  }\r\n\r\n  private calculateCapabilityMatch(agent: AgentState, task: TaskDefinition): number {\r\n    const requiredCaps = task.requirements.capabilities;\r\n    let matches = 0;\r\n\r\n    for (const cap of requiredCaps) {\r\n      if (this.agentHasCapability(agent, cap)) {\r\n        matches++;\r\n      }\r\n    }\r\n\r\n    return requiredCaps.length > 0 ? matches / requiredCaps.length : 1.0;\r\n  }\r\n\r\n  private agentHasCapability(agent: AgentState, capability: string): boolean {\r\n    const caps = agent.capabilities;\r\n\r\n    switch (capability) {\r\n      case 'code-generation':\r\n        return caps.codeGeneration;\r\n      case 'code-review':\r\n        return caps.codeReview;\r\n      case 'testing':\r\n        return caps.testing;\r\n      case 'documentation':\r\n        return caps.documentation;\r\n      case 'research':\r\n        return caps.research;\r\n      case 'analysis':\r\n        return caps.analysis;\r\n      case 'web-search':\r\n        return caps.webSearch;\r\n      case 'api-integration':\r\n        return caps.apiIntegration;\r\n      case 'file-system':\r\n        return caps.fileSystem;\r\n      case 'terminal-access':\r\n        return caps.terminalAccess;\r\n      default:\r\n        return (\r\n          caps.domains.includes(capability) ||\r\n          caps.languages.includes(capability) ||\r\n          caps.frameworks.includes(capability) ||\r\n          caps.tools.includes(capability)\r\n        );\r\n    }\r\n  }\r\n\r\n  private getAgentPerformanceScore(agentId: string): number {\r\n    const history = this.performanceHistory.get(agentId);\r\n    if (!history || history.length === 0) return 0.8; // Default score\r\n\r\n    const average = history.reduce((sum, score) => sum + score, 0) / history.length;\r\n    return Math.min(average, 1.0);\r\n  }\r\n\r\n  private applyMLHeuristics(agent: AgentState, task: TaskDefinition): number {\r\n    const taskType = this.detectTaskType(task.description);\r\n    const weight = this.mlHeuristics.taskTypeWeights[taskType] || 1.0;\r\n\r\n    // Apply agent type bonus\r\n    let bonus = 0;\r\n    if (agent.type === 'coder' && taskType === 'development') bonus = 0.2;\r\n    if (agent.type === 'tester' && taskType === 'testing') bonus = 0.2;\r\n    if (agent.type === 'analyst' && taskType === 'analysis') bonus = 0.2;\r\n\r\n    return Math.min(weight + bonus, 1.0);\r\n  }\r\n\r\n  private updateAgentPerformanceHistory(agentId: string, score: number): void {\r\n    if (!this.performanceHistory.has(agentId)) {\r\n      this.performanceHistory.set(agentId, []);\r\n    }\r\n\r\n    const history = this.performanceHistory.get(agentId)!;\r\n    history.push(score);\r\n\r\n    // Keep only last 10 scores\r\n    if (history.length > 10) {\r\n      history.shift();\r\n    }\r\n  }\r\n\r\n  private async createPredictiveSchedule(\r\n    tasks: TaskDefinition[],\r\n    agents: AgentState[],\r\n  ): Promise<PredictiveSchedule> {\r\n    // Simplified predictive scheduling implementation\r\n    const timeline: ScheduleSlot[] = [];\r\n    let currentTime = Date.now();\r\n\r\n    for (const task of tasks) {\r\n      const duration = task.constraints.timeoutAfter || 300000; // 5 min default\r\n      timeline.push({\r\n        startTime: currentTime,\r\n        endTime: currentTime + duration,\r\n        tasks: [task.id.id],\r\n        agents: [], // To be filled by allocation\r\n        dependencies: task.constraints.dependencies.map((dep) => dep.id),\r\n      });\r\n      currentTime += duration;\r\n    }\r\n\r\n    return {\r\n      timeline,\r\n      resourceUtilization: { cpu: 0.7, memory: 0.6 },\r\n      bottlenecks: [],\r\n      optimizationSuggestions: ['Consider parallel execution for independent tasks'],\r\n    };\r\n  }\r\n\r\n  private allocateAgentsOptimally(\r\n    tasks: TaskDefinition[],\r\n    agents: AgentState[],\r\n    schedule: PredictiveSchedule,\r\n  ): AgentAllocation[] {\r\n    const allocations: AgentAllocation[] = [];\r\n\r\n    agents.forEach((agent) => {\r\n      const suitableTasks = tasks.filter(\r\n        (task) => this.calculateCapabilityMatch(agent, task) > 0.5,\r\n      );\r\n\r\n      if (suitableTasks.length > 0) {\r\n        allocations.push({\r\n          agentId: agent.id.id,\r\n          tasks: suitableTasks.slice(0, 3).map((t) => t.id.id), // Limit to 3 tasks per agent\r\n          estimatedWorkload: suitableTasks.length * 0.3,\r\n          capabilities: Object.keys(agent.capabilities).filter(\r\n            (cap) => (agent.capabilities as any)[cap] === true,\r\n          ),\r\n        });\r\n      }\r\n    });\r\n\r\n    return allocations;\r\n  }\r\n}\r\n"],"names":["BaseStrategy","generateId","AutoStrategy","mlHeuristics","decompositionCache","patternCache","performanceHistory","config","initializeMLHeuristics","Map","decomposeObjective","objective","startTime","Date","now","cacheKey","getCacheKey","has","metrics","cacheHitRate","get","detectedPatterns","taskTypes","complexity","Promise","all","detectPatternsAsync","description","analyzeTaskTypesAsync","estimateComplexityAsync","tasks","generateTasksWithBatching","dependencies","analyzeDependencies","batchGroups","createTaskBatches","estimatedDuration","calculateOptimizedDuration","result","recommendedStrategy","selectOptimalStrategy","timestamp","ttl","accessCount","lastAccessed","data","objectiveId","id","strategy","set","updateMetrics","selectAgentForTask","task","availableAgents","length","scoredAgents","map","agent","score","calculateAgentScore","sort","a","b","selectedAgent","updateAgentPerformanceHistory","optimizeTaskSchedule","agents","schedule","createPredictiveSchedule","allocateAgentsOptimally","taskTypeWeights","development","testing","analysis","documentation","optimization","research","agentPerformanceHistory","complexityFactors","integration","system","api","database","ui","algorithm","parallelismOpportunities","slice","resolve","setTimeout","patterns","taskPatterns","filter","pattern","test","dynamicPatterns","generateDynamicPatterns","allPatterns","types","push","estimateComplexity","factor","weight","Object","entries","toLowerCase","includes","Math","min","round","type","requiredAgents","priority","generateDevelopmentTasks","generateAnalysisTasks","generateAutoTasks","baseId","createTaskDefinition","name","max","capabilities","implementationTasks","createParallelImplementationTasks","t","canParallelize","canParallelizeImplementation","components","identifyComponents","forEach","component","index","optimalStructure","determineOptimalTaskStructure","requiresAnalysis","analysisDuration","requiresImplementation","implTasks","createOptimalImplementationTasks","requiresTesting","testingDuration","params","taskId","swarmId","sequence","instructions","requirements","tools","getRequiredTools","permissions","constraints","dep","dependents","conflicts","maxRetries","timeoutAfter","input","context","examples","status","createdAt","updatedAt","attempts","statusHistory","from","to","reason","triggeredBy","toolMap","coding","review","deployment","monitoring","coordination","communication","maintenance","validation","custom","parallelKeywords","some","keyword","structure","batches","processed","Set","batchIndex","size","batchTasks","every","batch","canRunInParallel","requiredResources","calculateBatchResources","add","memory","cpu","reduce","total","capabilityMatch","calculateCapabilityMatch","performanceScore","getAgentPerformanceScore","workloadScore","workload","mlScore","applyMLHeuristics","requiredCaps","matches","cap","agentHasCapability","capability","caps","codeGeneration","codeReview","webSearch","apiIntegration","fileSystem","terminalAccess","domains","languages","frameworks","agentId","history","average","sum","taskType","detectTaskType","bonus","shift","timeline","currentTime","duration","endTime","resourceUtilization","bottlenecks","optimizationSuggestions","allocations","suitableTasks","estimatedWorkload","keys"],"mappings":"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"}