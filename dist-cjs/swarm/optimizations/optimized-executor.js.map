{
  "version": 3,
  "sources": ["../../../src/swarm/optimizations/optimized-executor.ts"],
  "sourcesContent": ["/**\n * Optimized Task Executor\n * Implements async execution with connection pooling and caching\n */\n\nimport { EventEmitter } from 'node:events';\nimport { Logger } from '../../core/logger.js';\nimport { ClaudeConnectionPool } from './connection-pool.js';\nimport { AsyncFileManager } from './async-file-manager.js';\nimport { TTLMap } from './ttl-map.js';\nimport { CircularBuffer } from './circular-buffer.js';\nimport PQueue from 'p-queue';\nimport type {\n  TaskDefinition,\n  TaskResult,\n  AgentId,\n  TaskStatus,\n  TaskType,\n  TaskPriority,\n} from '../types.js';\n\nexport interface ExecutorConfig {\n  connectionPool?: {\n    min?: number;\n    max?: number;\n  };\n  concurrency?: number;\n  caching?: {\n    enabled?: boolean;\n    ttl?: number;\n    maxSize?: number;\n  };\n  fileOperations?: {\n    outputDir?: string;\n    concurrency?: number;\n  };\n  monitoring?: {\n    metricsInterval?: number;\n    slowTaskThreshold?: number;\n  };\n}\n\nexport interface ExecutionMetrics {\n  totalExecuted: number;\n  totalSucceeded: number;\n  totalFailed: number;\n  avgExecutionTime: number;\n  cacheHitRate: number;\n  queueLength: number;\n  activeExecutions: number;\n}\n\nexport class OptimizedExecutor extends EventEmitter {\n  private logger: Logger;\n  private connectionPool: ClaudeConnectionPool;\n  private fileManager: AsyncFileManager;\n  private executionQueue: PQueue;\n  private resultCache: TTLMap<string, TaskResult>;\n  private executionHistory: CircularBuffer<{\n    taskId: string;\n    duration: number;\n    status: 'success' | 'failed';\n    timestamp: Date;\n  }>;\n\n  private metrics = {\n    totalExecuted: 0,\n    totalSucceeded: 0,\n    totalFailed: 0,\n    totalExecutionTime: 0,\n    cacheHits: 0,\n    cacheMisses: 0,\n  };\n\n  private activeExecutions = new Set<string>();\n\n  constructor(private config: ExecutorConfig = {}) {\n    super();\n\n    // Use test-safe logger configuration\n    const loggerConfig =\n      process.env.CLAUDE_FLOW_ENV === 'test'\n        ? { level: 'error' as const, format: 'json' as const, destination: 'console' as const }\n        : { level: 'info' as const, format: 'json' as const, destination: 'console' as const };\n\n    this.logger = new Logger(loggerConfig, { component: 'OptimizedExecutor' });\n\n    // Initialize connection pool\n    this.connectionPool = new ClaudeConnectionPool({\n      min: config.connectionPool?.min || 2,\n      max: config.connectionPool?.max || 10,\n    });\n\n    // Initialize file manager\n    this.fileManager = new AsyncFileManager({\n      write: config.fileOperations?.concurrency || 10,\n      read: config.fileOperations?.concurrency || 20,\n    });\n\n    // Initialize execution queue\n    this.executionQueue = new PQueue({\n      concurrency: config.concurrency || 10,\n    });\n\n    // Initialize result cache\n    this.resultCache = new TTLMap({\n      defaultTTL: config.caching?.ttl || 3600000, // 1 hour\n      maxSize: config.caching?.maxSize || 1000,\n      onExpire: (key, value) => {\n        this.logger.debug('Cache entry expired', { taskId: key });\n      },\n    });\n\n    // Initialize execution history\n    this.executionHistory = new CircularBuffer(1000);\n\n    // Start monitoring if configured\n    if (config.monitoring?.metricsInterval) {\n      setInterval(() => {\n        this.emitMetrics();\n      }, config.monitoring.metricsInterval);\n    }\n  }\n\n  async executeTask(task: TaskDefinition, agentId: AgentId): Promise<TaskResult> {\n    const startTime = Date.now();\n    const taskKey = this.getTaskCacheKey(task);\n\n    // Check cache if enabled\n    if (this.config.caching?.enabled) {\n      const cached = this.resultCache.get(taskKey);\n      if (cached) {\n        this.metrics.cacheHits++;\n        this.logger.debug('Cache hit for task', { taskId: task.id });\n        return cached;\n      }\n      this.metrics.cacheMisses++;\n    }\n\n    // Add to active executions\n    this.activeExecutions.add(task.id);\n\n    // Queue the execution\n    const result = await this.executionQueue.add(async () => {\n      try {\n        // Execute with connection pool\n        const executionResult = await this.connectionPool.execute(async (api) => {\n          const response = await api.complete({\n            messages: this.buildMessages(task),\n            model: task.metadata?.model || 'claude-3-5-sonnet-20241022',\n            max_tokens: task.constraints.maxTokens || 4096,\n            temperature: task.metadata?.temperature || 0.7,\n          });\n\n          return {\n            success: true,\n            output: response.content[0]?.text || '',\n            usage: {\n              inputTokens: response.usage?.input_tokens || 0,\n              outputTokens: response.usage?.output_tokens || 0,\n            },\n          };\n        });\n\n        // Save result to file asynchronously\n        if (this.config.fileOperations?.outputDir) {\n          const outputPath = `${this.config.fileOperations.outputDir}/${task.id}.json`;\n          await this.fileManager.writeJSON(outputPath, {\n            taskId: task.id,\n            agentId: agentId.id,\n            result: executionResult,\n            timestamp: new Date(),\n          });\n        }\n\n        // Create task result\n        const taskResult: TaskResult = {\n          taskId: task.id,\n          agentId: agentId.id,\n          success: executionResult.success,\n          output: executionResult.output,\n          error: undefined,\n          executionTime: Date.now() - startTime,\n          tokensUsed: executionResult.usage,\n          timestamp: new Date(),\n        };\n\n        // Cache result if enabled\n        if (this.config.caching?.enabled && executionResult.success) {\n          this.resultCache.set(taskKey, taskResult);\n        }\n\n        // Update metrics\n        this.metrics.totalExecuted++;\n        this.metrics.totalSucceeded++;\n        this.metrics.totalExecutionTime += taskResult.executionTime;\n\n        // Record in history\n        this.executionHistory.push({\n          taskId: task.id,\n          duration: taskResult.executionTime,\n          status: 'success',\n          timestamp: new Date(),\n        });\n\n        // Check if slow task\n        if (\n          this.config.monitoring?.slowTaskThreshold &&\n          taskResult.executionTime > this.config.monitoring.slowTaskThreshold\n        ) {\n          this.logger.warn('Slow task detected', {\n            taskId: task.id,\n            duration: taskResult.executionTime,\n            threshold: this.config.monitoring.slowTaskThreshold,\n          });\n        }\n\n        this.emit('task:completed', taskResult);\n        return taskResult;\n      } catch (error) {\n        this.metrics.totalExecuted++;\n        this.metrics.totalFailed++;\n\n        const errorResult: TaskResult = {\n          taskId: task.id,\n          agentId: agentId.id,\n          success: false,\n          output: '',\n          error: {\n            type: error instanceof Error ? error.constructor.name : 'UnknownError',\n            message: error instanceof Error ? error.message : 'Unknown error',\n            code: (error as any).code,\n            stack: error instanceof Error ? error.stack : undefined,\n            context: { taskId: task.id, agentId: agentId.id },\n            recoverable: this.isRecoverableError(error),\n            retryable: this.isRetryableError(error),\n          },\n          executionTime: Date.now() - startTime,\n          timestamp: new Date(),\n        };\n\n        // Record in history\n        this.executionHistory.push({\n          taskId: task.id,\n          duration: errorResult.executionTime,\n          status: 'failed',\n          timestamp: new Date(),\n        });\n\n        this.emit('task:failed', errorResult);\n        throw error;\n      } finally {\n        this.activeExecutions.delete(task.id);\n      }\n    });\n\n    return result;\n  }\n\n  async executeBatch(tasks: TaskDefinition[], agentId: AgentId): Promise<TaskResult[]> {\n    return Promise.all(tasks.map((task) => this.executeTask(task, agentId)));\n  }\n\n  private buildMessages(task: TaskDefinition): any[] {\n    const messages = [];\n\n    // Add system message if needed\n    if (task.metadata?.systemPrompt) {\n      messages.push({\n        role: 'system',\n        content: task.metadata.systemPrompt,\n      });\n    }\n\n    // Add main task objective\n    messages.push({\n      role: 'user',\n      content: task.objective,\n    });\n\n    // Add context if available\n    if (task.context) {\n      if (task.context.previousResults?.length) {\n        messages.push({\n          role: 'assistant',\n          content:\n            'Previous results:\\n' + task.context.previousResults.map((r) => r.output).join('\\n\\n'),\n        });\n      }\n\n      if (task.context.relatedTasks?.length) {\n        messages.push({\n          role: 'user',\n          content:\n            'Related context:\\n' + task.context.relatedTasks.map((t) => t.objective).join('\\n'),\n        });\n      }\n    }\n\n    return messages;\n  }\n\n  private getTaskCacheKey(task: TaskDefinition): string {\n    // Create a cache key based on task properties\n    return `${task.type}-${task.objective}-${JSON.stringify(task.metadata || {})}`;\n  }\n\n  private isRecoverableError(error: any): boolean {\n    if (!error) return false;\n\n    // Network errors are often recoverable\n    if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT' || error.code === 'ENOTFOUND') {\n      return true;\n    }\n\n    // Rate limit errors are recoverable with backoff\n    if (error.status === 429) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private isRetryableError(error: any): boolean {\n    if (!error) return false;\n\n    // Most recoverable errors are retryable\n    if (this.isRecoverableError(error)) {\n      return true;\n    }\n\n    // Server errors might be temporary\n    if (error.status >= 500 && error.status < 600) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getMetrics(): ExecutionMetrics {\n    const history = this.executionHistory.getAll();\n    const avgExecutionTime =\n      this.metrics.totalExecuted > 0\n        ? this.metrics.totalExecutionTime / this.metrics.totalExecuted\n        : 0;\n\n    const cacheTotal = this.metrics.cacheHits + this.metrics.cacheMisses;\n    const cacheHitRate = cacheTotal > 0 ? this.metrics.cacheHits / cacheTotal : 0;\n\n    return {\n      totalExecuted: this.metrics.totalExecuted,\n      totalSucceeded: this.metrics.totalSucceeded,\n      totalFailed: this.metrics.totalFailed,\n      avgExecutionTime,\n      cacheHitRate,\n      queueLength: this.executionQueue.size,\n      activeExecutions: this.activeExecutions.size,\n    };\n  }\n\n  private emitMetrics(): void {\n    const metrics = this.getMetrics();\n    this.emit('metrics', metrics);\n\n    // Also log if configured\n    this.logger.info('Executor metrics', metrics);\n  }\n\n  async waitForPendingExecutions(): Promise<void> {\n    await this.executionQueue.onIdle();\n    await this.fileManager.waitForPendingOperations();\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down optimized executor');\n\n    // Clear the queue\n    this.executionQueue.clear();\n\n    // Wait for active executions\n    await this.waitForPendingExecutions();\n\n    // Drain connection pool\n    await this.connectionPool.drain();\n\n    // Clear caches\n    this.resultCache.destroy();\n\n    this.logger.info('Optimized executor shut down');\n  }\n\n  /**\n   * Get execution history for analysis\n   */\n  getExecutionHistory() {\n    return this.executionHistory.snapshot();\n  }\n\n  /**\n   * Get connection pool statistics\n   */\n  getConnectionPoolStats() {\n    return this.connectionPool.getStats();\n  }\n\n  /**\n   * Get file manager metrics\n   */\n  getFileManagerMetrics() {\n    return this.fileManager.getMetrics();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    return this.resultCache.getStats();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,yBAA6B;AAC7B,oBAAuB;AACvB,6BAAqC;AACrC,gCAAiC;AACjC,qBAAuB;AACvB,6BAA+B;AAC/B,qBAAmB;AAyCZ,MAAM,0BAA0B,gCAAa;AAAA,EAwBlD,YAAoB,SAAyB,CAAC,GAAG;AAC/C,UAAM;AADY;AAIlB,UAAM,eACJ,QAAQ,IAAI,oBAAoB,SAC5B,EAAE,OAAO,SAAkB,QAAQ,QAAiB,aAAa,UAAmB,IACpF,EAAE,OAAO,QAAiB,QAAQ,QAAiB,aAAa,UAAmB;AAEzF,SAAK,SAAS,IAAI,qBAAO,cAAc,EAAE,WAAW,oBAAoB,CAAC;AAGzE,SAAK,iBAAiB,IAAI,4CAAqB;AAAA,MAC7C,KAAK,OAAO,gBAAgB,OAAO;AAAA,MACnC,KAAK,OAAO,gBAAgB,OAAO;AAAA,IACrC,CAAC;AAGD,SAAK,cAAc,IAAI,2CAAiB;AAAA,MACtC,OAAO,OAAO,gBAAgB,eAAe;AAAA,MAC7C,MAAM,OAAO,gBAAgB,eAAe;AAAA,IAC9C,CAAC;AAGD,SAAK,iBAAiB,IAAI,eAAAA,QAAO;AAAA,MAC/B,aAAa,OAAO,eAAe;AAAA,IACrC,CAAC;AAGD,SAAK,cAAc,IAAI,sBAAO;AAAA,MAC5B,YAAY,OAAO,SAAS,OAAO;AAAA;AAAA,MACnC,SAAS,OAAO,SAAS,WAAW;AAAA,MACpC,UAAU,CAAC,KAAK,UAAU;AACxB,aAAK,OAAO,MAAM,uBAAuB,EAAE,QAAQ,IAAI,CAAC;AAAA,MAC1D;AAAA,IACF,CAAC;AAGD,SAAK,mBAAmB,IAAI,sCAAe,GAAI;AAG/C,QAAI,OAAO,YAAY,iBAAiB;AACtC,kBAAY,MAAM;AAChB,aAAK,YAAY;AAAA,MACnB,GAAG,OAAO,WAAW,eAAe;AAAA,IACtC;AAAA,EACF;AAAA,EA1HF,OAoDoD;AAAA;AAAA;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAOA,UAAU;AAAA,IAChB,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,aAAa;AAAA,IACb,oBAAoB;AAAA,IACpB,WAAW;AAAA,IACX,aAAa;AAAA,EACf;AAAA,EAEQ,mBAAmB,oBAAI,IAAY;AAAA,EAkD3C,MAAM,YAAY,MAAsB,SAAuC;AAC7E,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,UAAU,KAAK,gBAAgB,IAAI;AAGzC,QAAI,KAAK,OAAO,SAAS,SAAS;AAChC,YAAM,SAAS,KAAK,YAAY,IAAI,OAAO;AAC3C,UAAI,QAAQ;AACV,aAAK,QAAQ;AACb,aAAK,OAAO,MAAM,sBAAsB,EAAE,QAAQ,KAAK,GAAG,CAAC;AAC3D,eAAO;AAAA,MACT;AACA,WAAK,QAAQ;AAAA,IACf;AAGA,SAAK,iBAAiB,IAAI,KAAK,EAAE;AAGjC,UAAM,SAAS,MAAM,KAAK,eAAe,IAAI,YAAY;AACvD,UAAI;AAEF,cAAM,kBAAkB,MAAM,KAAK,eAAe,QAAQ,OAAO,QAAQ;AACvE,gBAAM,WAAW,MAAM,IAAI,SAAS;AAAA,YAClC,UAAU,KAAK,cAAc,IAAI;AAAA,YACjC,OAAO,KAAK,UAAU,SAAS;AAAA,YAC/B,YAAY,KAAK,YAAY,aAAa;AAAA,YAC1C,aAAa,KAAK,UAAU,eAAe;AAAA,UAC7C,CAAC;AAED,iBAAO;AAAA,YACL,SAAS;AAAA,YACT,QAAQ,SAAS,QAAQ,CAAC,GAAG,QAAQ;AAAA,YACrC,OAAO;AAAA,cACL,aAAa,SAAS,OAAO,gBAAgB;AAAA,cAC7C,cAAc,SAAS,OAAO,iBAAiB;AAAA,YACjD;AAAA,UACF;AAAA,QACF,CAAC;AAGD,YAAI,KAAK,OAAO,gBAAgB,WAAW;AACzC,gBAAM,aAAa,GAAG,KAAK,OAAO,eAAe,SAAS,IAAI,KAAK,EAAE;AACrE,gBAAM,KAAK,YAAY,UAAU,YAAY;AAAA,YAC3C,QAAQ,KAAK;AAAA,YACb,SAAS,QAAQ;AAAA,YACjB,QAAQ;AAAA,YACR,WAAW,oBAAI,KAAK;AAAA,UACtB,CAAC;AAAA,QACH;AAGA,cAAM,aAAyB;AAAA,UAC7B,QAAQ,KAAK;AAAA,UACb,SAAS,QAAQ;AAAA,UACjB,SAAS,gBAAgB;AAAA,UACzB,QAAQ,gBAAgB;AAAA,UACxB,OAAO;AAAA,UACP,eAAe,KAAK,IAAI,IAAI;AAAA,UAC5B,YAAY,gBAAgB;AAAA,UAC5B,WAAW,oBAAI,KAAK;AAAA,QACtB;AAGA,YAAI,KAAK,OAAO,SAAS,WAAW,gBAAgB,SAAS;AAC3D,eAAK,YAAY,IAAI,SAAS,UAAU;AAAA,QAC1C;AAGA,aAAK,QAAQ;AACb,aAAK,QAAQ;AACb,aAAK,QAAQ,sBAAsB,WAAW;AAG9C,aAAK,iBAAiB,KAAK;AAAA,UACzB,QAAQ,KAAK;AAAA,UACb,UAAU,WAAW;AAAA,UACrB,QAAQ;AAAA,UACR,WAAW,oBAAI,KAAK;AAAA,QACtB,CAAC;AAGD,YACE,KAAK,OAAO,YAAY,qBACxB,WAAW,gBAAgB,KAAK,OAAO,WAAW,mBAClD;AACA,eAAK,OAAO,KAAK,sBAAsB;AAAA,YACrC,QAAQ,KAAK;AAAA,YACb,UAAU,WAAW;AAAA,YACrB,WAAW,KAAK,OAAO,WAAW;AAAA,UACpC,CAAC;AAAA,QACH;AAEA,aAAK,KAAK,kBAAkB,UAAU;AACtC,eAAO;AAAA,MACT,SAAS,OAAO;AACd,aAAK,QAAQ;AACb,aAAK,QAAQ;AAEb,cAAM,cAA0B;AAAA,UAC9B,QAAQ,KAAK;AAAA,UACb,SAAS,QAAQ;AAAA,UACjB,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,OAAO;AAAA,YACL,MAAM,iBAAiB,QAAQ,MAAM,YAAY,OAAO;AAAA,YACxD,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,YAClD,MAAO,MAAc;AAAA,YACrB,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,YAC9C,SAAS,EAAE,QAAQ,KAAK,IAAI,SAAS,QAAQ,GAAG;AAAA,YAChD,aAAa,KAAK,mBAAmB,KAAK;AAAA,YAC1C,WAAW,KAAK,iBAAiB,KAAK;AAAA,UACxC;AAAA,UACA,eAAe,KAAK,IAAI,IAAI;AAAA,UAC5B,WAAW,oBAAI,KAAK;AAAA,QACtB;AAGA,aAAK,iBAAiB,KAAK;AAAA,UACzB,QAAQ,KAAK;AAAA,UACb,UAAU,YAAY;AAAA,UACtB,QAAQ;AAAA,UACR,WAAW,oBAAI,KAAK;AAAA,QACtB,CAAC;AAED,aAAK,KAAK,eAAe,WAAW;AACpC,cAAM;AAAA,MACR,UAAE;AACA,aAAK,iBAAiB,OAAO,KAAK,EAAE;AAAA,MACtC;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,aAAa,OAAyB,SAAyC;AACnF,WAAO,QAAQ,IAAI,MAAM,IAAI,CAAC,SAAS,KAAK,YAAY,MAAM,OAAO,CAAC,CAAC;AAAA,EACzE;AAAA,EAEQ,cAAc,MAA6B;AACjD,UAAM,WAAW,CAAC;AAGlB,QAAI,KAAK,UAAU,cAAc;AAC/B,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS,KAAK,SAAS;AAAA,MACzB,CAAC;AAAA,IACH;AAGA,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS,KAAK;AAAA,IAChB,CAAC;AAGD,QAAI,KAAK,SAAS;AAChB,UAAI,KAAK,QAAQ,iBAAiB,QAAQ;AACxC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SACE,wBAAwB,KAAK,QAAQ,gBAAgB,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,MAAM;AAAA,QACzF,CAAC;AAAA,MACH;AAEA,UAAI,KAAK,QAAQ,cAAc,QAAQ;AACrC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SACE,uBAAuB,KAAK,QAAQ,aAAa,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,IAAI;AAAA,QACtF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,gBAAgB,MAA8B;AAEpD,WAAO,GAAG,KAAK,IAAI,IAAI,KAAK,SAAS,IAAI,KAAK,UAAU,KAAK,YAAY,CAAC,CAAC,CAAC;AAAA,EAC9E;AAAA,EAEQ,mBAAmB,OAAqB;AAC9C,QAAI,CAAC;AAAO,aAAO;AAGnB,QAAI,MAAM,SAAS,gBAAgB,MAAM,SAAS,eAAe,MAAM,SAAS,aAAa;AAC3F,aAAO;AAAA,IACT;AAGA,QAAI,MAAM,WAAW,KAAK;AACxB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,iBAAiB,OAAqB;AAC5C,QAAI,CAAC;AAAO,aAAO;AAGnB,QAAI,KAAK,mBAAmB,KAAK,GAAG;AAClC,aAAO;AAAA,IACT;AAGA,QAAI,MAAM,UAAU,OAAO,MAAM,SAAS,KAAK;AAC7C,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAA+B;AAC7B,UAAM,UAAU,KAAK,iBAAiB,OAAO;AAC7C,UAAM,mBACJ,KAAK,QAAQ,gBAAgB,IACzB,KAAK,QAAQ,qBAAqB,KAAK,QAAQ,gBAC/C;AAEN,UAAM,aAAa,KAAK,QAAQ,YAAY,KAAK,QAAQ;AACzD,UAAM,eAAe,aAAa,IAAI,KAAK,QAAQ,YAAY,aAAa;AAE5E,WAAO;AAAA,MACL,eAAe,KAAK,QAAQ;AAAA,MAC5B,gBAAgB,KAAK,QAAQ;AAAA,MAC7B,aAAa,KAAK,QAAQ;AAAA,MAC1B;AAAA,MACA;AAAA,MACA,aAAa,KAAK,eAAe;AAAA,MACjC,kBAAkB,KAAK,iBAAiB;AAAA,IAC1C;AAAA,EACF;AAAA,EAEQ,cAAoB;AAC1B,UAAM,UAAU,KAAK,WAAW;AAChC,SAAK,KAAK,WAAW,OAAO;AAG5B,SAAK,OAAO,KAAK,oBAAoB,OAAO;AAAA,EAC9C;AAAA,EAEA,MAAM,2BAA0C;AAC9C,UAAM,KAAK,eAAe,OAAO;AACjC,UAAM,KAAK,YAAY,yBAAyB;AAAA,EAClD;AAAA,EAEA,MAAM,WAA0B;AAC9B,SAAK,OAAO,KAAK,kCAAkC;AAGnD,SAAK,eAAe,MAAM;AAG1B,UAAM,KAAK,yBAAyB;AAGpC,UAAM,KAAK,eAAe,MAAM;AAGhC,SAAK,YAAY,QAAQ;AAEzB,SAAK,OAAO,KAAK,8BAA8B;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB;AACpB,WAAO,KAAK,iBAAiB,SAAS;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB;AACvB,WAAO,KAAK,eAAe,SAAS;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB;AACtB,WAAO,KAAK,YAAY,WAAW;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB;AACd,WAAO,KAAK,YAAY,SAAS;AAAA,EACnC;AACF;",
  "names": ["PQueue"]
}
