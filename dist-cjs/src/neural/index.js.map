{"version":3,"sources":["../../../src/neural/index.ts"],"sourcesContent":["/**\r\n * Neural Module - Advanced Domain Mapping and GNN Analysis\r\n * \r\n * This module provides Graph Neural Network (GNN) based domain relationship\r\n * mapping, analysis, and optimization capabilities for Claude Flow.\r\n * \r\n * Key Features:\r\n * - Domain structure to graph conversion\r\n * - GNN-based relationship analysis\r\n * - Domain cohesion scoring\r\n * - Cross-domain dependency identification\r\n * - Predictive boundary optimization\r\n * - Neural network training and inference\r\n * - Integration with Claude Flow hooks system\r\n * \r\n * @author Claude Flow Neural Team\r\n * @version 2.0.0\r\n */\r\n\r\n// Core exports\r\nexport {\r\n  NeuralDomainMapper,\r\n  type DomainNode,\r\n  type DomainEdge,\r\n  type DomainGraph,\r\n  type CohesionAnalysis,\r\n  type DependencyAnalysis,\r\n  type BoundaryOptimization,\r\n  type GNNLayerConfig,\r\n  type TrainingConfig,\r\n} from './NeuralDomainMapper.js';\r\n\r\n// Integration exports\r\nexport {\r\n  NeuralDomainMapperIntegration,\r\n  createDomainMapperIntegration,\r\n  type DomainMapperIntegrationConfig,\r\n  type DomainAnalysisResult,\r\n} from './integration.js';\r\n\r\n// Re-export commonly used types from the hooks system\r\nexport type {\r\n  Pattern,\r\n  TrainingData,\r\n  Prediction,\r\n  Adaptation,\r\n  AgenticHookContext,\r\n  NeuralHookPayload,\r\n} from '../services/agentic-flow-hooks/types.js';\r\n\r\n/**\r\n * Neural module version\r\n */\r\nexport const NEURAL_MODULE_VERSION = '2.0.0';\r\n\r\n/**\r\n * Default configurations for common use cases\r\n */\r\nexport const DEFAULT_CONFIGS = {\r\n  /**\r\n   * Configuration for small-scale domain analysis (< 50 domains)\r\n   */\r\n  SMALL_SCALE: {\r\n    training: {\r\n      learningRate: 0.01,\r\n      batchSize: 16,\r\n      epochs: 50,\r\n      optimizer: 'adam' as const,\r\n      lossFunction: 'mse' as const,\r\n      regularization: {\r\n        l1: 0.0001,\r\n        l2: 0.0001,\r\n        dropout: 0.1,\r\n      },\r\n      earlyStoping: {\r\n        enabled: true,\r\n        patience: 10,\r\n        minDelta: 0.001,\r\n      },\r\n      validationSplit: 0.2,\r\n    },\r\n    integration: {\r\n      enableAutoAnalysis: true,\r\n      enableOptimizationSuggestions: true,\r\n      enableContinuousLearning: true,\r\n      confidenceThreshold: 0.6,\r\n      analysisInterval: 60000, // 1 minute\r\n      maxOptimizationProposals: 5,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Configuration for medium-scale domain analysis (50-200 domains)\r\n   */\r\n  MEDIUM_SCALE: {\r\n    training: {\r\n      learningRate: 0.005,\r\n      batchSize: 32,\r\n      epochs: 100,\r\n      optimizer: 'adam' as const,\r\n      lossFunction: 'mse' as const,\r\n      regularization: {\r\n        l1: 0.0001,\r\n        l2: 0.0001,\r\n        dropout: 0.15,\r\n      },\r\n      earlyStoping: {\r\n        enabled: true,\r\n        patience: 15,\r\n        minDelta: 0.0005,\r\n      },\r\n      validationSplit: 0.2,\r\n    },\r\n    integration: {\r\n      enableAutoAnalysis: true,\r\n      enableOptimizationSuggestions: true,\r\n      enableContinuousLearning: true,\r\n      confidenceThreshold: 0.7,\r\n      analysisInterval: 30000, // 30 seconds\r\n      maxOptimizationProposals: 10,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Configuration for large-scale domain analysis (> 200 domains)\r\n   */\r\n  LARGE_SCALE: {\r\n    training: {\r\n      learningRate: 0.001,\r\n      batchSize: 64,\r\n      epochs: 200,\r\n      optimizer: 'adamw' as const,\r\n      lossFunction: 'mse' as const,\r\n      regularization: {\r\n        l1: 0.0002,\r\n        l2: 0.0002,\r\n        dropout: 0.2,\r\n      },\r\n      earlyStoping: {\r\n        enabled: true,\r\n        patience: 20,\r\n        minDelta: 0.0001,\r\n      },\r\n      validationSplit: 0.15,\r\n    },\r\n    integration: {\r\n      enableAutoAnalysis: true,\r\n      enableOptimizationSuggestions: true,\r\n      enableContinuousLearning: false, // Disable for performance\r\n      confidenceThreshold: 0.8,\r\n      analysisInterval: 120000, // 2 minutes\r\n      maxOptimizationProposals: 20,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Configuration for high-frequency real-time analysis\r\n   */\r\n  REAL_TIME: {\r\n    training: {\r\n      learningRate: 0.01,\r\n      batchSize: 8,\r\n      epochs: 20,\r\n      optimizer: 'sgd' as const,\r\n      lossFunction: 'mse' as const,\r\n      regularization: {\r\n        l1: 0,\r\n        l2: 0,\r\n        dropout: 0.05,\r\n      },\r\n      earlyStoping: {\r\n        enabled: true,\r\n        patience: 5,\r\n        minDelta: 0.01,\r\n      },\r\n      validationSplit: 0.1,\r\n    },\r\n    integration: {\r\n      enableAutoAnalysis: true,\r\n      enableOptimizationSuggestions: false, // Disable for speed\r\n      enableContinuousLearning: true,\r\n      confidenceThreshold: 0.5,\r\n      analysisInterval: 5000, // 5 seconds\r\n      maxOptimizationProposals: 3,\r\n    },\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Utility functions for common operations\r\n */\r\nexport const NeuralUtils = {\r\n  /**\r\n   * Create a simple domain graph from a basic structure\r\n   */\r\n  createSimpleDomainGraph: (\r\n    domains: Array<{ id: string; name: string; type: string }>,\r\n    relationships: Array<{ source: string; target: string; type?: string }>\r\n  ) => {\r\n    const graph: DomainGraph = {\r\n      nodes: new Map(),\r\n      edges: new Map(),\r\n      metadata: {\r\n        created: Date.now(),\r\n        lastTraining: 0,\r\n        version: '1.0.0',\r\n        cohesionScore: 0,\r\n        totalNodes: domains.length,\r\n        totalEdges: relationships.length,\r\n      },\r\n    };\r\n\r\n    // Add nodes\r\n    domains.forEach(domain => {\r\n      const node: DomainNode = {\r\n        id: domain.id,\r\n        name: domain.name,\r\n        type: domain.type as DomainNode['type'],\r\n        features: Array.from({ length: 64 }, () => Math.random()),\r\n        metadata: {\r\n          size: 1,\r\n          complexity: 0.5,\r\n          stability: 0.8,\r\n          dependencies: [],\r\n          lastUpdated: Date.now(),\r\n          version: '1.0.0',\r\n        },\r\n        activation: 0,\r\n        embedding: Array.from({ length: 32 }, () => (Math.random() - 0.5) * 0.1),\r\n      };\r\n      graph.nodes.set(domain.id, node);\r\n    });\r\n\r\n    // Add edges\r\n    relationships.forEach(rel => {\r\n      const edgeId = `${rel.source}->${rel.target}`;\r\n      const edge: DomainEdge = {\r\n        source: rel.source,\r\n        target: rel.target,\r\n        weight: 1.0,\r\n        type: (rel.type as DomainEdge['type']) || 'dependency',\r\n        features: Array.from({ length: 32 }, () => Math.random()),\r\n        metadata: {\r\n          frequency: 1,\r\n          latency: 100,\r\n          reliability: 0.99,\r\n          bandwidth: 1000,\r\n          direction: 'unidirectional',\r\n        },\r\n      };\r\n      graph.edges.set(edgeId, edge);\r\n    });\r\n\r\n    return graph;\r\n  },\r\n\r\n  /**\r\n   * Generate synthetic training data for testing\r\n   */\r\n  generateSyntheticTrainingData: (size: number): TrainingData => {\r\n    const inputs = Array.from({ length: size }, () => ({\r\n      features: Array.from({ length: 64 }, () => Math.random()),\r\n    }));\r\n\r\n    const outputs = Array.from({ length: size }, () => \r\n      Array.from({ length: 4 }, () => Math.random())\r\n    );\r\n\r\n    return {\r\n      inputs,\r\n      outputs,\r\n      batchSize: Math.min(32, size),\r\n      epochs: Math.max(1, Math.min(50, size / 10)),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Calculate basic domain metrics\r\n   */\r\n  calculateBasicMetrics: (graph: DomainGraph) => {\r\n    const nodeCount = graph.nodes.size;\r\n    const edgeCount = graph.edges.size;\r\n    const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;\r\n\r\n    // Calculate in/out degree distributions\r\n    const inDegrees = new Map<string, number>();\r\n    const outDegrees = new Map<string, number>();\r\n\r\n    // Initialize degrees\r\n    for (const nodeId of graph.nodes.keys()) {\r\n      inDegrees.set(nodeId, 0);\r\n      outDegrees.set(nodeId, 0);\r\n    }\r\n\r\n    // Count degrees\r\n    for (const edge of graph.edges.values()) {\r\n      outDegrees.set(edge.source, (outDegrees.get(edge.source) || 0) + 1);\r\n      inDegrees.set(edge.target, (inDegrees.get(edge.target) || 0) + 1);\r\n    }\r\n\r\n    const avgInDegree = Array.from(inDegrees.values()).reduce((sum, deg) => sum + deg, 0) / nodeCount;\r\n    const avgOutDegree = Array.from(outDegrees.values()).reduce((sum, deg) => sum + deg, 0) / nodeCount;\r\n\r\n    return {\r\n      nodeCount,\r\n      edgeCount,\r\n      density,\r\n      avgInDegree,\r\n      avgOutDegree,\r\n      complexity: Math.log(nodeCount + 1) * density,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Validate domain graph structure\r\n   */\r\n  validateDomainGraph: (graph: DomainGraph): {\r\n    valid: boolean;\r\n    errors: string[];\r\n    warnings: string[];\r\n  } => {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n\r\n    // Check for empty graph\r\n    if (graph.nodes.size === 0) {\r\n      errors.push('Graph has no nodes');\r\n    }\r\n\r\n    // Check for orphaned edges\r\n    for (const edge of graph.edges.values()) {\r\n      if (!graph.nodes.has(edge.source)) {\r\n        errors.push(`Edge references non-existent source node: ${edge.source}`);\r\n      }\r\n      if (!graph.nodes.has(edge.target)) {\r\n        errors.push(`Edge references non-existent target node: ${edge.target}`);\r\n      }\r\n    }\r\n\r\n    // Check for isolated nodes\r\n    const connectedNodes = new Set<string>();\r\n    for (const edge of graph.edges.values()) {\r\n      connectedNodes.add(edge.source);\r\n      connectedNodes.add(edge.target);\r\n    }\r\n\r\n    for (const nodeId of graph.nodes.keys()) {\r\n      if (!connectedNodes.has(nodeId)) {\r\n        warnings.push(`Isolated node detected: ${nodeId}`);\r\n      }\r\n    }\r\n\r\n    // Check for very sparse or very dense graphs\r\n    const density = NeuralUtils.calculateBasicMetrics(graph).density;\r\n    if (density < 0.1) {\r\n      warnings.push('Graph is very sparse (density < 0.1)');\r\n    } else if (density > 0.8) {\r\n      warnings.push('Graph is very dense (density > 0.8)');\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n    };\r\n  },\r\n};\r\n\r\n/**\r\n * Example usage patterns\r\n */\r\nexport const Examples = {\r\n  /**\r\n   * Basic domain analysis example\r\n   */\r\n  basicAnalysis: async () => {\r\n    // Create a simple domain mapper\r\n    const mapper = new NeuralDomainMapper(DEFAULT_CONFIGS.SMALL_SCALE.training);\r\n\r\n    // Create a sample domain graph\r\n    const graph = NeuralUtils.createSimpleDomainGraph(\r\n      [\r\n        { id: 'user-service', name: 'User Service', type: 'api' },\r\n        { id: 'auth-service', name: 'Authentication Service', type: 'api' },\r\n        { id: 'user-db', name: 'User Database', type: 'data' },\r\n        { id: 'user-ui', name: 'User Interface', type: 'ui' },\r\n      ],\r\n      [\r\n        { source: 'user-service', target: 'auth-service', type: 'dependency' },\r\n        { source: 'user-service', target: 'user-db', type: 'data-flow' },\r\n        { source: 'user-ui', target: 'user-service', type: 'communication' },\r\n      ]\r\n    );\r\n\r\n    // Perform analysis\r\n    const analysis = await mapper.analyzeDomains(graph);\r\n    \r\n    return {\r\n      cohesionScore: analysis.cohesion.overallScore,\r\n      dependencyCount: analysis.dependencies.graph.size,\r\n      optimizationProposals: analysis.optimization.proposals.length,\r\n      recommendations: analysis.recommendations,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Training and prediction example\r\n   */\r\n  trainingExample: async () => {\r\n    const mapper = new NeuralDomainMapper(DEFAULT_CONFIGS.MEDIUM_SCALE.training);\r\n\r\n    // Generate synthetic training data\r\n    const trainingData = NeuralUtils.generateSyntheticTrainingData(100);\r\n    const validationData = NeuralUtils.generateSyntheticTrainingData(20);\r\n\r\n    // Train the model\r\n    const trainingResult = await mapper.train(trainingData, validationData);\r\n\r\n    // Make a prediction\r\n    const prediction = await mapper.predict({\r\n      features: Array.from({ length: 64 }, () => Math.random()),\r\n    });\r\n\r\n    return {\r\n      finalAccuracy: trainingResult.finalAccuracy,\r\n      trainingEpochs: trainingResult.trainingHistory.length,\r\n      predictionConfidence: prediction.confidence,\r\n      alternativeCount: prediction.alternatives.length,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Integration with hooks system example\r\n   */\r\n  integrationExample: async () => {\r\n    // Create integrated domain mapper\r\n    const integration = await createDomainMapperIntegration(\r\n      DEFAULT_CONFIGS.MEDIUM_SCALE.integration\r\n    );\r\n\r\n    // Set up event listeners\r\n    integration.on('domain-analysis-completed', (result: DomainAnalysisResult) => {\r\n      console.log(`Analysis completed: ${result.cohesion.overallScore} cohesion score`);\r\n    });\r\n\r\n    integration.on('optimization-suggestions-generated', (result: any) => {\r\n      console.log(`${result.prioritizedActions.length} optimization suggestions generated`);\r\n    });\r\n\r\n    // Get integration statistics\r\n    const stats = integration.getIntegrationStats();\r\n\r\n    return {\r\n      initialized: true,\r\n      stats,\r\n    };\r\n  },\r\n};\r\n\r\n// Default export for convenience\r\nexport default {\r\n  NeuralDomainMapper,\r\n  NeuralDomainMapperIntegration,\r\n  createDomainMapperIntegration,\r\n  DEFAULT_CONFIGS,\r\n  NeuralUtils,\r\n  Examples,\r\n  NEURAL_MODULE_VERSION,\r\n};"],"names":["NeuralDomainMapper","NeuralDomainMapperIntegration","createDomainMapperIntegration","NEURAL_MODULE_VERSION","DEFAULT_CONFIGS","SMALL_SCALE","training","learningRate","batchSize","epochs","optimizer","lossFunction","regularization","l1","l2","dropout","earlyStoping","enabled","patience","minDelta","validationSplit","integration","enableAutoAnalysis","enableOptimizationSuggestions","enableContinuousLearning","confidenceThreshold","analysisInterval","maxOptimizationProposals","MEDIUM_SCALE","LARGE_SCALE","REAL_TIME","NeuralUtils","createSimpleDomainGraph","domains","relationships","graph","nodes","Map","edges","metadata","created","Date","now","lastTraining","version","cohesionScore","totalNodes","length","totalEdges","forEach","domain","node","id","name","type","features","Array","from","Math","random","size","complexity","stability","dependencies","lastUpdated","activation","embedding","set","rel","edgeId","source","target","edge","weight","frequency","latency","reliability","bandwidth","direction","generateSyntheticTrainingData","inputs","outputs","min","max","calculateBasicMetrics","nodeCount","edgeCount","density","inDegrees","outDegrees","nodeId","keys","values","get","avgInDegree","reduce","sum","deg","avgOutDegree","log","validateDomainGraph","errors","warnings","push","has","connectedNodes","Set","add","valid","Examples","basicAnalysis","mapper","analysis","analyzeDomains","cohesion","overallScore","dependencyCount","optimizationProposals","optimization","proposals","recommendations","trainingExample","trainingData","validationData","trainingResult","train","prediction","predict","finalAccuracy","trainingEpochs","trainingHistory","predictionConfidence","confidence","alternativeCount","alternatives","integrationExample","on","result","console","prioritizedActions","stats","getIntegrationStats","initialized"],"mappings":"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"}