{
  "version": 3,
  "sources": ["../../src/agents/agent-loader.ts"],
  "sourcesContent": ["/**\n * Dynamic Agent Loader - Reads agent definitions from .claude/agents/ directory\n * This is the single source of truth for all agent types in the system\n */\n\nimport { readFileSync, existsSync } from 'node:fs';\nimport { glob } from 'glob';\nimport { resolve, dirname } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\n\n// Legacy agent type mapping for backward compatibility\nconst LEGACY_AGENT_MAPPING = {\n  analyst: 'code-analyzer',\n  coordinator: 'task-orchestrator', \n  optimizer: 'perf-analyzer',\n  documenter: 'api-docs',\n  monitor: 'performance-benchmarker',\n  specialist: 'system-architect',\n  architect: 'system-architect',\n} as const;\n\n/**\n * Resolve legacy agent types to current equivalents\n */\nfunction resolveLegacyAgentType(legacyType: string): string {\n  return LEGACY_AGENT_MAPPING[legacyType as keyof typeof LEGACY_AGENT_MAPPING] || legacyType;\n}\n\nexport interface AgentDefinition {\n  name: string;\n  type?: string;\n  color?: string;\n  description: string;\n  capabilities?: string[];\n  priority?: 'low' | 'medium' | 'high' | 'critical';\n  hooks?: {\n    pre?: string;\n    post?: string;\n  };\n  content?: string; // The markdown content after frontmatter\n}\n\nexport interface AgentCategory {\n  name: string;\n  agents: AgentDefinition[];\n}\n\nclass AgentLoader {\n  private agentCache: Map<string, AgentDefinition> = new Map();\n  private categoriesCache: AgentCategory[] = [];\n  private lastLoadTime = 0;\n  private cacheExpiry = 60000; // 1 minute cache\n\n  /**\n   * Get the .claude/agents directory path\n   */\n  private getAgentsDirectory(): string {\n    // Start from current working directory and walk up to find .claude/agents\n    let currentDir = process.cwd();\n    \n    while (currentDir !== '/') {\n      const claudeAgentsPath = resolve(currentDir, '.claude', 'agents');\n      if (existsSync(claudeAgentsPath)) {\n        return claudeAgentsPath;\n      }\n      currentDir = dirname(currentDir);\n    }\n    \n    // Fallback to relative path\n    return resolve(process.cwd(), '.claude', 'agents');\n  }\n\n  /**\n   * Parse agent definition from markdown file\n   */\n  private parseAgentFile(filePath: string): AgentDefinition | null {\n    try {\n      const content = readFileSync(filePath, 'utf-8');\n      \n      // Split frontmatter and content\n      const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n      if (!frontmatterMatch) {\n        console.warn(`No frontmatter found in ${filePath}`);\n        return null;\n      }\n\n      const [, yamlContent, markdownContent] = frontmatterMatch;\n      const frontmatter = parseYaml(yamlContent);\n\n      if (!frontmatter.name || !frontmatter.metadata?.description) {\n        console.warn(`Missing required fields (name, metadata.description) in ${filePath}`);\n        return null;\n      }\n\n      return {\n        name: frontmatter.name,\n        type: frontmatter.type,\n        color: frontmatter.color,\n        description: frontmatter.metadata.description,\n        capabilities: frontmatter.metadata.capabilities || frontmatter.capabilities || [],\n        priority: frontmatter.priority || 'medium',\n        hooks: frontmatter.hooks,\n        content: markdownContent.trim(),\n      };\n    } catch (error) {\n      console.error(`Error parsing agent file ${filePath}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Load all agent definitions from .claude/agents directory\n   */\n  private async loadAgents(): Promise<void> {\n    const agentsDir = this.getAgentsDirectory();\n    \n    if (!existsSync(agentsDir)) {\n      console.warn(`Agents directory not found: ${agentsDir}`);\n      return;\n    }\n\n    // Find all .md files in the agents directory\n    const agentFiles = await glob('**/*.md', {\n      cwd: agentsDir,\n      ignore: ['**/README.md', '**/MIGRATION_SUMMARY.md'],\n      absolute: true,\n    });\n\n    // Clear cache\n    this.agentCache.clear();\n    this.categoriesCache = [];\n\n    // Track categories\n    const categoryMap = new Map<string, AgentDefinition[]>();\n\n    // Parse each agent file\n    for (const filePath of agentFiles) {\n      const agent = this.parseAgentFile(filePath);\n      if (agent) {\n        this.agentCache.set(agent.name, agent);\n        \n        // Determine category from file path\n        const relativePath = filePath.replace(agentsDir, '');\n        const pathParts = relativePath.split('/');\n        const category = pathParts[1] || 'uncategorized'; // First directory after agents/\n        \n        if (!categoryMap.has(category)) {\n          categoryMap.set(category, []);\n        }\n        categoryMap.get(category)!.push(agent);\n      }\n    }\n\n    // Build categories array\n    this.categoriesCache = Array.from(categoryMap.entries()).map(([name, agents]) => ({\n      name,\n      agents: agents.sort((a, b) => a.name.localeCompare(b.name)),\n    }));\n\n    this.lastLoadTime = Date.now();\n  }\n\n  /**\n   * Check if cache needs refresh\n   */\n  private needsRefresh(): boolean {\n    return Date.now() - this.lastLoadTime > this.cacheExpiry;\n  }\n\n  /**\n   * Ensure agents are loaded and cache is fresh\n   */\n  private async ensureLoaded(): Promise<void> {\n    if (this.agentCache.size === 0 || this.needsRefresh()) {\n      await this.loadAgents();\n    }\n  }\n\n  /**\n   * Get all available agent types\n   */\n  async getAvailableAgentTypes(): Promise<string[]> {\n    await this.ensureLoaded();\n    const currentTypes = Array.from(this.agentCache.keys());\n    const legacyTypes = Object.keys(LEGACY_AGENT_MAPPING);\n    // Return both current types and legacy types, removing duplicates\n    const combined = [...currentTypes, ...legacyTypes];\n    const uniqueTypes = Array.from(new Set(combined));\n    return uniqueTypes.sort();\n  }\n\n  /**\n   * Get agent definition by name\n   */\n  async getAgent(name: string): Promise<AgentDefinition | null> {\n    await this.ensureLoaded();\n    // First try the original name, then try the legacy mapping\n    return this.agentCache.get(name) || this.agentCache.get(resolveLegacyAgentType(name)) || null;\n  }\n\n  /**\n   * Get all agent definitions\n   */\n  async getAllAgents(): Promise<AgentDefinition[]> {\n    await this.ensureLoaded();\n    return Array.from(this.agentCache.values()).sort((a, b) => a.name.localeCompare(b.name));\n  }\n\n  /**\n   * Get agents organized by category\n   */\n  async getAgentCategories(): Promise<AgentCategory[]> {\n    await this.ensureLoaded();\n    return this.categoriesCache;\n  }\n\n  /**\n   * Search agents by capabilities, description, or name\n   */\n  async searchAgents(query: string): Promise<AgentDefinition[]> {\n    await this.ensureLoaded();\n    const lowerQuery = query.toLowerCase();\n    \n    return Array.from(this.agentCache.values()).filter(agent => {\n      return (\n        agent.name.toLowerCase().includes(lowerQuery) ||\n        agent.description.toLowerCase().includes(lowerQuery) ||\n        agent.capabilities?.some(cap => cap.toLowerCase().includes(lowerQuery)) ||\n        false\n      );\n    });\n  }\n\n  /**\n   * Check if an agent type is valid\n   */\n  async isValidAgentType(name: string): Promise<boolean> {\n    await this.ensureLoaded();\n    // First try the original name, then try the legacy mapping\n    return this.agentCache.has(name) || this.agentCache.has(resolveLegacyAgentType(name));\n  }\n\n  /**\n   * Get agents by category name\n   */\n  async getAgentsByCategory(category: string): Promise<AgentDefinition[]> {\n    const categories = await this.getAgentCategories();\n    const found = categories.find(cat => cat.name === category);\n    return found?.agents || [];\n  }\n\n  /**\n   * Force refresh the agent cache\n   */\n  async refresh(): Promise<void> {\n    this.lastLoadTime = 0; // Force reload\n    await this.loadAgents();\n  }\n}\n\n// Singleton instance\nexport const agentLoader = new AgentLoader();\n\n// Convenience functions\nexport const getAvailableAgentTypes = () => agentLoader.getAvailableAgentTypes();\nexport const getAgent = (name: string) => agentLoader.getAgent(name);\nexport const getAllAgents = () => agentLoader.getAllAgents();\nexport const getAgentCategories = () => agentLoader.getAgentCategories();\nexport const searchAgents = (query: string) => agentLoader.searchAgents(query);\nexport const isValidAgentType = (name: string) => agentLoader.isValidAgentType(name);\nexport const getAgentsByCategory = (category: string) => agentLoader.getAgentsByCategory(category);\nexport const refreshAgents = () => agentLoader.refresh();\n\n// Export legacy mapping utilities\nexport { resolveLegacyAgentType, LEGACY_AGENT_MAPPING };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,qBAAyC;AACzC,kBAAqB;AACrB,uBAAiC;AACjC,kBAAmC;AAGnC,MAAM,uBAAuB;AAAA,EAC3B,SAAS;AAAA,EACT,aAAa;AAAA,EACb,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,WAAW;AACb;AAKA,SAAS,uBAAuB,YAA4B;AAC1D,SAAO,qBAAqB,UAA+C,KAAK;AAClF;AAFS;AAuBT,MAAM,YAAY;AAAA,EA/ClB,OA+CkB;AAAA;AAAA;AAAA,EACR,aAA2C,oBAAI,IAAI;AAAA,EACnD,kBAAmC,CAAC;AAAA,EACpC,eAAe;AAAA,EACf,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAKd,qBAA6B;AAEnC,QAAI,aAAa,QAAQ,IAAI;AAE7B,WAAO,eAAe,KAAK;AACzB,YAAM,uBAAmB,0BAAQ,YAAY,WAAW,QAAQ;AAChE,cAAI,2BAAW,gBAAgB,GAAG;AAChC,eAAO;AAAA,MACT;AACA,uBAAa,0BAAQ,UAAU;AAAA,IACjC;AAGA,eAAO,0BAAQ,QAAQ,IAAI,GAAG,WAAW,QAAQ;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,UAA0C;AAC/D,QAAI;AACF,YAAM,cAAU,6BAAa,UAAU,OAAO;AAG9C,YAAM,mBAAmB,QAAQ,MAAM,mCAAmC;AAC1E,UAAI,CAAC,kBAAkB;AACrB,gBAAQ,KAAK,2BAA2B,QAAQ,EAAE;AAClD,eAAO;AAAA,MACT;AAEA,YAAM,CAAC,EAAE,aAAa,eAAe,IAAI;AACzC,YAAM,kBAAc,YAAAA,OAAU,WAAW;AAEzC,UAAI,CAAC,YAAY,QAAQ,CAAC,YAAY,UAAU,aAAa;AAC3D,gBAAQ,KAAK,2DAA2D,QAAQ,EAAE;AAClF,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,QACL,MAAM,YAAY;AAAA,QAClB,MAAM,YAAY;AAAA,QAClB,OAAO,YAAY;AAAA,QACnB,aAAa,YAAY,SAAS;AAAA,QAClC,cAAc,YAAY,SAAS,gBAAgB,YAAY,gBAAgB,CAAC;AAAA,QAChF,UAAU,YAAY,YAAY;AAAA,QAClC,OAAO,YAAY;AAAA,QACnB,SAAS,gBAAgB,KAAK;AAAA,MAChC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,4BAA4B,QAAQ,KAAK,KAAK;AAC5D,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,aAA4B;AACxC,UAAM,YAAY,KAAK,mBAAmB;AAE1C,QAAI,KAAC,2BAAW,SAAS,GAAG;AAC1B,cAAQ,KAAK,+BAA+B,SAAS,EAAE;AACvD;AAAA,IACF;AAGA,UAAM,aAAa,UAAM,kBAAK,WAAW;AAAA,MACvC,KAAK;AAAA,MACL,QAAQ,CAAC,gBAAgB,yBAAyB;AAAA,MAClD,UAAU;AAAA,IACZ,CAAC;AAGD,SAAK,WAAW,MAAM;AACtB,SAAK,kBAAkB,CAAC;AAGxB,UAAM,cAAc,oBAAI,IAA+B;AAGvD,eAAW,YAAY,YAAY;AACjC,YAAM,QAAQ,KAAK,eAAe,QAAQ;AAC1C,UAAI,OAAO;AACT,aAAK,WAAW,IAAI,MAAM,MAAM,KAAK;AAGrC,cAAM,eAAe,SAAS,QAAQ,WAAW,EAAE;AACnD,cAAM,YAAY,aAAa,MAAM,GAAG;AACxC,cAAM,WAAW,UAAU,CAAC,KAAK;AAEjC,YAAI,CAAC,YAAY,IAAI,QAAQ,GAAG;AAC9B,sBAAY,IAAI,UAAU,CAAC,CAAC;AAAA,QAC9B;AACA,oBAAY,IAAI,QAAQ,EAAG,KAAK,KAAK;AAAA,MACvC;AAAA,IACF;AAGA,SAAK,kBAAkB,MAAM,KAAK,YAAY,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,MAAM,OAAO;AAAA,MAChF;AAAA,MACA,QAAQ,OAAO,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,cAAc,EAAE,IAAI,CAAC;AAAA,IAC5D,EAAE;AAEF,SAAK,eAAe,KAAK,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAwB;AAC9B,WAAO,KAAK,IAAI,IAAI,KAAK,eAAe,KAAK;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,eAA8B;AAC1C,QAAI,KAAK,WAAW,SAAS,KAAK,KAAK,aAAa,GAAG;AACrD,YAAM,KAAK,WAAW;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,yBAA4C;AAChD,UAAM,KAAK,aAAa;AACxB,UAAM,eAAe,MAAM,KAAK,KAAK,WAAW,KAAK,CAAC;AACtD,UAAM,cAAc,OAAO,KAAK,oBAAoB;AAEpD,UAAM,WAAW,CAAC,GAAG,cAAc,GAAG,WAAW;AACjD,UAAM,cAAc,MAAM,KAAK,IAAI,IAAI,QAAQ,CAAC;AAChD,WAAO,YAAY,KAAK;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,MAA+C;AAC5D,UAAM,KAAK,aAAa;AAExB,WAAO,KAAK,WAAW,IAAI,IAAI,KAAK,KAAK,WAAW,IAAI,uBAAuB,IAAI,CAAC,KAAK;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAA2C;AAC/C,UAAM,KAAK,aAAa;AACxB,WAAO,MAAM,KAAK,KAAK,WAAW,OAAO,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,cAAc,EAAE,IAAI,CAAC;AAAA,EACzF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAA+C;AACnD,UAAM,KAAK,aAAa;AACxB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,OAA2C;AAC5D,UAAM,KAAK,aAAa;AACxB,UAAM,aAAa,MAAM,YAAY;AAErC,WAAO,MAAM,KAAK,KAAK,WAAW,OAAO,CAAC,EAAE,OAAO,WAAS;AAC1D,aACE,MAAM,KAAK,YAAY,EAAE,SAAS,UAAU,KAC5C,MAAM,YAAY,YAAY,EAAE,SAAS,UAAU,KACnD,MAAM,cAAc,KAAK,SAAO,IAAI,YAAY,EAAE,SAAS,UAAU,CAAC,KACtE;AAAA,IAEJ,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,MAAgC;AACrD,UAAM,KAAK,aAAa;AAExB,WAAO,KAAK,WAAW,IAAI,IAAI,KAAK,KAAK,WAAW,IAAI,uBAAuB,IAAI,CAAC;AAAA,EACtF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,UAA8C;AACtE,UAAM,aAAa,MAAM,KAAK,mBAAmB;AACjD,UAAM,QAAQ,WAAW,KAAK,SAAO,IAAI,SAAS,QAAQ;AAC1D,WAAO,OAAO,UAAU,CAAC;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAyB;AAC7B,SAAK,eAAe;AACpB,UAAM,KAAK,WAAW;AAAA,EACxB;AACF;AAGO,MAAM,cAAc,IAAI,YAAY;AAGpC,MAAM,yBAAyB,6BAAM,YAAY,uBAAuB,GAAzC;AAC/B,MAAM,WAAW,wBAAC,SAAiB,YAAY,SAAS,IAAI,GAA3C;AACjB,MAAM,eAAe,6BAAM,YAAY,aAAa,GAA/B;AACrB,MAAM,qBAAqB,6BAAM,YAAY,mBAAmB,GAArC;AAC3B,MAAM,eAAe,wBAAC,UAAkB,YAAY,aAAa,KAAK,GAAjD;AACrB,MAAM,mBAAmB,wBAAC,SAAiB,YAAY,iBAAiB,IAAI,GAAnD;AACzB,MAAM,sBAAsB,wBAAC,aAAqB,YAAY,oBAAoB,QAAQ,GAA9D;AAC5B,MAAM,gBAAgB,6BAAM,YAAY,QAAQ,GAA1B;",
  "names": ["parseYaml"]
}
