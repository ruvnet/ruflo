{"version":3,"sources":["../../../../src/hive-mind/core/Agent.ts"],"sourcesContent":["/**\r\n * Base Agent Class\r\n *\r\n * Foundation for all agent types in the Hive Mind swarm.\r\n * Provides core functionality for task execution, communication, and coordination.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { DatabaseManager } from './DatabaseManager.js';\r\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\r\nimport {\r\n  AgentType,\r\n  AgentStatus,\r\n  AgentCapability,\r\n  Task,\r\n  Message,\r\n  AgentConfig,\r\n  ExecutionResult,\r\n} from '../types.js';\r\n\r\nexport class Agent extends EventEmitter {\r\n  public readonly id: string;\r\n  public readonly name: string;\r\n  public readonly type: AgentType;\r\n  public readonly swarmId: string;\r\n  public readonly capabilities: AgentCapability[];\r\n  public readonly createdAt: Date;\r\n\r\n  public status: AgentStatus = 'idle';\r\n  public currentTask: string | null = null;\r\n  public messageCount: number = 0;\r\n\r\n  private db: DatabaseManager;\r\n  private mcpWrapper: MCPToolWrapper;\r\n  private memory: Map<string, any>;\r\n  private communicationBuffer: Message[];\r\n  private lastHeartbeat: number;\r\n  private isActive: boolean = false;\r\n\r\n  constructor(config: AgentConfig) {\r\n    super();\r\n    this.id = config.id || uuidv4();\r\n    this.name = config.name;\r\n    this.type = config.type;\r\n    this.swarmId = config.swarmId;\r\n    this.capabilities = config.capabilities || [];\r\n    this.createdAt = new Date();\r\n\r\n    this.memory = new Map();\r\n    this.communicationBuffer = [];\r\n    this.lastHeartbeat = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Initialize the agent\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.db = await DatabaseManager.getInstance();\r\n    this.mcpWrapper = new MCPToolWrapper();\r\n\r\n    // Load agent state from database if exists\r\n    const existingAgent = await this.db.getAgent(this.id);\r\n    if (existingAgent) {\r\n      this.status = existingAgent.status as AgentStatus;\r\n      this.currentTask = existingAgent.current_task_id;\r\n      this.messageCount = existingAgent.message_count;\r\n    }\r\n\r\n    // Start agent loops\r\n    this.startHeartbeatLoop();\r\n    this.startCommunicationLoop();\r\n    this.startLearningLoop();\r\n\r\n    this.isActive = true;\r\n    this.emit('initialized');\r\n  }\r\n\r\n  /**\r\n   * Assign a task to this agent\r\n   */\r\n  async assignTask(taskId: string, executionPlan: any): Promise<void> {\r\n    if (this.currentTask) {\r\n      throw new Error('Agent already has an active task');\r\n    }\r\n\r\n    this.currentTask = taskId;\r\n    this.status = 'busy';\r\n\r\n    // Update database\r\n    await this.db.updateAgent(this.id, {\r\n      status: 'busy',\r\n      current_task_id: taskId,\r\n    });\r\n\r\n    // Store task in memory\r\n    this.memory.set('current_task', { taskId, executionPlan, startTime: Date.now() });\r\n\r\n    // Start task execution\r\n    this.executeTask(taskId, executionPlan).catch((error) => {\r\n      this.emit('taskError', { taskId, error });\r\n    });\r\n\r\n    this.emit('taskAssigned', { taskId });\r\n  }\r\n\r\n  /**\r\n   * Execute assigned task\r\n   */\r\n  private async executeTask(taskId: string, executionPlan: any): Promise<void> {\r\n    try {\r\n      // Load task details\r\n      const task = await this.db.getTask(taskId);\r\n      if (!task) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      // Update task status\r\n      await this.db.updateTaskStatus(taskId, 'in_progress');\r\n\r\n      // Execute based on agent type\r\n      const result = await this.executeByType(task, executionPlan);\r\n\r\n      // Store result\r\n      await this.db.updateTask(taskId, {\r\n        status: 'completed',\r\n        result: JSON.stringify(result),\r\n        progress: 100,\r\n        completed_at: new Date(),\r\n      });\r\n\r\n      // Learn from execution\r\n      await this.learnFromExecution(task, result);\r\n\r\n      // Clear task\r\n      this.currentTask = null;\r\n      this.status = 'idle';\r\n\r\n      await this.db.updateAgent(this.id, {\r\n        status: 'idle',\r\n        current_task_id: null,\r\n        success_count: this.db.raw('success_count + 1'),\r\n      });\r\n\r\n      this.emit('taskCompleted', { taskId, result });\r\n    } catch (error) {\r\n      // Handle task failure\r\n      await this.handleTaskFailure(taskId, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute task based on agent type\r\n   */\r\n  protected async executeByType(task: any, executionPlan: any): Promise<ExecutionResult> {\r\n    // Base implementation - override in specialized agents\r\n    const startTime = Date.now();\r\n\r\n    // Simulate task execution phases\r\n    const phases = executionPlan.phases || ['analysis', 'execution', 'validation'];\r\n    const results: any[] = [];\r\n\r\n    for (const phase of phases) {\r\n      const phaseResult = await this.executePhase(phase, task, executionPlan);\r\n      results.push(phaseResult);\r\n\r\n      // Update progress\r\n      const progress = Math.round(((phases.indexOf(phase) + 1) / phases.length) * 100);\r\n      await this.updateTaskProgress(task.id, progress);\r\n\r\n      // Communicate progress\r\n      await this.communicateProgress(task.id, phase, progress);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      data: results,\r\n      executionTime: Date.now() - startTime,\r\n      agentId: this.id,\r\n      metadata: {\r\n        phases: phases,\r\n        plan: executionPlan,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Execute a specific phase of the task\r\n   */\r\n  protected async executePhase(phase: string, task: any, plan: any): Promise<any> {\r\n    // Use MCP tools based on phase and agent capabilities\r\n    switch (phase) {\r\n      case 'analysis':\r\n        return this.performAnalysis(task);\r\n\r\n      case 'execution':\r\n        return this.performExecution(task, plan);\r\n\r\n      case 'validation':\r\n        return this.performValidation(task);\r\n\r\n      default:\r\n        return { phase, status: 'completed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform analysis phase\r\n   */\r\n  protected async performAnalysis(task: any): Promise<any> {\r\n    // Use neural analysis for task understanding\r\n    const analysis = await this.mcpWrapper.analyzePattern({\r\n      action: 'analyze',\r\n      operation: `${this.type}_analysis`,\r\n      metadata: {\r\n        task: task.description,\r\n        agentType: this.type,\r\n        capabilities: this.capabilities,\r\n      },\r\n    });\r\n\r\n    // Store analysis in memory\r\n    await this.storeInMemory('task_analysis', analysis);\r\n\r\n    return {\r\n      phase: 'analysis',\r\n      complexity: analysis.complexity || 'medium',\r\n      estimatedTime: analysis.estimatedTime || 3600000,\r\n      requirements: analysis.requirements || [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Perform execution phase\r\n   */\r\n  protected async performExecution(task: any, plan: any): Promise<any> {\r\n    // Base execution - specialized agents override this\r\n    const actions =\r\n      plan.agentAssignments?.find((a: any) => a.agentId === this.id)?.responsibilities || [];\r\n    const results = [];\r\n\r\n    for (const action of actions) {\r\n      const actionResult = await this.executeAction(action, task);\r\n      results.push(actionResult);\r\n    }\r\n\r\n    return {\r\n      phase: 'execution',\r\n      actions: actions,\r\n      results: results,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Perform validation phase\r\n   */\r\n  protected async performValidation(task: any): Promise<any> {\r\n    // Validate execution results\r\n    const validation = {\r\n      phase: 'validation',\r\n      checks: [],\r\n      passed: true,\r\n    };\r\n\r\n    // Basic validation checks\r\n    const checks = [\r\n      { name: 'completeness', passed: true },\r\n      { name: 'quality', passed: true },\r\n      { name: 'performance', passed: true },\r\n    ];\r\n\r\n    validation.checks = checks;\r\n    validation.passed = checks.every((c) => c.passed);\r\n\r\n    return validation;\r\n  }\r\n\r\n  /**\r\n   * Execute a specific action\r\n   */\r\n  protected async executeAction(action: string, task: any): Promise<any> {\r\n    // Base action execution\r\n    return {\r\n      action: action,\r\n      status: 'completed',\r\n      timestamp: new Date(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Send a message to another agent or broadcast\r\n   */\r\n  async sendMessage(toAgentId: string | null, messageType: string, content: any): Promise<void> {\r\n    const message: Message = {\r\n      id: uuidv4(),\r\n      fromAgentId: this.id,\r\n      toAgentId,\r\n      swarmId: this.swarmId,\r\n      type: messageType,\r\n      content,\r\n      timestamp: new Date(),\r\n      requiresResponse: false,\r\n    };\r\n\r\n    // Store in database\r\n    await this.db.createCommunication({\r\n      from_agent_id: this.id,\r\n      to_agent_id: toAgentId,\r\n      swarm_id: this.swarmId,\r\n      message_type: messageType,\r\n      content: JSON.stringify(content),\r\n      priority: 'normal',\r\n    });\r\n\r\n    this.messageCount++;\r\n    this.emit('messageSent', message);\r\n  }\r\n\r\n  /**\r\n   * Receive and process a message\r\n   */\r\n  async receiveMessage(message: Message): Promise<void> {\r\n    this.communicationBuffer.push(message);\r\n    this.emit('messageReceived', message);\r\n  }\r\n\r\n  /**\r\n   * Vote on a consensus proposal\r\n   */\r\n  async voteOnProposal(proposalId: string, vote: boolean, reason?: string): Promise<void> {\r\n    await this.db.submitConsensusVote(proposalId, this.id, vote, reason);\r\n    this.emit('voteCast', { proposalId, vote, reason });\r\n  }\r\n\r\n  /**\r\n   * Update task progress\r\n   */\r\n  protected async updateTaskProgress(taskId: string, progress: number): Promise<void> {\r\n    await this.db.updateTask(taskId, {\r\n      progress,\r\n      last_progress_update: new Date(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Communicate progress to other agents\r\n   */\r\n  protected async communicateProgress(\r\n    taskId: string,\r\n    phase: string,\r\n    progress: number,\r\n  ): Promise<void> {\r\n    await this.sendMessage(null, 'progress_update', {\r\n      taskId,\r\n      agentId: this.id,\r\n      phase,\r\n      progress,\r\n      timestamp: new Date(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Store data in agent memory\r\n   */\r\n  protected async storeInMemory(key: string, value: any): Promise<void> {\r\n    this.memory.set(key, value);\r\n\r\n    // Also store in persistent memory\r\n    await this.mcpWrapper.storeMemory({\r\n      action: 'store',\r\n      key: `agent/${this.id}/${key}`,\r\n      value: JSON.stringify(value),\r\n      namespace: 'agent-memory',\r\n      ttl: 3600, // 1 hour\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieve from agent memory\r\n   */\r\n  protected async retrieveFromMemory(key: string): Promise<any> {\r\n    // Check local memory first\r\n    if (this.memory.has(key)) {\r\n      return this.memory.get(key);\r\n    }\r\n\r\n    // Check persistent memory\r\n    const result = await this.mcpWrapper.retrieveMemory({\r\n      action: 'retrieve',\r\n      key: `agent/${this.id}/${key}`,\r\n      namespace: 'agent-memory',\r\n    });\r\n\r\n    return result ? JSON.parse(result) : null;\r\n  }\r\n\r\n  /**\r\n   * Learn from task execution\r\n   */\r\n  protected async learnFromExecution(task: any, result: ExecutionResult): Promise<void> {\r\n    const learningData = {\r\n      taskType: this.detectTaskType(task.description),\r\n      agentType: this.type,\r\n      success: result.success,\r\n      executionTime: result.executionTime,\r\n      patterns: this.extractPatterns(task, result),\r\n    };\r\n\r\n    // Train neural patterns\r\n    await this.mcpWrapper.trainNeural({\r\n      pattern_type: 'optimization',\r\n      training_data: JSON.stringify(learningData),\r\n      epochs: 10,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle task failure\r\n   */\r\n  protected async handleTaskFailure(taskId: string, error: any): Promise<void> {\r\n    // Update task status\r\n    await this.db.updateTask(taskId, {\r\n      status: 'failed',\r\n      error: error.message,\r\n      completed_at: new Date(),\r\n    });\r\n\r\n    // Update agent stats\r\n    await this.db.updateAgent(this.id, {\r\n      status: 'idle',\r\n      current_task_id: null,\r\n      error_count: this.db.raw('error_count + 1'),\r\n    });\r\n\r\n    // Clear current task\r\n    this.currentTask = null;\r\n    this.status = 'idle';\r\n\r\n    // Notify swarm of failure\r\n    await this.sendMessage(null, 'task_failed', {\r\n      taskId,\r\n      agentId: this.id,\r\n      error: error.message,\r\n      timestamp: new Date(),\r\n    });\r\n\r\n    this.emit('taskFailed', { taskId, error });\r\n  }\r\n\r\n  /**\r\n   * Start heartbeat loop\r\n   */\r\n  private startHeartbeatLoop(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      this.lastHeartbeat = Date.now();\r\n\r\n      // Update last active timestamp\r\n      await this.db.updateAgent(this.id, {\r\n        last_active_at: new Date(),\r\n      });\r\n\r\n      this.emit('heartbeat');\r\n    }, 30000); // Every 30 seconds\r\n  }\r\n\r\n  /**\r\n   * Start communication processing loop\r\n   */\r\n  private startCommunicationLoop(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive || this.communicationBuffer.length === 0) return;\r\n\r\n      // Process buffered messages\r\n      const messages = [...this.communicationBuffer];\r\n      this.communicationBuffer = [];\r\n\r\n      for (const message of messages) {\r\n        await this.processMessage(message);\r\n      }\r\n    }, 1000); // Every second\r\n  }\r\n\r\n  /**\r\n   * Start learning loop\r\n   */\r\n  private startLearningLoop(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      try {\r\n        // Analyze recent patterns\r\n        const patterns = await this.analyzeRecentPatterns();\r\n\r\n        // Update capabilities if needed\r\n        await this.updateCapabilities(patterns);\r\n      } catch (error) {\r\n        this.emit('learningError', error);\r\n      }\r\n    }, 300000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * Process incoming message\r\n   */\r\n  protected async processMessage(message: Message): Promise<void> {\r\n    switch (message.type) {\r\n      case 'task_assignment':\r\n        await this.handleTaskAssignment(message.content);\r\n        break;\r\n\r\n      case 'consensus':\r\n        await this.handleConsensusRequest(message.content);\r\n        break;\r\n\r\n      case 'query':\r\n        await this.handleQuery(message);\r\n        break;\r\n\r\n      case 'coordination':\r\n        await this.handleCoordination(message.content);\r\n        break;\r\n\r\n      default:\r\n        this.emit('unknownMessage', message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if agent is responsive\r\n   */\r\n  isResponsive(): boolean {\r\n    const timeout = 60000; // 1 minute\r\n    return Date.now() - this.lastHeartbeat < timeout;\r\n  }\r\n\r\n  /**\r\n   * Get agent state\r\n   */\r\n  getState(): any {\r\n    return {\r\n      id: this.id,\r\n      name: this.name,\r\n      type: this.type,\r\n      status: this.status,\r\n      currentTask: this.currentTask,\r\n      capabilities: this.capabilities,\r\n      messageCount: this.messageCount,\r\n      isResponsive: this.isResponsive(),\r\n      memory: Object.fromEntries(this.memory),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Shutdown the agent\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    this.isActive = false;\r\n\r\n    // Update status in database\r\n    await this.db.updateAgent(this.id, {\r\n      status: 'offline',\r\n    });\r\n\r\n    // Clear memory\r\n    this.memory.clear();\r\n    this.communicationBuffer = [];\r\n\r\n    this.emit('shutdown');\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  private detectTaskType(description: string): string {\r\n    const lower = description.toLowerCase();\r\n\r\n    if (lower.includes('research') || lower.includes('investigate')) return 'research';\r\n    if (lower.includes('develop') || lower.includes('implement')) return 'development';\r\n    if (lower.includes('analyze') || lower.includes('review')) return 'analysis';\r\n    if (lower.includes('test') || lower.includes('validate')) return 'testing';\r\n    if (lower.includes('optimize') || lower.includes('improve')) return 'optimization';\r\n\r\n    return 'general';\r\n  }\r\n\r\n  private extractPatterns(task: any, result: ExecutionResult): any {\r\n    return {\r\n      taskComplexity: task.priority,\r\n      executionStrategy: task.strategy,\r\n      phasesCompleted: result.metadata?.phases?.length || 0,\r\n      timePerPhase: result.executionTime / (result.metadata?.phases?.length || 1),\r\n    };\r\n  }\r\n\r\n  private async analyzeRecentPatterns(): Promise<any> {\r\n    return this.mcpWrapper.analyzePattern({\r\n      action: 'analyze',\r\n      operation: 'agent_patterns',\r\n      metadata: {\r\n        agentId: this.id,\r\n        agentType: this.type,\r\n        timeframe: '1h',\r\n      },\r\n    });\r\n  }\r\n\r\n  private async updateCapabilities(patterns: any): Promise<void> {\r\n    if (patterns.suggestedCapabilities) {\r\n      // Update capabilities based on learning\r\n      const newCapabilities = patterns.suggestedCapabilities.filter(\r\n        (cap: string) => !this.capabilities.includes(cap),\r\n      );\r\n\r\n      if (newCapabilities.length > 0) {\r\n        this.capabilities.push(...newCapabilities);\r\n\r\n        await this.db.updateAgent(this.id, {\r\n          capabilities: JSON.stringify(this.capabilities),\r\n        });\r\n\r\n        this.emit('capabilitiesUpdated', newCapabilities);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async handleTaskAssignment(content: any): Promise<void> {\r\n    // Handle incoming task assignment\r\n    if (!this.currentTask && content.taskId) {\r\n      await this.assignTask(content.taskId, content.executionPlan || {});\r\n    }\r\n  }\r\n\r\n  private async handleConsensusRequest(content: any): Promise<void> {\r\n    // Analyze proposal and vote\r\n    const analysis = await this.analyzeProposal(content);\r\n    await this.voteOnProposal(content.proposalId, analysis.vote, analysis.reason);\r\n  }\r\n\r\n  private async handleQuery(message: Message): Promise<void> {\r\n    // Respond to query\r\n    const response = await this.processQuery(message.content);\r\n\r\n    if (message.fromAgentId) {\r\n      await this.sendMessage(message.fromAgentId, 'response', {\r\n        queryId: message.id,\r\n        response,\r\n      });\r\n    }\r\n  }\r\n\r\n  private async handleCoordination(content: any): Promise<void> {\r\n    // Handle coordination messages\r\n    this.emit('coordinationReceived', content);\r\n  }\r\n\r\n  private async analyzeProposal(proposal: any): Promise<any> {\r\n    // Simple analysis - can be overridden by specialized agents\r\n    return {\r\n      vote: Math.random() > 0.3, // 70% approval rate\r\n      reason: 'Based on agent analysis',\r\n    };\r\n  }\r\n\r\n  private async processQuery(query: any): Promise<any> {\r\n    // Process and respond to queries\r\n    return {\r\n      agentId: this.id,\r\n      agentType: this.type,\r\n      status: this.status,\r\n      response: 'Query processed',\r\n    };\r\n  }\r\n}\r\n"],"names":["EventEmitter","v4","uuidv4","DatabaseManager","MCPToolWrapper","Agent","id","name","type","swarmId","capabilities","createdAt","status","currentTask","messageCount","db","mcpWrapper","memory","communicationBuffer","lastHeartbeat","isActive","config","Date","Map","now","initialize","getInstance","existingAgent","getAgent","current_task_id","message_count","startHeartbeatLoop","startCommunicationLoop","startLearningLoop","emit","assignTask","taskId","executionPlan","Error","updateAgent","set","startTime","executeTask","catch","error","task","getTask","updateTaskStatus","result","executeByType","updateTask","JSON","stringify","progress","completed_at","learnFromExecution","success_count","raw","handleTaskFailure","phases","results","phase","phaseResult","executePhase","push","Math","round","indexOf","length","updateTaskProgress","communicateProgress","success","data","executionTime","agentId","metadata","plan","performAnalysis","performExecution","performValidation","analysis","analyzePattern","action","operation","description","agentType","storeInMemory","complexity","estimatedTime","requirements","actions","agentAssignments","find","a","responsibilities","actionResult","executeAction","validation","checks","passed","every","c","timestamp","sendMessage","toAgentId","messageType","content","message","fromAgentId","requiresResponse","createCommunication","from_agent_id","to_agent_id","swarm_id","message_type","priority","receiveMessage","voteOnProposal","proposalId","vote","reason","submitConsensusVote","last_progress_update","key","value","storeMemory","namespace","ttl","retrieveFromMemory","has","get","retrieveMemory","parse","learningData","taskType","detectTaskType","patterns","extractPatterns","trainNeural","pattern_type","training_data","epochs","error_count","setInterval","last_active_at","messages","processMessage","analyzeRecentPatterns","updateCapabilities","handleTaskAssignment","handleConsensusRequest","handleQuery","handleCoordination","isResponsive","timeout","getState","Object","fromEntries","shutdown","clear","lower","toLowerCase","includes","taskComplexity","executionStrategy","strategy","phasesCompleted","timePerPhase","timeframe","suggestedCapabilities","newCapabilities","filter","cap","analyzeProposal","response","processQuery","queryId","proposal","random","query"],"mappings":"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"}