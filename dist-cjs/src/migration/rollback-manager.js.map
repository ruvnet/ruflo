{"version":3,"sources":["../../../src/migration/rollback-manager.ts"],"sourcesContent":["/**\r\n * Rollback Manager - Handles rollback operations and backup management\r\n */\r\n\r\nimport * as fs from 'fs-extra';\r\nimport * as path from 'path';\r\nimport * as crypto from 'crypto';\r\nimport type { MigrationBackup, BackupFile } from './types.js';\r\nimport { logger } from './logger.js';\r\nimport * as chalk from 'chalk';\r\nimport * as inquirer from 'inquirer';\r\n\r\nexport class RollbackManager {\r\n  private projectPath: string;\r\n  private backupDir: string;\r\n\r\n  constructor(projectPath: string, backupDir: string = '.claude-backup') {\r\n    this.projectPath = projectPath;\r\n    this.backupDir = path.join(projectPath, backupDir);\r\n  }\r\n\r\n  async createBackup(metadata: Record<string, any> = {}): Promise<MigrationBackup> {\r\n    const timestamp = new Date();\r\n    const backupId = timestamp.toISOString().replace(/[:.]/g, '-');\r\n    const backupPath = path.join(this.backupDir, backupId);\r\n\r\n    logger.info(`Creating backup at ${backupPath}...`);\r\n\r\n    await fs.ensureDir(backupPath);\r\n\r\n    const backup: MigrationBackup = {\r\n      timestamp,\r\n      version: '1.0.0',\r\n      files: [],\r\n      metadata: {\r\n        projectPath: this.projectPath,\r\n        backupId,\r\n        ...metadata,\r\n      },\r\n    };\r\n\r\n    // Backup critical files and directories\r\n    const backupTargets = [\r\n      '.claude',\r\n      'CLAUDE.md',\r\n      '.roomodes',\r\n      'package.json',\r\n      'memory/memory-store.json',\r\n      'coordination/config.json',\r\n    ];\r\n\r\n    for (const target of backupTargets) {\r\n      const sourcePath = path.join(this.projectPath, target);\r\n      const targetPath = path.join(backupPath, target);\r\n\r\n      if (await fs.pathExists(sourcePath)) {\r\n        const stats = await fs.stat(sourcePath);\r\n\r\n        if (stats.isDirectory()) {\r\n          await this.backupDirectory(sourcePath, targetPath, backup);\r\n        } else {\r\n          await this.backupFile(sourcePath, targetPath, backup, target);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Save backup manifest\r\n    const manifestPath = path.join(backupPath, 'backup-manifest.json');\r\n    await fs.writeJson(manifestPath, backup, { spaces: 2 });\r\n\r\n    // Update backup index\r\n    await this.updateBackupIndex(backup);\r\n\r\n    logger.success(`Backup created with ${backup.files.length} files`);\r\n    return backup;\r\n  }\r\n\r\n  private async backupDirectory(\r\n    sourcePath: string,\r\n    targetPath: string,\r\n    backup: MigrationBackup,\r\n  ): Promise<void> {\r\n    await fs.ensureDir(targetPath);\r\n\r\n    const entries = await fs.readdir(sourcePath);\r\n\r\n    for (const entry of entries) {\r\n      const entrySource = path.join(sourcePath, entry);\r\n      const entryTarget = path.join(targetPath, entry);\r\n      const stats = await fs.stat(entrySource);\r\n\r\n      if (stats.isDirectory()) {\r\n        await this.backupDirectory(entrySource, entryTarget, backup);\r\n      } else {\r\n        const relativePath = path.relative(this.projectPath, entrySource);\r\n        await this.backupFile(entrySource, entryTarget, backup, relativePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async backupFile(\r\n    sourcePath: string,\r\n    targetPath: string,\r\n    backup: MigrationBackup,\r\n    relativePath: string,\r\n  ): Promise<void> {\r\n    const content = await fs.readFile(sourcePath, 'utf-8');\r\n    const checksum = crypto.createHash('sha256').update(content).digest('hex');\r\n\r\n    await fs.ensureDir(path.dirname(targetPath));\r\n    await fs.writeFile(targetPath, content);\r\n\r\n    const backupFile: BackupFile = {\r\n      path: relativePath,\r\n      content,\r\n      checksum,\r\n      permissions: (await fs.stat(sourcePath)).mode.toString(8),\r\n    };\r\n\r\n    backup.files.push(backupFile);\r\n  }\r\n\r\n  async listBackups(): Promise<MigrationBackup[]> {\r\n    if (!(await fs.pathExists(this.backupDir))) {\r\n      return [];\r\n    }\r\n\r\n    const backupFolders = await fs.readdir(this.backupDir);\r\n    const backups: MigrationBackup[] = [];\r\n\r\n    for (const folder of backupFolders.sort().reverse()) {\r\n      const manifestPath = path.join(this.backupDir, folder, 'backup-manifest.json');\r\n\r\n      if (await fs.pathExists(manifestPath)) {\r\n        try {\r\n          const backup = await fs.readJson(manifestPath);\r\n          backups.push(backup);\r\n        } catch (error) {\r\n          logger.warn(\r\n            `Invalid backup manifest in ${folder}: ${error instanceof Error ? error.message : String(error)}`,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return backups;\r\n  }\r\n\r\n  async rollback(backupId?: string, interactive: boolean = true): Promise<void> {\r\n    const backups = await this.listBackups();\r\n\r\n    if (backups.length === 0) {\r\n      throw new Error('No backups found');\r\n    }\r\n\r\n    let selectedBackup: MigrationBackup;\r\n\r\n    if (backupId) {\r\n      selectedBackup = backups.find((b) => b.metadata.backupId === backupId);\r\n      if (!selectedBackup) {\r\n        throw new Error(`Backup not found: ${backupId}`);\r\n      }\r\n    } else if (interactive) {\r\n      selectedBackup = await this.selectBackupInteractively(backups);\r\n    } else {\r\n      selectedBackup = backups[0]; // Most recent\r\n    }\r\n\r\n    logger.info(`Rolling back to backup from ${selectedBackup.timestamp.toISOString()}...`);\r\n\r\n    // Confirm rollback\r\n    if (interactive) {\r\n      const confirm = await inquirer.prompt([\r\n        {\r\n          type: 'confirm',\r\n          name: 'proceed',\r\n          message: `Are you sure you want to rollback? This will overwrite current files.`,\r\n          default: false,\r\n        },\r\n      ]);\r\n\r\n      if (!confirm.proceed) {\r\n        logger.info('Rollback cancelled');\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Create pre-rollback backup\r\n    const preRollbackBackup = await this.createBackup({\r\n      type: 'pre-rollback',\r\n      rollingBackTo: selectedBackup.metadata.backupId,\r\n    });\r\n\r\n    try {\r\n      // Restore files\r\n      await this.restoreFiles(selectedBackup);\r\n\r\n      // Validate restoration\r\n      await this.validateRestore(selectedBackup);\r\n\r\n      logger.success('Rollback completed successfully');\r\n    } catch (error) {\r\n      logger.error('Rollback failed, attempting to restore pre-rollback state...');\r\n\r\n      try {\r\n        await this.restoreFiles(preRollbackBackup);\r\n        logger.success('Pre-rollback state restored');\r\n      } catch (restoreError) {\r\n        logger.error('Failed to restore pre-rollback state:', restoreError);\r\n        throw new Error('Rollback failed and unable to restore previous state');\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async selectBackupInteractively(backups: MigrationBackup[]): Promise<MigrationBackup> {\r\n    const choices = backups.map((backup) => ({\r\n      name: `${backup.timestamp.toLocaleString()} - ${backup.files.length} files (${backup.metadata.type || 'migration'})`,\r\n      value: backup,\r\n      short: backup.metadata.backupId,\r\n    }));\r\n\r\n    const answer = await inquirer.prompt([\r\n      {\r\n        type: 'list',\r\n        name: 'backup',\r\n        message: 'Select backup to rollback to:',\r\n        choices,\r\n        pageSize: 10,\r\n      },\r\n    ]);\r\n\r\n    return answer.backup;\r\n  }\r\n\r\n  private async restoreFiles(backup: MigrationBackup): Promise<void> {\r\n    logger.info(`Restoring ${backup.files.length} files...`);\r\n\r\n    for (const file of backup.files) {\r\n      const targetPath = path.join(this.projectPath, file.path);\r\n\r\n      logger.debug(`Restoring ${file.path}`);\r\n\r\n      await fs.ensureDir(path.dirname(targetPath));\r\n      await fs.writeFile(targetPath, file.content);\r\n\r\n      // Restore permissions if available\r\n      if (file.permissions) {\r\n        try {\r\n          await fs.chmod(targetPath, parseInt(file.permissions, 8));\r\n        } catch (error) {\r\n          logger.warn(\r\n            `Could not restore permissions for ${file.path}: ${error instanceof Error ? error.message : String(error)}`,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async validateRestore(backup: MigrationBackup): Promise<void> {\r\n    logger.info('Validating restored files...');\r\n\r\n    const errors: string[] = [];\r\n\r\n    for (const file of backup.files) {\r\n      const filePath = path.join(this.projectPath, file.path);\r\n\r\n      if (!(await fs.pathExists(filePath))) {\r\n        errors.push(`Missing file: ${file.path}`);\r\n        continue;\r\n      }\r\n\r\n      const content = await fs.readFile(filePath, 'utf-8');\r\n      const checksum = crypto.createHash('sha256').update(content).digest('hex');\r\n\r\n      if (checksum !== file.checksum) {\r\n        errors.push(`Checksum mismatch: ${file.path}`);\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      throw new Error(`Validation failed:\\n${errors.join('\\n')}`);\r\n    }\r\n\r\n    logger.success('Validation passed');\r\n  }\r\n\r\n  async cleanupOldBackups(retentionDays: number = 30, maxBackups: number = 10): Promise<void> {\r\n    const backups = await this.listBackups();\r\n\r\n    if (backups.length <= maxBackups) {\r\n      return; // No cleanup needed\r\n    }\r\n\r\n    const cutoffDate = new Date();\r\n    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\r\n\r\n    const backupsToDelete = backups.filter((backup, index) => {\r\n      // Keep the most recent maxBackups\r\n      if (index < maxBackups) {\r\n        return false;\r\n      }\r\n\r\n      // Delete old backups\r\n      return backup.timestamp < cutoffDate;\r\n    });\r\n\r\n    if (backupsToDelete.length === 0) {\r\n      return;\r\n    }\r\n\r\n    logger.info(`Cleaning up ${backupsToDelete.length} old backups...`);\r\n\r\n    for (const backup of backupsToDelete) {\r\n      const backupPath = path.join(this.backupDir, backup.metadata.backupId);\r\n      await fs.remove(backupPath);\r\n      logger.debug(`Removed backup: ${backup.metadata.backupId}`);\r\n    }\r\n\r\n    logger.success(`Cleanup completed, removed ${backupsToDelete.length} backups`);\r\n  }\r\n\r\n  async getBackupInfo(backupId: string): Promise<MigrationBackup | null> {\r\n    const backups = await this.listBackups();\r\n    return backups.find((b) => b.metadata.backupId === backupId) || null;\r\n  }\r\n\r\n  async exportBackup(backupId: string, exportPath: string): Promise<void> {\r\n    const backup = await this.getBackupInfo(backupId);\r\n    if (!backup) {\r\n      throw new Error(`Backup not found: ${backupId}`);\r\n    }\r\n\r\n    const backupPath = path.join(this.backupDir, backup.metadata.backupId);\r\n    await fs.copy(backupPath, exportPath);\r\n\r\n    logger.success(`Backup exported to ${exportPath}`);\r\n  }\r\n\r\n  async importBackup(importPath: string): Promise<MigrationBackup> {\r\n    const manifestPath = path.join(importPath, 'backup-manifest.json');\r\n\r\n    if (!(await fs.pathExists(manifestPath))) {\r\n      throw new Error('Invalid backup: missing manifest');\r\n    }\r\n\r\n    const backup = await fs.readJson(manifestPath);\r\n    const backupPath = path.join(this.backupDir, backup.metadata.backupId);\r\n\r\n    await fs.copy(importPath, backupPath);\r\n    await this.updateBackupIndex(backup);\r\n\r\n    logger.success(`Backup imported: ${backup.metadata.backupId}`);\r\n    return backup;\r\n  }\r\n\r\n  private async updateBackupIndex(backup: MigrationBackup): Promise<void> {\r\n    const indexPath = path.join(this.backupDir, 'backup-index.json');\r\n\r\n    let index: Record<string, any> = {};\r\n    if (await fs.pathExists(indexPath)) {\r\n      index = await fs.readJson(indexPath);\r\n    }\r\n\r\n    index[backup.metadata.backupId] = {\r\n      timestamp: backup.timestamp,\r\n      version: backup.version,\r\n      fileCount: backup.files.length,\r\n      metadata: backup.metadata,\r\n    };\r\n\r\n    await fs.writeJson(indexPath, index, { spaces: 2 });\r\n  }\r\n\r\n  printBackupSummary(backups: MigrationBackup[]): void {\r\n    if (backups.length === 0) {\r\n      console.log(chalk.yellow('No backups found'));\r\n      return;\r\n    }\r\n\r\n    console.log(chalk.bold('\\nüíæ Available Backups'));\r\n    console.log(chalk.gray('‚îÄ'.repeat(70)));\r\n\r\n    backups.forEach((backup, index) => {\r\n      const isRecent = index === 0;\r\n      const date = backup.timestamp.toLocaleString();\r\n      const type = backup.metadata.type || 'migration';\r\n      const fileCount = backup.files.length;\r\n\r\n      console.log(\r\n        `\\n${isRecent ? chalk.green('‚óè') : chalk.gray('‚óã')} ${chalk.bold(backup.metadata.backupId)}`,\r\n      );\r\n      console.log(`  ${chalk.gray('Date:')} ${date}`);\r\n      console.log(`  ${chalk.gray('Type:')} ${type}`);\r\n      console.log(`  ${chalk.gray('Files:')} ${fileCount}`);\r\n\r\n      if (backup.metadata.strategy) {\r\n        console.log(`  ${chalk.gray('Strategy:')} ${backup.metadata.strategy}`);\r\n      }\r\n    });\r\n\r\n    console.log(chalk.gray('\\n' + '‚îÄ'.repeat(70)));\r\n  }\r\n}\r\n"],"names":["fs","path","crypto","logger","chalk","inquirer","RollbackManager","projectPath","backupDir","join","createBackup","metadata","timestamp","Date","backupId","toISOString","replace","backupPath","info","ensureDir","backup","version","files","backupTargets","target","sourcePath","targetPath","pathExists","stats","stat","isDirectory","backupDirectory","backupFile","manifestPath","writeJson","spaces","updateBackupIndex","success","length","entries","readdir","entry","entrySource","entryTarget","relativePath","relative","content","readFile","checksum","createHash","update","digest","dirname","writeFile","permissions","mode","toString","push","listBackups","backupFolders","backups","folder","sort","reverse","readJson","error","warn","Error","message","String","rollback","interactive","selectedBackup","find","b","selectBackupInteractively","confirm","prompt","type","name","default","proceed","preRollbackBackup","rollingBackTo","restoreFiles","validateRestore","restoreError","choices","map","toLocaleString","value","short","answer","pageSize","file","debug","chmod","parseInt","errors","filePath","cleanupOldBackups","retentionDays","maxBackups","cutoffDate","setDate","getDate","backupsToDelete","filter","index","remove","getBackupInfo","exportBackup","exportPath","copy","importBackup","importPath","indexPath","fileCount","printBackupSummary","console","log","yellow","bold","gray","repeat","forEach","isRecent","date","green","strategy"],"mappings":"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"}