{
  "version": 3,
  "sources": ["../../src/mcp/claude-flow-tools.ts"],
  "sourcesContent": ["/**\n * Claude-Flow specific MCP tools\n */\n\nimport type { MCPTool, MCPContext, AgentProfile, Task, MemoryEntry } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { getAvailableAgentTypes, getAgentTypeSchema } from '../constants/agent-types.js';\nimport type { Permissions } from './auth.js';\n\nexport interface ClaudeFlowToolContext extends MCPContext {\n  orchestrator?: any; // Reference to orchestrator instance\n}\n\n/**\n * Enhance tool schema with dynamic agent types\n */\nasync function enhanceToolWithAgentTypes(tool: MCPTool): Promise<MCPTool> {\n  const availableTypes = await getAvailableAgentTypes();\n  \n  // Clone the tool to avoid modifying the original\n  const enhancedTool = JSON.parse(JSON.stringify(tool));\n  \n  // Find and populate enum fields for agent types\n  function addEnumToAgentTypeFields(obj: any) {\n    if (typeof obj !== 'object' || obj === null) return;\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'object' && value !== null) {\n        // Check if this is an agent type field\n        if (key === 'type' || key === 'filterByType' || key === 'assignToAgentType') {\n          const field = value as any;\n          if (field.type === 'string' && field.description?.includes('loaded dynamically from .claude/agents/')) {\n            field.enum = availableTypes;\n          }\n        }\n        addEnumToAgentTypeFields(value);\n      }\n    }\n  }\n  \n  addEnumToAgentTypeFields(enhancedTool.inputSchema);\n  return enhancedTool;\n}\n\n/**\n * Create all Claude-Flow specific MCP tools\n */\nexport async function createClaudeFlowTools(logger: ILogger): Promise<MCPTool[]> {\n  const tools = [\n    // Agent management tools\n    createSpawnAgentTool(logger),\n    createListAgentsTool(logger),\n    createTerminateAgentTool(logger),\n    createGetAgentInfoTool(logger),\n\n    // Task management tools\n    createCreateTaskTool(logger),\n    createListTasksTool(logger),\n    createGetTaskStatusTool(logger),\n    createCancelTaskTool(logger),\n    createAssignTaskTool(logger),\n\n    // Memory management tools\n    createQueryMemoryTool(logger),\n    createStoreMemoryTool(logger),\n    createDeleteMemoryTool(logger),\n    createExportMemoryTool(logger),\n    createImportMemoryTool(logger),\n\n    // System monitoring tools\n    createGetSystemStatusTool(logger),\n    createGetMetricsTool(logger),\n    createHealthCheckTool(logger),\n\n    // Configuration tools\n    createGetConfigTool(logger),\n    createUpdateConfigTool(logger),\n    createValidateConfigTool(logger),\n\n    // Workflow tools\n    createExecuteWorkflowTool(logger),\n    createCreateWorkflowTool(logger),\n    createListWorkflowsTool(logger),\n\n    // Terminal management tools\n    createExecuteCommandTool(logger),\n    createListTerminalsTool(logger),\n    createCreateTerminalTool(logger),\n  ];\n\n  // Enhance tools with dynamic agent types\n  const enhancedTools = await Promise.all(\n    tools.map(tool => enhanceToolWithAgentTypes(tool))\n  );\n\n  return enhancedTools;\n}\n\nfunction createSpawnAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/spawn',\n    description: 'Spawn a new Claude agent with specified configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to spawn (loaded dynamically from .claude/agents/)',\n        },\n        name: {\n          type: 'string',\n          description: 'Display name for the agent',\n        },\n        capabilities: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of capabilities for the agent',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'Custom system prompt for the agent',\n        },\n        maxConcurrentTasks: {\n          type: 'number',\n          default: 3,\n          description: 'Maximum number of concurrent tasks',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Agent priority level (1-10)',\n        },\n        environment: {\n          type: 'object',\n          description: 'Environment variables for the agent',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Working directory for the agent',\n        },\n      },\n      required: ['type', 'name'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Spawning agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const profile: AgentProfile = {\n        id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        name: input.name,\n        type: input.type,\n        capabilities: input.capabilities || [],\n        systemPrompt: input.systemPrompt || getDefaultSystemPrompt(input.type),\n        maxConcurrentTasks: input.maxConcurrentTasks || 3,\n        priority: input.priority || 5,\n        environment: input.environment,\n        workingDirectory: input.workingDirectory,\n      };\n\n      const sessionId = await context.orchestrator.spawnAgent(profile);\n\n      return {\n        agentId: profile.id,\n        sessionId,\n        profile,\n        status: 'spawned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListAgentsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/list',\n    description: 'List all active agents in the system',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeTerminated: {\n          type: 'boolean',\n          default: false,\n          description: 'Include terminated agents in the list',\n        },\n        filterByType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Filter agents by type (loaded dynamically from .claude/agents/)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing agents', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agents = await context.orchestrator.listAgents();\n\n      let filteredAgents = agents;\n\n      if (!input.includeTerminated) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.status !== 'terminated');\n      }\n\n      if (input.filterByType) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.type === input.filterByType);\n      }\n\n      return {\n        agents: filteredAgents,\n        count: filteredAgents.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createTerminateAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/terminate',\n    description: 'Terminate a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to terminate',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for termination',\n        },\n        graceful: {\n          type: 'boolean',\n          default: true,\n          description: 'Whether to perform graceful shutdown',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Terminating agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.terminateAgent(input.agentId, {\n        reason: input.reason || 'Manual termination',\n        graceful: input.graceful !== false,\n      });\n\n      return {\n        agentId: input.agentId,\n        status: 'terminated',\n        reason: input.reason || 'Manual termination',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetAgentInfoTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/info',\n    description: 'Get detailed information about a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting agent info', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agentInfo = await context.orchestrator.getAgentInfo(input.agentId);\n\n      if (!agentInfo) {\n        throw new Error(`Agent not found: ${input.agentId}`);\n      }\n\n      return {\n        agent: agentInfo,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/create',\n    description: 'Create a new task for execution',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          description: 'Type of task to create',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the task',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Task priority (1-10)',\n        },\n        dependencies: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of task IDs this task depends on',\n        },\n        assignToAgent: {\n          type: 'string',\n          description: 'Specific agent ID to assign the task to',\n        },\n        assignToAgentType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to assign the task to (loaded dynamically from .claude/agents/)',\n        },\n        input: {\n          type: 'object',\n          description: 'Input data for the task',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Task timeout in milliseconds',\n        },\n      },\n      required: ['type', 'description'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task: Partial<Task> = {\n        type: input.type,\n        description: input.description,\n        priority: input.priority || 5,\n        dependencies: input.dependencies || [],\n        input: input.input || {},\n        status: 'pending',\n        createdAt: new Date(),\n      };\n\n      const taskId = await context.orchestrator.createTask(task);\n\n      // Handle assignment\n      if (input.assignToAgent) {\n        await context.orchestrator.assignTask(taskId, input.assignToAgent);\n      } else if (input.assignToAgentType) {\n        await context.orchestrator.assignTaskToType(taskId, input.assignToAgentType);\n      }\n\n      return {\n        taskId,\n        task: { ...task, id: taskId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTasksTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/list',\n    description: 'List tasks with optional filtering',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        status: {\n          type: 'string',\n          enum: ['pending', 'queued', 'assigned', 'running', 'completed', 'failed', 'cancelled'],\n          description: 'Filter by task status',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by assigned agent ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by task type',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of tasks to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of tasks to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing tasks', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const tasks = await context.orchestrator.listTasks({\n        status: input.status,\n        agentId: input.agentId,\n        type: input.type,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      });\n\n      return {\n        tasks,\n        count: tasks.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetTaskStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/status',\n    description: 'Get detailed status of a specific task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting task status', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task = await context.orchestrator.getTask(input.taskId);\n\n      if (!task) {\n        throw new Error(`Task not found: ${input.taskId}`);\n      }\n\n      return {\n        task,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCancelTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/cancel',\n    description: 'Cancel a pending or running task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to cancel',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for cancellation',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Cancelling task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.cancelTask(input.taskId, input.reason || 'Manual cancellation');\n\n      return {\n        taskId: input.taskId,\n        status: 'cancelled',\n        reason: input.reason || 'Manual cancellation',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createAssignTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/assign',\n    description: 'Assign a task to a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to assign',\n        },\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to assign the task to',\n        },\n      },\n      required: ['taskId', 'agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Assigning task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.assignTask(input.taskId, input.agentId);\n\n      return {\n        taskId: input.taskId,\n        agentId: input.agentId,\n        status: 'assigned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createQueryMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/query',\n    description: 'Query agent memory with filters and search',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Filter by entry type',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Filter by tags',\n        },\n        search: {\n          type: 'string',\n          description: 'Full-text search query',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries before this time',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of entries to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of entries to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Querying memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const query = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        tags: input.tags,\n        search: input.search,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      };\n\n      const entries = await context.orchestrator.queryMemory(query);\n\n      return {\n        entries,\n        count: entries.length,\n        query,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createStoreMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/store',\n    description: 'Store a new memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Agent ID for the memory entry',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for the memory entry',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Type of memory entry',\n        },\n        content: {\n          type: 'string',\n          description: 'Content of the memory entry',\n        },\n        context: {\n          type: 'object',\n          description: 'Context data for the memory entry',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Tags for the memory entry',\n        },\n        parentId: {\n          type: 'string',\n          description: 'Parent memory entry ID',\n        },\n      },\n      required: ['agentId', 'sessionId', 'type', 'content'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Storing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const entry: Partial<MemoryEntry> = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        content: input.content,\n        context: input.context || {},\n        tags: input.tags || [],\n        parentId: input.parentId,\n        timestamp: new Date(),\n        version: 1,\n      };\n\n      const entryId = await context.orchestrator.storeMemory(entry);\n\n      return {\n        entryId,\n        entry: { ...entry, id: entryId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createDeleteMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/delete',\n    description: 'Delete a memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        entryId: {\n          type: 'string',\n          description: 'ID of the memory entry to delete',\n        },\n      },\n      required: ['entryId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Deleting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.deleteMemory(input.entryId);\n\n      return {\n        entryId: input.entryId,\n        status: 'deleted',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/export',\n    description: 'Export memory entries to a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        format: {\n          type: 'string',\n          enum: ['json', 'csv', 'markdown'],\n          default: 'json',\n          description: 'Export format',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries before this time',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Exporting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const exportResult = await context.orchestrator.exportMemory({\n        format: input.format || 'json',\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n      });\n\n      return {\n        ...exportResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createImportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/import',\n    description: 'Import memory entries from a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to the file to import',\n        },\n        format: {\n          type: 'string',\n          enum: ['json', 'csv'],\n          default: 'json',\n          description: 'Import format',\n        },\n        mergeStrategy: {\n          type: 'string',\n          enum: ['skip', 'overwrite', 'version'],\n          default: 'skip',\n          description: 'Strategy for handling duplicate entries',\n        },\n      },\n      required: ['filePath'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Importing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const importResult = await context.orchestrator.importMemory({\n        filePath: input.filePath,\n        format: input.format || 'json',\n        mergeStrategy: input.mergeStrategy || 'skip',\n      });\n\n      return {\n        ...importResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetSystemStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/status',\n    description: 'Get comprehensive system status information',\n    inputSchema: {\n      type: 'object',\n      properties: {},\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system status', { sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const status = await context.orchestrator.getSystemStatus();\n\n      return {\n        ...status,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetMetricsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/metrics',\n    description: 'Get system performance metrics',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        timeRange: {\n          type: 'string',\n          enum: ['1h', '6h', '24h', '7d'],\n          default: '1h',\n          description: 'Time range for metrics',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system metrics', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const metrics = await context.orchestrator.getMetrics(input.timeRange || '1h');\n\n      return {\n        metrics,\n        timeRange: input.timeRange || '1h',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createHealthCheckTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/health',\n    description: 'Perform a comprehensive health check',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        deep: {\n          type: 'boolean',\n          default: false,\n          description: 'Perform deep health check including component tests',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Performing health check', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const healthCheck = await context.orchestrator.performHealthCheck(input.deep || false);\n\n      return {\n        ...healthCheck,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/get',\n    description: 'Get current system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Specific configuration section to retrieve',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const config = await context.orchestrator.getConfig(input.section);\n\n      return {\n        config,\n        section: input.section,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createUpdateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/update',\n    description: 'Update system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Configuration section to update',\n        },\n        config: {\n          type: 'object',\n          description: 'Configuration values to update',\n        },\n        restart: {\n          type: 'boolean',\n          default: false,\n          description: 'Restart affected components after update',\n        },\n      },\n      required: ['section', 'config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Updating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.updateConfig(\n        input.section,\n        input.config,\n        input.restart || false,\n      );\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createValidateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/validate',\n    description: 'Validate a configuration object',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        config: {\n          type: 'object',\n          description: 'Configuration object to validate',\n        },\n      },\n      required: ['config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Validating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const validation = await context.orchestrator.validateConfig(input.config);\n\n      return {\n        ...validation,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/execute',\n    description: 'Execute a workflow from a file or definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to workflow file',\n        },\n        workflow: {\n          type: 'object',\n          description: 'Inline workflow definition',\n        },\n        parameters: {\n          type: 'object',\n          description: 'Parameters to pass to the workflow',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      if (!input.filePath && !input.workflow) {\n        throw new Error('Either filePath or workflow must be provided');\n      }\n\n      const result = await context.orchestrator.executeWorkflow({\n        filePath: input.filePath,\n        workflow: input.workflow,\n        parameters: input.parameters || {},\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/create',\n    description: 'Create a new workflow definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Name of the workflow',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the workflow',\n        },\n        tasks: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string' },\n              type: { type: 'string' },\n              description: { type: 'string' },\n              dependencies: {\n                type: 'array',\n                items: { type: 'string' },\n              },\n              assignTo: { type: 'string' },\n            },\n            required: ['id', 'type', 'description'],\n          },\n          description: 'List of tasks in the workflow',\n        },\n        savePath: {\n          type: 'string',\n          description: 'Path to save the workflow file',\n        },\n      },\n      required: ['name', 'tasks'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflow = {\n        name: input.name,\n        description: input.description,\n        tasks: input.tasks,\n        created: new Date().toISOString(),\n      };\n\n      const result = await context.orchestrator.createWorkflow(workflow, input.savePath);\n\n      return {\n        ...result,\n        workflow,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListWorkflowsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/list',\n    description: 'List available workflows',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'Directory to search for workflows',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing workflows', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflows = await context.orchestrator.listWorkflows(input.directory);\n\n      return {\n        workflows,\n        count: workflows.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteCommandTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/execute',\n    description: 'Execute a command in a terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'Command to execute',\n        },\n        args: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Command arguments',\n        },\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the command',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        timeout: {\n          type: 'number',\n          default: 30000,\n          description: 'Command timeout in milliseconds',\n        },\n        terminalId: {\n          type: 'string',\n          description: 'Specific terminal ID to use',\n        },\n      },\n      required: ['command'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing command', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.executeCommand({\n        command: input.command,\n        args: input.args,\n        cwd: input.cwd,\n        env: input.env,\n        timeout: input.timeout || 30000,\n        terminalId: input.terminalId,\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTerminalsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/list',\n    description: 'List all terminal sessions',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeIdle: {\n          type: 'boolean',\n          default: true,\n          description: 'Include idle terminals',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing terminals', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminals = await context.orchestrator.listTerminals(input.includeIdle !== false);\n\n      return {\n        terminals,\n        count: terminals.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTerminalTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/create',\n    description: 'Create a new terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the terminal',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        shell: {\n          type: 'string',\n          description: 'Shell to use (bash, zsh, etc.)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating terminal', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminal = await context.orchestrator.createTerminal({\n        cwd: input.cwd,\n        env: input.env,\n        shell: input.shell,\n      });\n\n      return {\n        terminal,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction getDefaultSystemPrompt(type: string): string {\n  const prompts = {\n    coordinator:\n      'You are a coordinator agent responsible for planning, delegating, and orchestrating tasks across multiple agents.',\n    researcher:\n      'You are a research agent specialized in gathering, analyzing, and synthesizing information from various sources.',\n    implementer:\n      'You are an implementation agent focused on writing code, creating solutions, and executing technical tasks.',\n    analyst:\n      'You are an analysis agent that identifies patterns, generates insights, and provides data-driven recommendations.',\n    custom: 'You are a specialized agent with custom capabilities defined by your configuration.',\n  };\n\n  return prompts[type as keyof typeof prompts] || prompts.custom;\n}\n"],
  "mappings": "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",
  "names": []
}
