{"version":3,"sources":["../../../src/core/HiveMindCore.ts"],"sourcesContent":["/**\r\n * HiveMindCore - Collective intelligence coordination\r\n * Implements the Queen-Worker pattern for distributed AI coordination\r\n */\r\n\r\nimport { IDatabaseProvider, IHiveMindQueen, Objective, Strategy, Task, Assignment, QueenMetrics, Feedback, Agent } from '../types/interfaces.js';\r\nimport { AgentRegistry } from './AgentRegistry.js';\r\nimport { ConsensusEngine } from './ConsensusEngine.js';\r\nimport { MetricsCollector } from './MetricsCollector.js';\r\nimport { nanoid } from 'nanoid';\r\n\r\nexport interface WorkerPool {\r\n  id: string;\r\n  specialization: string;\r\n  agents: Agent[];\r\n  capacity: number;\r\n  utilization: number;\r\n  performance: {\r\n    tasksCompleted: number;\r\n    averageQuality: number;\r\n    successRate: number;\r\n  };\r\n}\r\n\r\nexport interface HiveMindConfig {\r\n  maxWorkerPools: number;\r\n  queenEnabled: boolean;\r\n  adaptationRate: number;\r\n  consensusThreshold: number;\r\n  specializations: string[];\r\n}\r\n\r\nexport class HiveMindCore {\r\n  private queen: QueenManager;\r\n  private workerPools: Map<string, WorkerPool> = new Map();\r\n  private objectives: Map<string, Objective> = new Map();\r\n  private strategies: Map<string, Strategy> = new Map();\r\n  private assignments: Map<string, Assignment> = new Map();\r\n  private config: HiveMindConfig;\r\n\r\n  constructor(\r\n    private database: IDatabaseProvider,\r\n    private agentRegistry: AgentRegistry,\r\n    private consensusEngine: ConsensusEngine,\r\n    private metricsCollector: MetricsCollector,\r\n    config: Partial<HiveMindConfig> = {}\r\n  ) {\r\n    this.config = {\r\n      maxWorkerPools: 5,\r\n      queenEnabled: true,\r\n      adaptationRate: 0.1,\r\n      consensusThreshold: 0.7,\r\n      specializations: ['research', 'development', 'testing', 'optimization', 'coordination'],\r\n      ...config\r\n    };\r\n\r\n    this.queen = new QueenManager(\r\n      this.database,\r\n      this.agentRegistry,\r\n      this.consensusEngine,\r\n      this.metricsCollector\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Initialize the Hive Mind system\r\n   */\r\n  async initialize(): Promise<void> {\r\n    // Initialize Queen\r\n    if (this.config.queenEnabled) {\r\n      await this.queen.initialize();\r\n    }\r\n\r\n    // Create initial worker pools\r\n    await this.createInitialWorkerPools();\r\n\r\n    // Load existing objectives and strategies\r\n    await this.loadPersistedState();\r\n\r\n    console.log('ðŸ§  Hive Mind Core initialized with collective intelligence capabilities');\r\n  }\r\n\r\n  /**\r\n   * Create initial worker pools based on specializations\r\n   */\r\n  private async createInitialWorkerPools(): Promise<void> {\r\n    for (const specialization of this.config.specializations) {\r\n      const pool: WorkerPool = {\r\n        id: nanoid(),\r\n        specialization,\r\n        agents: [],\r\n        capacity: 5, // Default capacity\r\n        utilization: 0,\r\n        performance: {\r\n          tasksCompleted: 0,\r\n          averageQuality: 0.8,\r\n          successRate: 1.0\r\n        }\r\n      };\r\n\r\n      this.workerPools.set(pool.id, pool);\r\n      await this.database.store(`worker-pool:${pool.id}`, pool, 'hive-mind');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load persisted objectives and strategies\r\n   */\r\n  private async loadPersistedState(): Promise<void> {\r\n    try {\r\n      const objectiveKeys = await this.database.list('hive-mind');\r\n      const objectiveItems = objectiveKeys.filter(key => key.startsWith('objective:'));\r\n\r\n      for (const key of objectiveItems) {\r\n        const objective = await this.database.retrieve(key, 'hive-mind');\r\n        if (objective) {\r\n          this.objectives.set(objective.id, objective);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to load persisted hive mind state:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a new objective for the hive mind\r\n   */\r\n  async setObjective(objective: Omit<Objective, 'id'>): Promise<string> {\r\n    const fullObjective: Objective = {\r\n      ...objective,\r\n      id: nanoid()\r\n    };\r\n\r\n    this.objectives.set(fullObjective.id, fullObjective);\r\n    await this.database.store(`objective:${fullObjective.id}`, fullObjective, 'hive-mind');\r\n\r\n    // Have the Queen strategize if enabled\r\n    if (this.config.queenEnabled) {\r\n      const strategy = await this.queen.strategize(fullObjective);\r\n      this.strategies.set(fullObjective.id, strategy);\r\n      await this.database.store(`strategy:${fullObjective.id}`, strategy, 'hive-mind');\r\n    }\r\n\r\n    return fullObjective.id;\r\n  }\r\n\r\n  /**\r\n   * Execute an objective using collective intelligence\r\n   */\r\n  async executeObjective(objectiveId: string): Promise<{\r\n    success: boolean;\r\n    assignments: Assignment[];\r\n    results: any[];\r\n    metrics: any;\r\n  }> {\r\n    const objective = this.objectives.get(objectiveId);\r\n    if (!objective) {\r\n      throw new Error(`Objective ${objectiveId} not found`);\r\n    }\r\n\r\n    const strategy = this.strategies.get(objectiveId);\r\n    if (!strategy) {\r\n      throw new Error(`No strategy found for objective ${objectiveId}`);\r\n    }\r\n\r\n    // Extract tasks from strategy phases\r\n    const allTasks: Task[] = [];\r\n    strategy.phases.forEach(phase => {\r\n      allTasks.push(...phase.tasks);\r\n    });\r\n\r\n    // Delegate tasks to worker pools\r\n    const assignments = await this.delegateTasks(allTasks);\r\n\r\n    // Execute assignments in parallel (with dependency management)\r\n    const results = await this.executeAssignments(assignments);\r\n\r\n    // Collect metrics\r\n    const metrics = await this.collectExecutionMetrics(objectiveId, assignments, results);\r\n\r\n    return {\r\n      success: results.every(r => r.success),\r\n      assignments,\r\n      results,\r\n      metrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Delegate tasks to appropriate worker pools\r\n   */\r\n  private async delegateTasks(tasks: Task[]): Promise<Assignment[]> {\r\n    const assignments: Assignment[] = [];\r\n\r\n    for (const task of tasks) {\r\n      // Find best worker pool for this task\r\n      const bestPool = this.findBestWorkerPool(task);\r\n      if (!bestPool) {\r\n        console.warn(`No suitable worker pool found for task ${task.id}`);\r\n        continue;\r\n      }\r\n\r\n      // Find best agent in the pool\r\n      const bestAgent = await this.findBestAgentInPool(bestPool, task);\r\n      if (!bestAgent) {\r\n        console.warn(`No suitable agent found in pool ${bestPool.id} for task ${task.id}`);\r\n        continue;\r\n      }\r\n\r\n      const assignment: Assignment = {\r\n        agentId: bestAgent.id,\r\n        task,\r\n        deadline: task.deadline || new Date(Date.now() + 3600000), // 1 hour default\r\n        resources: {\r\n          memory: 256,\r\n          cpu: 1,\r\n          storage: 100,\r\n          network: 10\r\n        }\r\n      };\r\n\r\n      assignments.push(assignment);\r\n      this.assignments.set(task.id, assignment);\r\n\r\n      // Update pool utilization\r\n      bestPool.utilization += 1;\r\n    }\r\n\r\n    return assignments;\r\n  }\r\n\r\n  /**\r\n   * Find the best worker pool for a task\r\n   */\r\n  private findBestWorkerPool(task: Task): WorkerPool | null {\r\n    let bestPool: WorkerPool | null = null;\r\n    let bestScore = -1;\r\n\r\n    for (const pool of this.workerPools.values()) {\r\n      // Check if pool can handle the task's capabilities\r\n      const canHandle = task.requiredCapabilities.some(capability =>\r\n        capability.toLowerCase().includes(pool.specialization.toLowerCase()) ||\r\n        pool.specialization.toLowerCase().includes(capability.toLowerCase())\r\n      );\r\n\r\n      if (!canHandle) continue;\r\n\r\n      // Score based on performance, capacity, and utilization\r\n      let score = pool.performance.successRate * 40;\r\n      score += pool.performance.averageQuality * 30;\r\n      score += Math.max(0, (pool.capacity - pool.utilization) / pool.capacity) * 30;\r\n\r\n      if (score > bestScore) {\r\n        bestScore = score;\r\n        bestPool = pool;\r\n      }\r\n    }\r\n\r\n    return bestPool;\r\n  }\r\n\r\n  /**\r\n   * Find the best agent in a worker pool for a task\r\n   */\r\n  private async findBestAgentInPool(pool: WorkerPool, task: Task): Promise<Agent | null> {\r\n    if (pool.agents.length === 0) {\r\n      // Spawn a new agent for this pool\r\n      const agent = await this.agentRegistry.spawn(\r\n        this.getAgentTypeForSpecialization(pool.specialization),\r\n        {\r\n          capabilities: task.requiredCapabilities,\r\n          metadata: { workerPoolId: pool.id, specialization: pool.specialization }\r\n        }\r\n      );\r\n\r\n      pool.agents.push(agent);\r\n      await this.database.store(`worker-pool:${pool.id}`, pool, 'hive-mind');\r\n      return agent;\r\n    }\r\n\r\n    // Find best existing agent\r\n    let bestAgent: Agent | null = null;\r\n    let bestScore = -1;\r\n\r\n    for (const agent of pool.agents) {\r\n      if (agent.status !== 'idle' && agent.status !== 'active') continue;\r\n\r\n      // Score based on capability match and performance\r\n      const capabilityMatch = task.requiredCapabilities.filter(cap =>\r\n        agent.capabilities.includes(cap)\r\n      ).length / task.requiredCapabilities.length;\r\n\r\n      const performanceScore = agent.performance?.successRate || 0.5;\r\n\r\n      const score = capabilityMatch * 60 + performanceScore * 40;\r\n\r\n      if (score > bestScore) {\r\n        bestScore = score;\r\n        bestAgent = agent;\r\n      }\r\n    }\r\n\r\n    return bestAgent;\r\n  }\r\n\r\n  /**\r\n   * Get appropriate agent type for specialization\r\n   */\r\n  private getAgentTypeForSpecialization(specialization: string): any {\r\n    const typeMap: Record<string, string> = {\r\n      research: 'researcher',\r\n      development: 'coder',\r\n      testing: 'tester',\r\n      optimization: 'optimizer',\r\n      coordination: 'coordinator'\r\n    };\r\n\r\n    return typeMap[specialization] || 'researcher';\r\n  }\r\n\r\n  /**\r\n   * Execute assignments\r\n   */\r\n  private async executeAssignments(assignments: Assignment[]): Promise<any[]> {\r\n    const results: any[] = [];\r\n\r\n    // Group assignments by dependencies\r\n    const dependencyGroups = this.groupByDependencies(assignments);\r\n\r\n    // Execute groups in order\r\n    for (const group of dependencyGroups) {\r\n      const groupResults = await Promise.all(\r\n        group.map(async assignment => {\r\n          try {\r\n            return await this.agentRegistry.coordinate(assignment.task);\r\n          } catch (error) {\r\n            return {\r\n              success: false,\r\n              error: error instanceof Error ? error.message : String(error),\r\n              assignment\r\n            };\r\n          }\r\n        })\r\n      );\r\n\r\n      results.push(...groupResults);\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Group assignments by dependencies\r\n   */\r\n  private groupByDependencies(assignments: Assignment[]): Assignment[][] {\r\n    // Simplified dependency grouping - in production, this would be more sophisticated\r\n    const groups: Assignment[][] = [];\r\n    const remaining = [...assignments];\r\n\r\n    while (remaining.length > 0) {\r\n      const currentGroup = remaining.filter(assignment =>\r\n        !assignment.task.dependencies?.some(dep =>\r\n          remaining.some(other => other.task.id === dep)\r\n        )\r\n      );\r\n\r\n      if (currentGroup.length === 0) {\r\n        // Break circular dependencies by taking first item\r\n        currentGroup.push(remaining[0]);\r\n      }\r\n\r\n      groups.push(currentGroup);\r\n      remaining.splice(0, currentGroup.length);\r\n    }\r\n\r\n    return groups;\r\n  }\r\n\r\n  /**\r\n   * Collect execution metrics\r\n   */\r\n  private async collectExecutionMetrics(\r\n    objectiveId: string,\r\n    assignments: Assignment[],\r\n    results: any[]\r\n  ): Promise<any> {\r\n    const successCount = results.filter(r => r.success).length;\r\n    const successRate = successCount / results.length;\r\n\r\n    const totalTime = results.reduce((sum, r) => sum + (r.metadata?.executionTime || 0), 0);\r\n    const averageTime = totalTime / results.length;\r\n\r\n    const metrics = {\r\n      objectiveId,\r\n      totalTasks: assignments.length,\r\n      successfulTasks: successCount,\r\n      successRate,\r\n      averageExecutionTime: averageTime,\r\n      workerPoolUtilization: this.calculatePoolUtilization(),\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    await this.metricsCollector.recordSystemMetrics({\r\n      cpuUsage: 50 + Math.random() * 30, // Simulated\r\n      memoryUsage: 60 + Math.random() * 20,\r\n      diskUsage: 30 + Math.random() * 10,\r\n      networkLatency: 10 + Math.random() * 20,\r\n      activeConnections: assignments.length\r\n    });\r\n\r\n    return metrics;\r\n  }\r\n\r\n  /**\r\n   * Calculate worker pool utilization\r\n   */\r\n  private calculatePoolUtilization(): Record<string, number> {\r\n    const utilization: Record<string, number> = {};\r\n\r\n    for (const [poolId, pool] of this.workerPools) {\r\n      utilization[pool.specialization] = pool.utilization / pool.capacity;\r\n    }\r\n\r\n    return utilization;\r\n  }\r\n\r\n  /**\r\n   * Adapt hive mind based on feedback\r\n   */\r\n  async adapt(feedback: Feedback[]): Promise<void> {\r\n    if (this.config.queenEnabled) {\r\n      await this.queen.adapt(feedback);\r\n    }\r\n\r\n    // Adapt worker pools based on performance\r\n    for (const pool of this.workerPools.values()) {\r\n      const poolFeedback = feedback.filter(f =>\r\n        pool.agents.some(agent => agent.id === f.source)\r\n      );\r\n\r\n      if (poolFeedback.length > 0) {\r\n        const avgRating = poolFeedback.reduce((sum, f) => sum + f.rating, 0) / poolFeedback.length;\r\n\r\n        // Adjust pool performance metrics\r\n        const alpha = this.config.adaptationRate;\r\n        pool.performance.averageQuality = pool.performance.averageQuality * (1 - alpha) + (avgRating / 5) * alpha;\r\n\r\n        await this.database.store(`worker-pool:${pool.id}`, pool, 'hive-mind');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get hive mind status\r\n   */\r\n  async getStatus(): Promise<{\r\n    queen: any;\r\n    workerPools: WorkerPool[];\r\n    activeObjectives: number;\r\n    totalAssignments: number;\r\n    overallPerformance: number;\r\n  }> {\r\n    const queenMetrics = this.config.queenEnabled ? await this.queen.monitor() : null;\r\n\r\n    const overallPerformance = Array.from(this.workerPools.values())\r\n      .reduce((sum, pool) => sum + pool.performance.averageQuality, 0) / this.workerPools.size;\r\n\r\n    return {\r\n      queen: queenMetrics,\r\n      workerPools: Array.from(this.workerPools.values()),\r\n      activeObjectives: this.objectives.size,\r\n      totalAssignments: this.assignments.size,\r\n      overallPerformance\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get worker pool by specialization\r\n   */\r\n  getWorkerPoolBySpecialization(specialization: string): WorkerPool | undefined {\r\n    return Array.from(this.workerPools.values())\r\n      .find(pool => pool.specialization === specialization);\r\n  }\r\n\r\n  /**\r\n   * Scale worker pool\r\n   */\r\n  async scaleWorkerPool(poolId: string, newCapacity: number): Promise<void> {\r\n    const pool = this.workerPools.get(poolId);\r\n    if (!pool) return;\r\n\r\n    pool.capacity = newCapacity;\r\n    await this.database.store(`worker-pool:${poolId}`, pool, 'hive-mind');\r\n  }\r\n}\r\n\r\n/**\r\n * Queen Manager - Implements the strategic intelligence layer\r\n */\r\nclass QueenManager implements IHiveMindQueen {\r\n  private strategies: Map<string, Strategy> = new Map();\r\n  private metrics: QueenMetrics = {\r\n    strategiesCreated: 0,\r\n    tasksAssigned: 0,\r\n    successRate: 1.0,\r\n    adaptationCount: 0,\r\n    performanceScore: 100\r\n  };\r\n\r\n  constructor(\r\n    private database: IDatabaseProvider,\r\n    private agentRegistry: AgentRegistry,\r\n    private consensusEngine: ConsensusEngine,\r\n    private metricsCollector: MetricsCollector\r\n  ) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    console.log('ðŸ‘‘ Queen Manager initialized - Strategic intelligence online');\r\n  }\r\n\r\n  async strategize(objective: Objective): Promise<Strategy> {\r\n    // Analyze objective complexity and requirements\r\n    const complexity = this.analyzeComplexity(objective);\r\n    const riskLevel = this.assessRisk(objective);\r\n\r\n    // Create strategy phases\r\n    const phases = this.createStrategyPhases(objective, complexity);\r\n\r\n    // Estimate resource requirements\r\n    const resourceAllocation = this.estimateResources(objective, phases);\r\n\r\n    // Assess risks\r\n    const riskAssessment = this.identifyRisks(objective, riskLevel);\r\n\r\n    const strategy: Strategy = {\r\n      approach: this.selectApproach(complexity, riskLevel),\r\n      phases,\r\n      resourceAllocation,\r\n      expectedOutcome: `Complete objective: ${objective.description}`,\r\n      riskAssessment\r\n    };\r\n\r\n    this.strategies.set(objective.id, strategy);\r\n    this.metrics.strategiesCreated++;\r\n\r\n    return strategy;\r\n  }\r\n\r\n  async delegate(tasks: Task[]): Promise<Assignment[]> {\r\n    // This would be handled by the main HiveMindCore\r\n    // Queen focuses on high-level strategy\r\n    this.metrics.tasksAssigned += tasks.length;\r\n    return [];\r\n  }\r\n\r\n  async monitor(): Promise<QueenMetrics> {\r\n    // Update performance score based on recent strategies\r\n    const recentStrategies = Array.from(this.strategies.values()).slice(-10);\r\n    if (recentStrategies.length > 0) {\r\n      // Simulate performance based on strategy complexity and success\r\n      this.metrics.performanceScore = Math.min(100, 70 + Math.random() * 30);\r\n    }\r\n\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  async adapt(feedback: Feedback[]): Promise<void> {\r\n    // Adapt strategy creation based on feedback\r\n    const avgRating = feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length;\r\n\r\n    // Update success rate\r\n    const alpha = 0.1;\r\n    this.metrics.successRate = this.metrics.successRate * (1 - alpha) + (avgRating / 5) * alpha;\r\n    this.metrics.adaptationCount++;\r\n  }\r\n\r\n  private analyzeComplexity(objective: Objective): 'low' | 'medium' | 'high' {\r\n    const factors = [\r\n      objective.goals.length,\r\n      objective.constraints.length,\r\n      objective.priority === 'critical' ? 2 : 1\r\n    ];\r\n\r\n    const complexity = factors.reduce((sum, factor) => sum + factor, 0);\r\n\r\n    if (complexity <= 3) return 'low';\r\n    if (complexity <= 6) return 'medium';\r\n    return 'high';\r\n  }\r\n\r\n  private assessRisk(objective: Objective): 'low' | 'medium' | 'high' {\r\n    // Assess risk based on constraints and deadline\r\n    const hasDeadline = !!objective.deadline;\r\n    const constraintCount = objective.constraints.length;\r\n    const isCritical = objective.priority === 'critical';\r\n\r\n    if (isCritical || constraintCount > 3 || (hasDeadline && new Date(objective.deadline!) < new Date(Date.now() + 86400000))) {\r\n      return 'high';\r\n    }\r\n\r\n    if (constraintCount > 1 || hasDeadline) {\r\n      return 'medium';\r\n    }\r\n\r\n    return 'low';\r\n  }\r\n\r\n  private createStrategyPhases(objective: Objective, complexity: string): any[] {\r\n    const basePhases = [\r\n      { name: 'Analysis', description: 'Analyze requirements and constraints' },\r\n      { name: 'Planning', description: 'Create detailed execution plan' },\r\n      { name: 'Execution', description: 'Implement the solution' },\r\n      { name: 'Validation', description: 'Validate outcomes against goals' }\r\n    ];\r\n\r\n    if (complexity === 'high') {\r\n      basePhases.splice(2, 0, { name: 'Prototyping', description: 'Create and test prototypes' });\r\n    }\r\n\r\n    return basePhases.map((phase, index) => ({\r\n      ...phase,\r\n      tasks: this.createTasksForPhase(phase, objective),\r\n      dependencies: index > 0 ? [basePhases[index - 1].name] : [],\r\n      duration: complexity === 'high' ? 3600 : complexity === 'medium' ? 1800 : 900 // seconds\r\n    }));\r\n  }\r\n\r\n  private createTasksForPhase(phase: any, objective: Objective): Task[] {\r\n    // Generate tasks based on phase and objective\r\n    return [{\r\n      id: nanoid(),\r\n      type: phase.name.toLowerCase(),\r\n      description: `${phase.description} for objective: ${objective.description}`,\r\n      priority: objective.priority,\r\n      requiredCapabilities: this.inferCapabilities(phase.name),\r\n      deadline: objective.deadline\r\n    }];\r\n  }\r\n\r\n  private inferCapabilities(phaseName: string): string[] {\r\n    const capabilityMap: Record<string, string[]> = {\r\n      'Analysis': ['research', 'analysis'],\r\n      'Planning': ['planning', 'coordination'],\r\n      'Prototyping': ['programming', 'testing'],\r\n      'Execution': ['programming', 'implementation'],\r\n      'Validation': ['testing', 'quality-assurance']\r\n    };\r\n\r\n    return capabilityMap[phaseName] || ['general'];\r\n  }\r\n\r\n  private selectApproach(complexity: string, riskLevel: string): string {\r\n    if (complexity === 'high' && riskLevel === 'high') {\r\n      return 'Incremental development with continuous validation';\r\n    }\r\n\r\n    if (complexity === 'high') {\r\n      return 'Phased implementation with parallel workstreams';\r\n    }\r\n\r\n    if (riskLevel === 'high') {\r\n      return 'Risk-first approach with contingency planning';\r\n    }\r\n\r\n    return 'Standard agile approach with regular checkpoints';\r\n  }\r\n\r\n  private estimateResources(objective: Objective, phases: any[]): any {\r\n    return {\r\n      memory: phases.length * 512, // MB\r\n      cpu: phases.length * 2, // cores\r\n      storage: phases.length * 100, // MB\r\n      network: 10 // Mbps\r\n    };\r\n  }\r\n\r\n  private identifyRisks(objective: Objective, riskLevel: string): any[] {\r\n    const baseRisks = [\r\n      {\r\n        description: 'Requirement changes during execution',\r\n        probability: 0.3,\r\n        impact: 0.6,\r\n        mitigation: 'Regular stakeholder communication and flexible planning'\r\n      }\r\n    ];\r\n\r\n    if (riskLevel === 'high') {\r\n      baseRisks.push({\r\n        description: 'Resource constraints affecting timeline',\r\n        probability: 0.5,\r\n        impact: 0.8,\r\n        mitigation: 'Resource monitoring and contingency planning'\r\n      });\r\n    }\r\n\r\n    return baseRisks;\r\n  }\r\n}"],"names":["nanoid","HiveMindCore","queen","workerPools","Map","objectives","strategies","assignments","config","database","agentRegistry","consensusEngine","metricsCollector","maxWorkerPools","queenEnabled","adaptationRate","consensusThreshold","specializations","QueenManager","initialize","createInitialWorkerPools","loadPersistedState","console","log","specialization","pool","id","agents","capacity","utilization","performance","tasksCompleted","averageQuality","successRate","set","store","objectiveKeys","list","objectiveItems","filter","key","startsWith","objective","retrieve","error","warn","setObjective","fullObjective","strategy","strategize","executeObjective","objectiveId","get","Error","allTasks","phases","forEach","phase","push","tasks","delegateTasks","results","executeAssignments","metrics","collectExecutionMetrics","success","every","r","task","bestPool","findBestWorkerPool","bestAgent","findBestAgentInPool","assignment","agentId","deadline","Date","now","resources","memory","cpu","storage","network","bestScore","values","canHandle","requiredCapabilities","some","capability","toLowerCase","includes","score","Math","max","length","agent","spawn","getAgentTypeForSpecialization","capabilities","metadata","workerPoolId","status","capabilityMatch","cap","performanceScore","typeMap","research","development","testing","optimization","coordination","dependencyGroups","groupByDependencies","group","groupResults","Promise","all","map","coordinate","message","String","groups","remaining","currentGroup","dependencies","dep","other","splice","successCount","totalTime","reduce","sum","executionTime","averageTime","totalTasks","successfulTasks","averageExecutionTime","workerPoolUtilization","calculatePoolUtilization","timestamp","toISOString","recordSystemMetrics","cpuUsage","random","memoryUsage","diskUsage","networkLatency","activeConnections","poolId","adapt","feedback","poolFeedback","f","source","avgRating","rating","alpha","getStatus","queenMetrics","monitor","overallPerformance","Array","from","size","activeObjectives","totalAssignments","getWorkerPoolBySpecialization","find","scaleWorkerPool","newCapacity","strategiesCreated","tasksAssigned","adaptationCount","complexity","analyzeComplexity","riskLevel","assessRisk","createStrategyPhases","resourceAllocation","estimateResources","riskAssessment","identifyRisks","approach","selectApproach","expectedOutcome","description","delegate","recentStrategies","slice","min","factors","goals","constraints","priority","factor","hasDeadline","constraintCount","isCritical","basePhases","name","index","createTasksForPhase","duration","type","inferCapabilities","phaseName","capabilityMap","baseRisks","probability","impact","mitigation"],"mappings":"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"}