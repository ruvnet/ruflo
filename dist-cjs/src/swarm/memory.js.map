{"version":3,"sources":["../../../src/swarm/memory.ts"],"sourcesContent":["/**\r\n * Distributed Memory System with Cross-Agent Sharing\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport * as fs from 'node:fs/promises';\r\nimport * as path from 'node:path';\r\nimport * as crypto from 'node:crypto';\r\nimport { Logger } from '../core/logger.js';\r\nimport { generateId } from '../utils/helpers.js';\r\nimport {\r\n  MemoryEntry,\r\n  MemoryPartition,\r\n  SwarmMemory,\r\n  AccessLevel,\r\n  ConsistencyLevel,\r\n  MemoryType,\r\n  MemoryPermissions,\r\n  AgentId,\r\n  SwarmEvent,\r\n  SWARM_CONSTANTS,\r\n} from './types.js';\r\n\r\nexport interface MemoryQuery {\r\n  namespace?: string;\r\n  partition?: string;\r\n  key?: string;\r\n  tags?: string[];\r\n  type?: MemoryType;\r\n  owner?: AgentId;\r\n  accessLevel?: AccessLevel;\r\n  createdAfter?: Date;\r\n  createdBefore?: Date;\r\n  expiresAfter?: Date;\r\n  limit?: number;\r\n  offset?: number;\r\n  sortBy?: 'createdAt' | 'updatedAt' | 'key' | 'relevance';\r\n  sortOrder?: 'asc' | 'desc';\r\n}\r\n\r\nexport interface MemorySearchOptions {\r\n  query: string;\r\n  searchFields?: string[];\r\n  fuzzyMatch?: boolean;\r\n  maxResults?: number;\r\n  threshold?: number;\r\n  includeContent?: boolean;\r\n}\r\n\r\nexport interface MemoryStatistics {\r\n  totalEntries: number;\r\n  totalSize: number;\r\n  partitionCount: number;\r\n  entriesByType: Record<MemoryType, number>;\r\n  entriesByAccess: Record<AccessLevel, number>;\r\n  averageSize: number;\r\n  oldestEntry: Date;\r\n  newestEntry: Date;\r\n  expiringEntries: number;\r\n}\r\n\r\nexport interface MemoryBackup {\r\n  timestamp: Date;\r\n  version: string;\r\n  checksum: string;\r\n  metadata: Record<string, any>;\r\n  entries: MemoryEntry[];\r\n  partitions: MemoryPartition[];\r\n}\r\n\r\nexport interface MemoryConfig {\r\n  namespace: string;\r\n  persistencePath: string;\r\n  maxMemorySize: number;\r\n  maxEntrySize: number;\r\n  defaultTtl: number;\r\n  enableCompression: boolean;\r\n  enableEncryption: boolean;\r\n  encryptionKey?: string;\r\n  consistencyLevel: ConsistencyLevel;\r\n  syncInterval: number;\r\n  backupInterval: number;\r\n  maxBackups: number;\r\n  enableDistribution: boolean;\r\n  distributionNodes: string[];\r\n  replicationFactor: number;\r\n  enableCaching: boolean;\r\n  cacheSize: number;\r\n  cacheTtl: number;\r\n}\r\n\r\nexport class SwarmMemoryManager extends EventEmitter {\r\n  private logger: Logger;\r\n  private config: MemoryConfig;\r\n  private memory: SwarmMemory;\r\n  private partitions: Map<string, MemoryPartition> = new Map();\r\n  private entries: Map<string, MemoryEntry> = new Map();\r\n  private index: MemoryIndex;\r\n  private cache: MemoryCache;\r\n  private replication: MemoryReplication;\r\n  private persistence: MemoryPersistence;\r\n  private encryption: MemoryEncryption;\r\n  private isInitialized = false;\r\n\r\n  // Background processes\r\n  private syncTimer?: NodeJS.Timeout;\r\n  private backupTimer?: NodeJS.Timeout;\r\n  private cleanupTimer?: NodeJS.Timeout;\r\n\r\n  constructor(config: Partial<MemoryConfig & { logging?: any }> = {}) {\r\n    super();\r\n\r\n    // Configure logger based on config or default to quiet mode\r\n    const logLevel = config.logging?.level || 'error';\r\n    const logFormat = config.logging?.format || 'text';\r\n    const logDestination = config.logging?.destination || 'console';\r\n\r\n    this.logger = new Logger(\r\n      { level: logLevel, format: logFormat, destination: logDestination },\r\n      { component: 'SwarmMemoryManager' },\r\n    );\r\n    this.config = this.mergeWithDefaults(config);\r\n\r\n    // Initialize memory structure\r\n    this.memory = {\r\n      namespace: this.config.namespace,\r\n      partitions: [],\r\n      permissions: {\r\n        read: 'swarm',\r\n        write: 'team',\r\n        delete: 'private',\r\n        share: 'team',\r\n      },\r\n      persistent: true,\r\n      backupEnabled: true,\r\n      distributed: this.config.enableDistribution,\r\n      consistency: this.config.consistencyLevel,\r\n      cacheEnabled: this.config.enableCaching,\r\n      compressionEnabled: this.config.enableCompression,\r\n    };\r\n\r\n    // Initialize subsystems\r\n    this.index = new MemoryIndex();\r\n    this.cache = new MemoryCache(this.config.cacheSize, this.config.cacheTtl);\r\n    this.replication = new MemoryReplication(this.config);\r\n    this.persistence = new MemoryPersistence(this.config);\r\n    this.encryption = new MemoryEncryption(this.config);\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.isInitialized) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Initializing swarm memory manager...');\r\n\r\n    try {\r\n      // Initialize subsystems\r\n      await this.persistence.initialize();\r\n      await this.encryption.initialize();\r\n      await this.replication.initialize();\r\n      await this.index.initialize();\r\n\r\n      // Load existing data\r\n      await this.loadMemoryState();\r\n\r\n      // Create default partitions\r\n      await this.createDefaultPartitions();\r\n\r\n      // Start background processes\r\n      this.startBackgroundProcesses();\r\n\r\n      this.isInitialized = true;\r\n\r\n      this.emit('memory:initialized', {\r\n        namespace: this.config.namespace,\r\n        entriesLoaded: this.entries.size,\r\n        partitionsLoaded: this.partitions.size,\r\n      });\r\n\r\n      this.logger.info('Swarm memory manager initialized', {\r\n        namespace: this.config.namespace,\r\n        entries: this.entries.size,\r\n        partitions: this.partitions.size,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize memory manager', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    if (!this.isInitialized) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('Shutting down swarm memory manager...');\r\n\r\n    try {\r\n      // Stop background processes\r\n      this.stopBackgroundProcesses();\r\n\r\n      // Save final state\r\n      await this.saveMemoryState();\r\n\r\n      // Shutdown subsystems\r\n      await this.replication.shutdown();\r\n      await this.persistence.shutdown();\r\n      await this.encryption.shutdown();\r\n\r\n      this.isInitialized = false;\r\n\r\n      this.emit('memory:shutdown');\r\n      this.logger.info('Swarm memory manager shut down');\r\n    } catch (error) {\r\n      this.logger.error('Error during memory manager shutdown', { error });\r\n    }\r\n  }\r\n\r\n  // ===== MEMORY OPERATIONS =====\r\n\r\n  async store(\r\n    key: string,\r\n    value: any,\r\n    options: Partial<{\r\n      partition: string;\r\n      type: MemoryType;\r\n      tags: string[];\r\n      owner: AgentId;\r\n      accessLevel: AccessLevel;\r\n      ttl: number;\r\n      metadata: Record<string, any>;\r\n    }> = {},\r\n  ): Promise<string> {\r\n    this.ensureInitialized();\r\n\r\n    const entryId = generateId('mem');\r\n    const now = new Date();\r\n\r\n    // Validate access permissions\r\n    if (options.owner) {\r\n      await this.validateAccess(options.owner, 'write', options.partition);\r\n    }\r\n\r\n    // Determine partition\r\n    const partitionName = options.partition || 'default';\r\n    const partition = await this.getOrCreatePartition(partitionName);\r\n\r\n    // Create memory entry\r\n    const entry: MemoryEntry = {\r\n      id: entryId,\r\n      key,\r\n      value: await this.serializeValue(value),\r\n      type: options.type || 'knowledge',\r\n      tags: options.tags || [],\r\n      owner: options.owner || { id: 'system', swarmId: '', type: 'coordinator', instance: 0 },\r\n      accessLevel: options.accessLevel || 'team',\r\n      createdAt: now,\r\n      updatedAt: now,\r\n      expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\r\n      version: 1,\r\n      references: [],\r\n      dependencies: [],\r\n    };\r\n\r\n    // Validate entry size\r\n    const entrySize = this.calculateEntrySize(entry);\r\n    if (entrySize > this.config.maxEntrySize) {\r\n      throw new Error(`Entry size ${entrySize} exceeds maximum ${this.config.maxEntrySize}`);\r\n    }\r\n\r\n    // Check memory limits\r\n    await this.enforceMemoryLimits(entrySize);\r\n\r\n    // Store entry\r\n    this.entries.set(entryId, entry);\r\n    partition.entries.push(entry);\r\n\r\n    // Update index\r\n    await this.index.addEntry(entry);\r\n\r\n    // Update cache\r\n    if (this.config.enableCaching) {\r\n      this.cache.set(key, entry);\r\n    }\r\n\r\n    // Replicate if enabled\r\n    if (this.config.enableDistribution) {\r\n      await this.replication.replicate(entry);\r\n    }\r\n\r\n    // Emit event\r\n    this.emit('memory:stored', {\r\n      entryId,\r\n      key,\r\n      partition: partitionName,\r\n      type: entry.type,\r\n      size: entrySize,\r\n    });\r\n\r\n    this.logger.debug('Stored memory entry', {\r\n      entryId,\r\n      key,\r\n      partition: partitionName,\r\n      type: entry.type,\r\n      size: entrySize,\r\n    });\r\n\r\n    return entryId;\r\n  }\r\n\r\n  async retrieve(\r\n    key: string,\r\n    options: Partial<{\r\n      partition: string;\r\n      requester: AgentId;\r\n      includeMetadata: boolean;\r\n    }> = {},\r\n  ): Promise<any> {\r\n    this.ensureInitialized();\r\n\r\n    // Try cache first\r\n    if (this.config.enableCaching) {\r\n      const cached = this.cache.get(key);\r\n      if (cached && !this.isExpired(cached)) {\r\n        if (options.requester) {\r\n          await this.validateAccess(options.requester, 'read', options.partition);\r\n        }\r\n        return options.includeMetadata ? cached : await this.deserializeValue(cached.value);\r\n      }\r\n    }\r\n\r\n    // Find entry\r\n    const entry = await this.findEntry(key, options.partition);\r\n    if (!entry) {\r\n      return null;\r\n    }\r\n\r\n    // Check expiration\r\n    if (this.isExpired(entry)) {\r\n      await this.deleteEntry(entry.id);\r\n      return null;\r\n    }\r\n\r\n    // Validate access\r\n    if (options.requester) {\r\n      await this.validateAccess(options.requester, 'read', options.partition);\r\n    }\r\n\r\n    // Update cache\r\n    if (this.config.enableCaching) {\r\n      this.cache.set(key, entry);\r\n    }\r\n\r\n    // Emit event\r\n    this.emit('memory:retrieved', {\r\n      entryId: entry.id,\r\n      key,\r\n      requester: options.requester?.id,\r\n    });\r\n\r\n    return options.includeMetadata ? entry : await this.deserializeValue(entry.value);\r\n  }\r\n\r\n  async update(\r\n    key: string,\r\n    value: any,\r\n    options: Partial<{\r\n      partition: string;\r\n      updater: AgentId;\r\n      metadata: Record<string, any>;\r\n      incrementVersion: boolean;\r\n    }> = {},\r\n  ): Promise<boolean> {\r\n    this.ensureInitialized();\r\n\r\n    const entry = await this.findEntry(key, options.partition);\r\n    if (!entry) {\r\n      return false;\r\n    }\r\n\r\n    // Validate access\r\n    if (options.updater) {\r\n      await this.validateAccess(options.updater, 'write', options.partition);\r\n    }\r\n\r\n    // Create backup of old version\r\n    if (options.incrementVersion !== false) {\r\n      entry.previousVersions = entry.previousVersions || [];\r\n      entry.previousVersions.push({ ...entry });\r\n\r\n      // Limit version history\r\n      if (entry.previousVersions.length > 10) {\r\n        entry.previousVersions = entry.previousVersions.slice(-10);\r\n      }\r\n    }\r\n\r\n    // Update entry\r\n    entry.value = await this.serializeValue(value);\r\n    entry.updatedAt = new Date();\r\n    if (options.incrementVersion !== false) {\r\n      entry.version++;\r\n    }\r\n\r\n    // Update index\r\n    await this.index.updateEntry(entry);\r\n\r\n    // Update cache\r\n    if (this.config.enableCaching) {\r\n      this.cache.set(key, entry);\r\n    }\r\n\r\n    // Replicate if enabled\r\n    if (this.config.enableDistribution) {\r\n      await this.replication.replicate(entry);\r\n    }\r\n\r\n    this.emit('memory:updated', {\r\n      entryId: entry.id,\r\n      key,\r\n      version: entry.version,\r\n      updater: options.updater?.id,\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  async delete(\r\n    key: string,\r\n    options: Partial<{\r\n      partition: string;\r\n      deleter: AgentId;\r\n      force: boolean;\r\n    }> = {},\r\n  ): Promise<boolean> {\r\n    this.ensureInitialized();\r\n\r\n    const entry = await this.findEntry(key, options.partition);\r\n    if (!entry) {\r\n      return false;\r\n    }\r\n\r\n    // Validate access\r\n    if (options.deleter && !options.force) {\r\n      await this.validateAccess(options.deleter, 'delete', options.partition);\r\n    }\r\n\r\n    return await this.deleteEntry(entry.id);\r\n  }\r\n\r\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\r\n    this.ensureInitialized();\r\n\r\n    let results = Array.from(this.entries.values());\r\n\r\n    // Apply filters\r\n    if (query.partition) {\r\n      const partition = this.partitions.get(query.partition);\r\n      if (partition) {\r\n        const entryIds = new Set(partition.entries.map((e) => e.id));\r\n        results = results.filter((e) => entryIds.has(e.id));\r\n      } else {\r\n        return [];\r\n      }\r\n    }\r\n\r\n    if (query.key) {\r\n      results = results.filter((e) => e.key === query.key);\r\n    }\r\n\r\n    if (query.type) {\r\n      results = results.filter((e) => e.type === query.type);\r\n    }\r\n\r\n    if (query.owner) {\r\n      results = results.filter((e) => e.owner.id === query.owner!.id);\r\n    }\r\n\r\n    if (query.accessLevel) {\r\n      results = results.filter((e) => e.accessLevel === query.accessLevel);\r\n    }\r\n\r\n    if (query.tags && query.tags.length > 0) {\r\n      results = results.filter((e) => query.tags!.some((tag) => e.tags.includes(tag)));\r\n    }\r\n\r\n    if (query.createdAfter) {\r\n      results = results.filter((e) => e.createdAt >= query.createdAfter!);\r\n    }\r\n\r\n    if (query.createdBefore) {\r\n      results = results.filter((e) => e.createdAt <= query.createdBefore!);\r\n    }\r\n\r\n    if (query.expiresAfter) {\r\n      results = results.filter((e) => e.expiresAt && e.expiresAt >= query.expiresAfter!);\r\n    }\r\n\r\n    // Filter out expired entries\r\n    results = results.filter((e) => !this.isExpired(e));\r\n\r\n    // Sort results\r\n    if (query.sortBy) {\r\n      results.sort((a, b) => {\r\n        let compareValue = 0;\r\n\r\n        switch (query.sortBy) {\r\n          case 'createdAt':\r\n            compareValue = a.createdAt.getTime() - b.createdAt.getTime();\r\n            break;\r\n          case 'updatedAt':\r\n            compareValue = a.updatedAt.getTime() - b.updatedAt.getTime();\r\n            break;\r\n          case 'key':\r\n            compareValue = a.key.localeCompare(b.key);\r\n            break;\r\n          default:\r\n            compareValue = 0;\r\n        }\r\n\r\n        return query.sortOrder === 'desc' ? -compareValue : compareValue;\r\n      });\r\n    }\r\n\r\n    // Apply pagination\r\n    const offset = query.offset || 0;\r\n    const limit = query.limit || results.length;\r\n    results = results.slice(offset, offset + limit);\r\n\r\n    return results;\r\n  }\r\n\r\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\r\n    this.ensureInitialized();\r\n    return await this.index.search(options);\r\n  }\r\n\r\n  // ===== SHARING AND COLLABORATION =====\r\n\r\n  async shareMemory(\r\n    key: string,\r\n    targetAgent: AgentId,\r\n    options: Partial<{\r\n      partition: string;\r\n      sharer: AgentId;\r\n      accessLevel: AccessLevel;\r\n      expiresAt: Date;\r\n    }> = {},\r\n  ): Promise<string> {\r\n    this.ensureInitialized();\r\n\r\n    const entry = await this.findEntry(key, options.partition);\r\n    if (!entry) {\r\n      throw new Error(`Memory entry not found: ${key}`);\r\n    }\r\n\r\n    // Validate sharing permissions\r\n    if (options.sharer) {\r\n      await this.validateAccess(options.sharer, 'share', options.partition);\r\n    }\r\n\r\n    // Create shared copy\r\n    const sharedEntryId = generateId('shared-mem');\r\n    const sharedEntry: MemoryEntry = {\r\n      ...entry,\r\n      id: sharedEntryId,\r\n      owner: targetAgent,\r\n      accessLevel: options.accessLevel || entry.accessLevel,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      expiresAt: options.expiresAt,\r\n      references: [...entry.references, entry.id],\r\n    };\r\n\r\n    // Store shared entry\r\n    this.entries.set(sharedEntryId, sharedEntry);\r\n    await this.index.addEntry(sharedEntry);\r\n\r\n    // Add to target agent's partition\r\n    const targetPartition = await this.getOrCreatePartition(`agent_${targetAgent.id}`);\r\n    targetPartition.entries.push(sharedEntry);\r\n\r\n    this.emit('memory:shared', {\r\n      originalId: entry.id,\r\n      sharedId: sharedEntryId,\r\n      key,\r\n      sharer: options.sharer?.id,\r\n      target: targetAgent.id,\r\n    });\r\n\r\n    this.logger.info('Shared memory entry', {\r\n      key,\r\n      from: options.sharer?.id,\r\n      to: targetAgent.id,\r\n      sharedId: sharedEntryId,\r\n    });\r\n\r\n    return sharedEntryId;\r\n  }\r\n\r\n  async broadcastMemory(\r\n    key: string,\r\n    targetAgents: AgentId[],\r\n    options: Partial<{\r\n      partition: string;\r\n      broadcaster: AgentId;\r\n      accessLevel: AccessLevel;\r\n    }> = {},\r\n  ): Promise<string[]> {\r\n    this.ensureInitialized();\r\n\r\n    const sharedIds: string[] = [];\r\n\r\n    for (const targetAgent of targetAgents) {\r\n      try {\r\n        const sharedId = await this.shareMemory(key, targetAgent, {\r\n          ...options,\r\n          sharer: options.broadcaster,\r\n        });\r\n        sharedIds.push(sharedId);\r\n      } catch (error) {\r\n        this.logger.warn('Failed to share memory with agent', {\r\n          key,\r\n          targetAgent: targetAgent.id,\r\n          error: error instanceof Error ? error.message : String(error),\r\n        });\r\n      }\r\n    }\r\n\r\n    this.emit('memory:broadcasted', {\r\n      key,\r\n      broadcaster: options.broadcaster?.id,\r\n      targets: targetAgents.map((a) => a.id),\r\n      sharedCount: sharedIds.length,\r\n    });\r\n\r\n    return sharedIds;\r\n  }\r\n\r\n  async synchronizeWith(\r\n    targetNode: string,\r\n    options: Partial<{\r\n      partition: string;\r\n      direction: 'pull' | 'push' | 'bidirectional';\r\n      filter: MemoryQuery;\r\n    }> = {},\r\n  ): Promise<void> {\r\n    this.ensureInitialized();\r\n\r\n    if (!this.config.enableDistribution) {\r\n      throw new Error('Distribution not enabled');\r\n    }\r\n\r\n    await this.replication.synchronizeWith(targetNode, options);\r\n\r\n    this.emit('memory:synchronized', {\r\n      targetNode,\r\n      direction: options.direction || 'bidirectional',\r\n      partition: options.partition,\r\n    });\r\n  }\r\n\r\n  // ===== PARTITION MANAGEMENT =====\r\n\r\n  async createPartition(\r\n    name: string,\r\n    options: Partial<{\r\n      type: MemoryType;\r\n      maxSize: number;\r\n      ttl: number;\r\n      readOnly: boolean;\r\n      shared: boolean;\r\n      indexed: boolean;\r\n      compressed: boolean;\r\n    }> = {},\r\n    skipInitCheck: boolean = false,\r\n  ): Promise<string> {\r\n    if (!skipInitCheck) {\r\n      this.ensureInitialized();\r\n    }\r\n\r\n    if (this.partitions.has(name)) {\r\n      throw new Error(`Partition already exists: ${name}`);\r\n    }\r\n\r\n    const partition: MemoryPartition = {\r\n      id: generateId('partition'),\r\n      name,\r\n      type: options.type || 'knowledge',\r\n      entries: [],\r\n      maxSize: options.maxSize || this.config.maxMemorySize,\r\n      ttl: options.ttl,\r\n      readOnly: options.readOnly || false,\r\n      shared: options.shared || true,\r\n      indexed: options.indexed !== false,\r\n      compressed: options.compressed || this.config.enableCompression,\r\n    };\r\n\r\n    this.partitions.set(name, partition);\r\n    this.memory.partitions.push(partition);\r\n\r\n    this.emit('memory:partition-created', {\r\n      partitionId: partition.id,\r\n      name,\r\n      type: partition.type,\r\n    });\r\n\r\n    this.logger.info('Created memory partition', {\r\n      name,\r\n      type: partition.type,\r\n      maxSize: partition.maxSize,\r\n    });\r\n\r\n    return partition.id;\r\n  }\r\n\r\n  async deletePartition(name: string, force: boolean = false): Promise<boolean> {\r\n    this.ensureInitialized();\r\n\r\n    const partition = this.partitions.get(name);\r\n    if (!partition) {\r\n      return false;\r\n    }\r\n\r\n    if (partition.entries.length > 0 && !force) {\r\n      throw new Error(`Partition ${name} contains entries. Use force=true to delete.`);\r\n    }\r\n\r\n    // Delete all entries in partition\r\n    for (const entry of partition.entries) {\r\n      await this.deleteEntry(entry.id);\r\n    }\r\n\r\n    this.partitions.delete(name);\r\n    this.memory.partitions = this.memory.partitions.filter((p) => p.id !== partition.id);\r\n\r\n    this.emit('memory:partition-deleted', {\r\n      partitionId: partition.id,\r\n      name,\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  getPartition(name: string): MemoryPartition | undefined {\r\n    return this.partitions.get(name);\r\n  }\r\n\r\n  getPartitions(): MemoryPartition[] {\r\n    return Array.from(this.partitions.values());\r\n  }\r\n\r\n  // ===== BACKUP AND RECOVERY =====\r\n\r\n  async createBackup(): Promise<string> {\r\n    this.ensureInitialized();\r\n\r\n    const backup: MemoryBackup = {\r\n      timestamp: new Date(),\r\n      version: '1.0.0',\r\n      checksum: '',\r\n      metadata: {\r\n        namespace: this.config.namespace,\r\n        entryCount: this.entries.size,\r\n        partitionCount: this.partitions.size,\r\n      },\r\n      entries: Array.from(this.entries.values()),\r\n      partitions: Array.from(this.partitions.values()),\r\n    };\r\n\r\n    // Calculate checksum\r\n    backup.checksum = this.calculateChecksum(backup);\r\n\r\n    const backupId = generateId('backup');\r\n    await this.persistence.saveBackup(backupId, backup);\r\n\r\n    this.emit('memory:backup-created', {\r\n      backupId,\r\n      entryCount: backup.entries.length,\r\n      size: JSON.stringify(backup).length,\r\n    });\r\n\r\n    return backupId;\r\n  }\r\n\r\n  async restoreFromBackup(backupId: string): Promise<void> {\r\n    this.ensureInitialized();\r\n\r\n    const backup = await this.persistence.loadBackup(backupId);\r\n    if (!backup) {\r\n      throw new Error(`Backup not found: ${backupId}`);\r\n    }\r\n\r\n    // Verify checksum\r\n    const calculatedChecksum = this.calculateChecksum(backup);\r\n    if (calculatedChecksum !== backup.checksum) {\r\n      throw new Error('Backup checksum verification failed');\r\n    }\r\n\r\n    // Clear current state\r\n    this.entries.clear();\r\n    this.partitions.clear();\r\n    await this.index.clear();\r\n\r\n    // Restore entries\r\n    for (const entry of backup.entries) {\r\n      this.entries.set(entry.id, entry);\r\n      await this.index.addEntry(entry);\r\n    }\r\n\r\n    // Restore partitions\r\n    for (const partition of backup.partitions) {\r\n      this.partitions.set(partition.name, partition);\r\n    }\r\n\r\n    this.memory.partitions = backup.partitions;\r\n\r\n    this.emit('memory:backup-restored', {\r\n      backupId,\r\n      entryCount: backup.entries.length,\r\n      partitionCount: backup.partitions.length,\r\n    });\r\n\r\n    this.logger.info('Restored from backup', {\r\n      backupId,\r\n      entries: backup.entries.length,\r\n      partitions: backup.partitions.length,\r\n    });\r\n  }\r\n\r\n  // ===== STATISTICS AND MONITORING =====\r\n\r\n  getStatistics(): MemoryStatistics {\r\n    const entries = Array.from(this.entries.values());\r\n    const validEntries = entries.filter((e) => !this.isExpired(e));\r\n\r\n    const entriesByType: Record<MemoryType, number> = {\r\n      knowledge: 0,\r\n      state: 0,\r\n      cache: 0,\r\n      logs: 0,\r\n      results: 0,\r\n      communication: 0,\r\n      configuration: 0,\r\n      metrics: 0,\r\n    };\r\n\r\n    const entriesByAccess: Record<AccessLevel, number> = {\r\n      private: 0,\r\n      team: 0,\r\n      swarm: 0,\r\n      public: 0,\r\n      system: 0,\r\n    };\r\n\r\n    let totalSize = 0;\r\n    let oldestEntry = new Date();\r\n    let newestEntry = new Date(0);\r\n    let expiringEntries = 0;\r\n\r\n    for (const entry of validEntries) {\r\n      entriesByType[entry.type]++;\r\n      entriesByAccess[entry.accessLevel]++;\r\n\r\n      const entrySize = this.calculateEntrySize(entry);\r\n      totalSize += entrySize;\r\n\r\n      if (entry.createdAt < oldestEntry) {\r\n        oldestEntry = entry.createdAt;\r\n      }\r\n\r\n      if (entry.createdAt > newestEntry) {\r\n        newestEntry = entry.createdAt;\r\n      }\r\n\r\n      if (entry.expiresAt && entry.expiresAt.getTime() - Date.now() < 24 * 60 * 60 * 1000) {\r\n        expiringEntries++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalEntries: validEntries.length,\r\n      totalSize,\r\n      partitionCount: this.partitions.size,\r\n      entriesByType,\r\n      entriesByAccess,\r\n      averageSize: validEntries.length > 0 ? totalSize / validEntries.length : 0,\r\n      oldestEntry,\r\n      newestEntry,\r\n      expiringEntries,\r\n    };\r\n  }\r\n\r\n  async exportMemory(\r\n    options: Partial<{\r\n      format: 'json' | 'csv';\r\n      includeExpired: boolean;\r\n      filter: MemoryQuery;\r\n    }> = {},\r\n  ): Promise<string> {\r\n    this.ensureInitialized();\r\n\r\n    let entries = Array.from(this.entries.values());\r\n\r\n    if (!options.includeExpired) {\r\n      entries = entries.filter((e) => !this.isExpired(e));\r\n    }\r\n\r\n    if (options.filter) {\r\n      const filteredResults = await this.query(options.filter);\r\n      const filteredIds = new Set(filteredResults.map((e) => e.id));\r\n      entries = entries.filter((e) => filteredIds.has(e.id));\r\n    }\r\n\r\n    if (options.format === 'csv') {\r\n      return this.entriesToCSV(entries);\r\n    } else {\r\n      return JSON.stringify(\r\n        {\r\n          exported: new Date().toISOString(),\r\n          namespace: this.config.namespace,\r\n          entryCount: entries.length,\r\n          entries: entries.map((e) => ({\r\n            ...e,\r\n            value: e.value, // Value is already serialized\r\n          })),\r\n        },\r\n        null,\r\n        2,\r\n      );\r\n    }\r\n  }\r\n\r\n  // ===== PRIVATE METHODS =====\r\n\r\n  private ensureInitialized(): void {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Memory manager not initialized');\r\n    }\r\n  }\r\n\r\n  private async findEntry(key: string, partition?: string): Promise<MemoryEntry | null> {\r\n    for (const entry of this.entries.values()) {\r\n      if (entry.key === key) {\r\n        if (partition) {\r\n          const part = this.partitions.get(partition);\r\n          if (part && part.entries.find((e) => e.id === entry.id)) {\r\n            return entry;\r\n          }\r\n        } else {\r\n          return entry;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private async deleteEntry(entryId: string): Promise<boolean> {\r\n    const entry = this.entries.get(entryId);\r\n    if (!entry) {\r\n      return false;\r\n    }\r\n\r\n    // Remove from entries\r\n    this.entries.delete(entryId);\r\n\r\n    // Remove from partitions\r\n    for (const partition of this.partitions.values()) {\r\n      partition.entries = partition.entries.filter((e) => e.id !== entryId);\r\n    }\r\n\r\n    // Remove from index\r\n    await this.index.removeEntry(entryId);\r\n\r\n    // Remove from cache\r\n    if (this.config.enableCaching) {\r\n      this.cache.delete(entry.key);\r\n    }\r\n\r\n    this.emit('memory:deleted', {\r\n      entryId,\r\n      key: entry.key,\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  private isExpired(entry: MemoryEntry): boolean {\r\n    return entry.expiresAt ? entry.expiresAt <= new Date() : false;\r\n  }\r\n\r\n  private async validateAccess(\r\n    agent: AgentId,\r\n    operation: 'read' | 'write' | 'delete' | 'share',\r\n    partition?: string,\r\n  ): Promise<void> {\r\n    // Implement access control logic here\r\n    // For now, allow all operations\r\n    return;\r\n  }\r\n\r\n  private async getOrCreatePartition(name: string): Promise<MemoryPartition> {\r\n    let partition = this.partitions.get(name);\r\n    if (!partition) {\r\n      await this.createPartition(name, {}, !this.isInitialized);\r\n      partition = this.partitions.get(name)!;\r\n    }\r\n    return partition;\r\n  }\r\n\r\n  private async serializeValue(value: any): Promise<any> {\r\n    // Apply compression and encryption if enabled\r\n    let serialized = JSON.stringify(value);\r\n\r\n    if (this.config.enableCompression) {\r\n      // Compression would be implemented here\r\n      // For now, just return the serialized value\r\n    }\r\n\r\n    if (this.config.enableEncryption) {\r\n      serialized = await this.encryption.encrypt(serialized);\r\n    }\r\n\r\n    return serialized;\r\n  }\r\n\r\n  private async deserializeValue(value: any): Promise<any> {\r\n    let deserialized = value;\r\n\r\n    if (this.config.enableEncryption) {\r\n      deserialized = await this.encryption.decrypt(deserialized);\r\n    }\r\n\r\n    if (this.config.enableCompression) {\r\n      // Decompression would be implemented here\r\n      // For now, just use the deserialized value\r\n    }\r\n\r\n    return JSON.parse(deserialized);\r\n  }\r\n\r\n  private calculateEntrySize(entry: MemoryEntry): number {\r\n    return JSON.stringify(entry).length;\r\n  }\r\n\r\n  private async enforceMemoryLimits(newEntrySize: number): Promise<void> {\r\n    const stats = this.getStatistics();\r\n    const projectedSize = stats.totalSize + newEntrySize;\r\n\r\n    if (projectedSize > this.config.maxMemorySize) {\r\n      // Remove expired entries first\r\n      await this.cleanupExpiredEntries();\r\n\r\n      // If still over limit, remove oldest entries\r\n      const updatedStats = this.getStatistics();\r\n      if (updatedStats.totalSize + newEntrySize > this.config.maxMemorySize) {\r\n        await this.evictOldEntries(newEntrySize);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async cleanupExpiredEntries(): Promise<void> {\r\n    const expiredEntries = Array.from(this.entries.values()).filter((e) => this.isExpired(e));\r\n\r\n    for (const entry of expiredEntries) {\r\n      await this.deleteEntry(entry.id);\r\n    }\r\n\r\n    if (expiredEntries.length > 0) {\r\n      this.logger.info('Cleaned up expired entries', { count: expiredEntries.length });\r\n    }\r\n  }\r\n\r\n  private async evictOldEntries(requiredSpace: number): Promise<void> {\r\n    const entries = Array.from(this.entries.values())\r\n      .filter((e) => !this.isExpired(e))\r\n      .sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\r\n\r\n    let freedSpace = 0;\r\n    let evictedCount = 0;\r\n\r\n    for (const entry of entries) {\r\n      if (freedSpace >= requiredSpace) {\r\n        break;\r\n      }\r\n\r\n      if (entry.accessLevel !== 'system') {\r\n        // Don't evict system entries\r\n        const entrySize = this.calculateEntrySize(entry);\r\n        await this.deleteEntry(entry.id);\r\n        freedSpace += entrySize;\r\n        evictedCount++;\r\n      }\r\n    }\r\n\r\n    this.logger.warn('Evicted old entries for space', {\r\n      evictedCount,\r\n      freedSpace,\r\n      requiredSpace,\r\n    });\r\n  }\r\n\r\n  private calculateChecksum(backup: MemoryBackup): string {\r\n    const content = JSON.stringify({\r\n      entries: backup.entries,\r\n      partitions: backup.partitions,\r\n    });\r\n    return crypto.createHash('sha256').update(content).digest('hex');\r\n  }\r\n\r\n  private entriesToCSV(entries: MemoryEntry[]): string {\r\n    const headers = ['id', 'key', 'type', 'accessLevel', 'createdAt', 'updatedAt', 'owner', 'tags'];\r\n    const rows = entries.map((entry) => [\r\n      entry.id,\r\n      entry.key,\r\n      entry.type,\r\n      entry.accessLevel,\r\n      entry.createdAt.toISOString(),\r\n      entry.updatedAt.toISOString(),\r\n      entry.owner.id,\r\n      entry.tags.join(';'),\r\n    ]);\r\n\r\n    return [headers, ...rows].map((row) => row.join(',')).join('\\n');\r\n  }\r\n\r\n  private async loadMemoryState(): Promise<void> {\r\n    try {\r\n      const state = await this.persistence.loadState();\r\n      if (state) {\r\n        // Load entries\r\n        for (const entry of state.entries || []) {\r\n          this.entries.set(entry.id, entry);\r\n          await this.index.addEntry(entry);\r\n        }\r\n\r\n        // Load partitions\r\n        for (const partition of state.partitions || []) {\r\n          this.partitions.set(partition.name, partition);\r\n        }\r\n\r\n        this.memory.partitions = state.partitions || [];\r\n\r\n        this.logger.info('Loaded memory state', {\r\n          entries: this.entries.size,\r\n          partitions: this.partitions.size,\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to load memory state', { error });\r\n    }\r\n  }\r\n\r\n  private async saveMemoryState(): Promise<void> {\r\n    try {\r\n      const state = {\r\n        namespace: this.config.namespace,\r\n        timestamp: new Date(),\r\n        entries: Array.from(this.entries.values()),\r\n        partitions: Array.from(this.partitions.values()),\r\n      };\r\n\r\n      await this.persistence.saveState(state);\r\n    } catch (error) {\r\n      this.logger.error('Failed to save memory state', { error });\r\n    }\r\n  }\r\n\r\n  private async createDefaultPartitions(): Promise<void> {\r\n    const defaultPartitions = [\r\n      { name: 'default', type: 'knowledge' as MemoryType },\r\n      { name: 'system', type: 'configuration' as MemoryType },\r\n      { name: 'cache', type: 'cache' as MemoryType },\r\n      { name: 'logs', type: 'logs' as MemoryType },\r\n    ];\r\n\r\n    for (const partition of defaultPartitions) {\r\n      if (!this.partitions.has(partition.name)) {\r\n        await this.createPartition(partition.name, { type: partition.type }, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  private mergeWithDefaults(config: Partial<MemoryConfig>): MemoryConfig {\r\n    return {\r\n      namespace: 'default',\r\n      persistencePath: './swarm-memory',\r\n      maxMemorySize: 100 * 1024 * 1024, // 100MB\r\n      maxEntrySize: 10 * 1024 * 1024, // 10MB\r\n      defaultTtl: 24 * 60 * 60 * 1000, // 24 hours\r\n      enableCompression: false,\r\n      enableEncryption: false,\r\n      consistencyLevel: 'eventual',\r\n      syncInterval: 60000, // 1 minute\r\n      backupInterval: 3600000, // 1 hour\r\n      maxBackups: 24,\r\n      enableDistribution: false,\r\n      distributionNodes: [],\r\n      replicationFactor: 1,\r\n      enableCaching: true,\r\n      cacheSize: 1000,\r\n      cacheTtl: 300000, // 5 minutes\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  private startBackgroundProcesses(): void {\r\n    // Sync process\r\n    if (this.config.syncInterval > 0) {\r\n      this.syncTimer = setInterval(() => {\r\n        this.performSync();\r\n      }, this.config.syncInterval);\r\n    }\r\n\r\n    // Backup process\r\n    if (this.config.backupInterval > 0) {\r\n      this.backupTimer = setInterval(() => {\r\n        this.createBackup().catch((error) => {\r\n          this.logger.error('Background backup failed', { error });\r\n        });\r\n      }, this.config.backupInterval);\r\n    }\r\n\r\n    // Cleanup process\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupExpiredEntries();\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  private stopBackgroundProcesses(): void {\r\n    if (this.syncTimer) {\r\n      clearInterval(this.syncTimer);\r\n      this.syncTimer = undefined;\r\n    }\r\n\r\n    if (this.backupTimer) {\r\n      clearInterval(this.backupTimer);\r\n      this.backupTimer = undefined;\r\n    }\r\n\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = undefined;\r\n    }\r\n  }\r\n\r\n  private async performSync(): Promise<void> {\r\n    try {\r\n      await this.saveMemoryState();\r\n\r\n      if (this.config.enableDistribution) {\r\n        await this.replication.sync();\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Background sync failed', { error });\r\n    }\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    // Handle replication events\r\n    this.replication.on('entry-received', async (data: any) => {\r\n      const entry = data.entry as MemoryEntry;\r\n      this.entries.set(entry.id, entry);\r\n      await this.index.addEntry(entry);\r\n\r\n      this.emit('memory:replicated', {\r\n        entryId: entry.id,\r\n        key: entry.key,\r\n        source: data.source,\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n// ===== SUPPORTING CLASSES =====\r\n\r\nclass MemoryIndex {\r\n  private index: Map<string, Set<string>> = new Map();\r\n\r\n  async initialize(): Promise<void> {\r\n    // Initialize search index\r\n  }\r\n\r\n  async addEntry(entry: MemoryEntry): Promise<void> {\r\n    // Add entry to search index\r\n    this.indexTerms(entry.id, [entry.key, ...entry.tags, entry.type]);\r\n  }\r\n\r\n  async updateEntry(entry: MemoryEntry): Promise<void> {\r\n    await this.removeEntry(entry.id);\r\n    await this.addEntry(entry);\r\n  }\r\n\r\n  async removeEntry(entryId: string): Promise<void> {\r\n    // Remove from all index terms\r\n    for (const termSet of this.index.values()) {\r\n      termSet.delete(entryId);\r\n    }\r\n  }\r\n\r\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\r\n    // Implement search logic\r\n    return [];\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    this.index.clear();\r\n  }\r\n\r\n  private indexTerms(entryId: string, terms: string[]): void {\r\n    for (const term of terms) {\r\n      const normalizedTerm = term.toLowerCase();\r\n      if (!this.index.has(normalizedTerm)) {\r\n        this.index.set(normalizedTerm, new Set());\r\n      }\r\n      this.index.get(normalizedTerm)!.add(entryId);\r\n    }\r\n  }\r\n}\r\n\r\nclass MemoryCache {\r\n  private cache: Map<string, { entry: MemoryEntry; expiry: number }> = new Map();\r\n  private maxSize: number;\r\n  private ttl: number;\r\n\r\n  constructor(maxSize: number, ttl: number) {\r\n    this.maxSize = maxSize;\r\n    this.ttl = ttl;\r\n  }\r\n\r\n  set(key: string, entry: MemoryEntry): void {\r\n    // Evict if at capacity\r\n    if (this.cache.size >= this.maxSize) {\r\n      const oldestKey = this.cache.keys().next().value;\r\n      this.cache.delete(oldestKey);\r\n    }\r\n\r\n    this.cache.set(key, {\r\n      entry,\r\n      expiry: Date.now() + this.ttl,\r\n    });\r\n  }\r\n\r\n  get(key: string): MemoryEntry | null {\r\n    const cached = this.cache.get(key);\r\n    if (!cached) {\r\n      return null;\r\n    }\r\n\r\n    if (Date.now() > cached.expiry) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return cached.entry;\r\n  }\r\n\r\n  delete(key: string): void {\r\n    this.cache.delete(key);\r\n  }\r\n}\r\n\r\nclass MemoryReplication extends EventEmitter {\r\n  private config: MemoryConfig;\r\n\r\n  constructor(config: MemoryConfig) {\r\n    super();\r\n    this.config = config;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    // Initialize replication\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    // Shutdown replication\r\n  }\r\n\r\n  async replicate(entry: MemoryEntry): Promise<void> {\r\n    // Replicate entry to other nodes\r\n  }\r\n\r\n  async synchronizeWith(targetNode: string, options: any): Promise<void> {\r\n    // Synchronize with target node\r\n  }\r\n\r\n  async sync(): Promise<void> {\r\n    // Perform background sync\r\n  }\r\n}\r\n\r\nclass MemoryPersistence {\r\n  private config: MemoryConfig;\r\n\r\n  constructor(config: MemoryConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    await fs.mkdir(this.config.persistencePath, { recursive: true });\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    // Shutdown persistence\r\n  }\r\n\r\n  async saveState(state: any): Promise<void> {\r\n    const statePath = path.join(this.config.persistencePath, 'state.json');\r\n    await fs.writeFile(statePath, JSON.stringify(state, null, 2));\r\n  }\r\n\r\n  async loadState(): Promise<any> {\r\n    try {\r\n      const statePath = path.join(this.config.persistencePath, 'state.json');\r\n      const content = await fs.readFile(statePath, 'utf-8');\r\n      return JSON.parse(content);\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async saveBackup(backupId: string, backup: MemoryBackup): Promise<void> {\r\n    const backupPath = path.join(this.config.persistencePath, 'backups', `${backupId}.json`);\r\n    await fs.mkdir(path.dirname(backupPath), { recursive: true });\r\n    await fs.writeFile(backupPath, JSON.stringify(backup, null, 2));\r\n  }\r\n\r\n  async loadBackup(backupId: string): Promise<MemoryBackup | null> {\r\n    try {\r\n      const backupPath = path.join(this.config.persistencePath, 'backups', `${backupId}.json`);\r\n      const content = await fs.readFile(backupPath, 'utf-8');\r\n      return JSON.parse(content);\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nclass MemoryEncryption {\r\n  private config: MemoryConfig;\r\n\r\n  constructor(config: MemoryConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    // Initialize encryption\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    // Shutdown encryption\r\n  }\r\n\r\n  async encrypt(data: string): Promise<string> {\r\n    // Implement encryption\r\n    return data;\r\n  }\r\n\r\n  async decrypt(data: string): Promise<string> {\r\n    // Implement decryption\r\n    return data;\r\n  }\r\n}\r\n\r\nexport default SwarmMemoryManager;\r\n"],"names":["EventEmitter","fs","path","crypto","Logger","generateId","SwarmMemoryManager","logger","config","memory","partitions","Map","entries","index","cache","replication","persistence","encryption","isInitialized","syncTimer","backupTimer","cleanupTimer","logLevel","logging","level","logFormat","format","logDestination","destination","component","mergeWithDefaults","namespace","permissions","read","write","delete","share","persistent","backupEnabled","distributed","enableDistribution","consistency","consistencyLevel","cacheEnabled","enableCaching","compressionEnabled","enableCompression","MemoryIndex","MemoryCache","cacheSize","cacheTtl","MemoryReplication","MemoryPersistence","MemoryEncryption","setupEventHandlers","initialize","info","loadMemoryState","createDefaultPartitions","startBackgroundProcesses","emit","entriesLoaded","size","partitionsLoaded","error","shutdown","stopBackgroundProcesses","saveMemoryState","store","key","value","options","ensureInitialized","entryId","now","Date","owner","validateAccess","partition","partitionName","getOrCreatePartition","entry","id","serializeValue","type","tags","swarmId","instance","accessLevel","createdAt","updatedAt","expiresAt","ttl","getTime","undefined","version","references","dependencies","entrySize","calculateEntrySize","maxEntrySize","Error","enforceMemoryLimits","set","push","addEntry","replicate","debug","retrieve","cached","get","isExpired","requester","includeMetadata","deserializeValue","findEntry","deleteEntry","update","updater","incrementVersion","previousVersions","length","slice","updateEntry","deleter","force","query","results","Array","from","values","entryIds","Set","map","e","filter","has","some","tag","includes","createdAfter","createdBefore","expiresAfter","sortBy","sort","a","b","compareValue","localeCompare","sortOrder","offset","limit","search","shareMemory","targetAgent","sharer","sharedEntryId","sharedEntry","targetPartition","originalId","sharedId","target","to","broadcastMemory","targetAgents","sharedIds","broadcaster","warn","message","String","targets","sharedCount","synchronizeWith","targetNode","direction","createPartition","name","skipInitCheck","maxSize","maxMemorySize","readOnly","shared","indexed","compressed","partitionId","deletePartition","p","getPartition","getPartitions","createBackup","backup","timestamp","checksum","metadata","entryCount","partitionCount","calculateChecksum","backupId","saveBackup","JSON","stringify","restoreFromBackup","loadBackup","calculatedChecksum","clear","getStatistics","validEntries","entriesByType","knowledge","state","logs","communication","configuration","metrics","entriesByAccess","private","team","swarm","public","system","totalSize","oldestEntry","newestEntry","expiringEntries","totalEntries","averageSize","exportMemory","includeExpired","filteredResults","filteredIds","entriesToCSV","exported","toISOString","part","find","removeEntry","agent","operation","serialized","enableEncryption","encrypt","deserialized","decrypt","parse","newEntrySize","stats","projectedSize","cleanupExpiredEntries","updatedStats","evictOldEntries","expiredEntries","count","requiredSpace","freedSpace","evictedCount","content","createHash","digest","headers","rows","join","row","loadState","saveState","defaultPartitions","persistencePath","defaultTtl","syncInterval","backupInterval","maxBackups","distributionNodes","replicationFactor","setInterval","performSync","catch","clearInterval","sync","on","data","source","indexTerms","termSet","terms","term","normalizedTerm","toLowerCase","add","oldestKey","keys","next","expiry","mkdir","recursive","statePath","writeFile","readFile","backupPath","dirname"],"mappings":"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"}