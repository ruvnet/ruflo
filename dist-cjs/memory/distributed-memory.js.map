{
  "version": 3,
  "sources": ["../../src/memory/distributed-memory.ts"],
  "sourcesContent": ["/**\n * Distributed memory system with sharing capabilities\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  SwarmMemory,\n  MemoryPartition,\n  MemoryEntry,\n  MemoryType,\n  AccessLevel,\n  ConsistencyLevel,\n  MemoryPermissions,\n  AgentId,\n} from '../swarm/types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface DistributedMemoryConfig {\n  namespace: string;\n  distributed: boolean;\n  consistency: ConsistencyLevel;\n  replicationFactor: number;\n  syncInterval: number;\n  maxMemorySize: number;\n  compressionEnabled: boolean;\n  encryptionEnabled: boolean;\n  backupEnabled: boolean;\n  persistenceEnabled: boolean;\n  shardingEnabled: boolean;\n  cacheSize: number;\n  cacheTtl: number;\n  backend?: string;\n  timeout?: number;\n  retryAttempts?: number;\n}\n\nexport interface MemoryNode {\n  id: string;\n  address: string;\n  port: number;\n  status: 'online' | 'offline' | 'syncing' | 'failed';\n  lastSeen: Date;\n  partitions: string[];\n  load: number;\n  capacity: number;\n}\n\nexport interface SyncOperation {\n  id: string;\n  type: 'create' | 'update' | 'delete' | 'batch';\n  partition: string;\n  entry?: MemoryEntry;\n  entries?: MemoryEntry[];\n  timestamp: Date;\n  version: number;\n  origin: string;\n  targets: string[];\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n}\n\nexport interface MemoryQuery {\n  namespace?: string;\n  partition?: string;\n  type?: MemoryType;\n  tags?: string[];\n  owner?: AgentId;\n  accessLevel?: AccessLevel;\n  createdAfter?: Date;\n  updatedAfter?: Date;\n  limit?: number;\n  offset?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface MemoryStatistics {\n  totalEntries: number;\n  totalSize: number;\n  partitionCount: number;\n  nodeCount: number;\n  replicationHealth: number;\n  syncOperations: {\n    pending: number;\n    completed: number;\n    failed: number;\n  };\n  performance: {\n    readLatency: number;\n    writeLatency: number;\n    syncLatency: number;\n    throughput: number;\n  };\n  utilization: {\n    memoryUsage: number;\n    diskUsage: number;\n    networkUsage: number;\n  };\n}\n\n/**\n * Distributed memory system for sharing data across swarm agents\n */\nexport class DistributedMemorySystem extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: DistributedMemoryConfig;\n\n  // Storage\n  private partitions = new Map<string, MemoryPartition>();\n  private entries = new Map<string, MemoryEntry>();\n  private cache = new Map<string, { entry: MemoryEntry; expiry: number }>();\n\n  // Distribution\n  private nodes = new Map<string, MemoryNode>();\n  private localNodeId: string;\n  private syncQueue: SyncOperation[] = [];\n  private replicationMap = new Map<string, string[]>(); // entryId -> nodeIds\n\n  // Synchronization\n  private syncInterval?: NodeJS.Timeout;\n  private vectorClock = new Map<string, number>();\n  private conflictResolver?: (local: MemoryEntry, remote: MemoryEntry) => MemoryEntry;\n\n  // Performance tracking\n  private statistics: MemoryStatistics;\n  private operationMetrics = new Map<string, { count: number; totalTime: number }>();\n\n  constructor(config: Partial<DistributedMemoryConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      namespace: 'default',\n      distributed: true,\n      consistency: 'eventual',\n      replicationFactor: 3,\n      syncInterval: 5000,\n      maxMemorySize: 1024 * 1024 * 1024, // 1GB\n      compressionEnabled: true,\n      encryptionEnabled: false,\n      backupEnabled: true,\n      persistenceEnabled: true,\n      shardingEnabled: true,\n      cacheSize: 10000,\n      cacheTtl: 300000, // 5 minutes\n      ...config,\n    };\n\n    this.localNodeId = generateId('memory-node');\n    this.statistics = this.initializeStatistics();\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('memory:sync-request', (data) => {\n      this.handleSyncRequest(data);\n    });\n\n    this.eventBus.on('memory:node-joined', (data) => {\n      this.handleNodeJoined(data);\n    });\n\n    this.eventBus.on('memory:node-left', (data) => {\n      this.handleNodeLeft(data);\n    });\n\n    this.eventBus.on('memory:conflict-detected', (data) => {\n      this.handleConflict(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing distributed memory system', {\n      nodeId: this.localNodeId,\n      namespace: this.config.namespace,\n      distributed: this.config.distributed,\n    });\n\n    // Register local node\n    const localNode: MemoryNode = {\n      id: this.localNodeId,\n      address: 'localhost',\n      port: 8080,\n      status: 'online',\n      lastSeen: new Date(),\n      partitions: [],\n      load: 0,\n      capacity: this.config.maxMemorySize,\n    };\n\n    this.nodes.set(this.localNodeId, localNode);\n\n    // Initialize default partitions\n    await this.createPartition('knowledge', 'knowledge');\n    await this.createPartition('state', 'state');\n    await this.createPartition('cache', 'cache');\n    await this.createPartition('results', 'results');\n\n    // Start synchronization if distributed\n    if (this.config.distributed) {\n      this.startSynchronization();\n    }\n\n    // Load persisted data if enabled\n    if (this.config.persistenceEnabled) {\n      await this.loadPersistedData();\n    }\n\n    this.emit('memory:initialized', { nodeId: this.localNodeId });\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down distributed memory system');\n\n    // Stop synchronization\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n    }\n\n    // Complete pending sync operations\n    await this.completePendingSyncOperations();\n\n    // Persist data if enabled\n    if (this.config.persistenceEnabled) {\n      await this.persistData();\n    }\n\n    // Clear caches\n    this.cache.clear();\n    this.partitions.clear();\n    this.entries.clear();\n\n    this.emit('memory:shutdown', { nodeId: this.localNodeId });\n  }\n\n  // === PARTITION MANAGEMENT ===\n\n  async createPartition(\n    name: string,\n    type: MemoryType,\n    options: {\n      maxSize?: number;\n      ttl?: number;\n      readOnly?: boolean;\n      shared?: boolean;\n      indexed?: boolean;\n      compressed?: boolean;\n    } = {},\n  ): Promise<string> {\n    const partitionId = generateId('partition');\n\n    const partition: MemoryPartition = {\n      id: partitionId,\n      name,\n      type,\n      entries: [],\n      maxSize: options.maxSize || this.config.maxMemorySize / 10,\n      ttl: options.ttl,\n      readOnly: options.readOnly || false,\n      shared: options.shared !== false, // Default to shared\n      indexed: options.indexed || false,\n      compressed: options.compressed || this.config.compressionEnabled,\n    };\n\n    this.partitions.set(partitionId, partition);\n\n    // Update local node partition list\n    const localNode = this.nodes.get(this.localNodeId)!;\n    localNode.partitions.push(partitionId);\n\n    this.logger.info('Created partition', { partitionId, name, type });\n    this.emit('memory:partition-created', { partition });\n\n    // Sync with other nodes if distributed\n    if (this.config.distributed) {\n      await this.syncPartitionCreation(partition);\n    }\n\n    return partitionId;\n  }\n\n  async deletePartition(partitionId: string): Promise<void> {\n    const partition = this.partitions.get(partitionId);\n    if (!partition) {\n      throw new Error(`Partition ${partitionId} not found`);\n    }\n\n    // Delete all entries in partition\n    const entriesToDelete = Array.from(this.entries.values()).filter(\n      (entry) => this.getEntryPartition(entry.id) === partitionId,\n    );\n\n    for (const entry of entriesToDelete) {\n      await this.deleteEntry(entry.id);\n    }\n\n    // Remove partition\n    this.partitions.delete(partitionId);\n\n    // Update local node\n    const localNode = this.nodes.get(this.localNodeId)!;\n    localNode.partitions = localNode.partitions.filter((p) => p !== partitionId);\n\n    this.logger.info('Deleted partition', { partitionId });\n    this.emit('memory:partition-deleted', { partitionId });\n\n    // Sync with other nodes if distributed\n    if (this.config.distributed) {\n      await this.syncPartitionDeletion(partitionId);\n    }\n  }\n\n  // === ENTRY OPERATIONS ===\n\n  async store(\n    key: string,\n    value: any,\n    options: {\n      type?: string;\n      tags?: string[];\n      owner?: AgentId;\n      accessLevel?: AccessLevel;\n      partition?: string;\n      ttl?: number;\n      replicate?: boolean;\n    } = {},\n  ): Promise<string> {\n    const startTime = Date.now();\n\n    try {\n      const entryId = generateId('entry');\n      const now = new Date();\n\n      // Determine partition\n      const partitionId = options.partition || this.selectPartition(options.type || 'knowledge');\n      const partition = this.partitions.get(partitionId);\n\n      if (!partition) {\n        throw new Error(`Partition ${partitionId} not found`);\n      }\n\n      if (partition.readOnly) {\n        throw new Error('Cannot write to read-only partition');\n      }\n\n      // Check partition capacity\n      if (this.getPartitionSize(partitionId) >= partition.maxSize) {\n        await this.evictOldEntries(partitionId);\n      }\n\n      // Create entry\n      const entry: MemoryEntry = {\n        id: entryId,\n        key,\n        value: await this.processValue(value, partition),\n        type: options.type || 'data',\n        tags: options.tags || [],\n        owner: options.owner || { id: 'system', swarmId: '', type: 'coordinator', instance: 0 },\n        accessLevel: options.accessLevel || 'swarm',\n        createdAt: now,\n        updatedAt: now,\n        expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n        version: 1,\n        references: [],\n        dependencies: [],\n      };\n\n      // Store entry\n      this.entries.set(entryId, entry);\n      partition.entries.push(entry);\n\n      // Update cache\n      this.updateCache(entryId, entry);\n\n      // Update vector clock\n      this.incrementVectorClock(this.localNodeId);\n\n      this.logger.debug('Stored entry', { entryId, key, partition: partitionId });\n      this.emit('memory:entry-stored', { entry });\n\n      // Replicate if distributed and requested\n      if (this.config.distributed && options.replicate !== false) {\n        await this.replicateEntry(entry);\n      }\n\n      this.recordMetric('store', Date.now() - startTime);\n      return entryId;\n    } catch (error) {\n      this.recordMetric('store-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async retrieve(\n    key: string,\n    options: {\n      partition?: string;\n      consistency?: ConsistencyLevel;\n      maxAge?: number;\n    } = {},\n  ): Promise<MemoryEntry | null> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const cached = this.getCachedEntry(key);\n      if (cached && this.isCacheValid(cached)) {\n        this.recordMetric('retrieve-cache', Date.now() - startTime);\n        return cached.entry;\n      }\n\n      // Search in specified partition or all partitions\n      const partitions = options.partition\n        ? [this.partitions.get(options.partition)].filter(Boolean)\n        : Array.from(this.partitions.values());\n\n      for (const partition of partitions) {\n        const entry = partition!.entries.find((e) => e.key === key);\n        if (entry) {\n          // Check if entry is expired\n          if (entry.expiresAt && entry.expiresAt < new Date()) {\n            await this.deleteEntry(entry.id);\n            continue;\n          }\n\n          // Check access permissions\n          if (!this.checkAccess(entry, 'read')) {\n            continue;\n          }\n\n          // Apply consistency model\n          if (this.config.distributed && options.consistency === 'strong') {\n            const latestEntry = await this.ensureConsistency(entry);\n            this.updateCache(latestEntry.id, latestEntry);\n            this.recordMetric('retrieve', Date.now() - startTime);\n            return latestEntry;\n          }\n\n          this.updateCache(entry.id, entry);\n          this.recordMetric('retrieve', Date.now() - startTime);\n          return entry;\n        }\n      }\n\n      // Not found locally, try remote nodes if distributed\n      if (this.config.distributed) {\n        const remoteEntry = await this.retrieveFromRemote(key, options);\n        if (remoteEntry) {\n          this.recordMetric('retrieve-remote', Date.now() - startTime);\n          return remoteEntry;\n        }\n      }\n\n      this.recordMetric('retrieve-miss', Date.now() - startTime);\n      return null;\n    } catch (error) {\n      this.recordMetric('retrieve-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async update(\n    key: string,\n    value: any,\n    options: {\n      partition?: string;\n      merge?: boolean;\n      version?: number;\n    } = {},\n  ): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = await this.retrieve(key, { partition: options.partition });\n      if (!entry) {\n        this.recordMetric('update-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Check access permissions\n      if (!this.checkAccess(entry, 'write')) {\n        throw new Error('Access denied for update operation');\n      }\n\n      // Version check for optimistic locking\n      if (options.version && entry.version !== options.version) {\n        throw new Error('Version conflict: entry has been modified');\n      }\n\n      // Update entry\n      const partition = this.partitions.get(this.getEntryPartition(entry.id))!;\n\n      entry.value = options.merge\n        ? await this.mergeValues(entry.value, value, partition)\n        : await this.processValue(value, partition);\n\n      entry.updatedAt = new Date();\n      entry.version++;\n\n      // Update cache\n      this.updateCache(entry.id, entry);\n\n      // Update vector clock\n      this.incrementVectorClock(this.localNodeId);\n\n      this.logger.debug('Updated entry', { entryId: entry.id, key });\n      this.emit('memory:entry-updated', { entry });\n\n      // Sync with other nodes if distributed\n      if (this.config.distributed) {\n        await this.syncEntryUpdate(entry);\n      }\n\n      this.recordMetric('update', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('update-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async deleteEntry(entryId: string): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = this.entries.get(entryId);\n      if (!entry) {\n        this.recordMetric('delete-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Check access permissions\n      if (!this.checkAccess(entry, 'delete')) {\n        throw new Error('Access denied for delete operation');\n      }\n\n      // Remove from partition\n      const partitionId = this.getEntryPartition(entryId);\n      const partition = this.partitions.get(partitionId);\n      if (partition) {\n        partition.entries = partition.entries.filter((e) => e.id !== entryId);\n      }\n\n      // Remove from storage\n      this.entries.delete(entryId);\n\n      // Remove from cache\n      this.removeFromCache(entry.key);\n\n      // Update vector clock\n      this.incrementVectorClock(this.localNodeId);\n\n      this.logger.debug('Deleted entry', { entryId, key: entry.key });\n      this.emit('memory:entry-deleted', { entryId });\n\n      // Sync with other nodes if distributed\n      if (this.config.distributed) {\n        await this.syncEntryDeletion(entryId);\n      }\n\n      this.recordMetric('delete', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('delete-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === QUERY OPERATIONS ===\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    const startTime = Date.now();\n\n    try {\n      let results: MemoryEntry[] = [];\n\n      // Get relevant partitions\n      const partitions = query.partition\n        ? [this.partitions.get(query.partition)].filter(Boolean)\n        : Array.from(this.partitions.values());\n\n      for (const partition of partitions) {\n        for (const entry of partition!.entries) {\n          if (this.matchesQuery(entry, query)) {\n            results.push(entry);\n          }\n        }\n      }\n\n      // Apply sorting\n      if (query.sortBy) {\n        results.sort((a, b) => {\n          const aVal = this.getNestedProperty(a, query.sortBy!);\n          const bVal = this.getNestedProperty(b, query.sortBy!);\n          const order = query.sortOrder === 'desc' ? -1 : 1;\n\n          if (aVal < bVal) return -1 * order;\n          if (aVal > bVal) return 1 * order;\n          return 0;\n        });\n      }\n\n      // Apply pagination\n      const offset = query.offset || 0;\n      const limit = query.limit || results.length;\n      results = results.slice(offset, offset + limit);\n\n      this.recordMetric('query', Date.now() - startTime);\n      return results;\n    } catch (error) {\n      this.recordMetric('query-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  /**\n   * Query entries by type\n   */\n  async queryByType(type: string, namespace?: string): Promise<MemoryEntry[]> {\n    return this.query({\n      filter: { type },\n      namespace,\n    });\n  }\n\n  // === SYNCHRONIZATION ===\n\n  private startSynchronization(): void {\n    this.syncInterval = setInterval(() => {\n      this.performSync();\n    }, this.config.syncInterval);\n\n    this.logger.info('Started synchronization', {\n      interval: this.config.syncInterval,\n      consistency: this.config.consistency,\n    });\n  }\n\n  private async performSync(): Promise<void> {\n    try {\n      // Process pending sync operations\n      await this.processSyncQueue();\n\n      // Send heartbeat to other nodes\n      await this.sendHeartbeat();\n\n      // Check for conflicts and resolve them\n      await this.detectAndResolveConflicts();\n\n      // Update statistics\n      this.updateStatistics();\n    } catch (error) {\n      this.logger.error('Sync error', error);\n    }\n  }\n\n  private async processSyncQueue(): Promise<void> {\n    const pendingOps = this.syncQueue.filter((op) => op.status === 'pending');\n\n    for (const operation of pendingOps) {\n      try {\n        operation.status = 'in_progress';\n        await this.executeSyncOperation(operation);\n        operation.status = 'completed';\n\n        this.statistics.syncOperations.completed++;\n      } catch (error) {\n        operation.status = 'failed';\n        this.statistics.syncOperations.failed++;\n        this.logger.error('Sync operation failed', { operation, error });\n      }\n    }\n\n    // Remove completed/failed operations older than 1 hour\n    const cutoff = new Date(Date.now() - 3600000);\n    this.syncQueue = this.syncQueue.filter(\n      (op) => op.status === 'pending' || op.timestamp > cutoff,\n    );\n  }\n\n  // === UTILITY METHODS ===\n\n  private async processValue(value: any, partition: MemoryPartition): Promise<any> {\n    if (partition.compressed && this.config.compressionEnabled) {\n      return this.compressValue(value);\n    }\n    return value;\n  }\n\n  private async mergeValues(\n    oldValue: any,\n    newValue: any,\n    partition: MemoryPartition,\n  ): Promise<any> {\n    // Simple merge strategy - can be enhanced\n    if (typeof oldValue === 'object' && typeof newValue === 'object') {\n      return { ...oldValue, ...newValue };\n    }\n    return newValue;\n  }\n\n  private compressValue(value: any): any {\n    // Placeholder for compression logic\n    return value;\n  }\n\n  private checkAccess(entry: MemoryEntry, operation: 'read' | 'write' | 'delete'): boolean {\n    // Simplified access control - can be enhanced\n    return true;\n  }\n\n  private selectPartition(type: string): string {\n    // Simple partition selection based on type\n    for (const [id, partition] of this.partitions) {\n      if (partition.type === type) {\n        return id;\n      }\n    }\n\n    // Default to first available partition\n    return Array.from(this.partitions.keys())[0] || '';\n  }\n\n  private getPartitionSize(partitionId: string): number {\n    const partition = this.partitions.get(partitionId);\n    if (!partition) return 0;\n\n    return partition.entries.reduce((size, entry) => {\n      return size + JSON.stringify(entry).length;\n    }, 0);\n  }\n\n  private getEntryPartition(entryId: string): string {\n    for (const [partitionId, partition] of this.partitions) {\n      if (partition.entries.some((e) => e.id === entryId)) {\n        return partitionId;\n      }\n    }\n    return '';\n  }\n\n  private updateCache(entryId: string, entry: MemoryEntry): void {\n    if (this.cache.size >= this.config.cacheSize) {\n      this.evictCache();\n    }\n\n    this.cache.set(entry.key, {\n      entry: { ...entry },\n      expiry: Date.now() + this.config.cacheTtl,\n    });\n  }\n\n  private getCachedEntry(key: string): { entry: MemoryEntry; expiry: number } | null {\n    return this.cache.get(key) || null;\n  }\n\n  private isCacheValid(cached: { entry: MemoryEntry; expiry: number }): boolean {\n    return cached.expiry > Date.now();\n  }\n\n  private removeFromCache(key: string): void {\n    this.cache.delete(key);\n  }\n\n  private evictCache(): void {\n    // Simple LRU eviction - remove oldest entries\n    const entries = Array.from(this.cache.entries());\n    entries.sort((a, b) => a[1].expiry - b[1].expiry);\n\n    const toRemove = entries.slice(0, Math.floor(this.config.cacheSize * 0.1));\n    toRemove.forEach(([key]) => this.cache.delete(key));\n  }\n\n  private async evictOldEntries(partitionId: string): Promise<void> {\n    const partition = this.partitions.get(partitionId);\n    if (!partition) return;\n\n    // Sort by last access time and remove oldest 10%\n    const entries = partition.entries.sort((a, b) => a.updatedAt.getTime() - b.updatedAt.getTime());\n\n    const toRemove = entries.slice(0, Math.floor(entries.length * 0.1));\n    for (const entry of toRemove) {\n      await this.deleteEntry(entry.id);\n    }\n  }\n\n  private matchesQuery(entry: MemoryEntry, query: MemoryQuery): boolean {\n    if (query.type && entry.type !== query.type) return false;\n    if (query.owner && entry.owner.id !== query.owner.id) return false;\n    if (query.accessLevel && entry.accessLevel !== query.accessLevel) return false;\n    if (query.createdAfter && entry.createdAt < query.createdAfter) return false;\n    if (query.updatedAfter && entry.updatedAt < query.updatedAfter) return false;\n\n    if (query.tags && query.tags.length > 0) {\n      const hasAllTags = query.tags.every((tag) => entry.tags.includes(tag));\n      if (!hasAllTags) return false;\n    }\n\n    return true;\n  }\n\n  private getNestedProperty(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n\n  private incrementVectorClock(nodeId: string): void {\n    const current = this.vectorClock.get(nodeId) || 0;\n    this.vectorClock.set(nodeId, current + 1);\n  }\n\n  private recordMetric(operation: string, duration: number): void {\n    const current = this.operationMetrics.get(operation) || { count: 0, totalTime: 0 };\n    current.count++;\n    current.totalTime += duration;\n    this.operationMetrics.set(operation, current);\n  }\n\n  private initializeStatistics(): MemoryStatistics {\n    return {\n      totalEntries: 0,\n      totalSize: 0,\n      partitionCount: 0,\n      nodeCount: 1,\n      replicationHealth: 1.0,\n      syncOperations: {\n        pending: 0,\n        completed: 0,\n        failed: 0,\n      },\n      performance: {\n        readLatency: 0,\n        writeLatency: 0,\n        syncLatency: 0,\n        throughput: 0,\n      },\n      utilization: {\n        memoryUsage: 0,\n        diskUsage: 0,\n        networkUsage: 0,\n      },\n    };\n  }\n\n  private updateStatistics(): void {\n    this.statistics.totalEntries = this.entries.size;\n    this.statistics.partitionCount = this.partitions.size;\n    this.statistics.nodeCount = this.nodes.size;\n\n    // Calculate performance metrics\n    const readMetrics = this.operationMetrics.get('retrieve') || { count: 0, totalTime: 0 };\n    const writeMetrics = this.operationMetrics.get('store') || { count: 0, totalTime: 0 };\n\n    this.statistics.performance.readLatency =\n      readMetrics.count > 0 ? readMetrics.totalTime / readMetrics.count : 0;\n    this.statistics.performance.writeLatency =\n      writeMetrics.count > 0 ? writeMetrics.totalTime / writeMetrics.count : 0;\n  }\n\n  // === DISTRIBUTED OPERATIONS (Placeholders) ===\n\n  private async replicateEntry(entry: MemoryEntry): Promise<void> {\n    // Implementation for replication to other nodes\n  }\n\n  private async syncPartitionCreation(partition: MemoryPartition): Promise<void> {\n    // Implementation for syncing partition creation\n  }\n\n  private async syncPartitionDeletion(partitionId: string): Promise<void> {\n    // Implementation for syncing partition deletion\n  }\n\n  private async syncEntryUpdate(entry: MemoryEntry): Promise<void> {\n    // Implementation for syncing entry updates\n  }\n\n  private async syncEntryDeletion(entryId: string): Promise<void> {\n    // Implementation for syncing entry deletion\n  }\n\n  private async retrieveFromRemote(key: string, options: any): Promise<MemoryEntry | null> {\n    // Implementation for retrieving from remote nodes\n    return null;\n  }\n\n  private async ensureConsistency(entry: MemoryEntry): Promise<MemoryEntry> {\n    // Implementation for ensuring strong consistency\n    return entry;\n  }\n\n  private async sendHeartbeat(): Promise<void> {\n    // Implementation for sending heartbeat to other nodes\n  }\n\n  private async detectAndResolveConflicts(): Promise<void> {\n    // Implementation for conflict detection and resolution\n  }\n\n  private async executeSyncOperation(operation: SyncOperation): Promise<void> {\n    // Implementation for executing sync operations\n  }\n\n  private async completePendingSyncOperations(): Promise<void> {\n    // Implementation for completing pending operations\n  }\n\n  private async loadPersistedData(): Promise<void> {\n    // Implementation for loading persisted data\n  }\n\n  private async persistData(): Promise<void> {\n    // Implementation for persisting data\n  }\n\n  private handleSyncRequest(data: any): void {\n    // Handle sync requests from other nodes\n  }\n\n  private handleNodeJoined(data: any): void {\n    // Handle new node joining\n  }\n\n  private handleNodeLeft(data: any): void {\n    // Handle node leaving\n  }\n\n  private handleConflict(data: any): void {\n    // Handle conflict resolution\n  }\n\n  // === PUBLIC API ===\n\n  getStatistics(): MemoryStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n\n  getPartitions(): MemoryPartition[] {\n    return Array.from(this.partitions.values());\n  }\n\n  getNodes(): MemoryNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  async backup(): Promise<string> {\n    // Create backup of all data\n    const backup = {\n      timestamp: new Date(),\n      partitions: Array.from(this.partitions.values()),\n      entries: Array.from(this.entries.values()),\n      metadata: {\n        version: '1.0',\n        nodeId: this.localNodeId,\n        config: this.config,\n      },\n    };\n\n    return JSON.stringify(backup);\n  }\n\n  async restore(backupData: string): Promise<void> {\n    // Restore from backup\n    const backup = JSON.parse(backupData);\n\n    // Clear current data\n    this.partitions.clear();\n    this.entries.clear();\n    this.cache.clear();\n\n    // Restore partitions\n    for (const partition of backup.partitions) {\n      this.partitions.set(partition.id, partition);\n    }\n\n    // Restore entries\n    for (const entry of backup.entries) {\n      this.entries.set(entry.id, entry);\n    }\n\n    this.logger.info('Restored from backup', {\n      partitions: backup.partitions.length,\n      entries: backup.entries.length,\n    });\n  }\n\n  async clear(): Promise<void> {\n    this.partitions.clear();\n    this.entries.clear();\n    this.cache.clear();\n    this.syncQueue = [];\n    this.statistics = this.initializeStatistics();\n\n    this.logger.info('Cleared all memory data');\n    this.emit('memory:cleared');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
