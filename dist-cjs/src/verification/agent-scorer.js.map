{"version":3,"sources":["../../../src/verification/agent-scorer.ts"],"sourcesContent":["/**\r\n * Agent Truth Scorer - Advanced performance evaluation and scoring system\r\n * \r\n * Provides comprehensive agent performance analysis including accuracy,\r\n * reliability, consistency, efficiency, and adaptability metrics.\r\n */\r\n\r\nimport type { ILogger } from '../core/logger.js';\r\nimport type {\r\n  TruthMetric,\r\n  AgentTruthScore,\r\n  PerformanceWindow,\r\n  ScoreTrend,\r\n  BenchmarkComparison,\r\n  RiskAssessment,\r\n  RiskFactor,\r\n  TruthTelemetryConfig,\r\n} from './telemetry.js';\r\n\r\nexport interface AgentScoringConfig {\r\n  windowSizes: {\r\n    recent: number; // minutes\r\n    short: number; // hours\r\n    medium: number; // days\r\n    long: number; // weeks\r\n  };\r\n  weights: {\r\n    accuracy: number;\r\n    reliability: number;\r\n    consistency: number;\r\n    efficiency: number;\r\n    adaptability: number;\r\n  };\r\n  benchmarks: {\r\n    minAccuracy: number;\r\n    minReliability: number;\r\n    minConsistency: number;\r\n    minEfficiency: number;\r\n    targetTasksPerHour: number;\r\n  };\r\n  riskThresholds: {\r\n    low: number;\r\n    medium: number;\r\n    high: number;\r\n  };\r\n}\r\n\r\nexport interface AgentPerformanceData {\r\n  agentId: string;\r\n  metrics: TruthMetric[];\r\n  recentMetrics: TruthMetric[];\r\n  taskHistory: TaskPerformance[];\r\n  errorHistory: ErrorAnalysis[];\r\n}\r\n\r\nexport interface TaskPerformance {\r\n  taskId: string;\r\n  timestamp: Date;\r\n  taskType: string;\r\n  complexity: string;\r\n  duration: number;\r\n  accuracy: number;\r\n  success: boolean;\r\n  interventionRequired: boolean;\r\n  errorCount: number;\r\n}\r\n\r\nexport interface ErrorAnalysis {\r\n  timestamp: Date;\r\n  errorType: string;\r\n  severity: string;\r\n  frequency: number;\r\n  impact: number;\r\n  resolved: boolean;\r\n  pattern: string;\r\n}\r\n\r\nexport interface TrendAnalysis {\r\n  metric: string;\r\n  timeframe: string;\r\n  direction: 'improving' | 'declining' | 'stable';\r\n  rate: number;\r\n  confidence: number;\r\n  significance: number;\r\n  seasonality?: {\r\n    detected: boolean;\r\n    period: number;\r\n    strength: number;\r\n  };\r\n}\r\n\r\nexport class AgentTruthScorer {\r\n  private config: AgentScoringConfig;\r\n  private logger: ILogger;\r\n  private telemetryConfig: TruthTelemetryConfig;\r\n  \r\n  // Agent data storage\r\n  private agentData = new Map<string, AgentPerformanceData>();\r\n  private agentScores = new Map<string, AgentTruthScore>();\r\n  \r\n  // Benchmark data\r\n  private benchmarkScores = new Map<string, number>();\r\n  private industryBenchmarks: Map<string, BenchmarkComparison[]> = new Map();\r\n  \r\n  constructor(telemetryConfig: TruthTelemetryConfig, logger: ILogger) {\r\n    this.telemetryConfig = telemetryConfig;\r\n    this.logger = logger;\r\n    \r\n    this.config = {\r\n      windowSizes: {\r\n        recent: 15, // 15 minutes\r\n        short: 4, // 4 hours\r\n        medium: 7, // 7 days\r\n        long: 4, // 4 weeks\r\n      },\r\n      weights: {\r\n        accuracy: 0.30,\r\n        reliability: 0.25,\r\n        consistency: 0.20,\r\n        efficiency: 0.15,\r\n        adaptability: 0.10,\r\n      },\r\n      benchmarks: {\r\n        minAccuracy: 0.90,\r\n        minReliability: 0.85,\r\n        minConsistency: 0.80,\r\n        minEfficiency: 0.75,\r\n        targetTasksPerHour: 10,\r\n      },\r\n      riskThresholds: {\r\n        low: 0.85,\r\n        medium: 0.70,\r\n        high: 0.50,\r\n      },\r\n    };\r\n    \r\n    this.initializeBenchmarks();\r\n  }\r\n  \r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing Agent Truth Scorer', {\r\n      weights: this.config.weights,\r\n      benchmarks: this.config.benchmarks,\r\n    });\r\n    \r\n    await this.loadHistoricalData();\r\n    \r\n    this.logger.info('Agent Truth Scorer initialized successfully');\r\n  }\r\n  \r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down Agent Truth Scorer');\r\n    \r\n    await this.persistScoringData();\r\n    \r\n    this.logger.info('Agent Truth Scorer shutdown complete');\r\n  }\r\n  \r\n  async updateAgentMetric(metric: TruthMetric): Promise<void> {\r\n    const agentId = metric.agentId;\r\n    \r\n    // Get or create agent data\r\n    let agentData = this.agentData.get(agentId);\r\n    if (!agentData) {\r\n      agentData = {\r\n        agentId,\r\n        metrics: [],\r\n        recentMetrics: [],\r\n        taskHistory: [],\r\n        errorHistory: [],\r\n      };\r\n      this.agentData.set(agentId, agentData);\r\n    }\r\n    \r\n    // Add metric to agent data\r\n    agentData.metrics.push(metric);\r\n    \r\n    // Update recent metrics (last 15 minutes)\r\n    const recentCutoff = new Date(Date.now() - this.config.windowSizes.recent * 60 * 1000);\r\n    agentData.recentMetrics = agentData.metrics.filter(m => m.timestamp >= recentCutoff);\r\n    \r\n    // Update task history\r\n    await this.updateTaskHistory(agentData, metric);\r\n    \r\n    // Update error history\r\n    await this.updateErrorHistory(agentData, metric);\r\n    \r\n    // Trigger score recalculation for significant updates\r\n    if (this.shouldRecalculateScore(metric)) {\r\n      await this.calculateAgentScore(agentId);\r\n    }\r\n  }\r\n  \r\n  async calculateAgentScore(agentId: string): Promise<AgentTruthScore | null> {\r\n    const agentData = this.agentData.get(agentId);\r\n    if (!agentData || agentData.metrics.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    try {\r\n      // Calculate component scores\r\n      const components = await this.calculateComponentScores(agentData);\r\n      \r\n      // Calculate overall score using weighted average\r\n      const overallScore = this.calculateWeightedScore(components);\r\n      \r\n      // Generate performance windows\r\n      const recentPerformance = await this.generatePerformanceWindows(agentData);\r\n      \r\n      // Analyze trends\r\n      const trends = await this.analyzeTrends(agentData);\r\n      \r\n      // Generate benchmark comparisons\r\n      const benchmarks = await this.generateBenchmarkComparisons(agentId, components);\r\n      \r\n      // Assess risk\r\n      const riskAssessment = await this.assessRisk(agentData, components);\r\n      \r\n      const score: AgentTruthScore = {\r\n        agentId,\r\n        timestamp: new Date(),\r\n        overallScore,\r\n        components,\r\n        recentPerformance,\r\n        trends,\r\n        benchmarks,\r\n        riskAssessment,\r\n      };\r\n      \r\n      this.agentScores.set(agentId, score);\r\n      \r\n      this.logger.debug('Calculated agent score', {\r\n        agentId,\r\n        overallScore: overallScore.toFixed(3),\r\n        components,\r\n      });\r\n      \r\n      return score;\r\n      \r\n    } catch (error) {\r\n      this.logger.error('Error calculating agent score', { agentId, error });\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  private async calculateComponentScores(agentData: AgentPerformanceData): Promise<{\r\n    accuracy: number;\r\n    reliability: number;\r\n    consistency: number;\r\n    efficiency: number;\r\n    adaptability: number;\r\n  }> {\r\n    const shortTermMetrics = this.getMetricsInWindow(\r\n      agentData.metrics,\r\n      this.config.windowSizes.short * 60 * 60 * 1000 // hours to ms\r\n    );\r\n    \r\n    return {\r\n      accuracy: await this.calculateAccuracyScore(shortTermMetrics),\r\n      reliability: await this.calculateReliabilityScore(shortTermMetrics),\r\n      consistency: await this.calculateConsistencyScore(shortTermMetrics),\r\n      efficiency: await this.calculateEfficiencyScore(agentData),\r\n      adaptability: await this.calculateAdaptabilityScore(agentData),\r\n    };\r\n  }\r\n  \r\n  private async calculateAccuracyScore(metrics: TruthMetric[]): Promise<number> {\r\n    if (metrics.length === 0) return 0;\r\n    \r\n    const accuracyMetrics = metrics.filter(m => m.metricType === 'accuracy');\r\n    if (accuracyMetrics.length === 0) return 0.8; // Default for new agents\r\n    \r\n    // Weighted average with more recent metrics having higher weight\r\n    let totalWeight = 0;\r\n    let weightedSum = 0;\r\n    \r\n    accuracyMetrics.forEach((metric, index) => {\r\n      const age = Date.now() - metric.timestamp.getTime();\r\n      const weight = Math.exp(-age / (24 * 60 * 60 * 1000)); // Exponential decay over 24 hours\r\n      \r\n      totalWeight += weight * metric.confidence;\r\n      weightedSum += metric.value * weight * metric.confidence;\r\n    });\r\n    \r\n    return totalWeight > 0 ? Math.min(1, weightedSum / totalWeight) : 0;\r\n  }\r\n  \r\n  private async calculateReliabilityScore(metrics: TruthMetric[]): Promise<number> {\r\n    if (metrics.length === 0) return 0;\r\n    \r\n    const reliabilityMetrics = metrics.filter(m => m.metricType === 'reliability');\r\n    const validationScores = metrics.map(m => m.validation.score);\r\n    \r\n    // Calculate task success rate\r\n    const successRate = validationScores.filter(score => score >= 0.8).length / validationScores.length;\r\n    \r\n    // Calculate consistency of performance\r\n    const variance = this.calculateVariance(validationScores);\r\n    const consistencyScore = Math.max(0, 1 - variance);\r\n    \r\n    // Combine factors\r\n    return (successRate * 0.7) + (consistencyScore * 0.3);\r\n  }\r\n  \r\n  private async calculateConsistencyScore(metrics: TruthMetric[]): Promise<number> {\r\n    if (metrics.length < 3) return 0.8; // Default for insufficient data\r\n    \r\n    const values = metrics.map(m => m.value);\r\n    const confidences = metrics.map(m => m.confidence);\r\n    \r\n    // Calculate coefficient of variation for values and confidence\r\n    const valueCV = this.calculateCoefficientOfVariation(values);\r\n    const confidenceCV = this.calculateCoefficientOfVariation(confidences);\r\n    \r\n    // Lower CV means higher consistency\r\n    const valueConsistency = Math.max(0, 1 - valueCV);\r\n    const confidenceConsistency = Math.max(0, 1 - confidenceCV);\r\n    \r\n    return (valueConsistency * 0.6) + (confidenceConsistency * 0.4);\r\n  }\r\n  \r\n  private async calculateEfficiencyScore(agentData: AgentPerformanceData): Promise<number> {\r\n    const recentTasks = agentData.taskHistory.filter(\r\n      task => task.timestamp > new Date(Date.now() - this.config.windowSizes.short * 60 * 60 * 1000)\r\n    );\r\n    \r\n    if (recentTasks.length === 0) return 0.8; // Default\r\n    \r\n    // Calculate tasks per hour\r\n    const hoursSpanned = this.config.windowSizes.short;\r\n    const tasksPerHour = recentTasks.length / hoursSpanned;\r\n    const throughputScore = Math.min(1, tasksPerHour / this.config.benchmarks.targetTasksPerHour);\r\n    \r\n    // Calculate average task duration relative to complexity\r\n    const durationEfficiency = this.calculateDurationEfficiency(recentTasks);\r\n    \r\n    // Calculate human intervention rate (lower is better)\r\n    const interventionRate = recentTasks.filter(t => t.interventionRequired).length / recentTasks.length;\r\n    const interventionScore = Math.max(0, 1 - (interventionRate * 2)); // Penalty for interventions\r\n    \r\n    return (throughputScore * 0.4) + (durationEfficiency * 0.4) + (interventionScore * 0.2);\r\n  }\r\n  \r\n  private async calculateAdaptabilityScore(agentData: AgentPerformanceData): Promise<number> {\r\n    const recentTasks = agentData.taskHistory.filter(\r\n      task => task.timestamp > new Date(Date.now() - this.config.windowSizes.medium * 24 * 60 * 60 * 1000)\r\n    );\r\n    \r\n    if (recentTasks.length < 5) return 0.7; // Default for new agents\r\n    \r\n    // Analyze performance across different task types\r\n    const taskTypes = new Set(recentTasks.map(t => t.taskType));\r\n    const performanceByType = new Map<string, number[]>();\r\n    \r\n    recentTasks.forEach(task => {\r\n      if (!performanceByType.has(task.taskType)) {\r\n        performanceByType.set(task.taskType, []);\r\n      }\r\n      performanceByType.get(task.taskType)!.push(task.accuracy);\r\n    });\r\n    \r\n    // Calculate adaptability as consistency across different task types\r\n    let adaptabilitySum = 0;\r\n    let typeCount = 0;\r\n    \r\n    for (const [taskType, accuracies] of performanceByType) {\r\n      if (accuracies.length >= 2) {\r\n        const avgAccuracy = accuracies.reduce((sum, acc) => sum + acc, 0) / accuracies.length;\r\n        adaptabilitySum += avgAccuracy;\r\n        typeCount++;\r\n      }\r\n    }\r\n    \r\n    const adaptabilityScore = typeCount > 0 ? adaptabilitySum / typeCount : 0.7;\r\n    \r\n    // Bonus for handling multiple task types\r\n    const diversityBonus = Math.min(0.1, taskTypes.size * 0.02);\r\n    \r\n    return Math.min(1, adaptabilityScore + diversityBonus);\r\n  }\r\n  \r\n  private calculateWeightedScore(components: {\r\n    accuracy: number;\r\n    reliability: number;\r\n    consistency: number;\r\n    efficiency: number;\r\n    adaptability: number;\r\n  }): number {\r\n    const weights = this.config.weights;\r\n    \r\n    return (\r\n      components.accuracy * weights.accuracy +\r\n      components.reliability * weights.reliability +\r\n      components.consistency * weights.consistency +\r\n      components.efficiency * weights.efficiency +\r\n      components.adaptability * weights.adaptability\r\n    );\r\n  }\r\n  \r\n  private async generatePerformanceWindows(agentData: AgentPerformanceData): Promise<PerformanceWindow[]> {\r\n    const windows: PerformanceWindow[] = [];\r\n    const now = new Date();\r\n    \r\n    // Recent window (last 15 minutes)\r\n    const recentStart = new Date(now.getTime() - this.config.windowSizes.recent * 60 * 1000);\r\n    windows.push(await this.createPerformanceWindow('recent', recentStart, now, agentData));\r\n    \r\n    // Short window (last 4 hours)\r\n    const shortStart = new Date(now.getTime() - this.config.windowSizes.short * 60 * 60 * 1000);\r\n    windows.push(await this.createPerformanceWindow('short', shortStart, now, agentData));\r\n    \r\n    // Medium window (last 7 days)\r\n    const mediumStart = new Date(now.getTime() - this.config.windowSizes.medium * 24 * 60 * 60 * 1000);\r\n    windows.push(await this.createPerformanceWindow('medium', mediumStart, now, agentData));\r\n    \r\n    // Long window (last 4 weeks)\r\n    const longStart = new Date(now.getTime() - this.config.windowSizes.long * 7 * 24 * 60 * 60 * 1000);\r\n    windows.push(await this.createPerformanceWindow('long', longStart, now, agentData));\r\n    \r\n    return windows;\r\n  }\r\n  \r\n  private async createPerformanceWindow(\r\n    period: string,\r\n    startTime: Date,\r\n    endTime: Date,\r\n    agentData: AgentPerformanceData\r\n  ): Promise<PerformanceWindow> {\r\n    const windowMetrics = agentData.metrics.filter(\r\n      m => m.timestamp >= startTime && m.timestamp <= endTime\r\n    );\r\n    \r\n    const windowTasks = agentData.taskHistory.filter(\r\n      t => t.timestamp >= startTime && t.timestamp <= endTime\r\n    );\r\n    \r\n    const successfulTasks = windowTasks.filter(t => t.success).length;\r\n    const accuracyValues = windowMetrics\r\n      .filter(m => m.metricType === 'accuracy')\r\n      .map(m => m.value);\r\n    const confidenceValues = windowMetrics.map(m => m.confidence);\r\n    const interventions = windowTasks.filter(t => t.interventionRequired).length;\r\n    const criticalErrors = agentData.errorHistory.filter(\r\n      e => e.timestamp >= startTime && e.timestamp <= endTime && e.severity === 'critical'\r\n    ).length;\r\n    \r\n    return {\r\n      period,\r\n      startTime,\r\n      endTime,\r\n      metrics: {\r\n        totalTasks: windowTasks.length,\r\n        successfulTasks,\r\n        averageAccuracy: accuracyValues.length > 0 ? \r\n          accuracyValues.reduce((sum, val) => sum + val, 0) / accuracyValues.length : 0,\r\n        averageConfidence: confidenceValues.length > 0 ?\r\n          confidenceValues.reduce((sum, val) => sum + val, 0) / confidenceValues.length : 0,\r\n        humanInterventions: interventions,\r\n        criticalErrors,\r\n      },\r\n    };\r\n  }\r\n  \r\n  private async analyzeTrends(agentData: AgentPerformanceData): Promise<ScoreTrend[]> {\r\n    const trends: ScoreTrend[] = [];\r\n    \r\n    const metricTypes = ['accuracy', 'reliability', 'consistency', 'efficiency'];\r\n    \r\n    for (const metricType of metricTypes) {\r\n      const trend = await this.analyzeTrendForMetric(agentData, metricType);\r\n      if (trend) {\r\n        trends.push(trend);\r\n      }\r\n    }\r\n    \r\n    return trends;\r\n  }\r\n  \r\n  private async analyzeTrendForMetric(\r\n    agentData: AgentPerformanceData,\r\n    metricType: string\r\n  ): Promise<ScoreTrend | null> {\r\n    const relevantMetrics = agentData.metrics\r\n      .filter(m => m.metricType === metricType)\r\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\r\n    \r\n    if (relevantMetrics.length < 5) return null; // Need minimum data points\r\n    \r\n    // Calculate linear trend\r\n    const values = relevantMetrics.map(m => m.value);\r\n    const times = relevantMetrics.map(m => m.timestamp.getTime());\r\n    \r\n    const { slope, correlation } = this.calculateLinearTrend(times, values);\r\n    \r\n    // Determine trend direction and significance\r\n    let direction: 'improving' | 'declining' | 'stable';\r\n    if (Math.abs(slope) < 0.001) {\r\n      direction = 'stable';\r\n    } else {\r\n      direction = slope > 0 ? 'improving' : 'declining';\r\n    }\r\n    \r\n    const confidence = Math.abs(correlation);\r\n    const rate = Math.abs(slope);\r\n    \r\n    return {\r\n      metric: metricType,\r\n      direction,\r\n      rate,\r\n      confidence,\r\n      timespan: 'medium',\r\n    };\r\n  }\r\n  \r\n  private async generateBenchmarkComparisons(\r\n    agentId: string,\r\n    components: any\r\n  ): Promise<BenchmarkComparison[]> {\r\n    const comparisons: BenchmarkComparison[] = [];\r\n    \r\n    // Compare against configured benchmarks\r\n    const benchmarks = this.config.benchmarks;\r\n    \r\n    comparisons.push({\r\n      category: 'accuracy',\r\n      agentScore: components.accuracy,\r\n      benchmarkScore: benchmarks.minAccuracy,\r\n      percentile: this.calculatePercentile(components.accuracy, 'accuracy'),\r\n      comparison: components.accuracy >= benchmarks.minAccuracy ? 'above' : 'below',\r\n    });\r\n    \r\n    comparisons.push({\r\n      category: 'reliability',\r\n      agentScore: components.reliability,\r\n      benchmarkScore: benchmarks.minReliability,\r\n      percentile: this.calculatePercentile(components.reliability, 'reliability'),\r\n      comparison: components.reliability >= benchmarks.minReliability ? 'above' : 'below',\r\n    });\r\n    \r\n    comparisons.push({\r\n      category: 'consistency',\r\n      agentScore: components.consistency,\r\n      benchmarkScore: benchmarks.minConsistency,\r\n      percentile: this.calculatePercentile(components.consistency, 'consistency'),\r\n      comparison: components.consistency >= benchmarks.minConsistency ? 'above' : 'below',\r\n    });\r\n    \r\n    comparisons.push({\r\n      category: 'efficiency',\r\n      agentScore: components.efficiency,\r\n      benchmarkScore: benchmarks.minEfficiency,\r\n      percentile: this.calculatePercentile(components.efficiency, 'efficiency'),\r\n      comparison: components.efficiency >= benchmarks.minEfficiency ? 'above' : 'below',\r\n    });\r\n    \r\n    return comparisons;\r\n  }\r\n  \r\n  private async assessRisk(\r\n    agentData: AgentPerformanceData,\r\n    components: any\r\n  ): Promise<RiskAssessment> {\r\n    const riskFactors: RiskFactor[] = [];\r\n    \r\n    // Accuracy risk\r\n    if (components.accuracy < this.config.riskThresholds.medium) {\r\n      riskFactors.push({\r\n        name: 'Low Accuracy',\r\n        severity: components.accuracy < this.config.riskThresholds.high ? 0.8 : 0.5,\r\n        probability: 0.9,\r\n        impact: 'High risk of incorrect outputs',\r\n        trend: this.getTrendDirection(agentData, 'accuracy'),\r\n      });\r\n    }\r\n    \r\n    // Reliability risk\r\n    if (components.reliability < this.config.riskThresholds.medium) {\r\n      riskFactors.push({\r\n        name: 'Low Reliability',\r\n        severity: components.reliability < this.config.riskThresholds.high ? 0.7 : 0.4,\r\n        probability: 0.8,\r\n        impact: 'Frequent task failures',\r\n        trend: this.getTrendDirection(agentData, 'reliability'),\r\n      });\r\n    }\r\n    \r\n    // Efficiency risk\r\n    if (components.efficiency < this.config.riskThresholds.medium) {\r\n      riskFactors.push({\r\n        name: 'Low Efficiency',\r\n        severity: 0.4,\r\n        probability: 0.7,\r\n        impact: 'Reduced throughput and increased costs',\r\n        trend: this.getTrendDirection(agentData, 'efficiency'),\r\n      });\r\n    }\r\n    \r\n    // Error pattern risk\r\n    const recentErrors = agentData.errorHistory.filter(\r\n      e => e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours\r\n    );\r\n    \r\n    if (recentErrors.length > 5) {\r\n      riskFactors.push({\r\n        name: 'High Error Rate',\r\n        severity: 0.6,\r\n        probability: 0.8,\r\n        impact: 'Increased human intervention required',\r\n        trend: 'increasing',\r\n      });\r\n    }\r\n    \r\n    // Determine overall risk level\r\n    const maxSeverity = riskFactors.length > 0 ? \r\n      Math.max(...riskFactors.map(f => f.severity)) : 0;\r\n    \r\n    let level: 'low' | 'medium' | 'high' | 'critical';\r\n    if (maxSeverity >= 0.8) level = 'critical';\r\n    else if (maxSeverity >= 0.6) level = 'high';\r\n    else if (maxSeverity >= 0.3) level = 'medium';\r\n    else level = 'low';\r\n    \r\n    return {\r\n      level,\r\n      factors: riskFactors,\r\n      recommendations: this.generateRecommendations(riskFactors),\r\n      mitigationStrategies: this.generateMitigationStrategies(riskFactors),\r\n    };\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Utility Methods\r\n  // ========================================================================================\r\n  \r\n  private getMetricsInWindow(metrics: TruthMetric[], windowMs: number): TruthMetric[] {\r\n    const cutoff = new Date(Date.now() - windowMs);\r\n    return metrics.filter(m => m.timestamp >= cutoff);\r\n  }\r\n  \r\n  private calculateVariance(values: number[]): number {\r\n    if (values.length === 0) return 0;\r\n    \r\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));\r\n    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;\r\n  }\r\n  \r\n  private calculateCoefficientOfVariation(values: number[]): number {\r\n    if (values.length === 0) return 0;\r\n    \r\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n    if (mean === 0) return 0;\r\n    \r\n    const variance = this.calculateVariance(values);\r\n    const stdDev = Math.sqrt(variance);\r\n    \r\n    return stdDev / mean;\r\n  }\r\n  \r\n  private calculateDurationEfficiency(tasks: TaskPerformance[]): number {\r\n    if (tasks.length === 0) return 0.8;\r\n    \r\n    // Group tasks by complexity and calculate average duration\r\n    const complexityGroups = new Map<string, number[]>();\r\n    \r\n    tasks.forEach(task => {\r\n      if (!complexityGroups.has(task.complexity)) {\r\n        complexityGroups.set(task.complexity, []);\r\n      }\r\n      complexityGroups.get(task.complexity)!.push(task.duration);\r\n    });\r\n    \r\n    // Expected durations by complexity (in minutes)\r\n    const expectedDurations: Record<string, number> = {\r\n      low: 5,\r\n      medium: 15,\r\n      high: 45,\r\n      critical: 120,\r\n    };\r\n    \r\n    let totalEfficiency = 0;\r\n    let groupCount = 0;\r\n    \r\n    for (const [complexity, durations] of complexityGroups) {\r\n      const avgDuration = durations.reduce((sum, d) => sum + d, 0) / durations.length;\r\n      const expected = expectedDurations[complexity] || 15;\r\n      \r\n      // Efficiency is better when duration is less than expected\r\n      const efficiency = Math.min(1, expected / avgDuration);\r\n      totalEfficiency += efficiency;\r\n      groupCount++;\r\n    }\r\n    \r\n    return groupCount > 0 ? totalEfficiency / groupCount : 0.8;\r\n  }\r\n  \r\n  private calculateLinearTrend(x: number[], y: number[]): { slope: number; correlation: number } {\r\n    const n = x.length;\r\n    if (n < 2) return { slope: 0, correlation: 0 };\r\n    \r\n    const sumX = x.reduce((sum, val) => sum + val, 0);\r\n    const sumY = y.reduce((sum, val) => sum + val, 0);\r\n    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);\r\n    const sumX2 = x.reduce((sum, val) => sum + val * val, 0);\r\n    const sumY2 = y.reduce((sum, val) => sum + val * val, 0);\r\n    \r\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\r\n    \r\n    const numerator = n * sumXY - sumX * sumY;\r\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\r\n    const correlation = denominator !== 0 ? numerator / denominator : 0;\r\n    \r\n    return { slope, correlation };\r\n  }\r\n  \r\n  private calculatePercentile(score: number, category: string): number {\r\n    // This would typically compare against a database of historical scores\r\n    // For now, using a simplified calculation\r\n    const allScores = Array.from(this.agentScores.values())\r\n      .map(s => s.components[category as keyof typeof s.components])\r\n      .filter(s => s !== undefined)\r\n      .sort((a, b) => a - b);\r\n    \r\n    if (allScores.length === 0) return 50;\r\n    \r\n    const index = allScores.findIndex(s => s >= score);\r\n    return index === -1 ? 100 : (index / allScores.length) * 100;\r\n  }\r\n  \r\n  private getTrendDirection(agentData: AgentPerformanceData, metricType: string): 'increasing' | 'stable' | 'decreasing' {\r\n    const recentMetrics = agentData.metrics\r\n      .filter(m => m.metricType === metricType)\r\n      .slice(-10); // Last 10 metrics\r\n    \r\n    if (recentMetrics.length < 3) return 'stable';\r\n    \r\n    const values = recentMetrics.map(m => m.value);\r\n    const firstHalf = values.slice(0, Math.floor(values.length / 2));\r\n    const secondHalf = values.slice(Math.floor(values.length / 2));\r\n    \r\n    const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;\r\n    const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;\r\n    \r\n    const diff = secondAvg - firstAvg;\r\n    if (Math.abs(diff) < 0.01) return 'stable';\r\n    return diff > 0 ? 'increasing' : 'decreasing';\r\n  }\r\n  \r\n  private generateRecommendations(riskFactors: RiskFactor[]): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    riskFactors.forEach(factor => {\r\n      switch (factor.name) {\r\n        case 'Low Accuracy':\r\n          recommendations.push('Implement additional validation steps');\r\n          recommendations.push('Review training data quality');\r\n          recommendations.push('Consider accuracy-focused training sessions');\r\n          break;\r\n        case 'Low Reliability':\r\n          recommendations.push('Increase redundancy in critical tasks');\r\n          recommendations.push('Implement circuit breaker patterns');\r\n          recommendations.push('Add health check monitoring');\r\n          break;\r\n        case 'Low Efficiency':\r\n          recommendations.push('Optimize task distribution algorithms');\r\n          recommendations.push('Review resource allocation');\r\n          recommendations.push('Consider task batching strategies');\r\n          break;\r\n        case 'High Error Rate':\r\n          recommendations.push('Implement better error handling');\r\n          recommendations.push('Add preventive validation checks');\r\n          recommendations.push('Review error patterns for systemic issues');\r\n          break;\r\n      }\r\n    });\r\n    \r\n    return Array.from(new Set(recommendations)); // Remove duplicates\r\n  }\r\n  \r\n  private generateMitigationStrategies(riskFactors: RiskFactor[]): string[] {\r\n    const strategies: string[] = [];\r\n    \r\n    const hasAccuracyRisk = riskFactors.some(f => f.name.includes('Accuracy'));\r\n    const hasReliabilityRisk = riskFactors.some(f => f.name.includes('Reliability'));\r\n    const hasEfficiencyRisk = riskFactors.some(f => f.name.includes('Efficiency'));\r\n    \r\n    if (hasAccuracyRisk) {\r\n      strategies.push('Increase human oversight for critical tasks');\r\n      strategies.push('Implement staged rollback procedures');\r\n      strategies.push('Add confidence-based task routing');\r\n    }\r\n    \r\n    if (hasReliabilityRisk) {\r\n      strategies.push('Implement automatic failover mechanisms');\r\n      strategies.push('Add task retry logic with exponential backoff');\r\n      strategies.push('Create backup processing pipelines');\r\n    }\r\n    \r\n    if (hasEfficiencyRisk) {\r\n      strategies.push('Implement dynamic load balancing');\r\n      strategies.push('Add performance-based task assignment');\r\n      strategies.push('Create efficiency monitoring dashboards');\r\n    }\r\n    \r\n    return strategies;\r\n  }\r\n  \r\n  private shouldRecalculateScore(metric: TruthMetric): boolean {\r\n    // Recalculate for significant changes\r\n    return (\r\n      metric.value < 0.7 || // Low performance\r\n      metric.confidence < 0.5 || // Low confidence\r\n      metric.validation.errors.some(e => e.severity === 'critical') || // Critical errors\r\n      metric.metricType === 'accuracy' // Always recalculate for accuracy metrics\r\n    );\r\n  }\r\n  \r\n  private async updateTaskHistory(agentData: AgentPerformanceData, metric: TruthMetric): Promise<void> {\r\n    // Convert metric to task performance record\r\n    const taskPerformance: TaskPerformance = {\r\n      taskId: metric.taskId,\r\n      timestamp: metric.timestamp,\r\n      taskType: metric.context.taskType,\r\n      complexity: metric.context.complexity,\r\n      duration: 0, // Would be calculated from task start/end times\r\n      accuracy: metric.value,\r\n      success: metric.validation.isValid,\r\n      interventionRequired: metric.context.verificationMethod === 'human',\r\n      errorCount: metric.validation.errors.length,\r\n    };\r\n    \r\n    agentData.taskHistory.push(taskPerformance);\r\n    \r\n    // Keep only recent history (last 1000 tasks)\r\n    if (agentData.taskHistory.length > 1000) {\r\n      agentData.taskHistory = agentData.taskHistory.slice(-1000);\r\n    }\r\n  }\r\n  \r\n  private async updateErrorHistory(agentData: AgentPerformanceData, metric: TruthMetric): Promise<void> {\r\n    // Process validation errors\r\n    metric.validation.errors.forEach(error => {\r\n      const errorAnalysis: ErrorAnalysis = {\r\n        timestamp: metric.timestamp,\r\n        errorType: error.type,\r\n        severity: error.severity,\r\n        frequency: 1,\r\n        impact: error.impact,\r\n        resolved: false,\r\n        pattern: this.identifyErrorPattern(error, agentData.errorHistory),\r\n      };\r\n      \r\n      agentData.errorHistory.push(errorAnalysis);\r\n    });\r\n    \r\n    // Keep only recent history (last 500 errors)\r\n    if (agentData.errorHistory.length > 500) {\r\n      agentData.errorHistory = agentData.errorHistory.slice(-500);\r\n    }\r\n  }\r\n  \r\n  private identifyErrorPattern(error: any, errorHistory: ErrorAnalysis[]): string {\r\n    // Simple pattern identification based on error type frequency\r\n    const recentSimilar = errorHistory.filter(\r\n      e => e.errorType === error.type && \r\n           e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours\r\n    );\r\n    \r\n    if (recentSimilar.length >= 3) return 'recurring';\r\n    if (recentSimilar.length >= 2) return 'intermittent';\r\n    return 'isolated';\r\n  }\r\n  \r\n  private initializeBenchmarks(): void {\r\n    // Initialize industry benchmarks (would typically load from external source)\r\n    this.benchmarkScores.set('accuracy', 0.92);\r\n    this.benchmarkScores.set('reliability', 0.88);\r\n    this.benchmarkScores.set('consistency', 0.85);\r\n    this.benchmarkScores.set('efficiency', 0.80);\r\n    this.benchmarkScores.set('adaptability', 0.75);\r\n  }\r\n  \r\n  private async loadHistoricalData(): Promise<void> {\r\n    // Placeholder for loading historical scoring data\r\n    this.logger.debug('Loading historical agent scoring data');\r\n  }\r\n  \r\n  private async persistScoringData(): Promise<void> {\r\n    // Placeholder for persisting scoring data\r\n    this.logger.debug('Persisting agent scoring data');\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Public API\r\n  // ========================================================================================\r\n  \r\n  getAgentScore(agentId: string): AgentTruthScore | undefined {\r\n    return this.agentScores.get(agentId);\r\n  }\r\n  \r\n  getAllAgentScores(): AgentTruthScore[] {\r\n    return Array.from(this.agentScores.values());\r\n  }\r\n  \r\n  getTopPerformers(limit: number = 10): AgentTruthScore[] {\r\n    return Array.from(this.agentScores.values())\r\n      .sort((a, b) => b.overallScore - a.overallScore)\r\n      .slice(0, limit);\r\n  }\r\n  \r\n  getAgentsByRiskLevel(riskLevel: 'low' | 'medium' | 'high' | 'critical'): AgentTruthScore[] {\r\n    return Array.from(this.agentScores.values())\r\n      .filter(score => score.riskAssessment.level === riskLevel);\r\n  }\r\n  \r\n  getPerformanceStatistics(): {\r\n    totalAgents: number;\r\n    averageScore: number;\r\n    highPerformers: number;\r\n    atRiskAgents: number;\r\n    improvingAgents: number;\r\n    decliningAgents: number;\r\n  } {\r\n    const scores = Array.from(this.agentScores.values());\r\n    \r\n    return {\r\n      totalAgents: scores.length,\r\n      averageScore: scores.length > 0 ? \r\n        scores.reduce((sum, s) => sum + s.overallScore, 0) / scores.length : 0,\r\n      highPerformers: scores.filter(s => s.overallScore >= 0.9).length,\r\n      atRiskAgents: scores.filter(s => s.riskAssessment.level === 'high' || s.riskAssessment.level === 'critical').length,\r\n      improvingAgents: scores.filter(s => \r\n        s.trends.some(t => t.direction === 'improving' && t.confidence > 0.7)\r\n      ).length,\r\n      decliningAgents: scores.filter(s => \r\n        s.trends.some(t => t.direction === 'declining' && t.confidence > 0.7)\r\n      ).length,\r\n    };\r\n  }\r\n}"],"names":["AgentTruthScorer","config","logger","telemetryConfig","agentData","Map","agentScores","benchmarkScores","industryBenchmarks","windowSizes","recent","short","medium","long","weights","accuracy","reliability","consistency","efficiency","adaptability","benchmarks","minAccuracy","minReliability","minConsistency","minEfficiency","targetTasksPerHour","riskThresholds","low","high","initializeBenchmarks","initialize","info","loadHistoricalData","shutdown","persistScoringData","updateAgentMetric","metric","agentId","get","metrics","recentMetrics","taskHistory","errorHistory","set","push","recentCutoff","Date","now","filter","m","timestamp","updateTaskHistory","updateErrorHistory","shouldRecalculateScore","calculateAgentScore","length","components","calculateComponentScores","overallScore","calculateWeightedScore","recentPerformance","generatePerformanceWindows","trends","analyzeTrends","generateBenchmarkComparisons","riskAssessment","assessRisk","score","debug","toFixed","error","shortTermMetrics","getMetricsInWindow","calculateAccuracyScore","calculateReliabilityScore","calculateConsistencyScore","calculateEfficiencyScore","calculateAdaptabilityScore","accuracyMetrics","metricType","totalWeight","weightedSum","forEach","index","age","getTime","weight","Math","exp","confidence","value","min","reliabilityMetrics","validationScores","map","validation","successRate","variance","calculateVariance","consistencyScore","max","values","confidences","valueCV","calculateCoefficientOfVariation","confidenceCV","valueConsistency","confidenceConsistency","recentTasks","task","hoursSpanned","tasksPerHour","throughputScore","durationEfficiency","calculateDurationEfficiency","interventionRate","t","interventionRequired","interventionScore","taskTypes","Set","taskType","performanceByType","has","adaptabilitySum","typeCount","accuracies","avgAccuracy","reduce","sum","acc","adaptabilityScore","diversityBonus","size","windows","recentStart","createPerformanceWindow","shortStart","mediumStart","longStart","period","startTime","endTime","windowMetrics","windowTasks","successfulTasks","success","accuracyValues","confidenceValues","interventions","criticalErrors","e","severity","totalTasks","averageAccuracy","val","averageConfidence","humanInterventions","metricTypes","trend","analyzeTrendForMetric","relevantMetrics","sort","a","b","times","slope","correlation","calculateLinearTrend","direction","abs","rate","timespan","comparisons","category","agentScore","benchmarkScore","percentile","calculatePercentile","comparison","riskFactors","name","probability","impact","getTrendDirection","recentErrors","maxSeverity","f","level","factors","recommendations","generateRecommendations","mitigationStrategies","generateMitigationStrategies","windowMs","cutoff","mean","squaredDiffs","pow","diff","stdDev","sqrt","tasks","complexityGroups","complexity","duration","expectedDurations","critical","totalEfficiency","groupCount","durations","avgDuration","d","expected","x","y","n","sumX","sumY","sumXY","i","sumX2","sumY2","numerator","denominator","allScores","Array","from","s","undefined","findIndex","slice","firstHalf","floor","secondHalf","firstAvg","secondAvg","factor","strategies","hasAccuracyRisk","some","includes","hasReliabilityRisk","hasEfficiencyRisk","errors","taskPerformance","taskId","context","isValid","verificationMethod","errorCount","errorAnalysis","errorType","type","frequency","resolved","pattern","identifyErrorPattern","recentSimilar","getAgentScore","getAllAgentScores","getTopPerformers","limit","getAgentsByRiskLevel","riskLevel","getPerformanceStatistics","scores","totalAgents","averageScore","highPerformers","atRiskAgents","improvingAgents","decliningAgents"],"mappings":"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"}