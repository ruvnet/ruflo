{"version":3,"sources":["../../../src/mcp/client.ts"],"sourcesContent":["/**\r\n * MCP Client for Model Context Protocol\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport type { ITransport } from './transports/base.js';\r\nimport { logger } from '../core/logger.js';\r\nimport type { MCPRequest, MCPResponse, MCPNotification, MCPConfig } from '../utils/types.js';\r\nimport { RecoveryManager, RecoveryConfig } from './recovery/index.js';\r\n\r\nexport interface MCPClientConfig {\r\n  transport: ITransport;\r\n  timeout?: number;\r\n  enableRecovery?: boolean;\r\n  recoveryConfig?: RecoveryConfig;\r\n  mcpConfig?: MCPConfig;\r\n}\r\n\r\nexport class MCPClient extends EventEmitter {\r\n  private transport: ITransport;\r\n  private timeout: number;\r\n  private connected = false;\r\n  private recoveryManager?: RecoveryManager;\r\n  private pendingRequests = new Map<\r\n    string,\r\n    { resolve: Function; reject: Function; timer: NodeJS.Timeout }\r\n  >();\r\n\r\n  constructor(config: MCPClientConfig) {\r\n    super();\r\n    this.transport = config.transport;\r\n    this.timeout = config.timeout || 30000;\r\n\r\n    // Initialize recovery manager if enabled\r\n    if (config.enableRecovery) {\r\n      this.recoveryManager = new RecoveryManager(\r\n        this,\r\n        config.mcpConfig || {},\r\n        logger,\r\n        config.recoveryConfig,\r\n      );\r\n      this.setupRecoveryHandlers();\r\n    }\r\n  }\r\n\r\n  async connect(): Promise<void> {\r\n    try {\r\n      await this.transport.connect();\r\n      this.connected = true;\r\n      logger.info('MCP Client connected');\r\n\r\n      // Start recovery manager if enabled\r\n      if (this.recoveryManager) {\r\n        await this.recoveryManager.start();\r\n      }\r\n\r\n      this.emit('connected');\r\n    } catch (error) {\r\n      logger.error('Failed to connect MCP client', error);\r\n      this.connected = false;\r\n\r\n      // Trigger recovery if enabled\r\n      if (this.recoveryManager) {\r\n        await this.recoveryManager.forceRecovery();\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async disconnect(): Promise<void> {\r\n    if (this.connected) {\r\n      // Stop recovery manager first\r\n      if (this.recoveryManager) {\r\n        await this.recoveryManager.stop();\r\n      }\r\n\r\n      await this.transport.disconnect();\r\n      this.connected = false;\r\n      logger.info('MCP Client disconnected');\r\n\r\n      this.emit('disconnected');\r\n    }\r\n  }\r\n\r\n  async request(method: string, params?: unknown): Promise<unknown> {\r\n    const request: MCPRequest = {\r\n      jsonrpc: '2.0' as const,\r\n      method,\r\n      params,\r\n      id: Math.random().toString(36).slice(2),\r\n    };\r\n\r\n    // If recovery manager is enabled, let it handle the request\r\n    if (this.recoveryManager && !this.connected) {\r\n      await this.recoveryManager.handleRequest(request);\r\n    }\r\n\r\n    if (!this.connected) {\r\n      throw new Error('Client not connected');\r\n    }\r\n\r\n    // Create promise for tracking the request\r\n    const requestPromise = new Promise((resolve, reject) => {\r\n      const timer = setTimeout(() => {\r\n        this.pendingRequests.delete(request.id!);\r\n        reject(new Error(`Request timeout: ${method}`));\r\n      }, this.timeout);\r\n\r\n      this.pendingRequests.set(request.id!, { resolve, reject, timer });\r\n    });\r\n\r\n    try {\r\n      const response = await this.transport.sendRequest(request);\r\n\r\n      // Clear pending request\r\n      const pending = this.pendingRequests.get(request.id!);\r\n      if (pending) {\r\n        clearTimeout(pending.timer);\r\n        this.pendingRequests.delete(request.id!);\r\n      }\r\n\r\n      if ('error' in response) {\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      return response.result;\r\n    } catch (error) {\r\n      // Clear pending request on error\r\n      const pending = this.pendingRequests.get(request.id!);\r\n      if (pending) {\r\n        clearTimeout(pending.timer);\r\n        this.pendingRequests.delete(request.id!);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async notify(method: string, params?: unknown): Promise<void> {\r\n    // Special handling for heartbeat notifications\r\n    if (method === 'heartbeat') {\r\n      // Always allow heartbeat notifications for recovery\r\n      const notification: MCPNotification = {\r\n        jsonrpc: '2.0' as const,\r\n        method,\r\n        params,\r\n      };\r\n\r\n      if (this.transport.sendNotification) {\r\n        await this.transport.sendNotification(notification);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (!this.connected) {\r\n      throw new Error('Client not connected');\r\n    }\r\n\r\n    const notification: MCPNotification = {\r\n      jsonrpc: '2.0' as const,\r\n      method,\r\n      params,\r\n    };\r\n\r\n    if (this.transport.sendNotification) {\r\n      await this.transport.sendNotification(notification);\r\n    } else {\r\n      throw new Error('Transport does not support notifications');\r\n    }\r\n  }\r\n\r\n  isConnected(): boolean {\r\n    return this.connected;\r\n  }\r\n\r\n  /**\r\n   * Get recovery status if recovery is enabled\r\n   */\r\n  getRecoveryStatus() {\r\n    return this.recoveryManager?.getStatus();\r\n  }\r\n\r\n  /**\r\n   * Force a recovery attempt\r\n   */\r\n  async forceRecovery(): Promise<boolean> {\r\n    if (!this.recoveryManager) {\r\n      throw new Error('Recovery not enabled');\r\n    }\r\n    return this.recoveryManager.forceRecovery();\r\n  }\r\n\r\n  private setupRecoveryHandlers(): void {\r\n    if (!this.recoveryManager) {\r\n      return;\r\n    }\r\n\r\n    // Handle recovery events\r\n    this.recoveryManager.on('recoveryStart', ({ trigger }) => {\r\n      logger.info('Recovery started', { trigger });\r\n      this.emit('recoveryStart', { trigger });\r\n    });\r\n\r\n    this.recoveryManager.on('recoveryComplete', ({ success, duration }) => {\r\n      if (success) {\r\n        logger.info('Recovery completed successfully', { duration });\r\n        this.connected = true;\r\n        this.emit('recoverySuccess', { duration });\r\n      } else {\r\n        logger.error('Recovery failed');\r\n        this.emit('recoveryFailed', { duration });\r\n      }\r\n    });\r\n\r\n    this.recoveryManager.on('fallbackActivated', (state) => {\r\n      logger.warn('Fallback mode activated', state);\r\n      this.emit('fallbackActivated', state);\r\n    });\r\n\r\n    this.recoveryManager.on('healthChange', (newStatus, oldStatus) => {\r\n      this.emit('healthChange', newStatus, oldStatus);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  async cleanup(): Promise<void> {\r\n    // Clear all pending requests\r\n    for (const [id, pending] of this.pendingRequests) {\r\n      clearTimeout(pending.timer);\r\n      pending.reject(new Error('Client cleanup'));\r\n    }\r\n    this.pendingRequests.clear();\r\n\r\n    // Cleanup recovery manager\r\n    if (this.recoveryManager) {\r\n      await this.recoveryManager.cleanup();\r\n    }\r\n\r\n    // Disconnect if connected\r\n    await this.disconnect();\r\n  }\r\n}\r\n"],"names":["EventEmitter","logger","RecoveryManager","MCPClient","transport","timeout","connected","recoveryManager","pendingRequests","Map","config","enableRecovery","mcpConfig","recoveryConfig","setupRecoveryHandlers","connect","info","start","emit","error","forceRecovery","disconnect","stop","request","method","params","jsonrpc","id","Math","random","toString","slice","handleRequest","Error","requestPromise","Promise","resolve","reject","timer","setTimeout","delete","set","response","sendRequest","pending","get","clearTimeout","result","notify","notification","sendNotification","isConnected","getRecoveryStatus","getStatus","on","trigger","success","duration","state","warn","newStatus","oldStatus","cleanup","clear"],"mappings":"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"}