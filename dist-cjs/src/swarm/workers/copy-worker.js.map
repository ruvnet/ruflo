{"version":3,"sources":["../../../../src/swarm/workers/copy-worker.ts"],"sourcesContent":["import { parentPort, workerData } from 'worker_threads';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport { createHash } from 'crypto';\r\n\r\ninterface WorkerData {\r\n  files: Array<{\r\n    sourcePath: string;\r\n    destPath: string;\r\n    permissions?: number;\r\n    verify?: boolean;\r\n  }>;\r\n  workerId: number;\r\n}\r\n\r\ninterface WorkerResult {\r\n  success: boolean;\r\n  file: string;\r\n  error?: string;\r\n  hash?: string;\r\n}\r\n\r\nasync function copyFile(file: WorkerData['files'][0]): Promise<WorkerResult> {\r\n  try {\r\n    // Ensure destination directory exists\r\n    const destDir = path.dirname(file.destPath);\r\n    await fs.mkdir(destDir, { recursive: true });\r\n\r\n    // Copy the file\r\n    await fs.copyFile(file.sourcePath, file.destPath);\r\n\r\n    // Preserve permissions if requested\r\n    if (file.permissions) {\r\n      await fs.chmod(file.destPath, file.permissions);\r\n    }\r\n\r\n    let hash: string | undefined;\r\n\r\n    // Calculate hash if verification is requested\r\n    if (file.verify) {\r\n      const content = await fs.readFile(file.destPath);\r\n      hash = createHash('sha256').update(content).digest('hex');\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      file: file.sourcePath,\r\n      hash,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      file: file.sourcePath,\r\n      error: error instanceof Error ? error.message : String(error),\r\n    };\r\n  }\r\n}\r\n\r\nasync function main() {\r\n  const data = workerData as WorkerData;\r\n\r\n  if (!parentPort) {\r\n    throw new Error('This script must be run as a worker thread');\r\n  }\r\n\r\n  for (const file of data.files) {\r\n    const result = await copyFile(file);\r\n    parentPort.postMessage(result);\r\n  }\r\n}\r\n\r\n// Run the worker\r\nmain().catch((error) => {\r\n  if (parentPort) {\r\n    parentPort.postMessage({\r\n      success: false,\r\n      file: 'worker',\r\n      error: error instanceof Error ? error.message : String(error),\r\n    });\r\n  }\r\n});\r\n"],"names":["parentPort","workerData","fs","path","createHash","copyFile","file","destDir","dirname","destPath","mkdir","recursive","sourcePath","permissions","chmod","hash","verify","content","readFile","update","digest","success","error","Error","message","String","main","data","files","result","postMessage","catch"],"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,QAAQ,iBAAiB;AACxD,YAAYC,QAAQ,cAAc;AAClC,YAAYC,UAAU,OAAO;AAC7B,SAASC,UAAU,QAAQ,SAAS;AAmBpC,eAAeC,SAASC,IAA4B;IAClD,IAAI;QAEF,MAAMC,UAAUJ,KAAKK,OAAO,CAACF,KAAKG,QAAQ;QAC1C,MAAMP,GAAGQ,KAAK,CAACH,SAAS;YAAEI,WAAW;QAAK;QAG1C,MAAMT,GAAGG,QAAQ,CAACC,KAAKM,UAAU,EAAEN,KAAKG,QAAQ;QAGhD,IAAIH,KAAKO,WAAW,EAAE;YACpB,MAAMX,GAAGY,KAAK,CAACR,KAAKG,QAAQ,EAAEH,KAAKO,WAAW;QAChD;QAEA,IAAIE;QAGJ,IAAIT,KAAKU,MAAM,EAAE;YACf,MAAMC,UAAU,MAAMf,GAAGgB,QAAQ,CAACZ,KAAKG,QAAQ;YAC/CM,OAAOX,WAAW,UAAUe,MAAM,CAACF,SAASG,MAAM,CAAC;QACrD;QAEA,OAAO;YACLC,SAAS;YACTf,MAAMA,KAAKM,UAAU;YACrBG;QACF;IACF,EAAE,OAAOO,OAAO;QACd,OAAO;YACLD,SAAS;YACTf,MAAMA,KAAKM,UAAU;YACrBU,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;QACzD;IACF;AACF;AAEA,eAAeI;IACb,MAAMC,OAAO1B;IAEb,IAAI,CAACD,YAAY;QACf,MAAM,IAAIuB,MAAM;IAClB;IAEA,KAAK,MAAMjB,QAAQqB,KAAKC,KAAK,CAAE;QAC7B,MAAMC,SAAS,MAAMxB,SAASC;QAC9BN,WAAW8B,WAAW,CAACD;IACzB;AACF;AAGAH,OAAOK,KAAK,CAAC,CAACT;IACZ,IAAItB,YAAY;QACdA,WAAW8B,WAAW,CAAC;YACrBT,SAAS;YACTf,MAAM;YACNgB,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;QACzD;IACF;AACF"}