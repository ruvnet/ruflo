{"version":3,"sources":["../../../src/verification/alert-manager.ts"],"sourcesContent":["/**\r\n * Truth Alert Manager - Advanced alerting and notification system\r\n * \r\n * Provides comprehensive threshold monitoring, intelligent alert routing,\r\n * escalation management, and automated remediation capabilities.\r\n */\r\n\r\nimport type { ILogger } from '../core/logger.js';\r\nimport type { IEventBus } from '../core/event-bus.js';\r\nimport type {\r\n  TruthMetric,\r\n  TruthAlert,\r\n  AlertThreshold,\r\n  AlertAction,\r\n  EscalationLevel,\r\n  TruthAlertType,\r\n  TruthTelemetryConfig,\r\n} from './telemetry.js';\r\n\r\nexport interface AlertRule {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  enabled: boolean;\r\n  \r\n  // Condition definition\r\n  metric: string;\r\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte' | 'ne' | 'change' | 'rate';\r\n  threshold: number;\r\n  duration: number; // How long condition must persist (ms)\r\n  \r\n  // Alert configuration\r\n  severity: 'info' | 'warning' | 'critical' | 'emergency';\r\n  category: TruthAlertType;\r\n  priority: number; // 1-10, higher is more urgent\r\n  \r\n  // Context and filtering\r\n  filters: Record<string, any>;\r\n  conditions: AlertCondition[];\r\n  \r\n  // Actions and escalation\r\n  actions: AlertAction[];\r\n  escalationPath: EscalationLevel[];\r\n  suppressions: AlertSuppression[];\r\n  \r\n  // Metadata\r\n  tags: Record<string, string>;\r\n  createdBy: string;\r\n  createdAt: Date;\r\n  lastModified: Date;\r\n}\r\n\r\nexport interface AlertCondition {\r\n  field: string;\r\n  operator: string;\r\n  value: any;\r\n  logicalOperator?: 'AND' | 'OR';\r\n}\r\n\r\nexport interface AlertSuppression {\r\n  id: string;\r\n  condition: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n  reason: string;\r\n  createdBy: string;\r\n}\r\n\r\nexport interface AlertChannel {\r\n  id: string;\r\n  name: string;\r\n  type: 'email' | 'slack' | 'webhook' | 'sms' | 'teams' | 'discord' | 'pagerduty';\r\n  config: Record<string, any>;\r\n  enabled: boolean;\r\n  filters: AlertFilter[];\r\n  rateLimits: RateLimit[];\r\n}\r\n\r\nexport interface AlertFilter {\r\n  field: string;\r\n  operator: string;\r\n  values: string[];\r\n  action: 'include' | 'exclude';\r\n}\r\n\r\nexport interface RateLimit {\r\n  window: number; // time window in milliseconds\r\n  maxAlerts: number;\r\n  resetTime?: Date;\r\n  currentCount: number;\r\n}\r\n\r\nexport interface AlertHistory {\r\n  alertId: string;\r\n  timestamp: Date;\r\n  action: 'created' | 'acknowledged' | 'resolved' | 'escalated' | 'suppressed';\r\n  actor: string;\r\n  details: Record<string, any>;\r\n}\r\n\r\nexport interface AlertStatistics {\r\n  totalAlerts: number;\r\n  activeAlerts: number;\r\n  resolvedAlerts: number;\r\n  averageResolutionTime: number;\r\n  alertsByType: Record<string, number>;\r\n  alertsBySeverity: Record<string, number>;\r\n  topAlertSources: Array<{ source: string; count: number }>;\r\n  escalationRate: number;\r\n  falsePositiveRate: number;\r\n}\r\n\r\nexport interface ThresholdGroup {\r\n  name: string;\r\n  thresholds: AlertThreshold[];\r\n  enabled: boolean;\r\n  scope: 'system' | 'agent' | 'task' | 'custom';\r\n}\r\n\r\nexport class TruthAlertManager {\r\n  private config: TruthTelemetryConfig;\r\n  private logger: ILogger;\r\n  private eventBus: IEventBus;\r\n  \r\n  // Alert management state\r\n  private alertRules = new Map<string, AlertRule>();\r\n  private activeAlerts = new Map<string, TruthAlert>();\r\n  private alertHistory: AlertHistory[] = [];\r\n  private alertChannels = new Map<string, AlertChannel>();\r\n  private suppressions = new Map<string, AlertSuppression>();\r\n  \r\n  // Threshold monitoring\r\n  private thresholdGroups = new Map<string, ThresholdGroup>();\r\n  private metricStates = new Map<string, MetricState>();\r\n  \r\n  // Processing state\r\n  private processingInterval?: NodeJS.Timeout;\r\n  private escalationInterval?: NodeJS.Timeout;\r\n  private cleanupInterval?: NodeJS.Timeout;\r\n  \r\n  // Statistics\r\n  private statistics: AlertStatistics;\r\n  \r\n  constructor(\r\n    config: TruthTelemetryConfig,\r\n    logger: ILogger,\r\n    eventBus: IEventBus\r\n  ) {\r\n    this.config = config;\r\n    this.logger = logger;\r\n    this.eventBus = eventBus;\r\n    \r\n    this.statistics = this.initializeStatistics();\r\n    this.initializeDefaultRules();\r\n    this.initializeDefaultChannels();\r\n  }\r\n  \r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing Truth Alert Manager', {\r\n      alertEnabled: this.config.alertEnabled,\r\n      thresholds: this.config.alertThresholds,\r\n    });\r\n    \r\n    // Start processing loops\r\n    this.startAlertProcessing();\r\n    this.startEscalationProcessing();\r\n    this.startCleanupProcessing();\r\n    \r\n    // Load configuration\r\n    await this.loadAlertConfiguration();\r\n    \r\n    this.logger.info('Truth Alert Manager initialized successfully', {\r\n      rules: this.alertRules.size,\r\n      channels: this.alertChannels.size,\r\n    });\r\n  }\r\n  \r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down Truth Alert Manager');\r\n    \r\n    // Stop processing intervals\r\n    if (this.processingInterval) clearInterval(this.processingInterval);\r\n    if (this.escalationInterval) clearInterval(this.escalationInterval);\r\n    if (this.cleanupInterval) clearInterval(this.cleanupInterval);\r\n    \r\n    // Save state\r\n    await this.saveAlertConfiguration();\r\n    \r\n    this.logger.info('Truth Alert Manager shutdown complete');\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Alert Processing\r\n  // ========================================================================================\r\n  \r\n  async checkThresholds(metric: TruthMetric): Promise<void> {\r\n    if (!this.config.alertEnabled) return;\r\n    \r\n    try {\r\n      // Update metric state\r\n      await this.updateMetricState(metric);\r\n      \r\n      // Check all applicable rules\r\n      const applicableRules = this.getApplicableRules(metric);\r\n      \r\n      for (const rule of applicableRules) {\r\n        await this.evaluateRule(rule, metric);\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.logger.error('Error checking thresholds', { metricId: metric.id, error });\r\n    }\r\n  }\r\n  \r\n  private async updateMetricState(metric: TruthMetric): Promise<void> {\r\n    const key = `${metric.agentId}:${metric.metricType}`;\r\n    \r\n    let state = this.metricStates.get(key);\r\n    if (!state) {\r\n      state = {\r\n        key,\r\n        currentValue: metric.value,\r\n        previousValue: metric.value,\r\n        lastUpdate: metric.timestamp,\r\n        changeRate: 0,\r\n        samples: [metric.value],\r\n        thresholdViolations: new Map(),\r\n      };\r\n      this.metricStates.set(key, state);\r\n    } else {\r\n      // Update state\r\n      state.previousValue = state.currentValue;\r\n      state.currentValue = metric.value;\r\n      state.lastUpdate = metric.timestamp;\r\n      \r\n      // Calculate change rate (per hour)\r\n      const timeDiff = metric.timestamp.getTime() - state.lastUpdate.getTime();\r\n      if (timeDiff > 0) {\r\n        const valueDiff = metric.value - state.previousValue;\r\n        state.changeRate = (valueDiff / timeDiff) * (60 * 60 * 1000); // per hour\r\n      }\r\n      \r\n      // Update samples (keep last 100)\r\n      state.samples.push(metric.value);\r\n      if (state.samples.length > 100) {\r\n        state.samples = state.samples.slice(-100);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private getApplicableRules(metric: TruthMetric): AlertRule[] {\r\n    return Array.from(this.alertRules.values()).filter(rule => {\r\n      if (!rule.enabled) return false;\r\n      \r\n      // Check if rule applies to this metric\r\n      if (rule.metric !== metric.metricType && rule.metric !== '*') return false;\r\n      \r\n      // Check filters\r\n      if (!this.matchesFilters(metric, rule.filters)) return false;\r\n      \r\n      // Check conditions\r\n      if (!this.matchesConditions(metric, rule.conditions)) return false;\r\n      \r\n      return true;\r\n    });\r\n  }\r\n  \r\n  private async evaluateRule(rule: AlertRule, metric: TruthMetric): Promise<void> {\r\n    const key = `${metric.agentId}:${metric.metricType}`;\r\n    const state = this.metricStates.get(key);\r\n    \r\n    if (!state) return;\r\n    \r\n    // Evaluate threshold condition\r\n    const conditionMet = this.evaluateCondition(rule, metric, state);\r\n    \r\n    if (conditionMet) {\r\n      await this.handleThresholdViolation(rule, metric, state);\r\n    } else {\r\n      await this.handleThresholdClearance(rule, metric, state);\r\n    }\r\n  }\r\n  \r\n  private evaluateCondition(rule: AlertRule, metric: TruthMetric, state: MetricState): boolean {\r\n    const value = metric.value;\r\n    const threshold = rule.threshold;\r\n    \r\n    switch (rule.operator) {\r\n      case 'gt': return value > threshold;\r\n      case 'gte': return value >= threshold;\r\n      case 'lt': return value < threshold;\r\n      case 'lte': return value <= threshold;\r\n      case 'eq': return value === threshold;\r\n      case 'ne': return value !== threshold;\r\n      case 'change': return Math.abs(value - state.previousValue) > threshold;\r\n      case 'rate': return Math.abs(state.changeRate) > threshold;\r\n      default: return false;\r\n    }\r\n  }\r\n  \r\n  private async handleThresholdViolation(\r\n    rule: AlertRule,\r\n    metric: TruthMetric,\r\n    state: MetricState\r\n  ): Promise<void> {\r\n    const violationKey = `${rule.id}:${state.key}`;\r\n    let violation = state.thresholdViolations.get(violationKey);\r\n    \r\n    if (!violation) {\r\n      // New violation\r\n      violation = {\r\n        ruleId: rule.id,\r\n        startTime: metric.timestamp,\r\n        lastSeen: metric.timestamp,\r\n        count: 1,\r\n        alertId: null,\r\n      };\r\n      state.thresholdViolations.set(violationKey, violation);\r\n    } else {\r\n      // Existing violation\r\n      violation.lastSeen = metric.timestamp;\r\n      violation.count++;\r\n    }\r\n    \r\n    // Check if violation has persisted long enough\r\n    const duration = metric.timestamp.getTime() - violation.startTime.getTime();\r\n    \r\n    if (duration >= rule.duration && !violation.alertId) {\r\n      // Create alert\r\n      const alertId = await this.createAlert(rule, metric, violation);\r\n      violation.alertId = alertId;\r\n    }\r\n  }\r\n  \r\n  private async handleThresholdClearance(\r\n    rule: AlertRule,\r\n    metric: TruthMetric,\r\n    state: MetricState\r\n  ): Promise<void> {\r\n    const violationKey = `${rule.id}:${state.key}`;\r\n    const violation = state.thresholdViolations.get(violationKey);\r\n    \r\n    if (violation && violation.alertId) {\r\n      // Resolve the alert\r\n      await this.resolveAlert(violation.alertId, 'threshold_cleared');\r\n    }\r\n    \r\n    // Clear violation\r\n    state.thresholdViolations.delete(violationKey);\r\n  }\r\n  \r\n  private async createAlert(\r\n    rule: AlertRule,\r\n    metric: TruthMetric,\r\n    violation: ThresholdViolation\r\n  ): Promise<string> {\r\n    const alertId = `alert-${Date.now()}-${Math.random().toString(36).slice(2)}`;\r\n    \r\n    const alert: TruthAlert = {\r\n      id: alertId,\r\n      timestamp: new Date(),\r\n      severity: rule.severity,\r\n      type: rule.category,\r\n      message: this.generateAlertMessage(rule, metric),\r\n      source: `agent:${metric.agentId}`,\r\n      context: {\r\n        ruleId: rule.id,\r\n        ruleName: rule.name,\r\n        metricType: metric.metricType,\r\n        metricValue: metric.value,\r\n        threshold: rule.threshold,\r\n        operator: rule.operator,\r\n        duration: violation.lastSeen.getTime() - violation.startTime.getTime(),\r\n        violationCount: violation.count,\r\n        agentId: metric.agentId,\r\n        taskId: metric.taskId,\r\n        ...metric.context,\r\n      },\r\n      thresholds: [\r\n        {\r\n          metric: rule.metric,\r\n          operator: rule.operator,\r\n          value: rule.threshold,\r\n          duration: rule.duration,\r\n          severity: rule.severity,\r\n        },\r\n      ],\r\n      actions: [...rule.actions],\r\n      escalationPath: [...rule.escalationPath],\r\n      resolved: false,\r\n    };\r\n    \r\n    this.activeAlerts.set(alertId, alert);\r\n    \r\n    // Update statistics\r\n    this.statistics.totalAlerts++;\r\n    this.statistics.activeAlerts++;\r\n    this.statistics.alertsByType[alert.type] = (this.statistics.alertsByType[alert.type] || 0) + 1;\r\n    this.statistics.alertsBySeverity[alert.severity] = (this.statistics.alertsBySeverity[alert.severity] || 0) + 1;\r\n    \r\n    // Log alert creation\r\n    this.logger.warn('Truth alert created', {\r\n      alertId,\r\n      rule: rule.name,\r\n      metric: metric.metricType,\r\n      value: metric.value,\r\n      threshold: rule.threshold,\r\n      agent: metric.agentId,\r\n    });\r\n    \r\n    // Add to history\r\n    this.addToHistory(alertId, 'created', 'system', { rule: rule.name });\r\n    \r\n    // Emit event\r\n    this.eventBus.emit('truth-alert:created', { alert, rule, metric });\r\n    \r\n    // Execute alert actions\r\n    await this.executeAlertActions(alert);\r\n    \r\n    return alertId;\r\n  }\r\n  \r\n  async executeAlertActions(alert: TruthAlert): Promise<void> {\r\n    for (const action of alert.actions) {\r\n      if (!action.enabled) continue;\r\n      \r\n      try {\r\n        await this.executeAction(alert, action);\r\n      } catch (error) {\r\n        this.logger.error('Failed to execute alert action', {\r\n          alertId: alert.id,\r\n          actionType: action.type,\r\n          error,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  private async executeAction(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    switch (action.type) {\r\n      case 'notify':\r\n        await this.sendNotification(alert, action);\r\n        break;\r\n      \r\n      case 'escalate':\r\n        await this.escalateAlert(alert, action);\r\n        break;\r\n      \r\n      case 'auto-remediate':\r\n        await this.autoRemediate(alert, action);\r\n        break;\r\n      \r\n      case 'suspend':\r\n        await this.suspendAgent(alert, action);\r\n        break;\r\n      \r\n      case 'restart':\r\n        await this.restartAgent(alert, action);\r\n        break;\r\n      \r\n      default:\r\n        this.logger.warn('Unknown alert action type', { type: action.type });\r\n    }\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Notification System\r\n  // ========================================================================================\r\n  \r\n  private async sendNotification(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    const channelIds = action.config.channels || ['default'];\r\n    \r\n    for (const channelId of channelIds) {\r\n      const channel = this.alertChannels.get(channelId);\r\n      if (!channel || !channel.enabled) continue;\r\n      \r\n      // Check filters\r\n      if (!this.alertMatchesChannelFilters(alert, channel)) continue;\r\n      \r\n      // Check rate limits\r\n      if (!this.checkRateLimit(channel, alert)) continue;\r\n      \r\n      await this.sendToChannel(alert, channel);\r\n    }\r\n  }\r\n  \r\n  private async sendToChannel(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    try {\r\n      switch (channel.type) {\r\n        case 'email':\r\n          await this.sendEmailNotification(alert, channel);\r\n          break;\r\n        \r\n        case 'slack':\r\n          await this.sendSlackNotification(alert, channel);\r\n          break;\r\n        \r\n        case 'webhook':\r\n          await this.sendWebhookNotification(alert, channel);\r\n          break;\r\n        \r\n        case 'teams':\r\n          await this.sendTeamsNotification(alert, channel);\r\n          break;\r\n        \r\n        case 'discord':\r\n          await this.sendDiscordNotification(alert, channel);\r\n          break;\r\n        \r\n        case 'pagerduty':\r\n          await this.sendPagerDutyNotification(alert, channel);\r\n          break;\r\n        \r\n        default:\r\n          this.logger.warn('Unknown channel type', { type: channel.type });\r\n      }\r\n      \r\n      this.logger.info('Alert notification sent', {\r\n        alertId: alert.id,\r\n        channel: channel.name,\r\n        type: channel.type,\r\n      });\r\n      \r\n    } catch (error) {\r\n      this.logger.error('Failed to send notification', {\r\n        alertId: alert.id,\r\n        channel: channel.name,\r\n        error,\r\n      });\r\n    }\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Escalation Management\r\n  // ========================================================================================\r\n  \r\n  private async escalateAlert(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    const escalationLevel = action.config.level || 1;\r\n    \r\n    if (escalationLevel <= alert.escalationLevel) return; // Already escalated\r\n    \r\n    alert.escalationLevel = escalationLevel;\r\n    \r\n    // Find escalation configuration\r\n    const escalation = alert.escalationPath.find(e => e.level === escalationLevel);\r\n    if (!escalation) return;\r\n    \r\n    // Check escalation conditions\r\n    if (!this.checkEscalationConditions(alert, escalation)) return;\r\n    \r\n    // Update alert severity if needed\r\n    if (escalationLevel > 1) {\r\n      alert.severity = this.getEscalatedSeverity(alert.severity);\r\n    }\r\n    \r\n    // Send escalation notifications\r\n    await this.sendEscalationNotifications(alert, escalation);\r\n    \r\n    // Add to history\r\n    this.addToHistory(alert.id, 'escalated', 'system', {\r\n      level: escalationLevel,\r\n      targets: escalation.targets,\r\n    });\r\n    \r\n    // Update statistics\r\n    this.statistics.escalationRate = this.calculateEscalationRate();\r\n    \r\n    this.logger.warn('Alert escalated', {\r\n      alertId: alert.id,\r\n      level: escalationLevel,\r\n      severity: alert.severity,\r\n    });\r\n    \r\n    this.eventBus.emit('truth-alert:escalated', { alert, escalationLevel });\r\n  }\r\n  \r\n  private async sendEscalationNotifications(\r\n    alert: TruthAlert,\r\n    escalation: EscalationLevel\r\n  ): Promise<void> {\r\n    for (const target of escalation.targets) {\r\n      const channel = this.alertChannels.get(target);\r\n      if (channel && channel.enabled) {\r\n        await this.sendToChannel(alert, channel);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Auto-Remediation\r\n  // ========================================================================================\r\n  \r\n  private async autoRemediate(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    const remediationType = action.config.type;\r\n    \r\n    try {\r\n      switch (remediationType) {\r\n        case 'restart_agent':\r\n          await this.restartAgent(alert, action);\r\n          break;\r\n        \r\n        case 'scale_resources':\r\n          await this.scaleResources(alert, action);\r\n          break;\r\n        \r\n        case 'adjust_thresholds':\r\n          await this.adjustThresholds(alert, action);\r\n          break;\r\n        \r\n        case 'redistribute_load':\r\n          await this.redistributeLoad(alert, action);\r\n          break;\r\n        \r\n        case 'failover':\r\n          await this.initiateFailover(alert, action);\r\n          break;\r\n        \r\n        default:\r\n          this.logger.warn('Unknown remediation type', { type: remediationType });\r\n      }\r\n      \r\n      this.logger.info('Auto-remediation executed', {\r\n        alertId: alert.id,\r\n        type: remediationType,\r\n      });\r\n      \r\n    } catch (error) {\r\n      this.logger.error('Auto-remediation failed', {\r\n        alertId: alert.id,\r\n        type: remediationType,\r\n        error,\r\n      });\r\n    }\r\n  }\r\n  \r\n  private async restartAgent(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    const agentId = alert.context.agentId;\r\n    if (!agentId) return;\r\n    \r\n    this.eventBus.emit('agent:restart-requested', {\r\n      agentId,\r\n      reason: 'automated_remediation',\r\n      alertId: alert.id,\r\n    });\r\n  }\r\n  \r\n  private async suspendAgent(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    const agentId = alert.context.agentId;\r\n    if (!agentId) return;\r\n    \r\n    this.eventBus.emit('agent:suspend-requested', {\r\n      agentId,\r\n      duration: action.config.duration || 300000, // 5 minutes default\r\n      reason: 'automated_remediation',\r\n      alertId: alert.id,\r\n    });\r\n  }\r\n  \r\n  private async scaleResources(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    this.eventBus.emit('system:scale-requested', {\r\n      direction: action.config.direction || 'up',\r\n      factor: action.config.factor || 1.5,\r\n      reason: 'automated_remediation',\r\n      alertId: alert.id,\r\n    });\r\n  }\r\n  \r\n  private async adjustThresholds(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    const ruleId = alert.context.ruleId;\r\n    const rule = this.alertRules.get(ruleId);\r\n    \r\n    if (rule) {\r\n      const adjustment = action.config.adjustment || 0.1;\r\n      rule.threshold = rule.threshold + (rule.threshold * adjustment);\r\n      \r\n      this.logger.info('Alert threshold adjusted', {\r\n        ruleId,\r\n        oldThreshold: rule.threshold - (rule.threshold * adjustment),\r\n        newThreshold: rule.threshold,\r\n      });\r\n    }\r\n  }\r\n  \r\n  private async redistributeLoad(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    this.eventBus.emit('load-balancer:redistribute', {\r\n      reason: 'automated_remediation',\r\n      alertId: alert.id,\r\n      excludeAgents: [alert.context.agentId],\r\n    });\r\n  }\r\n  \r\n  private async initiateFailover(alert: TruthAlert, action: AlertAction): Promise<void> {\r\n    this.eventBus.emit('system:failover-requested', {\r\n      primaryAgent: alert.context.agentId,\r\n      reason: 'automated_remediation',\r\n      alertId: alert.id,\r\n    });\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Alert Resolution\r\n  // ========================================================================================\r\n  \r\n  async resolveAlert(alertId: string, reason: string, resolvedBy?: string): Promise<boolean> {\r\n    const alert = this.activeAlerts.get(alertId);\r\n    if (!alert || alert.resolved) return false;\r\n    \r\n    alert.resolved = true;\r\n    alert.resolvedAt = new Date();\r\n    alert.resolvedBy = resolvedBy || 'system';\r\n    alert.context.resolutionReason = reason;\r\n    \r\n    // Update statistics\r\n    this.statistics.activeAlerts--;\r\n    this.statistics.resolvedAlerts++;\r\n    \r\n    // Calculate resolution time\r\n    const resolutionTime = alert.resolvedAt.getTime() - alert.timestamp.getTime();\r\n    this.updateAverageResolutionTime(resolutionTime);\r\n    \r\n    // Add to history\r\n    this.addToHistory(alertId, 'resolved', resolvedBy || 'system', { reason });\r\n    \r\n    this.logger.info('Alert resolved', {\r\n      alertId,\r\n      reason,\r\n      resolvedBy: resolvedBy || 'system',\r\n      duration: resolutionTime,\r\n    });\r\n    \r\n    this.eventBus.emit('truth-alert:resolved', { alert, reason, resolvedBy });\r\n    \r\n    return true;\r\n  }\r\n  \r\n  async acknowledgeAlert(alertId: string, acknowledgedBy: string, comment?: string): Promise<boolean> {\r\n    const alert = this.activeAlerts.get(alertId);\r\n    if (!alert || alert.resolved) return false;\r\n    \r\n    alert.acknowledged = true;\r\n    alert.acknowledgedAt = new Date();\r\n    alert.acknowledgedBy = acknowledgedBy;\r\n    \r\n    if (comment) {\r\n      alert.context.acknowledgmentComment = comment;\r\n    }\r\n    \r\n    // Add to history\r\n    this.addToHistory(alertId, 'acknowledged', acknowledgedBy, { comment });\r\n    \r\n    this.logger.info('Alert acknowledged', {\r\n      alertId,\r\n      acknowledgedBy,\r\n      comment,\r\n    });\r\n    \r\n    this.eventBus.emit('truth-alert:acknowledged', { alert, acknowledgedBy, comment });\r\n    \r\n    return true;\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Rule Management\r\n  // ========================================================================================\r\n  \r\n  createAlertRule(rule: Omit<AlertRule, 'id' | 'createdAt' | 'lastModified'>): string {\r\n    const ruleId = `rule-${Date.now()}-${Math.random().toString(36).slice(2)}`;\r\n    \r\n    const fullRule: AlertRule = {\r\n      ...rule,\r\n      id: ruleId,\r\n      createdAt: new Date(),\r\n      lastModified: new Date(),\r\n    };\r\n    \r\n    this.alertRules.set(ruleId, fullRule);\r\n    \r\n    this.logger.info('Alert rule created', {\r\n      ruleId,\r\n      name: rule.name,\r\n      metric: rule.metric,\r\n      threshold: rule.threshold,\r\n    });\r\n    \r\n    return ruleId;\r\n  }\r\n  \r\n  updateAlertRule(ruleId: string, updates: Partial<AlertRule>): boolean {\r\n    const rule = this.alertRules.get(ruleId);\r\n    if (!rule) return false;\r\n    \r\n    const updatedRule = {\r\n      ...rule,\r\n      ...updates,\r\n      id: ruleId, // Prevent ID changes\r\n      lastModified: new Date(),\r\n    };\r\n    \r\n    this.alertRules.set(ruleId, updatedRule);\r\n    \r\n    this.logger.info('Alert rule updated', { ruleId, updates });\r\n    \r\n    return true;\r\n  }\r\n  \r\n  deleteAlertRule(ruleId: string): boolean {\r\n    const deleted = this.alertRules.delete(ruleId);\r\n    \r\n    if (deleted) {\r\n      this.logger.info('Alert rule deleted', { ruleId });\r\n    }\r\n    \r\n    return deleted;\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Processing Loops\r\n  // ========================================================================================\r\n  \r\n  private startAlertProcessing(): void {\r\n    this.processingInterval = setInterval(() => {\r\n      this.processActiveAlerts();\r\n    }, 30000); // Every 30 seconds\r\n    \r\n    this.logger.info('Started alert processing');\r\n  }\r\n  \r\n  private startEscalationProcessing(): void {\r\n    this.escalationInterval = setInterval(() => {\r\n      this.processEscalations();\r\n    }, 60000); // Every minute\r\n    \r\n    this.logger.info('Started escalation processing');\r\n  }\r\n  \r\n  private startCleanupProcessing(): void {\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanupResolvedAlerts();\r\n      this.cleanupOldHistory();\r\n      this.resetRateLimits();\r\n    }, 300000); // Every 5 minutes\r\n    \r\n    this.logger.info('Started cleanup processing');\r\n  }\r\n  \r\n  async processAlert(alert: TruthAlert): Promise<void> {\r\n    // Check for auto-resolution conditions\r\n    await this.checkAutoResolution(alert);\r\n    \r\n    // Check for escalation conditions\r\n    await this.checkEscalation(alert);\r\n    \r\n    // Update alert statistics\r\n    this.updateAlertStatistics(alert);\r\n  }\r\n  \r\n  private async processActiveAlerts(): Promise<void> {\r\n    for (const alert of this.activeAlerts.values()) {\r\n      if (!alert.resolved) {\r\n        await this.processAlert(alert);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private async processEscalations(): Promise<void> {\r\n    for (const alert of this.activeAlerts.values()) {\r\n      if (!alert.resolved && !alert.acknowledged) {\r\n        await this.checkEscalation(alert);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private async checkAutoResolution(alert: TruthAlert): Promise<void> {\r\n    // Check if the underlying condition has been resolved\r\n    const currentValue = await this.getCurrentMetricValue(alert);\r\n    if (currentValue === null) return;\r\n    \r\n    const rule = this.alertRules.get(alert.context.ruleId);\r\n    if (!rule) return;\r\n    \r\n    // Check if condition is no longer met\r\n    const conditionMet = this.evaluateConditionValue(rule, currentValue);\r\n    \r\n    if (!conditionMet) {\r\n      await this.resolveAlert(alert.id, 'condition_resolved');\r\n    }\r\n  }\r\n  \r\n  private async checkEscalation(alert: TruthAlert): Promise<void> {\r\n    const now = Date.now();\r\n    const alertAge = now - alert.timestamp.getTime();\r\n    \r\n    // Find next escalation level\r\n    const nextEscalation = alert.escalationPath.find(\r\n      e => e.level > alert.escalationLevel\r\n    );\r\n    \r\n    if (nextEscalation && alertAge >= nextEscalation.delay) {\r\n      await this.escalateAlert(alert, {\r\n        type: 'escalate',\r\n        target: 'escalation',\r\n        config: { level: nextEscalation.level },\r\n        enabled: true,\r\n      });\r\n    }\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Utility Methods\r\n  // ========================================================================================\r\n  \r\n  private generateAlertMessage(rule: AlertRule, metric: TruthMetric): string {\r\n    return `${rule.name}: ${metric.metricType} ${rule.operator} ${rule.threshold} ` +\r\n           `(current: ${metric.value.toFixed(3)}) for agent ${metric.agentId}`;\r\n  }\r\n  \r\n  private matchesFilters(metric: TruthMetric, filters: Record<string, any>): boolean {\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      const metricValue = this.getMetricProperty(metric, key);\r\n      if (metricValue !== value) return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  private matchesConditions(metric: TruthMetric, conditions: AlertCondition[]): boolean {\r\n    if (conditions.length === 0) return true;\r\n    \r\n    // Simple AND/OR logic evaluation\r\n    let result = true;\r\n    let currentOperator = 'AND';\r\n    \r\n    for (const condition of conditions) {\r\n      const metricValue = this.getMetricProperty(metric, condition.field);\r\n      const conditionResult = this.evaluateConditionValue(condition, metricValue);\r\n      \r\n      if (currentOperator === 'AND') {\r\n        result = result && conditionResult;\r\n      } else {\r\n        result = result || conditionResult;\r\n      }\r\n      \r\n      currentOperator = condition.logicalOperator || 'AND';\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  private getMetricProperty(metric: TruthMetric, path: string): any {\r\n    const parts = path.split('.');\r\n    let value: any = metric;\r\n    \r\n    for (const part of parts) {\r\n      value = value?.[part];\r\n    }\r\n    \r\n    return value;\r\n  }\r\n  \r\n  private evaluateConditionValue(condition: any, value: any): boolean {\r\n    switch (condition.operator) {\r\n      case 'gt': return value > condition.value;\r\n      case 'gte': return value >= condition.value;\r\n      case 'lt': return value < condition.value;\r\n      case 'lte': return value <= condition.value;\r\n      case 'eq': return value === condition.value;\r\n      case 'ne': return value !== condition.value;\r\n      case 'contains': return String(value).includes(condition.value);\r\n      case 'startsWith': return String(value).startsWith(condition.value);\r\n      case 'endsWith': return String(value).endsWith(condition.value);\r\n      default: return false;\r\n    }\r\n  }\r\n  \r\n  private alertMatchesChannelFilters(alert: TruthAlert, channel: AlertChannel): boolean {\r\n    for (const filter of channel.filters) {\r\n      const alertValue = this.getMetricProperty(alert, filter.field);\r\n      const matches = filter.values.includes(String(alertValue));\r\n      \r\n      if (filter.action === 'include' && !matches) return false;\r\n      if (filter.action === 'exclude' && matches) return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  private checkRateLimit(channel: AlertChannel, alert: TruthAlert): boolean {\r\n    for (const rateLimit of channel.rateLimits) {\r\n      const now = Date.now();\r\n      \r\n      // Reset if window has passed\r\n      if (rateLimit.resetTime && now > rateLimit.resetTime.getTime()) {\r\n        rateLimit.currentCount = 0;\r\n        rateLimit.resetTime = new Date(now + rateLimit.window);\r\n      }\r\n      \r\n      // Initialize if needed\r\n      if (!rateLimit.resetTime) {\r\n        rateLimit.resetTime = new Date(now + rateLimit.window);\r\n        rateLimit.currentCount = 0;\r\n      }\r\n      \r\n      // Check limit\r\n      if (rateLimit.currentCount >= rateLimit.maxAlerts) {\r\n        return false;\r\n      }\r\n      \r\n      // Increment counter\r\n      rateLimit.currentCount++;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  private checkEscalationConditions(alert: TruthAlert, escalation: EscalationLevel): boolean {\r\n    // Simple condition evaluation\r\n    for (const condition of escalation.conditions) {\r\n      // This would typically parse and evaluate complex conditions\r\n      // For now, using simple checks\r\n      if (condition.includes('unacknowledged') && alert.acknowledged) return false;\r\n      if (condition.includes('duration') && !this.checkDurationCondition(alert, condition)) return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  private checkDurationCondition(alert: TruthAlert, condition: string): boolean {\r\n    // Parse condition like \"duration > 30m\"\r\n    const match = condition.match(/duration\\s*([><=]+)\\s*(\\d+)([mhs])/);\r\n    if (!match) return true;\r\n    \r\n    const operator = match[1];\r\n    const value = parseInt(match[2]);\r\n    const unit = match[3];\r\n    \r\n    const multiplier = unit === 's' ? 1000 : unit === 'm' ? 60000 : 3600000; // hours\r\n    const thresholdMs = value * multiplier;\r\n    const durationMs = Date.now() - alert.timestamp.getTime();\r\n    \r\n    switch (operator) {\r\n      case '>': return durationMs > thresholdMs;\r\n      case '>=': return durationMs >= thresholdMs;\r\n      case '<': return durationMs < thresholdMs;\r\n      case '<=': return durationMs <= thresholdMs;\r\n      case '=': return Math.abs(durationMs - thresholdMs) < 1000;\r\n      default: return true;\r\n    }\r\n  }\r\n  \r\n  private getEscalatedSeverity(currentSeverity: string): 'info' | 'warning' | 'critical' | 'emergency' {\r\n    switch (currentSeverity) {\r\n      case 'info': return 'warning';\r\n      case 'warning': return 'critical';\r\n      case 'critical': return 'emergency';\r\n      default: return 'emergency';\r\n    }\r\n  }\r\n  \r\n  private async getCurrentMetricValue(alert: TruthAlert): Promise<number | null> {\r\n    // This would typically query the current metric value\r\n    // For now, returning null to indicate unavailable\r\n    return null;\r\n  }\r\n  \r\n  private addToHistory(alertId: string, action: string, actor: string, details: Record<string, any>): void {\r\n    this.alertHistory.push({\r\n      alertId,\r\n      timestamp: new Date(),\r\n      action: action as any,\r\n      actor,\r\n      details,\r\n    });\r\n    \r\n    // Keep history size manageable\r\n    if (this.alertHistory.length > 10000) {\r\n      this.alertHistory = this.alertHistory.slice(-5000);\r\n    }\r\n  }\r\n  \r\n  private cleanupResolvedAlerts(): void {\r\n    const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 hours\r\n    \r\n    for (const [alertId, alert] of this.activeAlerts) {\r\n      if (alert.resolved && alert.resolvedAt && alert.resolvedAt < cutoff) {\r\n        this.activeAlerts.delete(alertId);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private cleanupOldHistory(): void {\r\n    const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days\r\n    this.alertHistory = this.alertHistory.filter(h => h.timestamp >= cutoff);\r\n  }\r\n  \r\n  private resetRateLimits(): void {\r\n    const now = Date.now();\r\n    \r\n    for (const channel of this.alertChannels.values()) {\r\n      for (const rateLimit of channel.rateLimits) {\r\n        if (rateLimit.resetTime && now > rateLimit.resetTime.getTime()) {\r\n          rateLimit.currentCount = 0;\r\n          rateLimit.resetTime = new Date(now + rateLimit.window);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  private updateAlertStatistics(alert: TruthAlert): void {\r\n    // Update top alert sources\r\n    const source = alert.source;\r\n    const existing = this.statistics.topAlertSources.find(s => s.source === source);\r\n    if (existing) {\r\n      existing.count++;\r\n    } else {\r\n      this.statistics.topAlertSources.push({ source, count: 1 });\r\n    }\r\n    \r\n    // Sort and limit\r\n    this.statistics.topAlertSources.sort((a, b) => b.count - a.count);\r\n    this.statistics.topAlertSources = this.statistics.topAlertSources.slice(0, 10);\r\n  }\r\n  \r\n  private updateAverageResolutionTime(resolutionTime: number): void {\r\n    const count = this.statistics.resolvedAlerts;\r\n    const currentAvg = this.statistics.averageResolutionTime;\r\n    \r\n    this.statistics.averageResolutionTime = \r\n      ((currentAvg * (count - 1)) + resolutionTime) / count;\r\n  }\r\n  \r\n  private calculateEscalationRate(): number {\r\n    const escalatedAlerts = this.alertHistory.filter(h => h.action === 'escalated').length;\r\n    return this.statistics.totalAlerts > 0 ? escalatedAlerts / this.statistics.totalAlerts : 0;\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Notification Implementations (Placeholders)\r\n  // ========================================================================================\r\n  \r\n  private async sendEmailNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    // Implementation would send actual email\r\n    this.logger.info('Email notification sent', { alertId: alert.id, to: channel.config.to });\r\n  }\r\n  \r\n  private async sendSlackNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    // Implementation would send to Slack webhook\r\n    this.logger.info('Slack notification sent', { alertId: alert.id, webhook: channel.config.webhook });\r\n  }\r\n  \r\n  private async sendWebhookNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    // Implementation would POST to webhook URL\r\n    this.logger.info('Webhook notification sent', { alertId: alert.id, url: channel.config.url });\r\n  }\r\n  \r\n  private async sendTeamsNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    // Implementation would send to Teams webhook\r\n    this.logger.info('Teams notification sent', { alertId: alert.id, webhook: channel.config.webhook });\r\n  }\r\n  \r\n  private async sendDiscordNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    // Implementation would send to Discord webhook\r\n    this.logger.info('Discord notification sent', { alertId: alert.id, webhook: channel.config.webhook });\r\n  }\r\n  \r\n  private async sendPagerDutyNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\r\n    // Implementation would create PagerDuty incident\r\n    this.logger.info('PagerDuty notification sent', { alertId: alert.id, serviceKey: channel.config.serviceKey });\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Configuration Management\r\n  // ========================================================================================\r\n  \r\n  private async loadAlertConfiguration(): Promise<void> {\r\n    // Placeholder for loading configuration from storage\r\n    this.logger.debug('Loading alert configuration');\r\n  }\r\n  \r\n  private async saveAlertConfiguration(): Promise<void> {\r\n    // Placeholder for saving configuration to storage\r\n    this.logger.debug('Saving alert configuration');\r\n  }\r\n  \r\n  private initializeDefaultRules(): void {\r\n    // Create default alert rules\r\n    const defaultRules: Omit<AlertRule, 'id' | 'createdAt' | 'lastModified'>[] = [\r\n      {\r\n        name: 'Low Truth Accuracy',\r\n        description: 'Alert when agent accuracy falls below threshold',\r\n        enabled: true,\r\n        metric: 'accuracy',\r\n        operator: 'lt',\r\n        threshold: this.config.alertThresholds.accuracyThreshold,\r\n        duration: 300000, // 5 minutes\r\n        severity: 'critical',\r\n        category: 'accuracy_degradation',\r\n        priority: 8,\r\n        filters: {},\r\n        conditions: [],\r\n        actions: [\r\n          { type: 'notify', target: 'default', config: { channels: ['default'] }, enabled: true },\r\n        ],\r\n        escalationPath: [\r\n          { level: 1, delay: 900000, targets: ['critical'], conditions: ['unacknowledged'] }, // 15 minutes\r\n        ],\r\n        suppressions: [],\r\n        tags: { category: 'accuracy', auto_created: 'true' },\r\n        createdBy: 'system',\r\n      },\r\n      {\r\n        name: 'High Human Intervention Rate',\r\n        description: 'Alert when human intervention rate exceeds threshold',\r\n        enabled: true,\r\n        metric: '*',\r\n        operator: 'gt',\r\n        threshold: this.config.alertThresholds.interventionRateThreshold,\r\n        duration: 600000, // 10 minutes\r\n        severity: 'warning',\r\n        category: 'high_intervention_rate',\r\n        priority: 6,\r\n        filters: { 'context.verificationMethod': 'human' },\r\n        conditions: [],\r\n        actions: [\r\n          { type: 'notify', target: 'default', config: { channels: ['default'] }, enabled: true },\r\n        ],\r\n        escalationPath: [],\r\n        suppressions: [],\r\n        tags: { category: 'efficiency', auto_created: 'true' },\r\n        createdBy: 'system',\r\n      },\r\n    ];\r\n    \r\n    defaultRules.forEach(rule => this.createAlertRule(rule));\r\n  }\r\n  \r\n  private initializeDefaultChannels(): void {\r\n    // Create default notification channels\r\n    const defaultChannels: Omit<AlertChannel, 'id'>[] = [\r\n      {\r\n        name: 'Default Log Channel',\r\n        type: 'email',\r\n        config: { to: 'admin@example.com' },\r\n        enabled: true,\r\n        filters: [],\r\n        rateLimits: [\r\n          { window: 300000, maxAlerts: 10, currentCount: 0 }, // 10 alerts per 5 minutes\r\n        ],\r\n      },\r\n      {\r\n        name: 'Critical Alerts',\r\n        type: 'slack',\r\n        config: { webhook: 'https://hooks.slack.com/services/...' },\r\n        enabled: false, // Disabled until configured\r\n        filters: [\r\n          { field: 'severity', operator: 'eq', values: ['critical', 'emergency'], action: 'include' },\r\n        ],\r\n        rateLimits: [\r\n          { window: 60000, maxAlerts: 5, currentCount: 0 }, // 5 alerts per minute\r\n        ],\r\n      },\r\n    ];\r\n    \r\n    defaultChannels.forEach(channel => {\r\n      const channelId = `channel-${Date.now()}-${Math.random().toString(36).slice(2)}`;\r\n      this.alertChannels.set(channelId, { ...channel, id: channelId });\r\n    });\r\n  }\r\n  \r\n  private initializeStatistics(): AlertStatistics {\r\n    return {\r\n      totalAlerts: 0,\r\n      activeAlerts: 0,\r\n      resolvedAlerts: 0,\r\n      averageResolutionTime: 0,\r\n      alertsByType: {},\r\n      alertsBySeverity: {},\r\n      topAlertSources: [],\r\n      escalationRate: 0,\r\n      falsePositiveRate: 0,\r\n    };\r\n  }\r\n  \r\n  // ========================================================================================\r\n  // Public API\r\n  // ========================================================================================\r\n  \r\n  getActiveAlerts(): TruthAlert[] {\r\n    return Array.from(this.activeAlerts.values()).filter(a => !a.resolved);\r\n  }\r\n  \r\n  getAlert(alertId: string): TruthAlert | undefined {\r\n    return this.activeAlerts.get(alertId);\r\n  }\r\n  \r\n  getAlertHistory(alertId?: string, limit: number = 100): AlertHistory[] {\r\n    let history = this.alertHistory;\r\n    \r\n    if (alertId) {\r\n      history = history.filter(h => h.alertId === alertId);\r\n    }\r\n    \r\n    return history.slice(-limit);\r\n  }\r\n  \r\n  getAlertRules(): AlertRule[] {\r\n    return Array.from(this.alertRules.values());\r\n  }\r\n  \r\n  getAlertChannels(): AlertChannel[] {\r\n    return Array.from(this.alertChannels.values());\r\n  }\r\n  \r\n  getStatistics(): AlertStatistics {\r\n    return { ...this.statistics };\r\n  }\r\n  \r\n  createSuppression(alertId: string, suppression: Omit<AlertSuppression, 'id'>): string {\r\n    const suppressionId = `suppression-${Date.now()}`;\r\n    this.suppressions.set(suppressionId, { ...suppression, id: suppressionId });\r\n    return suppressionId;\r\n  }\r\n  \r\n  removeSuppression(suppressionId: string): boolean {\r\n    return this.suppressions.delete(suppressionId);\r\n  }\r\n}\r\n\r\n// ========================================================================================\r\n// Supporting Interfaces\r\n// ========================================================================================\r\n\r\ninterface MetricState {\r\n  key: string;\r\n  currentValue: number;\r\n  previousValue: number;\r\n  lastUpdate: Date;\r\n  changeRate: number;\r\n  samples: number[];\r\n  thresholdViolations: Map<string, ThresholdViolation>;\r\n}\r\n\r\ninterface ThresholdViolation {\r\n  ruleId: string;\r\n  startTime: Date;\r\n  lastSeen: Date;\r\n  count: number;\r\n  alertId: string | null;\r\n}"],"names":["TruthAlertManager","config","logger","eventBus","alertRules","Map","activeAlerts","alertHistory","alertChannels","suppressions","thresholdGroups","metricStates","processingInterval","escalationInterval","cleanupInterval","statistics","initializeStatistics","initializeDefaultRules","initializeDefaultChannels","initialize","info","alertEnabled","thresholds","alertThresholds","startAlertProcessing","startEscalationProcessing","startCleanupProcessing","loadAlertConfiguration","rules","size","channels","shutdown","clearInterval","saveAlertConfiguration","checkThresholds","metric","updateMetricState","applicableRules","getApplicableRules","rule","evaluateRule","error","metricId","id","key","agentId","metricType","state","get","currentValue","value","previousValue","lastUpdate","timestamp","changeRate","samples","thresholdViolations","set","timeDiff","getTime","valueDiff","push","length","slice","Array","from","values","filter","enabled","matchesFilters","filters","matchesConditions","conditions","conditionMet","evaluateCondition","handleThresholdViolation","handleThresholdClearance","threshold","operator","Math","abs","violationKey","violation","ruleId","startTime","lastSeen","count","alertId","duration","createAlert","resolveAlert","delete","Date","now","random","toString","alert","severity","type","category","message","generateAlertMessage","source","context","ruleName","name","metricValue","violationCount","taskId","actions","escalationPath","resolved","totalAlerts","alertsByType","alertsBySeverity","warn","agent","addToHistory","emit","executeAlertActions","action","executeAction","actionType","sendNotification","escalateAlert","autoRemediate","suspendAgent","restartAgent","channelIds","channelId","channel","alertMatchesChannelFilters","checkRateLimit","sendToChannel","sendEmailNotification","sendSlackNotification","sendWebhookNotification","sendTeamsNotification","sendDiscordNotification","sendPagerDutyNotification","escalationLevel","level","escalation","find","e","checkEscalationConditions","getEscalatedSeverity","sendEscalationNotifications","targets","escalationRate","calculateEscalationRate","target","remediationType","scaleResources","adjustThresholds","redistributeLoad","initiateFailover","reason","direction","factor","adjustment","oldThreshold","newThreshold","excludeAgents","primaryAgent","resolvedBy","resolvedAt","resolutionReason","resolvedAlerts","resolutionTime","updateAverageResolutionTime","acknowledgeAlert","acknowledgedBy","comment","acknowledged","acknowledgedAt","acknowledgmentComment","createAlertRule","fullRule","createdAt","lastModified","updateAlertRule","updates","updatedRule","deleteAlertRule","deleted","setInterval","processActiveAlerts","processEscalations","cleanupResolvedAlerts","cleanupOldHistory","resetRateLimits","processAlert","checkAutoResolution","checkEscalation","updateAlertStatistics","getCurrentMetricValue","evaluateConditionValue","alertAge","nextEscalation","delay","toFixed","Object","entries","getMetricProperty","result","currentOperator","condition","field","conditionResult","logicalOperator","path","parts","split","part","String","includes","startsWith","endsWith","alertValue","matches","rateLimit","rateLimits","resetTime","currentCount","window","maxAlerts","checkDurationCondition","match","parseInt","unit","multiplier","thresholdMs","durationMs","currentSeverity","actor","details","cutoff","h","existing","topAlertSources","s","sort","a","b","currentAvg","averageResolutionTime","escalatedAlerts","to","webhook","url","serviceKey","debug","defaultRules","description","accuracyThreshold","priority","tags","auto_created","createdBy","interventionRateThreshold","forEach","defaultChannels","falsePositiveRate","getActiveAlerts","getAlert","getAlertHistory","limit","history","getAlertRules","getAlertChannels","getStatistics","createSuppression","suppression","suppressionId","removeSuppression"],"mappings":"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"}