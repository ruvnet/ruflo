{
  "version": 3,
  "sources": ["../../src/monitoring/health-check.ts"],
  "sourcesContent": ["/**\n * Health Check System for Claude Flow v2.0.0\n */\n\nimport { EventBus } from '../core/event-bus.js';\nimport { Logger } from '../core/logger.js';\nimport { SystemIntegration } from '../integration/system-integration.js';\nimport type {\n  HealthCheckResult,\n  ComponentStatus,\n  SystemHealth,\n  SystemMetrics,\n} from '../integration/types.js';\nimport { getErrorMessage } from '../utils/error-handler.js';\n\nexport interface HealthCheckConfig {\n  interval?: number; // Health check interval in ms (default: 30000)\n  timeout?: number; // Health check timeout in ms (default: 5000)\n  retries?: number; // Number of retries for failed checks (default: 3)\n  enableMetrics?: boolean; // Collect system metrics (default: true)\n  enableAlerts?: boolean; // Send alerts on health issues (default: true)\n}\n\nexport interface AlertConfig {\n  webhook?: string;\n  email?: string;\n  slack?: string;\n  threshold?: number; // Alert threshold for unhealthy components\n}\n\nexport class HealthCheckManager {\n  private eventBus: EventBus;\n  private logger: Logger;\n  private systemIntegration: SystemIntegration;\n  private config: Required<HealthCheckConfig>;\n  private intervalId: NodeJS.Timeout | null = null;\n  private healthHistory: Map<string, HealthCheckResult[]> = new Map();\n  private isRunning = false;\n  private lastMetrics: SystemMetrics | null = null;\n\n  constructor(eventBus: EventBus, logger: Logger, config: HealthCheckConfig = {}) {\n    this.eventBus = eventBus;\n    this.logger = logger;\n    this.systemIntegration = SystemIntegration.getInstance();\n\n    this.config = {\n      interval: config.interval || 30000, // 30 seconds\n      timeout: config.timeout || 5000, // 5 seconds\n      retries: config.retries || 3,\n      enableMetrics: config.enableMetrics !== false,\n      enableAlerts: config.enableAlerts !== false,\n    };\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Start health monitoring\n   */\n  start(): void {\n    if (this.isRunning) {\n      this.logger.warn('Health check manager already running');\n      return;\n    }\n\n    this.logger.info('Starting health check monitoring');\n    this.isRunning = true;\n\n    // Perform initial health check\n    this.performHealthCheck();\n\n    // Set up periodic health checks\n    this.intervalId = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.interval);\n\n    this.eventBus.emit('health:monitor:started', {\n      interval: this.config.interval,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stop(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    this.logger.info('Stopping health check monitoring');\n    this.isRunning = false;\n\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n\n    this.eventBus.emit('health:monitor:stopped', {\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Perform comprehensive health check\n   */\n  async performHealthCheck(): Promise<SystemHealth> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.debug('Performing system health check');\n\n      // Get system health from integration manager\n      const systemHealth = await this.systemIntegration.getSystemHealth();\n\n      // Perform individual component checks\n      const componentChecks = await this.checkAllComponents();\n\n      // Collect system metrics if enabled\n      if (this.config.enableMetrics) {\n        this.lastMetrics = await this.collectSystemMetrics();\n      }\n\n      // Store health history\n      this.storeHealthHistory(componentChecks);\n\n      // Check for alerts\n      if (this.config.enableAlerts) {\n        await this.checkForAlerts(systemHealth);\n      }\n\n      const duration = Date.now() - startTime;\n      this.logger.debug(`Health check completed in ${duration}ms`);\n\n      // Emit health check event\n      this.eventBus.emit('health:check:completed', {\n        health: systemHealth,\n        metrics: this.lastMetrics,\n        duration,\n        timestamp: Date.now(),\n      });\n\n      return systemHealth;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.error('Health check failed:', getErrorMessage(error));\n\n      this.eventBus.emit('health:check:failed', {\n        error: getErrorMessage(error),\n        duration,\n        timestamp: Date.now(),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Check all system components\n   */\n  private async checkAllComponents(): Promise<HealthCheckResult[]> {\n    const components = [\n      'orchestrator',\n      'configManager',\n      'memoryManager',\n      'agentManager',\n      'swarmCoordinator',\n      'taskEngine',\n      'monitor',\n      'mcpServer',\n    ];\n\n    const checks = await Promise.allSettled(\n      components.map((component) => this.checkComponent(component)),\n    );\n\n    return checks.map((result, index) => {\n      if (result.status === 'fulfilled') {\n        return result.value;\n      } else {\n        return {\n          component: components[index],\n          healthy: false,\n          message: getErrorMessage(result.reason),\n          timestamp: Date.now(),\n        };\n      }\n    });\n  }\n\n  /**\n   * Check individual component health\n   */\n  private async checkComponent(componentName: string): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n\n    try {\n      const component = this.systemIntegration.getComponent(componentName);\n\n      if (!component) {\n        return {\n          component: componentName,\n          healthy: false,\n          message: 'Component not found',\n          timestamp: Date.now(),\n        };\n      }\n\n      // Try to call health check method if available\n      if (typeof component.healthCheck === 'function') {\n        const result = await Promise.race([\n          component.healthCheck(),\n          new Promise((_, reject) =>\n            setTimeout(() => reject(new Error('Health check timeout')), this.config.timeout),\n          ),\n        ]);\n        return result as HealthCheckResult;\n      }\n\n      // Basic availability check\n      const duration = Date.now() - startTime;\n      return {\n        component: componentName,\n        healthy: true,\n        message: 'Component available',\n        metrics: { responseTime: duration },\n        timestamp: Date.now(),\n      };\n    } catch (error) {\n      return {\n        component: componentName,\n        healthy: false,\n        message: getErrorMessage(error),\n        timestamp: Date.now(),\n      };\n    }\n  }\n\n  /**\n   * Collect system metrics\n   */\n  private async collectSystemMetrics(): Promise<SystemMetrics> {\n    const startTime = Date.now();\n\n    try {\n      // Get system resource usage\n      const memoryUsage = process.memoryUsage();\n      const cpuUsage = process.cpuUsage();\n\n      // Get component-specific metrics\n      const agentManager = this.systemIntegration.getComponent('agentManager');\n      const taskEngine = this.systemIntegration.getComponent('taskEngine');\n\n      let activeAgents = 0;\n      let activeTasks = 0;\n      let queuedTasks = 0;\n      let completedTasks = 0;\n\n      if (agentManager && typeof agentManager.getMetrics === 'function') {\n        const agentMetrics = await agentManager.getMetrics();\n        activeAgents = agentMetrics.activeAgents || 0;\n      }\n\n      if (taskEngine && typeof taskEngine.getMetrics === 'function') {\n        const taskMetrics = await taskEngine.getMetrics();\n        activeTasks = taskMetrics.activeTasks || 0;\n        queuedTasks = taskMetrics.queuedTasks || 0;\n        completedTasks = taskMetrics.completedTasks || 0;\n      }\n\n      return {\n        cpu: (cpuUsage.user + cpuUsage.system) / 1000000, // Convert to percentage\n        memory: (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100,\n        network: 0, // Placeholder - would need additional monitoring\n        disk: 0, // Placeholder - would need additional monitoring\n        activeAgents,\n        activeTasks,\n        queuedTasks,\n        completedTasks,\n        errorCount: this.getErrorCount(),\n        uptime: process.uptime() * 1000,\n        timestamp: Date.now(),\n      };\n    } catch (error) {\n      this.logger.error('Failed to collect system metrics:', getErrorMessage(error));\n      return {\n        cpu: 0,\n        memory: 0,\n        network: 0,\n        disk: 0,\n        activeAgents: 0,\n        activeTasks: 0,\n        queuedTasks: 0,\n        completedTasks: 0,\n        errorCount: 0,\n        uptime: process.uptime() * 1000,\n        timestamp: Date.now(),\n      };\n    }\n  }\n\n  /**\n   * Store health check history\n   */\n  private storeHealthHistory(results: HealthCheckResult[]): void {\n    const maxHistorySize = 100; // Keep last 100 health checks per component\n\n    results.forEach((result) => {\n      if (!this.healthHistory.has(result.component)) {\n        this.healthHistory.set(result.component, []);\n      }\n\n      const history = this.healthHistory.get(result.component)!;\n      history.push(result);\n\n      // Trim history if too large\n      if (history.length > maxHistorySize) {\n        history.splice(0, history.length - maxHistorySize);\n      }\n    });\n  }\n\n  /**\n   * Check for alerts and send notifications\n   */\n  private async checkForAlerts(health: SystemHealth): Promise<void> {\n    const unhealthyComponents = Object.values(health.components).filter(\n      (component) => component.status === 'unhealthy',\n    );\n\n    if (unhealthyComponents.length > 0) {\n      const alert = {\n        type: 'component_failure',\n        severity: 'high',\n        message: `${unhealthyComponents.length} component(s) are unhealthy`,\n        components: unhealthyComponents.map((c) => c.component),\n        timestamp: Date.now(),\n      };\n\n      this.eventBus.emit('health:alert', alert);\n      this.logger.warn('Health alert triggered:', alert.message);\n    }\n\n    // Check system metrics for anomalies\n    if (this.lastMetrics) {\n      const alerts = [];\n\n      if (this.lastMetrics.cpu > 90) {\n        alerts.push({\n          type: 'high_cpu',\n          severity: 'medium',\n          message: `High CPU usage: ${this.lastMetrics.cpu.toFixed(1)}%`,\n          value: this.lastMetrics.cpu,\n        });\n      }\n\n      if (this.lastMetrics.memory > 90) {\n        alerts.push({\n          type: 'high_memory',\n          severity: 'medium',\n          message: `High memory usage: ${this.lastMetrics.memory.toFixed(1)}%`,\n          value: this.lastMetrics.memory,\n        });\n      }\n\n      if (this.lastMetrics.errorCount > 10) {\n        alerts.push({\n          type: 'high_errors',\n          severity: 'high',\n          message: `High error count: ${this.lastMetrics.errorCount}`,\n          value: this.lastMetrics.errorCount,\n        });\n      }\n\n      alerts.forEach((alert) => {\n        this.eventBus.emit('health:alert', {\n          ...alert,\n          timestamp: Date.now(),\n        });\n      });\n    }\n  }\n\n  /**\n   * Get component health history\n   */\n  getHealthHistory(component?: string): HealthCheckResult[] {\n    if (component) {\n      return this.healthHistory.get(component) || [];\n    }\n\n    // Return all history\n    const allHistory: HealthCheckResult[] = [];\n    for (const history of this.healthHistory.values()) {\n      allHistory.push(...history);\n    }\n\n    return allHistory.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Get current system metrics\n   */\n  getCurrentMetrics(): SystemMetrics | null {\n    return this.lastMetrics;\n  }\n\n  /**\n   * Get system health status\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    return await this.systemIntegration.getSystemHealth();\n  }\n\n  /**\n   * Get error count from recent history\n   */\n  private getErrorCount(): number {\n    const recentTime = Date.now() - 300000; // Last 5 minutes\n    let errorCount = 0;\n\n    for (const history of this.healthHistory.values()) {\n      errorCount += history.filter(\n        (check) => check.timestamp > recentTime && !check.healthy,\n      ).length;\n    }\n\n    return errorCount;\n  }\n\n  /**\n   * Setup event handlers\n   */\n  private setupEventHandlers(): void {\n    // Listen for component status changes\n    this.eventBus.on('component:status:updated', (status: ComponentStatus) => {\n      if (status.status === 'unhealthy') {\n        this.logger.warn(`Component ${status.component} became unhealthy: ${status.message}`);\n      }\n    });\n\n    // Listen for system errors\n    this.eventBus.on('system:error', (error) => {\n      this.logger.error('System error detected:', error);\n    });\n  }\n\n  /**\n   * Check if monitoring is running\n   */\n  isMonitoring(): boolean {\n    return this.isRunning;\n  }\n\n  /**\n   * Get monitoring configuration\n   */\n  getConfig(): Required<HealthCheckConfig> {\n    return { ...this.config };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
