{
  "version": 3,
  "sources": ["../../../../src/cli/commands/start/process-manager.ts"],
  "sourcesContent": ["/**\n * Process Manager - Handles lifecycle of system processes\n */\n\nimport { EventEmitter } from './event-emitter.js';\nimport chalk from 'chalk';\nimport { ProcessInfo, ProcessType, ProcessStatus, ProcessMetrics, SystemStats } from './types.js';\nimport { Orchestrator } from '../../../core/orchestrator.js';\nimport { TerminalManager } from '../../../terminal/manager.js';\nimport { MemoryManager } from '../../../memory/manager.js';\nimport { CoordinationManager } from '../../../coordination/manager.js';\nimport { MCPServer } from '../../../mcp/server.js';\nimport { eventBus } from '../../../core/event-bus.js';\nimport { logger } from '../../../core/logger.js';\nimport { configManager } from '../../../core/config.js';\n\nexport class ProcessManager extends EventEmitter {\n  private processes: Map<string, ProcessInfo> = new Map();\n  private orchestrator: Orchestrator | undefined;\n  private terminalManager: TerminalManager | undefined;\n  private memoryManager: MemoryManager | undefined;\n  private coordinationManager: CoordinationManager | undefined;\n  private mcpServer: MCPServer | undefined;\n  private config: any;\n\n  constructor() {\n    super();\n    this.initializeProcesses();\n  }\n\n  private initializeProcesses(): void {\n    // Define all manageable processes\n    const processDefinitions: ProcessInfo[] = [\n      {\n        id: 'event-bus',\n        name: 'Event Bus',\n        type: ProcessType.EVENT_BUS,\n        status: ProcessStatus.STOPPED,\n      },\n      {\n        id: 'orchestrator',\n        name: 'Orchestrator Engine',\n        type: ProcessType.ORCHESTRATOR,\n        status: ProcessStatus.STOPPED,\n      },\n      {\n        id: 'memory-manager',\n        name: 'Memory Manager',\n        type: ProcessType.MEMORY_MANAGER,\n        status: ProcessStatus.STOPPED,\n      },\n      {\n        id: 'terminal-pool',\n        name: 'Terminal Pool',\n        type: ProcessType.TERMINAL_POOL,\n        status: ProcessStatus.STOPPED,\n      },\n      {\n        id: 'mcp-server',\n        name: 'MCP Server',\n        type: ProcessType.MCP_SERVER,\n        status: ProcessStatus.STOPPED,\n      },\n      {\n        id: 'coordinator',\n        name: 'Coordination Manager',\n        type: ProcessType.COORDINATOR,\n        status: ProcessStatus.STOPPED,\n      },\n    ];\n\n    for (const process of processDefinitions) {\n      this.processes.set(process.id, process);\n    }\n  }\n\n  async initialize(configPath?: string): Promise<void> {\n    try {\n      this.config = await configManager.load(configPath);\n      this.emit('initialized', { config: this.config });\n    } catch (error) {\n      this.emit('error', { component: 'ProcessManager', error });\n      throw error;\n    }\n  }\n\n  async startProcess(processId: string): Promise<void> {\n    const process = this.processes.get(processId);\n    if (!process) {\n      throw new Error(`Unknown process: ${processId}`);\n    }\n\n    if (process.status === ProcessStatus.RUNNING) {\n      throw new Error(`Process ${processId} is already running`);\n    }\n\n    this.updateProcessStatus(processId, ProcessStatus.STARTING);\n\n    try {\n      switch (process.type) {\n        case ProcessType.EVENT_BUS:\n          // Event bus is already initialized globally\n          process.pid = Deno.pid;\n          break;\n\n        case ProcessType.MEMORY_MANAGER:\n          this.memoryManager = new MemoryManager(this.config.memory, eventBus, logger);\n          await this.memoryManager.initialize();\n          break;\n\n        case ProcessType.TERMINAL_POOL:\n          this.terminalManager = new TerminalManager(this.config.terminal, eventBus, logger);\n          await this.terminalManager.initialize();\n          break;\n\n        case ProcessType.COORDINATOR:\n          this.coordinationManager = new CoordinationManager(\n            this.config.coordination,\n            eventBus,\n            logger,\n          );\n          await this.coordinationManager.initialize();\n          break;\n\n        case ProcessType.MCP_SERVER:\n          this.mcpServer = new MCPServer(this.config.mcp, eventBus, logger);\n          await this.mcpServer.start();\n          break;\n\n        case ProcessType.ORCHESTRATOR:\n          if (\n            !this.terminalManager ||\n            !this.memoryManager ||\n            !this.coordinationManager ||\n            !this.mcpServer\n          ) {\n            throw new Error('Required components not initialized');\n          }\n\n          this.orchestrator = new Orchestrator(\n            this.config,\n            this.terminalManager,\n            this.memoryManager,\n            this.coordinationManager,\n            this.mcpServer,\n            eventBus,\n            logger,\n          );\n          await this.orchestrator.initialize();\n          break;\n      }\n\n      process.startTime = Date.now();\n      this.updateProcessStatus(processId, ProcessStatus.RUNNING);\n      this.emit('processStarted', { processId, process });\n    } catch (error) {\n      this.updateProcessStatus(processId, ProcessStatus.ERROR);\n      process.metrics = {\n        ...process.metrics,\n        lastError: (error as Error).message,\n      };\n      this.emit('processError', { processId, error });\n      throw error;\n    }\n  }\n\n  async stopProcess(processId: string): Promise<void> {\n    const process = this.processes.get(processId);\n    if (!process || process.status !== ProcessStatus.RUNNING) {\n      throw new Error(`Process ${processId} is not running`);\n    }\n\n    this.updateProcessStatus(processId, ProcessStatus.STOPPING);\n\n    try {\n      switch (process.type) {\n        case ProcessType.ORCHESTRATOR:\n          if (this.orchestrator) {\n            await this.orchestrator.shutdown();\n            this.orchestrator = undefined;\n          }\n          break;\n\n        case ProcessType.MCP_SERVER:\n          if (this.mcpServer) {\n            await this.mcpServer.stop();\n            this.mcpServer = undefined;\n          }\n          break;\n\n        case ProcessType.MEMORY_MANAGER:\n          if (this.memoryManager) {\n            await this.memoryManager.shutdown();\n            this.memoryManager = undefined;\n          }\n          break;\n\n        case ProcessType.TERMINAL_POOL:\n          if (this.terminalManager) {\n            await this.terminalManager.shutdown();\n            this.terminalManager = undefined;\n          }\n          break;\n\n        case ProcessType.COORDINATOR:\n          if (this.coordinationManager) {\n            await this.coordinationManager.shutdown();\n            this.coordinationManager = undefined;\n          }\n          break;\n      }\n\n      this.updateProcessStatus(processId, ProcessStatus.STOPPED);\n      this.emit('processStopped', { processId });\n    } catch (error) {\n      this.updateProcessStatus(processId, ProcessStatus.ERROR);\n      this.emit('processError', { processId, error });\n      throw error;\n    }\n  }\n\n  async restartProcess(processId: string): Promise<void> {\n    await this.stopProcess(processId);\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // Brief delay\n    await this.startProcess(processId);\n  }\n\n  async startAll(): Promise<void> {\n    // Start in dependency order\n    const startOrder = [\n      'event-bus',\n      'memory-manager',\n      'terminal-pool',\n      'coordinator',\n      'mcp-server',\n      'orchestrator',\n    ];\n\n    for (const processId of startOrder) {\n      try {\n        await this.startProcess(processId);\n      } catch (error) {\n        console.error(chalk.red(`Failed to start ${processId}:`), (error as Error).message);\n        // Continue with other processes\n      }\n    }\n  }\n\n  async stopAll(): Promise<void> {\n    // Stop in reverse dependency order\n    const stopOrder = [\n      'orchestrator',\n      'mcp-server',\n      'coordinator',\n      'terminal-pool',\n      'memory-manager',\n      'event-bus',\n    ];\n\n    for (const processId of stopOrder) {\n      const process = this.processes.get(processId);\n      if (process && process.status === ProcessStatus.RUNNING) {\n        try {\n          await this.stopProcess(processId);\n        } catch (error) {\n          console.error(chalk.red(`Failed to stop ${processId}:`), (error as Error).message);\n        }\n      }\n    }\n  }\n\n  getProcess(processId: string): ProcessInfo | undefined {\n    return this.processes.get(processId);\n  }\n\n  getAllProcesses(): ProcessInfo[] {\n    return Array.from(this.processes.values());\n  }\n\n  getSystemStats(): SystemStats {\n    const processes = this.getAllProcesses();\n    const runningProcesses = processes.filter((p) => p.status === ProcessStatus.RUNNING);\n    const stoppedProcesses = processes.filter((p) => p.status === ProcessStatus.STOPPED);\n    const errorProcesses = processes.filter((p) => p.status === ProcessStatus.ERROR);\n\n    return {\n      totalProcesses: processes.length,\n      runningProcesses: runningProcesses.length,\n      stoppedProcesses: stoppedProcesses.length,\n      errorProcesses: errorProcesses.length,\n      systemUptime: this.getSystemUptime(),\n      totalMemory: this.getTotalMemoryUsage(),\n      totalCpu: this.getTotalCpuUsage(),\n    };\n  }\n\n  private updateProcessStatus(processId: string, status: ProcessStatus): void {\n    const process = this.processes.get(processId);\n    if (process) {\n      process.status = status;\n      this.emit('statusChanged', { processId, status });\n    }\n  }\n\n  private getSystemUptime(): number {\n    const orchestrator = this.processes.get('orchestrator');\n    if (orchestrator && orchestrator.startTime) {\n      return Date.now() - orchestrator.startTime;\n    }\n    return 0;\n  }\n\n  private getTotalMemoryUsage(): number {\n    // Placeholder - would integrate with actual memory monitoring\n    return 0;\n  }\n\n  private getTotalCpuUsage(): number {\n    // Placeholder - would integrate with actual CPU monitoring\n    return 0;\n  }\n\n  async getProcessLogs(processId: string, lines: number = 50): Promise<string[]> {\n    // Placeholder - would integrate with actual logging system\n    return [\n      `[${new Date().toISOString()}] Process ${processId} started`,\n      `[${new Date().toISOString()}] Process ${processId} is running normally`,\n    ];\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_manager", "chalk"]
}
