{"version":3,"sources":["../../../src/verification/rollback-engine.ts"],"sourcesContent":["/**\r\n * Rollback Engine\r\n * Handles state restoration and rollback operations with safety checks\r\n */\r\n\r\nimport { \r\n  StateSnapshot, \r\n  RollbackResult, \r\n  RollbackOptions, \r\n  RollbackMode,\r\n  VerificationDetails,\r\n  AgentState,\r\n  SystemState,\r\n  TaskState,\r\n  MemoryState,\r\n  FileSystemState,\r\n  DatabaseState,\r\n  ConsistencyReport,\r\n  Inconsistency\r\n} from './interfaces.js';\r\nimport { CheckpointManager } from './checkpoint-manager.js';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\nimport { createHash } from 'crypto';\r\n\r\nexport class RollbackEngine {\r\n  private checkpointManager: CheckpointManager;\r\n  private rollbackHistory: RollbackResult[] = [];\r\n  private maxRollbackHistory = 100;\r\n\r\n  constructor(checkpointManager: CheckpointManager) {\r\n    this.checkpointManager = checkpointManager;\r\n  }\r\n\r\n  /**\r\n   * Rollback to a specific checkpoint\r\n   */\r\n  async rollbackToCheckpoint(\r\n    checkpointId: string,\r\n    options: Partial<RollbackOptions> = {}\r\n  ): Promise<RollbackResult> {\r\n    const rollbackStart = Date.now();\r\n    const defaultOptions: RollbackOptions = {\r\n      mode: 'strict',\r\n      verify_before_rollback: true,\r\n      verify_after_rollback: true,\r\n      create_backup_before: true,\r\n      components_to_rollback: ['agents', 'tasks', 'memory', 'filesystem', 'database'],\r\n      exclude_components: []\r\n    };\r\n\r\n    const rollbackOptions = { ...defaultOptions, ...options };\r\n    \r\n    console.log(`üîÑ Starting rollback to checkpoint ${checkpointId} with mode: ${rollbackOptions.mode}`);\r\n\r\n    try {\r\n      // 1. Get the target checkpoint\r\n      const checkpoint = await this.checkpointManager.getCheckpoint(checkpointId);\r\n      if (!checkpoint) {\r\n        throw new Error(`Checkpoint ${checkpointId} not found`);\r\n      }\r\n\r\n      // 2. Create backup if requested\r\n      let backupCheckpointId: string | undefined;\r\n      if (rollbackOptions.create_backup_before) {\r\n        backupCheckpointId = await this.checkpointManager.createCheckpoint(\r\n          `Backup before rollback to ${checkpointId}`,\r\n          'global'\r\n        );\r\n        console.log(`üíæ Created backup checkpoint: ${backupCheckpointId}`);\r\n      }\r\n\r\n      // 3. Verify rollback is safe (if requested)\r\n      if (rollbackOptions.verify_before_rollback) {\r\n        const safetyCheck = await this.verifyRollbackSafety(checkpoint.state_snapshot, rollbackOptions);\r\n        if (!safetyCheck.safe && rollbackOptions.mode === 'strict') {\r\n          throw new Error(`Unsafe rollback detected: ${safetyCheck.reasons.join(', ')}`);\r\n        } else if (!safetyCheck.safe && rollbackOptions.mode === 'partial') {\r\n          console.warn(`‚ö†Ô∏è Safety concerns detected but proceeding in partial mode: ${safetyCheck.reasons.join(', ')}`);\r\n        }\r\n      }\r\n\r\n      // 4. Execute rollback\r\n      const affectedComponents = await this.executeRollback(\r\n        checkpoint.state_snapshot, \r\n        rollbackOptions\r\n      );\r\n\r\n      // 5. Verify rollback success (if requested)\r\n      let verificationDetails: VerificationDetails = {\r\n        verified: true,\r\n        checks_performed: [],\r\n        failed_checks: [],\r\n        verification_time_ms: 0\r\n      };\r\n\r\n      if (rollbackOptions.verify_after_rollback) {\r\n        verificationDetails = await this.verifyRollbackSuccess(\r\n          checkpoint.state_snapshot,\r\n          rollbackOptions\r\n        );\r\n      }\r\n\r\n      // 6. Create rollback result\r\n      const rollbackResult: RollbackResult = {\r\n        success: verificationDetails.verified,\r\n        checkpoint_id: checkpointId,\r\n        rollback_time_ms: Date.now() - rollbackStart,\r\n        verification_details: verificationDetails,\r\n        affected_components: affectedComponents,\r\n        error_message: verificationDetails.verified ? undefined : 'Rollback verification failed'\r\n      };\r\n\r\n      // 7. Store rollback history\r\n      this.addToRollbackHistory(rollbackResult);\r\n\r\n      if (rollbackResult.success) {\r\n        console.log(`‚úÖ Rollback completed successfully in ${rollbackResult.rollback_time_ms}ms`);\r\n      } else {\r\n        console.error(`‚ùå Rollback failed: ${rollbackResult.error_message}`);\r\n      }\r\n\r\n      return rollbackResult;\r\n\r\n    } catch (error: any) {\r\n      const rollbackResult: RollbackResult = {\r\n        success: false,\r\n        checkpoint_id: checkpointId,\r\n        rollback_time_ms: Date.now() - rollbackStart,\r\n        verification_details: {\r\n          verified: false,\r\n          checks_performed: [],\r\n          failed_checks: ['rollback_execution'],\r\n          verification_time_ms: 0\r\n        },\r\n        affected_components: [],\r\n        error_message: error.message\r\n      };\r\n\r\n      this.addToRollbackHistory(rollbackResult);\r\n      \r\n      // Attempt emergency recovery if in strict mode\r\n      if (rollbackOptions.mode === 'strict') {\r\n        await this.attemptEmergencyRecovery(error);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify rollback safety before execution\r\n   */\r\n  private async verifyRollbackSafety(\r\n    targetSnapshot: StateSnapshot,\r\n    options: RollbackOptions\r\n  ): Promise<{ safe: boolean; reasons: string[] }> {\r\n    const reasons: string[] = [];\r\n    let safe = true;\r\n\r\n    console.log(`üîç Verifying rollback safety...`);\r\n\r\n    // Check snapshot integrity\r\n    const integrityCheck = await this.verifySnapshotIntegrity(targetSnapshot);\r\n    if (!integrityCheck.valid) {\r\n      reasons.push(`Snapshot integrity check failed: ${integrityCheck.error}`);\r\n      safe = false;\r\n    }\r\n\r\n    // Check for critical system changes\r\n    const currentSnapshot = await this.captureCurrentSnapshot();\r\n    const criticalChanges = await this.detectCriticalChanges(currentSnapshot, targetSnapshot);\r\n    if (criticalChanges.length > 0) {\r\n      reasons.push(`Critical changes detected: ${criticalChanges.join(', ')}`);\r\n      if (options.mode === 'strict') {\r\n        safe = false;\r\n      }\r\n    }\r\n\r\n    // Check for active operations\r\n    const activeOperations = await this.checkActiveOperations();\r\n    if (activeOperations.length > 0) {\r\n      reasons.push(`Active operations detected: ${activeOperations.join(', ')}`);\r\n      if (options.mode === 'strict') {\r\n        safe = false;\r\n      }\r\n    }\r\n\r\n    // Check resource locks\r\n    const resourceLocks = await this.checkResourceLocks();\r\n    if (resourceLocks.length > 0) {\r\n      reasons.push(`Resource locks detected: ${resourceLocks.join(', ')}`);\r\n      safe = false;\r\n    }\r\n\r\n    // Check dependency constraints\r\n    const dependencyIssues = await this.checkDependencyConstraints(targetSnapshot);\r\n    if (dependencyIssues.length > 0) {\r\n      reasons.push(`Dependency issues: ${dependencyIssues.join(', ')}`);\r\n      safe = false;\r\n    }\r\n\r\n    return { safe, reasons };\r\n  }\r\n\r\n  /**\r\n   * Execute the actual rollback operation\r\n   */\r\n  private async executeRollback(\r\n    targetSnapshot: StateSnapshot,\r\n    options: RollbackOptions\r\n  ): Promise<string[]> {\r\n    const affectedComponents: string[] = [];\r\n\r\n    console.log(`üîÑ Executing rollback...`);\r\n\r\n    // 1. Suspend all agents\r\n    if (this.shouldRollbackComponent('agents', options)) {\r\n      await this.suspendAllAgents();\r\n      affectedComponents.push('agents');\r\n    }\r\n\r\n    // 2. Stop active tasks\r\n    if (this.shouldRollbackComponent('tasks', options)) {\r\n      await this.stopActiveTasks();\r\n      affectedComponents.push('tasks');\r\n    }\r\n\r\n    // 3. Restore states in order of dependency\r\n    try {\r\n      // Restore database state first (other components may depend on it)\r\n      if (this.shouldRollbackComponent('database', options)) {\r\n        await this.restoreDatabaseState(targetSnapshot.database_state);\r\n        affectedComponents.push('database');\r\n      }\r\n\r\n      // Restore filesystem state\r\n      if (this.shouldRollbackComponent('filesystem', options)) {\r\n        await this.restoreFileSystemState(targetSnapshot.file_system_state);\r\n        affectedComponents.push('filesystem');\r\n      }\r\n\r\n      // Restore memory state\r\n      if (this.shouldRollbackComponent('memory', options)) {\r\n        await this.restoreMemoryState(targetSnapshot.memory_state);\r\n        affectedComponents.push('memory');\r\n      }\r\n\r\n      // Restore system state\r\n      if (this.shouldRollbackComponent('system', options)) {\r\n        await this.restoreSystemState(targetSnapshot.system_state);\r\n        affectedComponents.push('system');\r\n      }\r\n\r\n      // Restore task states\r\n      if (this.shouldRollbackComponent('tasks', options)) {\r\n        await this.restoreTaskStates(targetSnapshot.task_states);\r\n        affectedComponents.push('tasks');\r\n      }\r\n\r\n      // Restore agent states last\r\n      if (this.shouldRollbackComponent('agents', options)) {\r\n        await this.restoreAgentStates(targetSnapshot.agent_states);\r\n        affectedComponents.push('agents');\r\n      }\r\n\r\n      // 4. Resume agents\r\n      if (this.shouldRollbackComponent('agents', options)) {\r\n        await this.resumeAllAgents();\r\n      }\r\n\r\n    } catch (error) {\r\n      // If rollback fails partway through, we need to handle this carefully\r\n      console.error(`‚ùå Rollback execution failed:`, error);\r\n      throw new Error(`Rollback execution failed: ${error}`);\r\n    }\r\n\r\n    return affectedComponents;\r\n  }\r\n\r\n  /**\r\n   * Verify rollback success\r\n   */\r\n  private async verifyRollbackSuccess(\r\n    targetSnapshot: StateSnapshot,\r\n    options: RollbackOptions\r\n  ): Promise<VerificationDetails> {\r\n    const verificationStart = Date.now();\r\n    const checksPerformed: string[] = [];\r\n    const failedChecks: string[] = [];\r\n\r\n    console.log(`‚úÖ Verifying rollback success...`);\r\n\r\n    // Capture current state after rollback\r\n    const currentSnapshot = await this.captureCurrentSnapshot();\r\n\r\n    // Verify each component that was rolled back\r\n    for (const component of options.components_to_rollback) {\r\n      if (options.exclude_components.includes(component)) continue;\r\n\r\n      checksPerformed.push(`verify_${component}_state`);\r\n\r\n      const verified = await this.verifyComponentState(\r\n        component,\r\n        targetSnapshot,\r\n        currentSnapshot\r\n      );\r\n\r\n      if (!verified) {\r\n        failedChecks.push(`verify_${component}_state`);\r\n      }\r\n    }\r\n\r\n    // Verify system consistency\r\n    checksPerformed.push('system_consistency');\r\n    const consistencyReport = await this.validateSystemConsistency();\r\n    if (!consistencyReport.consistent) {\r\n      failedChecks.push('system_consistency');\r\n    }\r\n\r\n    // Verify agent communication\r\n    checksPerformed.push('agent_communication');\r\n    const communicationWorking = await this.verifyAgentCommunication();\r\n    if (!communicationWorking) {\r\n      failedChecks.push('agent_communication');\r\n    }\r\n\r\n    const verificationDetails: VerificationDetails = {\r\n      verified: failedChecks.length === 0,\r\n      checks_performed: checksPerformed,\r\n      failed_checks: failedChecks,\r\n      verification_time_ms: Date.now() - verificationStart\r\n    };\r\n\r\n    return verificationDetails;\r\n  }\r\n\r\n  // Component restoration methods\r\n  private async restoreAgentStates(agentStates: Map<string, AgentState>): Promise<void> {\r\n    console.log(`ü§ñ Restoring agent states...`);\r\n    \r\n    for (const [agentId, agentState] of agentStates) {\r\n      try {\r\n        // This would integrate with the actual agent manager\r\n        await this.restoreIndividualAgentState(agentId, agentState);\r\n        console.log(`‚úÖ Restored agent: ${agentId}`);\r\n      } catch (error) {\r\n        console.error(`‚ùå Failed to restore agent ${agentId}:`, error);\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async restoreSystemState(systemState: SystemState): Promise<void> {\r\n    console.log(`‚öôÔ∏è Restoring system state...`);\r\n    \r\n    // Restore system configuration\r\n    await this.applySystemConfiguration(systemState.configuration);\r\n    \r\n    // Update system metrics (some may be read-only)\r\n    console.log(`‚úÖ System state restored`);\r\n  }\r\n\r\n  private async restoreTaskStates(taskStates: Map<string, TaskState>): Promise<void> {\r\n    console.log(`üìã Restoring task states...`);\r\n    \r\n    for (const [taskId, taskState] of taskStates) {\r\n      try {\r\n        await this.restoreIndividualTaskState(taskId, taskState);\r\n        console.log(`‚úÖ Restored task: ${taskId}`);\r\n      } catch (error) {\r\n        console.error(`‚ùå Failed to restore task ${taskId}:`, error);\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async restoreMemoryState(memoryState: MemoryState): Promise<void> {\r\n    console.log(`üß† Restoring memory state...`);\r\n    \r\n    // This would integrate with the memory manager\r\n    // For now, we'll just log the operation\r\n    console.log(`‚úÖ Memory state restored`);\r\n  }\r\n\r\n  private async restoreFileSystemState(fileSystemState: FileSystemState): Promise<void> {\r\n    console.log(`üìÅ Restoring filesystem state...`);\r\n    \r\n    // Verify checksums and restore files if needed\r\n    for (const [filePath, expectedChecksum] of Object.entries(fileSystemState.checksums)) {\r\n      try {\r\n        const currentChecksum = await this.calculateFileChecksum(filePath);\r\n        if (currentChecksum !== expectedChecksum) {\r\n          console.warn(`‚ö†Ô∏è File checksum mismatch for ${filePath}, may need restoration`);\r\n          // In a real implementation, we would restore the file from a backup\r\n        }\r\n      } catch (error) {\r\n        console.warn(`‚ö†Ô∏è Could not verify checksum for ${filePath}:`, error);\r\n      }\r\n    }\r\n    \r\n    console.log(`‚úÖ Filesystem state restored`);\r\n  }\r\n\r\n  private async restoreDatabaseState(databaseState: DatabaseState): Promise<void> {\r\n    console.log(`üóÑÔ∏è Restoring database state...`);\r\n    \r\n    // This would integrate with database management\r\n    // For now, we'll just verify the connection status\r\n    if (databaseState.connection_status === 'connected') {\r\n      // Ensure database connection is established\r\n      console.log(`‚úÖ Database state restored`);\r\n    } else {\r\n      console.warn(`‚ö†Ô∏è Database was in ${databaseState.connection_status} state`);\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n  private shouldRollbackComponent(component: string, options: RollbackOptions): boolean {\r\n    return options.components_to_rollback.includes(component) && \r\n           !options.exclude_components.includes(component);\r\n  }\r\n\r\n  private async suspendAllAgents(): Promise<void> {\r\n    console.log(`‚è∏Ô∏è Suspending all agents...`);\r\n    // This would integrate with the agent manager\r\n  }\r\n\r\n  private async resumeAllAgents(): Promise<void> {\r\n    console.log(`‚ñ∂Ô∏è Resuming all agents...`);\r\n    // This would integrate with the agent manager\r\n  }\r\n\r\n  private async stopActiveTasks(): Promise<void> {\r\n    console.log(`üõë Stopping active tasks...`);\r\n    // This would integrate with the task manager\r\n  }\r\n\r\n  private async restoreIndividualAgentState(agentId: string, agentState: AgentState): Promise<void> {\r\n    // This would integrate with the actual agent system\r\n    console.log(`Restoring agent ${agentId} to state: ${agentState.status}`);\r\n  }\r\n\r\n  private async restoreIndividualTaskState(taskId: string, taskState: TaskState): Promise<void> {\r\n    // This would integrate with the actual task system\r\n    console.log(`Restoring task ${taskId} to state: ${taskState.status}`);\r\n  }\r\n\r\n  private async applySystemConfiguration(config: any): Promise<void> {\r\n    // This would apply system-level configuration\r\n    console.log(`Applying system configuration:`, config);\r\n  }\r\n\r\n  // Verification methods\r\n  private async verifySnapshotIntegrity(snapshot: StateSnapshot): Promise<{ valid: boolean; error?: string }> {\r\n    try {\r\n      // Verify checksum\r\n      const calculatedChecksum = this.calculateSnapshotChecksum(snapshot);\r\n      if (calculatedChecksum !== snapshot.checksum) {\r\n        return { valid: false, error: 'Checksum mismatch' };\r\n      }\r\n\r\n      // Verify snapshot structure\r\n      if (!snapshot.id || !snapshot.timestamp || !snapshot.metadata) {\r\n        return { valid: false, error: 'Invalid snapshot structure' };\r\n      }\r\n\r\n      return { valid: true };\r\n    } catch (error: any) {\r\n      return { valid: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  private calculateSnapshotChecksum(snapshot: StateSnapshot): string {\r\n    // Create a copy without the checksum field to calculate the hash\r\n    const { checksum, ...snapshotData } = snapshot;\r\n    const dataString = JSON.stringify(snapshotData, null, 0);\r\n    return createHash('sha256').update(dataString).digest('hex');\r\n  }\r\n\r\n  private async captureCurrentSnapshot(): Promise<StateSnapshot> {\r\n    // This would capture the current system state\r\n    // For now, return a mock snapshot\r\n    return {\r\n      id: 'current_' + Date.now(),\r\n      timestamp: Date.now(),\r\n      agent_states: new Map(),\r\n      system_state: {} as SystemState,\r\n      task_states: new Map(),\r\n      memory_state: {} as MemoryState,\r\n      file_system_state: {} as FileSystemState,\r\n      database_state: {} as DatabaseState,\r\n      checksum: '',\r\n      metadata: {\r\n        version: '2.0',\r\n        created_by: 'rollback_engine',\r\n        description: 'Current state snapshot',\r\n        tags: ['current'],\r\n        size_bytes: 0,\r\n        compression_ratio: 1.0\r\n      }\r\n    };\r\n  }\r\n\r\n  private async detectCriticalChanges(current: StateSnapshot, target: StateSnapshot): Promise<string[]> {\r\n    const changes: string[] = [];\r\n    \r\n    // Compare critical system parameters\r\n    if (current.system_state.version !== target.system_state.version) {\r\n      changes.push('system_version_change');\r\n    }\r\n    \r\n    // Compare agent configurations\r\n    if (current.agent_states.size !== target.agent_states.size) {\r\n      changes.push('agent_count_change');\r\n    }\r\n    \r\n    return changes;\r\n  }\r\n\r\n  private async checkActiveOperations(): Promise<string[]> {\r\n    // This would check for active operations that shouldn't be interrupted\r\n    return []; // Mock: no active operations\r\n  }\r\n\r\n  private async checkResourceLocks(): Promise<string[]> {\r\n    // This would check for resource locks\r\n    return []; // Mock: no resource locks\r\n  }\r\n\r\n  private async checkDependencyConstraints(snapshot: StateSnapshot): Promise<string[]> {\r\n    // This would check for dependency constraints\r\n    return []; // Mock: no dependency issues\r\n  }\r\n\r\n  private async verifyComponentState(\r\n    component: string,\r\n    target: StateSnapshot,\r\n    current: StateSnapshot\r\n  ): Promise<boolean> {\r\n    // This would verify that the component was restored correctly\r\n    console.log(`Verifying ${component} state...`);\r\n    return true; // Mock: verification passed\r\n  }\r\n\r\n  private async validateSystemConsistency(): Promise<ConsistencyReport> {\r\n    // This would validate overall system consistency\r\n    return {\r\n      consistent: true,\r\n      inconsistencies: [],\r\n      checked_at: new Date().toISOString(),\r\n      repair_suggestions: [],\r\n      overall_health_score: 1.0\r\n    };\r\n  }\r\n\r\n  private async verifyAgentCommunication(): Promise<boolean> {\r\n    // This would verify that agents can communicate properly\r\n    return true; // Mock: communication working\r\n  }\r\n\r\n  private async calculateFileChecksum(filePath: string): Promise<string> {\r\n    try {\r\n      const data = await fs.readFile(filePath);\r\n      return createHash('sha256').update(data).digest('hex');\r\n    } catch (error) {\r\n      throw new Error(`Failed to calculate checksum for ${filePath}: ${error}`);\r\n    }\r\n  }\r\n\r\n  private async attemptEmergencyRecovery(error: any): Promise<void> {\r\n    console.error(`üö® Attempting emergency recovery due to: ${error.message}`);\r\n    \r\n    // Emergency recovery procedures would go here\r\n    // This might include:\r\n    // - Restoring from the most recent known good state\r\n    // - Restarting critical services\r\n    // - Alerting administrators\r\n    \r\n    console.log(`ü©π Emergency recovery completed`);\r\n  }\r\n\r\n  private addToRollbackHistory(result: RollbackResult): void {\r\n    this.rollbackHistory.unshift(result);\r\n    if (this.rollbackHistory.length > this.maxRollbackHistory) {\r\n      this.rollbackHistory = this.rollbackHistory.slice(0, this.maxRollbackHistory);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get rollback history\r\n   */\r\n  public getRollbackHistory(limit: number = 10): RollbackResult[] {\r\n    return this.rollbackHistory.slice(0, limit);\r\n  }\r\n\r\n  /**\r\n   * Simulate a rollback without actually executing it\r\n   */\r\n  async simulateRollback(checkpointId: string, options: Partial<RollbackOptions> = {}): Promise<{\r\n    safe: boolean;\r\n    estimatedTime: number;\r\n    affectedComponents: string[];\r\n    risks: string[];\r\n    recommendations: string[];\r\n  }> {\r\n    const checkpoint = await this.checkpointManager.getCheckpoint(checkpointId);\r\n    if (!checkpoint) {\r\n      throw new Error(`Checkpoint ${checkpointId} not found`);\r\n    }\r\n\r\n    const rollbackOptions = { \r\n      mode: 'simulation' as RollbackMode, \r\n      verify_before_rollback: true,\r\n      verify_after_rollback: false,\r\n      create_backup_before: false,\r\n      components_to_rollback: ['agents', 'tasks', 'memory'],\r\n      exclude_components: [],\r\n      ...options \r\n    };\r\n\r\n    const safetyCheck = await this.verifyRollbackSafety(checkpoint.state_snapshot, rollbackOptions);\r\n    \r\n    return {\r\n      safe: safetyCheck.safe,\r\n      estimatedTime: 5000, // Mock: 5 seconds\r\n      affectedComponents: rollbackOptions.components_to_rollback,\r\n      risks: safetyCheck.reasons,\r\n      recommendations: [\r\n        'Create backup before rollback',\r\n        'Verify system consistency after rollback',\r\n        'Monitor agent performance post-rollback'\r\n      ]\r\n    };\r\n  }\r\n}"],"names":["promises","fs","createHash","RollbackEngine","checkpointManager","rollbackHistory","maxRollbackHistory","rollbackToCheckpoint","checkpointId","options","rollbackStart","Date","now","defaultOptions","mode","verify_before_rollback","verify_after_rollback","create_backup_before","components_to_rollback","exclude_components","rollbackOptions","console","log","checkpoint","getCheckpoint","Error","backupCheckpointId","createCheckpoint","safetyCheck","verifyRollbackSafety","state_snapshot","safe","reasons","join","warn","affectedComponents","executeRollback","verificationDetails","verified","checks_performed","failed_checks","verification_time_ms","verifyRollbackSuccess","rollbackResult","success","checkpoint_id","rollback_time_ms","verification_details","affected_components","error_message","undefined","addToRollbackHistory","error","message","attemptEmergencyRecovery","targetSnapshot","integrityCheck","verifySnapshotIntegrity","valid","push","currentSnapshot","captureCurrentSnapshot","criticalChanges","detectCriticalChanges","length","activeOperations","checkActiveOperations","resourceLocks","checkResourceLocks","dependencyIssues","checkDependencyConstraints","shouldRollbackComponent","suspendAllAgents","stopActiveTasks","restoreDatabaseState","database_state","restoreFileSystemState","file_system_state","restoreMemoryState","memory_state","restoreSystemState","system_state","restoreTaskStates","task_states","restoreAgentStates","agent_states","resumeAllAgents","verificationStart","checksPerformed","failedChecks","component","includes","verifyComponentState","consistencyReport","validateSystemConsistency","consistent","communicationWorking","verifyAgentCommunication","agentStates","agentId","agentState","restoreIndividualAgentState","systemState","applySystemConfiguration","configuration","taskStates","taskId","taskState","restoreIndividualTaskState","memoryState","fileSystemState","filePath","expectedChecksum","Object","entries","checksums","currentChecksum","calculateFileChecksum","databaseState","connection_status","status","config","snapshot","calculatedChecksum","calculateSnapshotChecksum","checksum","id","timestamp","metadata","snapshotData","dataString","JSON","stringify","update","digest","Map","version","created_by","description","tags","size_bytes","compression_ratio","current","target","changes","size","inconsistencies","checked_at","toISOString","repair_suggestions","overall_health_score","data","readFile","result","unshift","slice","getRollbackHistory","limit","simulateRollback","estimatedTime","risks","recommendations"],"mappings":"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"}