{"version":3,"sources":["../../../../src/hive-mind/integration/SwarmOrchestrator.ts"],"sourcesContent":["/**\r\n * SwarmOrchestrator Class\r\n *\r\n * Orchestrates task distribution, agent coordination, and\r\n * execution strategies within the Hive Mind swarm.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { HiveMind } from '../core/HiveMind.js';\r\nimport { Agent } from '../core/Agent.js';\r\nimport { DatabaseManager } from '../core/DatabaseManager.js';\r\nimport { MCPToolWrapper } from './MCPToolWrapper.js';\r\nimport {\r\n  Task,\r\n  TaskStrategy,\r\n  ExecutionPlan,\r\n  OrchestrationResult,\r\n  TaskAssignment,\r\n} from '../types.js';\r\n\r\nexport class SwarmOrchestrator extends EventEmitter {\r\n  private hiveMind: HiveMind;\r\n  private db: DatabaseManager;\r\n  private mcpWrapper: MCPToolWrapper;\r\n  private executionPlans: Map<string, ExecutionPlan>;\r\n  private taskAssignments: Map<string, TaskAssignment[]>;\r\n  private activeExecutions: Map<string, any>;\r\n  private isActive: boolean = false;\r\n\r\n  constructor(hiveMind: HiveMind) {\r\n    super();\r\n    this.hiveMind = hiveMind;\r\n    this.executionPlans = new Map();\r\n    this.taskAssignments = new Map();\r\n    this.activeExecutions = new Map();\r\n  }\r\n\r\n  /**\r\n   * Initialize the orchestrator\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.db = await DatabaseManager.getInstance();\r\n    this.mcpWrapper = new MCPToolWrapper();\r\n    await this.mcpWrapper.initialize();\r\n\r\n    // Start orchestration loops\r\n    this.startTaskDistributor();\r\n    this.startProgressMonitor();\r\n    this.startLoadBalancer();\r\n\r\n    this.isActive = true;\r\n    this.emit('initialized');\r\n  }\r\n\r\n  /**\r\n   * Submit a task for orchestration\r\n   */\r\n  async submitTask(task: Task): Promise<void> {\r\n    // Create execution plan based on strategy\r\n    const plan = await this.createExecutionPlan(task);\r\n    this.executionPlans.set(task.id, plan);\r\n\r\n    // Orchestrate task using MCP tools\r\n    const orchestrationResult = await this.mcpWrapper.orchestrateTask({\r\n      task: task.description,\r\n      priority: task.priority,\r\n      strategy: task.strategy,\r\n      dependencies: task.dependencies,\r\n    });\r\n\r\n    if (orchestrationResult.success) {\r\n      // Start task execution\r\n      await this.executeTask(task, plan);\r\n    } else {\r\n      this.emit('orchestrationError', { task, error: orchestrationResult.error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create execution plan for a task\r\n   */\r\n  private async createExecutionPlan(task: Task): Promise<ExecutionPlan> {\r\n    const strategy = this.getStrategyImplementation(task.strategy);\r\n\r\n    // Analyze task complexity\r\n    const analysis = await this.analyzeTaskComplexity(task);\r\n\r\n    // Determine phases based on strategy and complexity\r\n    const phases = strategy.determinePhases(task, analysis);\r\n\r\n    // Create assignments for each phase\r\n    const phaseAssignments = await Promise.all(\r\n      phases.map((phase) => this.createPhaseAssignments(task, phase, analysis)),\r\n    );\r\n\r\n    return {\r\n      taskId: task.id,\r\n      strategy: task.strategy,\r\n      phases,\r\n      phaseAssignments,\r\n      dependencies: task.dependencies,\r\n      checkpoints: this.createCheckpoints(phases),\r\n      parallelizable: strategy.isParallelizable(task),\r\n      estimatedDuration: analysis.estimatedDuration,\r\n      resourceRequirements: analysis.resourceRequirements,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Execute task according to plan\r\n   */\r\n  private async executeTask(task: Task, plan: ExecutionPlan): Promise<void> {\r\n    const execution = {\r\n      taskId: task.id,\r\n      plan,\r\n      startTime: Date.now(),\r\n      currentPhase: 0,\r\n      phaseResults: [],\r\n      status: 'executing',\r\n    };\r\n\r\n    this.activeExecutions.set(task.id, execution);\r\n\r\n    try {\r\n      // Execute phases according to strategy\r\n      if (plan.parallelizable) {\r\n        await this.executeParallel(task, plan, execution);\r\n      } else {\r\n        await this.executeSequential(task, plan, execution);\r\n      }\r\n\r\n      // Mark task as completed\r\n      execution.status = 'completed';\r\n      await this.completeTask(task, execution);\r\n    } catch (error) {\r\n      execution.status = 'failed';\r\n      execution.error = error;\r\n      await this.handleTaskFailure(task, execution, error);\r\n    } finally {\r\n      this.activeExecutions.delete(task.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute phases in parallel\r\n   */\r\n  private async executeParallel(task: Task, plan: ExecutionPlan, execution: any): Promise<void> {\r\n    const parallelPhases = plan.phases.filter((_, index) =>\r\n      plan.phaseAssignments[index].some((a) => a.canRunParallel),\r\n    );\r\n\r\n    const results = await Promise.all(\r\n      parallelPhases.map((phase) => this.executePhase(task, phase, plan, execution)),\r\n    );\r\n\r\n    execution.phaseResults = results;\r\n  }\r\n\r\n  /**\r\n   * Execute phases sequentially\r\n   */\r\n  private async executeSequential(task: Task, plan: ExecutionPlan, execution: any): Promise<void> {\r\n    for (let i = 0; i < plan.phases.length; i++) {\r\n      const phase = plan.phases[i];\r\n      execution.currentPhase = i;\r\n\r\n      const result = await this.executePhase(task, phase, plan, execution);\r\n      execution.phaseResults.push(result);\r\n\r\n      // Check checkpoint\r\n      if (plan.checkpoints[i]) {\r\n        await this.evaluateCheckpoint(task, plan.checkpoints[i], execution);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a single phase\r\n   */\r\n  private async executePhase(\r\n    task: Task,\r\n    phase: string,\r\n    plan: ExecutionPlan,\r\n    execution: any,\r\n  ): Promise<any> {\r\n    const phaseIndex = plan.phases.indexOf(phase);\r\n    const assignments = plan.phaseAssignments[phaseIndex];\r\n\r\n    // Assign agents to phase tasks\r\n    const agentAssignments = await this.assignAgentsToPhase(task, phase, assignments);\r\n\r\n    // Execute phase tasks\r\n    const phaseResults = await Promise.all(\r\n      agentAssignments.map((assignment) => this.executeAssignment(task, phase, assignment)),\r\n    );\r\n\r\n    // Aggregate phase results\r\n    return this.aggregatePhaseResults(phase, phaseResults);\r\n  }\r\n\r\n  /**\r\n   * Assign agents to phase tasks\r\n   */\r\n  private async assignAgentsToPhase(\r\n    task: Task,\r\n    phase: string,\r\n    assignments: TaskAssignment[],\r\n  ): Promise<any[]> {\r\n    const agentAssignments = [];\r\n\r\n    for (const assignment of assignments) {\r\n      // Find suitable agent\r\n      const agent = await this.findSuitableAgent(assignment.requiredCapabilities);\r\n\r\n      if (agent) {\r\n        await this.assignTaskToAgent(task.id, agent.id);\r\n        agentAssignments.push({\r\n          agent,\r\n          assignment,\r\n          phase,\r\n        });\r\n      } else {\r\n        // Queue for later assignment\r\n        this.queueAssignment(task.id, assignment);\r\n      }\r\n    }\r\n\r\n    return agentAssignments;\r\n  }\r\n\r\n  /**\r\n   * Execute a specific assignment\r\n   */\r\n  private async executeAssignment(task: Task, phase: string, assignment: any): Promise<any> {\r\n    const { agent, assignment: taskAssignment } = assignment;\r\n\r\n    // Send execution command to agent\r\n    await agent.assignTask(task.id, {\r\n      phase,\r\n      role: taskAssignment.role,\r\n      responsibilities: taskAssignment.responsibilities,\r\n      expectedOutput: taskAssignment.expectedOutput,\r\n    });\r\n\r\n    // Wait for completion or timeout\r\n    return this.waitForAgentCompletion(agent, task.id, taskAssignment.timeout);\r\n  }\r\n\r\n  /**\r\n   * Assign task to a specific agent\r\n   */\r\n  async assignTaskToAgent(taskId: string, agentId: string): Promise<void> {\r\n    // Update database\r\n    const task = await this.db.getTask(taskId);\r\n    const assignedAgents = JSON.parse(task.assigned_agents || '[]');\r\n\r\n    if (!assignedAgents.includes(agentId)) {\r\n      assignedAgents.push(agentId);\r\n      await this.db.updateTask(taskId, {\r\n        assigned_agents: JSON.stringify(assignedAgents),\r\n        status: 'assigned',\r\n      });\r\n    }\r\n\r\n    // Update agent\r\n    await this.db.updateAgent(agentId, {\r\n      current_task_id: taskId,\r\n      status: 'busy',\r\n    });\r\n\r\n    this.emit('taskAssigned', { taskId, agentId });\r\n  }\r\n\r\n  /**\r\n   * Cancel a task\r\n   */\r\n  async cancelTask(taskId: string): Promise<void> {\r\n    const execution = this.activeExecutions.get(taskId);\r\n\r\n    if (execution) {\r\n      execution.status = 'cancelled';\r\n\r\n      // Notify assigned agents\r\n      const task = await this.db.getTask(taskId);\r\n      const assignedAgents = JSON.parse(task.assigned_agents || '[]');\r\n\r\n      for (const agentId of assignedAgents) {\r\n        await this.notifyAgentTaskCancelled(agentId, taskId);\r\n      }\r\n    }\r\n\r\n    this.activeExecutions.delete(taskId);\r\n    this.executionPlans.delete(taskId);\r\n\r\n    this.emit('taskCancelled', { taskId });\r\n  }\r\n\r\n  /**\r\n   * Rebalance agent assignments\r\n   */\r\n  async rebalance(): Promise<void> {\r\n    // Get current load distribution\r\n    const loadDistribution = await this.analyzeLoadDistribution();\r\n\r\n    // Use MCP tool for load balancing\r\n    const balanceResult = await this.mcpWrapper.loadBalance({\r\n      tasks: loadDistribution.unassignedTasks,\r\n    });\r\n\r\n    if (balanceResult.success && balanceResult.data.reassignments) {\r\n      await this.applyReassignments(balanceResult.data.reassignments);\r\n    }\r\n\r\n    this.emit('rebalanced', { loadDistribution });\r\n  }\r\n\r\n  /**\r\n   * Strategy implementations\r\n   */\r\n  private getStrategyImplementation(strategy: TaskStrategy): any {\r\n    const strategies = {\r\n      parallel: {\r\n        determinePhases: (task: Task) => ['preparation', 'parallel-execution', 'aggregation'],\r\n        isParallelizable: () => true,\r\n        maxConcurrency: 5,\r\n      },\r\n      sequential: {\r\n        determinePhases: (task: Task) => ['analysis', 'planning', 'execution', 'validation'],\r\n        isParallelizable: () => false,\r\n        maxConcurrency: 1,\r\n      },\r\n      adaptive: {\r\n        determinePhases: (task: Task, analysis: any) => {\r\n          if (analysis.complexity === 'high') {\r\n            return ['deep-analysis', 'planning', 'phased-execution', 'integration', 'validation'];\r\n          }\r\n          return ['quick-analysis', 'execution', 'validation'];\r\n        },\r\n        isParallelizable: (task: Task) => !task.requireConsensus,\r\n        maxConcurrency: 3,\r\n      },\r\n      consensus: {\r\n        determinePhases: () => ['proposal', 'discussion', 'voting', 'execution', 'ratification'],\r\n        isParallelizable: () => false,\r\n        maxConcurrency: 1,\r\n      },\r\n    };\r\n\r\n    return strategies[strategy] || strategies.adaptive;\r\n  }\r\n\r\n  /**\r\n   * Analyze task complexity\r\n   */\r\n  private async analyzeTaskComplexity(task: Task): Promise<any> {\r\n    const analysis = await this.mcpWrapper.analyzePattern({\r\n      action: 'analyze',\r\n      operation: 'task_complexity',\r\n      metadata: {\r\n        description: task.description,\r\n        priority: task.priority,\r\n        dependencies: task.dependencies.length,\r\n        requiresConsensus: task.requireConsensus,\r\n      },\r\n    });\r\n\r\n    return {\r\n      complexity: analysis.data?.complexity || 'medium',\r\n      estimatedDuration: analysis.data?.estimatedDuration || 3600000,\r\n      resourceRequirements: analysis.data?.resourceRequirements || {\r\n        minAgents: 1,\r\n        maxAgents: task.maxAgents,\r\n        capabilities: task.requiredCapabilities,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create phase assignments\r\n   */\r\n  private async createPhaseAssignments(\r\n    task: Task,\r\n    phase: string,\r\n    analysis: any,\r\n  ): Promise<TaskAssignment[]> {\r\n    const assignments: TaskAssignment[] = [];\r\n\r\n    // Define assignments based on phase\r\n    switch (phase) {\r\n      case 'analysis':\r\n      case 'deep-analysis':\r\n        assignments.push({\r\n          role: 'analyst',\r\n          requiredCapabilities: ['data_analysis', 'pattern_recognition'],\r\n          responsibilities: ['Analyze task requirements', 'Identify patterns', 'Assess complexity'],\r\n          expectedOutput: 'Analysis report',\r\n          timeout: 300000, // 5 minutes\r\n          canRunParallel: false,\r\n        });\r\n        break;\r\n\r\n      case 'planning':\r\n        assignments.push({\r\n          role: 'architect',\r\n          requiredCapabilities: ['system_design', 'architecture_patterns'],\r\n          responsibilities: ['Design solution', 'Create implementation plan', 'Define interfaces'],\r\n          expectedOutput: 'Implementation plan',\r\n          timeout: 600000, // 10 minutes\r\n          canRunParallel: false,\r\n        });\r\n        break;\r\n\r\n      case 'execution':\r\n      case 'parallel-execution':\r\n        // Multiple execution assignments based on complexity\r\n        const executionCount = Math.min(analysis.resourceRequirements.maxAgents, 3);\r\n        for (let i = 0; i < executionCount; i++) {\r\n          assignments.push({\r\n            role: 'executor',\r\n            requiredCapabilities: task.requiredCapabilities,\r\n            responsibilities: ['Implement solution', 'Execute plan', 'Handle errors'],\r\n            expectedOutput: 'Execution results',\r\n            timeout: 1800000, // 30 minutes\r\n            canRunParallel: true,\r\n          });\r\n        }\r\n        break;\r\n\r\n      case 'validation':\r\n        assignments.push({\r\n          role: 'validator',\r\n          requiredCapabilities: ['quality_assurance', 'test_generation'],\r\n          responsibilities: ['Validate results', 'Run tests', 'Ensure quality'],\r\n          expectedOutput: 'Validation report',\r\n          timeout: 600000, // 10 minutes\r\n          canRunParallel: false,\r\n        });\r\n        break;\r\n\r\n      case 'consensus':\r\n      case 'voting':\r\n        assignments.push({\r\n          role: 'consensus-coordinator',\r\n          requiredCapabilities: ['consensus_building'],\r\n          responsibilities: ['Coordinate voting', 'Collect opinions', 'Determine consensus'],\r\n          expectedOutput: 'Consensus decision',\r\n          timeout: 300000, // 5 minutes\r\n          canRunParallel: false,\r\n        });\r\n        break;\r\n    }\r\n\r\n    return assignments;\r\n  }\r\n\r\n  /**\r\n   * Create execution checkpoints\r\n   */\r\n  private createCheckpoints(phases: string[]): any[] {\r\n    return phases.map((phase, index) => ({\r\n      phase,\r\n      index,\r\n      requiredProgress: Math.round(((index + 1) / phases.length) * 100),\r\n      validationCriteria: this.getValidationCriteria(phase),\r\n      failureThreshold: 0.3,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get validation criteria for a phase\r\n   */\r\n  private getValidationCriteria(phase: string): any[] {\r\n    const criteria: Record<string, any[]> = {\r\n      analysis: [\r\n        { name: 'completeness', weight: 0.4 },\r\n        { name: 'accuracy', weight: 0.6 },\r\n      ],\r\n      planning: [\r\n        { name: 'feasibility', weight: 0.5 },\r\n        { name: 'completeness', weight: 0.5 },\r\n      ],\r\n      execution: [\r\n        { name: 'correctness', weight: 0.7 },\r\n        { name: 'performance', weight: 0.3 },\r\n      ],\r\n      validation: [\r\n        { name: 'test_coverage', weight: 0.5 },\r\n        { name: 'quality_score', weight: 0.5 },\r\n      ],\r\n    };\r\n\r\n    return criteria[phase] || [{ name: 'completion', weight: 1.0 }];\r\n  }\r\n\r\n  /**\r\n   * Find suitable agent for capabilities\r\n   */\r\n  private async findSuitableAgent(requiredCapabilities: string[]): Promise<Agent | null> {\r\n    const agents = await this.hiveMind.getAgents();\r\n\r\n    // Filter available agents with required capabilities\r\n    const suitableAgents = agents.filter(\r\n      (agent) =>\r\n        agent.status === 'idle' &&\r\n        requiredCapabilities.every((cap) => agent.capabilities.includes(cap)),\r\n    );\r\n\r\n    if (suitableAgents.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Select best agent based on performance history\r\n    return this.selectBestAgent(suitableAgents, requiredCapabilities);\r\n  }\r\n\r\n  /**\r\n   * Select best agent from candidates\r\n   */\r\n  private async selectBestAgent(agents: Agent[], capabilities: string[]): Promise<Agent> {\r\n    // Simple selection - in production would use performance metrics\r\n    const scores = await Promise.all(\r\n      agents.map(async (agent) => {\r\n        const performance = await this.db.getAgentPerformance(agent.id);\r\n        return {\r\n          agent,\r\n          score: performance?.successRate || 0.5,\r\n        };\r\n      }),\r\n    );\r\n\r\n    scores.sort((a, b) => b.score - a.score);\r\n    return scores[0].agent;\r\n  }\r\n\r\n  /**\r\n   * Wait for agent to complete task\r\n   */\r\n  private async waitForAgentCompletion(\r\n    agent: Agent,\r\n    taskId: string,\r\n    timeout: number,\r\n  ): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n      const timer = setTimeout(() => {\r\n        reject(new Error(`Agent ${agent.id} timeout on task ${taskId}`));\r\n      }, timeout);\r\n\r\n      const checkCompletion = async () => {\r\n        const agentState = await this.db.getAgent(agent.id);\r\n\r\n        if (agentState.current_task_id !== taskId) {\r\n          clearTimeout(timer);\r\n          clearInterval(interval);\r\n\r\n          // Get task result\r\n          const task = await this.db.getTask(taskId);\r\n          resolve(task.result ? JSON.parse(task.result) : {});\r\n        }\r\n      };\r\n\r\n      const interval = setInterval(checkCompletion, 1000);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Aggregate results from phase execution\r\n   */\r\n  private aggregatePhaseResults(phase: string, results: any[]): any {\r\n    return {\r\n      phase,\r\n      results,\r\n      summary: this.summarizeResults(results),\r\n      timestamp: new Date(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Summarize phase results\r\n   */\r\n  private summarizeResults(results: any[]): any {\r\n    const successful = results.filter((r) => r.success).length;\r\n    const total = results.length;\r\n\r\n    return {\r\n      successRate: total > 0 ? successful / total : 0,\r\n      totalExecutions: total,\r\n      aggregatedData: results.map((r) => r.data).filter(Boolean),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Queue assignment for later\r\n   */\r\n  private queueAssignment(taskId: string, assignment: TaskAssignment): void {\r\n    if (!this.taskAssignments.has(taskId)) {\r\n      this.taskAssignments.set(taskId, []);\r\n    }\r\n\r\n    this.taskAssignments.get(taskId)!.push(assignment);\r\n    this.emit('assignmentQueued', { taskId, assignment });\r\n  }\r\n\r\n  /**\r\n   * Evaluate checkpoint\r\n   */\r\n  private async evaluateCheckpoint(task: Task, checkpoint: any, execution: any): Promise<void> {\r\n    const phaseResult = execution.phaseResults[checkpoint.index];\r\n\r\n    if (!phaseResult) return;\r\n\r\n    let score = 0;\r\n    for (const criterion of checkpoint.validationCriteria) {\r\n      const criterionScore = this.evaluateCriterion(phaseResult, criterion);\r\n      score += criterionScore * criterion.weight;\r\n    }\r\n\r\n    if (score < checkpoint.failureThreshold) {\r\n      throw new Error(`Checkpoint failed at phase ${checkpoint.phase}: score ${score}`);\r\n    }\r\n\r\n    this.emit('checkpointPassed', { task, checkpoint, score });\r\n  }\r\n\r\n  /**\r\n   * Evaluate validation criterion\r\n   */\r\n  private evaluateCriterion(result: any, criterion: any): number {\r\n    // Simplified evaluation - in production would be more sophisticated\r\n    if (result.summary && result.summary.successRate !== undefined) {\r\n      return result.summary.successRate;\r\n    }\r\n    return 0.7; // Default passing score\r\n  }\r\n\r\n  /**\r\n   * Complete task execution\r\n   */\r\n  private async completeTask(task: Task, execution: any): Promise<void> {\r\n    const finalResult = {\r\n      success: true,\r\n      executionTime: Date.now() - execution.startTime,\r\n      phases: execution.phaseResults,\r\n      summary: this.createExecutionSummary(execution),\r\n    };\r\n\r\n    await this.db.updateTask(task.id, {\r\n      status: 'completed',\r\n      result: JSON.stringify(finalResult),\r\n      progress: 100,\r\n      completed_at: new Date(),\r\n    });\r\n\r\n    this.emit('taskCompleted', { task, result: finalResult });\r\n  }\r\n\r\n  /**\r\n   * Handle task failure\r\n   */\r\n  private async handleTaskFailure(task: Task, execution: any, error: any): Promise<void> {\r\n    await this.db.updateTask(task.id, {\r\n      status: 'failed',\r\n      error: error.message,\r\n      completed_at: new Date(),\r\n    });\r\n\r\n    this.emit('taskFailed', { task, error });\r\n  }\r\n\r\n  /**\r\n   * Create execution summary\r\n   */\r\n  private createExecutionSummary(execution: any): any {\r\n    const phaseCount = execution.phaseResults.length;\r\n    const successfulPhases = execution.phaseResults.filter(\r\n      (r) => r.summary?.successRate > 0.5,\r\n    ).length;\r\n\r\n    return {\r\n      totalPhases: phaseCount,\r\n      successfulPhases,\r\n      overallSuccess: phaseCount > 0 ? successfulPhases / phaseCount : 0,\r\n      executionTime: Date.now() - execution.startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Notify agent of task cancellation\r\n   */\r\n  private async notifyAgentTaskCancelled(agentId: string, taskId: string): Promise<void> {\r\n    // Send cancellation message to agent\r\n    await this.db.createCommunication({\r\n      from_agent_id: 'orchestrator',\r\n      to_agent_id: agentId,\r\n      swarm_id: this.hiveMind.id,\r\n      message_type: 'task_cancellation',\r\n      content: JSON.stringify({ taskId, reason: 'User cancelled' }),\r\n      priority: 'urgent',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyze load distribution\r\n   */\r\n  private async analyzeLoadDistribution(): Promise<any> {\r\n    const agents = await this.hiveMind.getAgents();\r\n    const tasks = await this.db.getActiveTasks(this.hiveMind.id);\r\n\r\n    const busyAgents = agents.filter((a) => a.status === 'busy');\r\n    const idleAgents = agents.filter((a) => a.status === 'idle');\r\n    const unassignedTasks = tasks.filter(\r\n      (t) => !t.assigned_agents || JSON.parse(t.assigned_agents).length === 0,\r\n    );\r\n\r\n    return {\r\n      totalAgents: agents.length,\r\n      busyAgents: busyAgents.length,\r\n      idleAgents: idleAgents.length,\r\n      activeTasks: tasks.length,\r\n      unassignedTasks: unassignedTasks.map((t) => ({\r\n        id: t.id,\r\n        priority: t.priority,\r\n        requiredCapabilities: JSON.parse(t.required_capabilities || '[]'),\r\n      })),\r\n      loadFactor: agents.length > 0 ? busyAgents.length / agents.length : 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply load balancing reassignments\r\n   */\r\n  private async applyReassignments(reassignments: any[]): Promise<void> {\r\n    for (const reassignment of reassignments) {\r\n      await this.reassignTask(reassignment.taskId, reassignment.fromAgent, reassignment.toAgent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reassign task from one agent to another\r\n   */\r\n  private async reassignTask(\r\n    taskId: string,\r\n    fromAgentId: string,\r\n    toAgentId: string,\r\n  ): Promise<void> {\r\n    // Update task assignment\r\n    await this.db.reassignTask(taskId, toAgentId);\r\n\r\n    // Update agent states\r\n    await this.db.updateAgent(fromAgentId, {\r\n      current_task_id: null,\r\n      status: 'idle',\r\n    });\r\n\r\n    await this.db.updateAgent(toAgentId, {\r\n      current_task_id: taskId,\r\n      status: 'busy',\r\n    });\r\n\r\n    // Notify agents\r\n    await this.notifyAgentReassignment(fromAgentId, toAgentId, taskId);\r\n  }\r\n\r\n  /**\r\n   * Notify agents of reassignment\r\n   */\r\n  private async notifyAgentReassignment(\r\n    fromAgentId: string,\r\n    toAgentId: string,\r\n    taskId: string,\r\n  ): Promise<void> {\r\n    // Notify source agent\r\n    await this.db.createCommunication({\r\n      from_agent_id: 'orchestrator',\r\n      to_agent_id: fromAgentId,\r\n      swarm_id: this.hiveMind.id,\r\n      message_type: 'task_reassignment',\r\n      content: JSON.stringify({ taskId, reassignedTo: toAgentId }),\r\n      priority: 'high',\r\n    });\r\n\r\n    // Notify target agent\r\n    const task = await this.db.getTask(taskId);\r\n    const plan = this.executionPlans.get(taskId);\r\n\r\n    await this.db.createCommunication({\r\n      from_agent_id: 'orchestrator',\r\n      to_agent_id: toAgentId,\r\n      swarm_id: this.hiveMind.id,\r\n      message_type: 'task_assignment',\r\n      content: JSON.stringify({\r\n        taskId,\r\n        task: task.description,\r\n        executionPlan: plan,\r\n      }),\r\n      priority: 'high',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start task distributor loop\r\n   */\r\n  private startTaskDistributor(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      try {\r\n        // Check for queued assignments\r\n        for (const [taskId, assignments] of this.taskAssignments) {\r\n          for (const assignment of assignments) {\r\n            const agent = await this.findSuitableAgent(assignment.requiredCapabilities);\r\n            if (agent) {\r\n              await this.assignTaskToAgent(taskId, agent.id);\r\n              // Remove from queue\r\n              const remaining = assignments.filter((a) => a !== assignment);\r\n              if (remaining.length === 0) {\r\n                this.taskAssignments.delete(taskId);\r\n              } else {\r\n                this.taskAssignments.set(taskId, remaining);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        this.emit('error', error);\r\n      }\r\n    }, 5000); // Every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Start progress monitor loop\r\n   */\r\n  private startProgressMonitor(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      try {\r\n        // Monitor active executions\r\n        for (const [taskId, execution] of this.activeExecutions) {\r\n          const task = await this.db.getTask(taskId);\r\n\r\n          if (task.status === 'in_progress') {\r\n            const progress = this.calculateProgress(execution);\r\n\r\n            if (progress !== task.progress) {\r\n              await this.db.updateTask(taskId, { progress });\r\n              this.emit('progressUpdate', { taskId, progress });\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        this.emit('error', error);\r\n      }\r\n    }, 2000); // Every 2 seconds\r\n  }\r\n\r\n  /**\r\n   * Start load balancer loop\r\n   */\r\n  private startLoadBalancer(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      try {\r\n        const load = await this.analyzeLoadDistribution();\r\n\r\n        // Trigger rebalancing if needed\r\n        if (\r\n          load.loadFactor > 0.8 &&\r\n          load.idleAgents.length > 0 &&\r\n          load.unassignedTasks.length > 0\r\n        ) {\r\n          await this.rebalance();\r\n        }\r\n      } catch (error) {\r\n        this.emit('error', error);\r\n      }\r\n    }, 30000); // Every 30 seconds\r\n  }\r\n\r\n  /**\r\n   * Calculate task progress\r\n   */\r\n  private calculateProgress(execution: any): number {\r\n    if (!execution.plan || !execution.plan.phases) return 0;\r\n\r\n    const totalPhases = execution.plan.phases.length;\r\n    const completedPhases = execution.currentPhase;\r\n\r\n    return Math.round((completedPhases / totalPhases) * 100);\r\n  }\r\n\r\n  /**\r\n   * Shutdown orchestrator\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    this.isActive = false;\r\n\r\n    // Cancel all active executions\r\n    for (const taskId of this.activeExecutions.keys()) {\r\n      await this.cancelTask(taskId);\r\n    }\r\n\r\n    this.emit('shutdown');\r\n  }\r\n}\r\n"],"names":["EventEmitter","DatabaseManager","MCPToolWrapper","SwarmOrchestrator","hiveMind","db","mcpWrapper","executionPlans","taskAssignments","activeExecutions","isActive","Map","initialize","getInstance","startTaskDistributor","startProgressMonitor","startLoadBalancer","emit","submitTask","task","plan","createExecutionPlan","set","id","orchestrationResult","orchestrateTask","description","priority","strategy","dependencies","success","executeTask","error","getStrategyImplementation","analysis","analyzeTaskComplexity","phases","determinePhases","phaseAssignments","Promise","all","map","phase","createPhaseAssignments","taskId","checkpoints","createCheckpoints","parallelizable","isParallelizable","estimatedDuration","resourceRequirements","execution","startTime","Date","now","currentPhase","phaseResults","status","executeParallel","executeSequential","completeTask","handleTaskFailure","delete","parallelPhases","filter","_","index","some","a","canRunParallel","results","executePhase","i","length","result","push","evaluateCheckpoint","phaseIndex","indexOf","assignments","agentAssignments","assignAgentsToPhase","assignment","executeAssignment","aggregatePhaseResults","agent","findSuitableAgent","requiredCapabilities","assignTaskToAgent","queueAssignment","taskAssignment","assignTask","role","responsibilities","expectedOutput","waitForAgentCompletion","timeout","agentId","getTask","assignedAgents","JSON","parse","assigned_agents","includes","updateTask","stringify","updateAgent","current_task_id","cancelTask","get","notifyAgentTaskCancelled","rebalance","loadDistribution","analyzeLoadDistribution","balanceResult","loadBalance","tasks","unassignedTasks","data","reassignments","applyReassignments","strategies","parallel","maxConcurrency","sequential","adaptive","complexity","requireConsensus","consensus","analyzePattern","action","operation","metadata","requiresConsensus","minAgents","maxAgents","capabilities","executionCount","Math","min","requiredProgress","round","validationCriteria","getValidationCriteria","failureThreshold","criteria","name","weight","planning","validation","agents","getAgents","suitableAgents","every","cap","selectBestAgent","scores","performance","getAgentPerformance","score","successRate","sort","b","resolve","reject","timer","setTimeout","Error","checkCompletion","agentState","getAgent","clearTimeout","clearInterval","interval","setInterval","summary","summarizeResults","timestamp","successful","r","total","totalExecutions","aggregatedData","Boolean","has","checkpoint","phaseResult","criterion","criterionScore","evaluateCriterion","undefined","finalResult","executionTime","createExecutionSummary","progress","completed_at","message","phaseCount","successfulPhases","totalPhases","overallSuccess","createCommunication","from_agent_id","to_agent_id","swarm_id","message_type","content","reason","getActiveTasks","busyAgents","idleAgents","t","totalAgents","activeTasks","required_capabilities","loadFactor","reassignment","reassignTask","fromAgent","toAgent","fromAgentId","toAgentId","notifyAgentReassignment","reassignedTo","executionPlan","remaining","calculateProgress","load","completedPhases","shutdown","keys"],"mappings":"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"}