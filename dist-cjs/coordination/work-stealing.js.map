{
  "version": 3,
  "sources": ["../../src/coordination/work-stealing.ts"],
  "sourcesContent": ["/**\n * Work stealing algorithm for load balancing between agents\n */\n\nimport type { Task, AgentProfile } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\n\nexport interface WorkStealingConfig {\n  enabled: boolean;\n  stealThreshold: number; // Min difference in task count to trigger stealing\n  maxStealBatch: number; // Max tasks to steal at once\n  stealInterval: number; // How often to check for steal opportunities (ms)\n}\n\nexport interface AgentWorkload {\n  agentId: string;\n  taskCount: number;\n  avgTaskDuration: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  priority: number;\n  capabilities: string[];\n}\n\n/**\n * Work stealing coordinator for load balancing\n */\nexport class WorkStealingCoordinator {\n  private workloads = new Map<string, AgentWorkload>();\n  private stealInterval?: ReturnType<typeof setInterval>;\n  private taskDurations = new Map<string, number[]>(); // agentId -> task durations\n\n  constructor(\n    private config: WorkStealingConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    if (!this.config.enabled) {\n      this.logger.info('Work stealing is disabled');\n      return;\n    }\n\n    this.logger.info('Initializing work stealing coordinator');\n\n    // Start periodic steal checks\n    this.stealInterval = setInterval(() => this.checkAndSteal(), this.config.stealInterval);\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.stealInterval) {\n      clearInterval(this.stealInterval);\n    }\n\n    this.workloads.clear();\n    this.taskDurations.clear();\n  }\n\n  updateAgentWorkload(agentId: string, workload: Partial<AgentWorkload>): void {\n    const existing = this.workloads.get(agentId) || {\n      agentId,\n      taskCount: 0,\n      avgTaskDuration: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      priority: 0,\n      capabilities: [],\n    };\n\n    this.workloads.set(agentId, { ...existing, ...workload });\n  }\n\n  recordTaskDuration(agentId: string, duration: number): void {\n    if (!this.taskDurations.has(agentId)) {\n      this.taskDurations.set(agentId, []);\n    }\n\n    const durations = this.taskDurations.get(agentId)!;\n    durations.push(duration);\n\n    // Keep only last 100 durations\n    if (durations.length > 100) {\n      durations.shift();\n    }\n\n    // Update average duration\n    const avg = durations.reduce((sum, d) => sum + d, 0) / durations.length;\n    this.updateAgentWorkload(agentId, { avgTaskDuration: avg });\n  }\n\n  async checkAndSteal(): Promise<void> {\n    const workloads = Array.from(this.workloads.values());\n    if (workloads.length < 2) {\n      return; // Need at least 2 agents\n    }\n\n    // Sort by task count (ascending)\n    workloads.sort((a, b) => a.taskCount - b.taskCount);\n\n    const minLoaded = workloads[0];\n    const maxLoaded = workloads[workloads.length - 1];\n\n    // Check if stealing is warranted\n    const difference = maxLoaded.taskCount - minLoaded.taskCount;\n    if (difference < this.config.stealThreshold) {\n      return; // Not enough imbalance\n    }\n\n    // Calculate how many tasks to steal\n    const tasksToSteal = Math.min(Math.floor(difference / 2), this.config.maxStealBatch);\n\n    this.logger.info('Initiating work stealing', {\n      from: maxLoaded.agentId,\n      to: minLoaded.agentId,\n      tasksToSteal,\n      difference,\n    });\n\n    // Emit steal request event\n    this.eventBus.emit('workstealing:request', {\n      sourceAgent: maxLoaded.agentId,\n      targetAgent: minLoaded.agentId,\n      taskCount: tasksToSteal,\n    });\n  }\n\n  /**\n   * Find the best agent for a task based on capabilities and load\n   */\n  findBestAgent(task: Task, agents: AgentProfile[]): string | null {\n    const candidates: Array<{\n      agentId: string;\n      score: number;\n    }> = [];\n\n    for (const agent of agents) {\n      const workload = this.workloads.get(agent.id);\n      if (!workload) {\n        continue;\n      }\n\n      // Calculate score based on multiple factors\n      let score = 100;\n\n      // Factor 1: Task count (lower is better)\n      score -= workload.taskCount * 10;\n\n      // Factor 2: CPU usage (lower is better)\n      score -= workload.cpuUsage * 0.5;\n\n      // Factor 3: Memory usage (lower is better)\n      score -= workload.memoryUsage * 0.3;\n\n      // Factor 4: Agent priority (higher is better)\n      score += agent.priority * 5;\n\n      // Factor 5: Capability match\n      const taskType = task.type;\n      if (agent.capabilities.includes(taskType)) {\n        score += 20; // Bonus for capability match\n      }\n\n      // Factor 6: Average task duration (predictive load)\n      const predictedLoad = workload.avgTaskDuration * workload.taskCount;\n      score -= predictedLoad / 1000; // Convert to seconds\n\n      candidates.push({ agentId: agent.id, score });\n    }\n\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    // Sort by score (descending) and return best\n    candidates.sort((a, b) => b.score - a.score);\n\n    this.logger.debug('Agent selection scores', {\n      taskId: task.id,\n      candidates: candidates.slice(0, 5), // Top 5\n    });\n\n    return candidates[0].agentId;\n  }\n\n  getWorkloadStats(): Record<string, unknown> {\n    const stats: Record<string, unknown> = {\n      totalAgents: this.workloads.size,\n      workloads: {},\n    };\n\n    let totalTasks = 0;\n    let minTasks = Infinity;\n    let maxTasks = 0;\n\n    for (const [agentId, workload] of this.workloads) {\n      totalTasks += workload.taskCount;\n      minTasks = Math.min(minTasks, workload.taskCount);\n      maxTasks = Math.max(maxTasks, workload.taskCount);\n\n      (stats.workloads as Record<string, unknown>)[agentId] = {\n        taskCount: workload.taskCount,\n        avgTaskDuration: workload.avgTaskDuration,\n        cpuUsage: workload.cpuUsage,\n        memoryUsage: workload.memoryUsage,\n      };\n    }\n\n    stats.totalTasks = totalTasks;\n    stats.avgTasksPerAgent = totalTasks / this.workloads.size;\n    stats.minTasks = minTasks === Infinity ? 0 : minTasks;\n    stats.maxTasks = maxTasks;\n    stats.imbalance = maxTasks - (minTasks === Infinity ? 0 : minTasks);\n\n    return stats;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
