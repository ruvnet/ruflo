{
  "version": 3,
  "sources": ["../../src/terminal/pool.ts"],
  "sourcesContent": ["/**\n * Terminal pool management\n */\n\nimport type { Terminal, ITerminalAdapter } from './adapters/base.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TerminalError } from '../utils/errors.js';\nimport { delay } from '../utils/helpers.js';\n\ninterface PooledTerminal {\n  terminal: Terminal;\n  useCount: number;\n  lastUsed: Date;\n  inUse: boolean;\n}\n\n/**\n * Terminal pool for efficient resource management\n */\nexport class TerminalPool {\n  private terminals = new Map<string, PooledTerminal>();\n  private availableQueue: string[] = [];\n  private initializationPromise?: Promise<void>;\n\n  constructor(\n    private maxSize: number,\n    private recycleAfter: number,\n    private adapter: ITerminalAdapter,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n\n    this.initializationPromise = this.doInitialize();\n    return this.initializationPromise;\n  }\n\n  private async doInitialize(): Promise<void> {\n    this.logger.info('Initializing terminal pool', {\n      maxSize: this.maxSize,\n      recycleAfter: this.recycleAfter,\n    });\n\n    // Pre-create some terminals\n    const preCreateCount = Math.min(2, this.maxSize);\n    const promises: Promise<void>[] = [];\n\n    for (let i = 0; i < preCreateCount; i++) {\n      promises.push(this.createPooledTerminal());\n    }\n\n    await Promise.all(promises);\n\n    this.logger.info('Terminal pool initialized', {\n      created: preCreateCount,\n    });\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down terminal pool');\n\n    // Destroy all terminals\n    const terminals = Array.from(this.terminals.values());\n    await Promise.all(terminals.map(({ terminal }) => this.adapter.destroyTerminal(terminal)));\n\n    this.terminals.clear();\n    this.availableQueue = [];\n  }\n\n  async acquire(): Promise<Terminal> {\n    // Try to get an available terminal\n    while (this.availableQueue.length > 0) {\n      const terminalId = this.availableQueue.shift()!;\n      const pooled = this.terminals.get(terminalId);\n\n      if (pooled && pooled.terminal.isAlive()) {\n        pooled.inUse = true;\n        pooled.lastUsed = new Date();\n\n        this.logger.debug('Terminal acquired from pool', {\n          terminalId,\n          useCount: pooled.useCount,\n        });\n\n        return pooled.terminal;\n      }\n\n      // Terminal is dead, remove it\n      if (pooled) {\n        this.terminals.delete(terminalId);\n      }\n    }\n\n    // No available terminals, create new one if under limit\n    if (this.terminals.size < this.maxSize) {\n      await this.createPooledTerminal();\n      return this.acquire(); // Recursive call to get the newly created terminal\n    }\n\n    // Pool is full, wait for a terminal to become available\n    this.logger.info('Terminal pool full, waiting for available terminal');\n\n    const startTime = Date.now();\n    const timeout = 30000; // 30 seconds\n\n    while (Date.now() - startTime < timeout) {\n      await delay(100);\n\n      // Check if any terminal became available\n      const available = Array.from(this.terminals.values()).find(\n        (pooled) => !pooled.inUse && pooled.terminal.isAlive(),\n      );\n\n      if (available) {\n        available.inUse = true;\n        available.lastUsed = new Date();\n        return available.terminal;\n      }\n    }\n\n    throw new TerminalError('No terminal available in pool (timeout)');\n  }\n\n  async release(terminal: Terminal): Promise<void> {\n    const pooled = this.terminals.get(terminal.id);\n    if (!pooled) {\n      this.logger.warn('Attempted to release unknown terminal', {\n        terminalId: terminal.id,\n      });\n      return;\n    }\n\n    pooled.useCount++;\n    pooled.inUse = false;\n\n    // Check if terminal should be recycled\n    if (pooled.useCount >= this.recycleAfter || !terminal.isAlive()) {\n      this.logger.info('Recycling terminal', {\n        terminalId: terminal.id,\n        useCount: pooled.useCount,\n      });\n\n      // Destroy old terminal\n      this.terminals.delete(terminal.id);\n      await this.adapter.destroyTerminal(terminal);\n\n      // Create replacement if under limit\n      if (this.terminals.size < this.maxSize) {\n        await this.createPooledTerminal();\n      }\n    } else {\n      // Return to available queue\n      this.availableQueue.push(terminal.id);\n\n      this.logger.debug('Terminal returned to pool', {\n        terminalId: terminal.id,\n        useCount: pooled.useCount,\n      });\n    }\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    size: number;\n    available: number;\n    recycled: number;\n  }> {\n    const aliveTerminals = Array.from(this.terminals.values()).filter((pooled) =>\n      pooled.terminal.isAlive(),\n    );\n\n    const available = aliveTerminals.filter((pooled) => !pooled.inUse).length;\n    const recycled = Array.from(this.terminals.values()).filter(\n      (pooled) => pooled.useCount >= this.recycleAfter,\n    ).length;\n\n    return {\n      healthy: aliveTerminals.length > 0,\n      size: this.terminals.size,\n      available,\n      recycled,\n    };\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing terminal pool maintenance');\n\n    // Remove dead terminals\n    const deadTerminals: string[] = [];\n    for (const [id, pooled] of this.terminals.entries()) {\n      if (!pooled.terminal.isAlive()) {\n        deadTerminals.push(id);\n      }\n    }\n\n    // Clean up dead terminals\n    for (const id of deadTerminals) {\n      this.logger.warn('Removing dead terminal from pool', { terminalId: id });\n      this.terminals.delete(id);\n      const index = this.availableQueue.indexOf(id);\n      if (index !== -1) {\n        this.availableQueue.splice(index, 1);\n      }\n    }\n\n    // Ensure minimum pool size\n    const currentSize = this.terminals.size;\n    const minSize = Math.min(2, this.maxSize);\n\n    if (currentSize < minSize) {\n      const toCreate = minSize - currentSize;\n      this.logger.info('Replenishing terminal pool', {\n        currentSize,\n        minSize,\n        creating: toCreate,\n      });\n\n      const promises: Promise<void>[] = [];\n      for (let i = 0; i < toCreate; i++) {\n        promises.push(this.createPooledTerminal());\n      }\n\n      await Promise.all(promises);\n    }\n\n    // Check for stale terminals that should be recycled\n    const now = Date.now();\n    const staleTimeout = 300000; // 5 minutes\n\n    for (const [id, pooled] of this.terminals.entries()) {\n      if (!pooled.inUse && pooled.terminal.isAlive()) {\n        const idleTime = now - pooled.lastUsed.getTime();\n        if (idleTime > staleTimeout) {\n          this.logger.info('Recycling stale terminal', {\n            terminalId: id,\n            idleTime,\n          });\n\n          // Mark for recycling\n          pooled.useCount = this.recycleAfter;\n        }\n      }\n    }\n  }\n\n  private async createPooledTerminal(): Promise<void> {\n    try {\n      const terminal = await this.adapter.createTerminal();\n\n      const pooled: PooledTerminal = {\n        terminal,\n        useCount: 0,\n        lastUsed: new Date(),\n        inUse: false,\n      };\n\n      this.terminals.set(terminal.id, pooled);\n      this.availableQueue.push(terminal.id);\n\n      this.logger.debug('Created pooled terminal', { terminalId: terminal.id });\n    } catch (error) {\n      this.logger.error('Failed to create pooled terminal', error);\n      throw error;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
