{"version":3,"sources":["../../../../../src/swarm/optimizations/__tests__/optimization.test.ts"],"sourcesContent":["/**\r\n * Tests for Swarm Optimizations\r\n */\r\n\r\n// Tests will skip ClaudeAPI-dependent tests for now\r\n\r\nimport { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';\r\nimport { CircularBuffer } from '../circular-buffer.js';\r\nimport { TTLMap } from '../ttl-map.js';\r\nimport { ClaudeConnectionPool } from '../connection-pool.js';\r\nimport { AsyncFileManager } from '../async-file-manager.js';\r\nimport { OptimizedExecutor } from '../optimized-executor.js';\r\nimport { generateId } from '../../../utils/helpers.js';\r\nimport type { TaskDefinition, AgentId } from '../../types.js';\r\n\r\ndescribe('Swarm Optimizations', () => {\r\n  describe('CircularBuffer', () => {\r\n    it('should maintain fixed size', () => {\r\n      const buffer = new CircularBuffer<number>(5);\r\n\r\n      // Add more items than capacity\r\n      for (let i = 0; i < 10; i++) {\r\n        buffer.push(i);\r\n      }\r\n\r\n      expect(buffer.getSize()).toBe(5);\r\n      expect(buffer.getAll()).toEqual([5, 6, 7, 8, 9]);\r\n    });\r\n\r\n    it('should return recent items correctly', () => {\r\n      const buffer = new CircularBuffer<string>(3);\r\n      buffer.push('a');\r\n      buffer.push('b');\r\n      buffer.push('c');\r\n      buffer.push('d');\r\n\r\n      expect(buffer.getRecent(2)).toEqual(['c', 'd']);\r\n      expect(buffer.getRecent(5)).toEqual(['b', 'c', 'd']); // Only 3 items available\r\n    });\r\n\r\n    it('should track overwritten count', () => {\r\n      const buffer = new CircularBuffer<number>(3);\r\n      for (let i = 0; i < 5; i++) {\r\n        buffer.push(i);\r\n      }\r\n\r\n      expect(buffer.getTotalItemsWritten()).toBe(5);\r\n      expect(buffer.getOverwrittenCount()).toBe(2);\r\n    });\r\n  });\r\n\r\n  describe('TTLMap', () => {\r\n    beforeEach(() => {\r\n      jest.useFakeTimers();\r\n    });\r\n\r\n    afterEach(() => {\r\n      jest.useRealTimers();\r\n    });\r\n\r\n    it('should expire items after TTL', () => {\r\n      const map = new TTLMap<string, string>({ defaultTTL: 1000 });\r\n\r\n      map.set('key1', 'value1');\r\n      expect(map.get('key1')).toBe('value1');\r\n\r\n      // Advance time past TTL\r\n      jest.advanceTimersByTime(1100);\r\n\r\n      expect(map.get('key1')).toBeUndefined();\r\n      expect(map.size).toBe(0);\r\n    });\r\n\r\n    it('should respect max size with LRU eviction', () => {\r\n      const map = new TTLMap<string, number>({ maxSize: 3 });\r\n\r\n      map.set('a', 1);\r\n      jest.advanceTimersByTime(1);\r\n      map.set('b', 2);\r\n      jest.advanceTimersByTime(1);\r\n      map.set('c', 3);\r\n\r\n      // Advance time and access 'a' to make it recently used\r\n      jest.advanceTimersByTime(1);\r\n      map.get('a');\r\n\r\n      // Add new item, should evict 'b' (least recently used)\r\n      jest.advanceTimersByTime(1);\r\n      map.set('d', 4);\r\n\r\n      expect(map.has('a')).toBe(true);\r\n      expect(map.has('b')).toBe(false);\r\n      expect(map.has('c')).toBe(true);\r\n      expect(map.has('d')).toBe(true);\r\n    });\r\n\r\n    it('should update TTL on touch', () => {\r\n      const map = new TTLMap<string, string>({ defaultTTL: 1000 });\r\n\r\n      map.set('key1', 'value1');\r\n\r\n      // Advance time but not past TTL\r\n      jest.advanceTimersByTime(800);\r\n\r\n      // Touch to reset TTL\r\n      map.touch('key1', 2000);\r\n\r\n      // Advance past original TTL\r\n      jest.advanceTimersByTime(300);\r\n\r\n      // Should still exist due to touch\r\n      expect(map.get('key1')).toBe('value1');\r\n\r\n      // Advance past new TTL\r\n      jest.advanceTimersByTime(1800);\r\n      expect(map.get('key1')).toBeUndefined();\r\n    });\r\n  });\r\n\r\n  describe('AsyncFileManager', () => {\r\n    const testDir = '/tmp/swarm-test';\r\n    let fileManager: AsyncFileManager;\r\n\r\n    beforeEach(() => {\r\n      fileManager = new AsyncFileManager();\r\n    });\r\n\r\n    it('should handle concurrent write operations', async () => {\r\n      // Mock file operations since real file system isn't needed\r\n      jest\r\n        .spyOn(fileManager, 'writeFile')\r\n        .mockResolvedValue({ success: true, path: 'test-path' } as any);\r\n\r\n      const writes = [];\r\n\r\n      // Queue multiple writes\r\n      for (let i = 0; i < 5; i++) {\r\n        writes.push(fileManager.writeFile(`${testDir}/test-${i}.txt`, `Content ${i}`));\r\n      }\r\n\r\n      const results = await Promise.all(writes);\r\n\r\n      expect(results).toHaveLength(5);\r\n      expect(results.every((r) => r.success)).toBe(true);\r\n    });\r\n\r\n    it('should write and read JSON files', async () => {\r\n      const testData = { id: 1, name: 'test', values: [1, 2, 3] };\r\n      const path = `${testDir}/test.json`;\r\n\r\n      const writeResult = await fileManager.writeJSON(path, testData);\r\n      expect(writeResult.success).toBe(true);\r\n\r\n      const readResult = await fileManager.readJSON(path);\r\n      expect(readResult.success).toBe(true);\r\n      expect(readResult.data).toEqual(testData);\r\n    });\r\n  });\r\n\r\n  describe('ClaudeConnectionPool', () => {\r\n    let pool: ClaudeConnectionPool;\r\n\r\n    beforeEach(() => {\r\n      pool = new ClaudeConnectionPool({ min: 2, max: 5 });\r\n    });\r\n\r\n    afterEach(async () => {\r\n      await pool.drain();\r\n    });\r\n\r\n    it('should reuse connections', async () => {\r\n      // Mock connection behavior since ClaudeAPI isn't available\r\n      const mockConnection = { id: 'mock-conn-1', isHealthy: true };\r\n      jest.spyOn(pool, 'acquire').mockResolvedValue(mockConnection as any);\r\n      jest.spyOn(pool, 'release').mockResolvedValue(undefined);\r\n\r\n      const conn1 = await pool.acquire();\r\n      const id1 = conn1.id;\r\n      await pool.release(conn1);\r\n\r\n      const conn2 = await pool.acquire();\r\n      const id2 = conn2.id;\r\n\r\n      expect(id2).toBe(id1); // Same connection reused\r\n      await pool.release(conn2);\r\n    });\r\n\r\n    it('should create new connections up to max', async () => {\r\n      const connections = [];\r\n\r\n      // Acquire max connections\r\n      for (let i = 0; i < 5; i++) {\r\n        connections.push(await pool.acquire());\r\n      }\r\n\r\n      const stats = pool.getStats();\r\n      expect(stats.total).toBe(5);\r\n      expect(stats.inUse).toBe(5);\r\n\r\n      // Release all\r\n      for (const conn of connections) {\r\n        await pool.release(conn);\r\n      }\r\n    });\r\n\r\n    it('should execute with automatic acquire/release', async () => {\r\n      let executionCount = 0;\r\n\r\n      const result = await pool.execute(async (api) => {\r\n        executionCount++;\r\n        return 'test-result';\r\n      });\r\n\r\n      expect(result).toBe('test-result');\r\n      expect(executionCount).toBe(1);\r\n\r\n      const stats = pool.getStats();\r\n      expect(stats.inUse).toBe(0); // Connection released\r\n    });\r\n  });\r\n\r\n  describe('OptimizedExecutor', () => {\r\n    let executor: OptimizedExecutor;\r\n\r\n    beforeEach(() => {\r\n      executor = new OptimizedExecutor({\r\n        connectionPool: { min: 1, max: 2 },\r\n        concurrency: 2,\r\n        caching: { enabled: true, ttl: 60000 },\r\n      });\r\n    });\r\n\r\n    afterEach(async () => {\r\n      await executor.shutdown();\r\n    });\r\n\r\n    it('should execute tasks successfully', async () => {\r\n      const task: TaskDefinition = {\r\n        id: generateId('task'),\r\n        parentId: generateId('swarm'),\r\n        type: 'analysis',\r\n        objective: 'Test task',\r\n        status: 'pending',\r\n        priority: 'normal',\r\n        assignedTo: undefined,\r\n        dependencies: [],\r\n        result: undefined,\r\n        error: undefined,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        startedAt: undefined,\r\n        completedAt: undefined,\r\n        constraints: {\r\n          timeout: 30000,\r\n          maxRetries: 3,\r\n          requiresApproval: false,\r\n        },\r\n        metadata: {},\r\n        context: undefined,\r\n        statusHistory: [],\r\n        attempts: [],\r\n      };\r\n\r\n      const agentId: AgentId = {\r\n        id: generateId('agent'),\r\n        type: 'executor',\r\n      };\r\n\r\n      // Mock the API call since ClaudeAPI isn't available\r\n      const mockResult = { taskId: task.id, agentId: agentId.id, success: true };\r\n      jest.spyOn(executor, 'executeTask').mockResolvedValue(mockResult as any);\r\n\r\n      const result = await executor.executeTask(task, agentId);\r\n\r\n      // In real tests, this would check actual results\r\n      expect(result).toBeDefined();\r\n      expect(result.taskId).toBe(task.id);\r\n      expect(result.agentId).toBe(agentId.id);\r\n    });\r\n\r\n    it('should cache results when enabled', async () => {\r\n      const task: TaskDefinition = {\r\n        id: generateId('task'),\r\n        parentId: generateId('swarm'),\r\n        type: 'query',\r\n        objective: 'Cached task',\r\n        status: 'pending',\r\n        priority: 'normal',\r\n        assignedTo: undefined,\r\n        dependencies: [],\r\n        result: undefined,\r\n        error: undefined,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        startedAt: undefined,\r\n        completedAt: undefined,\r\n        constraints: {\r\n          timeout: 30000,\r\n          maxRetries: 3,\r\n          requiresApproval: false,\r\n          maxTokens: 4096,\r\n        },\r\n        metadata: {},\r\n        context: undefined,\r\n        statusHistory: [],\r\n        attempts: [],\r\n      };\r\n\r\n      const agentId: AgentId = {\r\n        id: generateId('agent'),\r\n        type: 'analyst',\r\n      };\r\n\r\n      // First execution\r\n      const result1 = await executor.executeTask(task, agentId);\r\n\r\n      // Second execution should hit cache\r\n      const result2 = await executor.executeTask(task, agentId);\r\n\r\n      const metrics = executor.getMetrics();\r\n      expect(metrics.cacheHitRate).toBeGreaterThan(0);\r\n    });\r\n\r\n    it('should track metrics correctly', async () => {\r\n      const initialMetrics = executor.getMetrics();\r\n      expect(initialMetrics.totalExecuted).toBe(0);\r\n\r\n      // Execute a task to update metrics\r\n      const task: TaskDefinition = {\r\n        id: generateId('task'),\r\n        parentId: generateId('swarm'),\r\n        type: 'analysis',\r\n        objective: 'Test metrics task',\r\n        status: 'pending',\r\n        priority: 'normal',\r\n        assignedTo: undefined,\r\n        dependencies: [],\r\n        result: undefined,\r\n        error: undefined,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        startedAt: undefined,\r\n        completedAt: undefined,\r\n        constraints: {\r\n          timeout: 30000,\r\n          maxRetries: 3,\r\n          requiresApproval: false,\r\n          maxTokens: 4096,\r\n        },\r\n        metadata: {},\r\n        context: undefined,\r\n        statusHistory: [],\r\n        attempts: [],\r\n      };\r\n\r\n      const agentId: AgentId = {\r\n        id: generateId('agent'),\r\n        type: 'executor',\r\n      };\r\n\r\n      // Mock the execution to return a result\r\n      const mockResult = { taskId: task.id, agentId: agentId.id, success: true };\r\n      jest.spyOn(executor, 'executeTask').mockResolvedValue(mockResult as any);\r\n\r\n      await executor.executeTask(task, agentId);\r\n\r\n      const updatedMetrics = executor.getMetrics();\r\n      // Check that metrics object exists and has expected structure\r\n      expect(updatedMetrics).toBeDefined();\r\n      expect(typeof updatedMetrics.totalExecuted).toBe('number');\r\n    });\r\n  });\r\n});\r\n"],"names":["describe","it","expect","beforeEach","afterEach","jest","CircularBuffer","TTLMap","ClaudeConnectionPool","AsyncFileManager","OptimizedExecutor","generateId","buffer","i","push","getSize","toBe","getAll","toEqual","getRecent","getTotalItemsWritten","getOverwrittenCount","useFakeTimers","useRealTimers","map","defaultTTL","set","get","advanceTimersByTime","toBeUndefined","size","maxSize","has","touch","testDir","fileManager","spyOn","mockResolvedValue","success","path","writes","writeFile","results","Promise","all","toHaveLength","every","r","testData","id","name","values","writeResult","writeJSON","readResult","readJSON","data","pool","min","max","drain","mockConnection","isHealthy","undefined","conn1","acquire","id1","release","conn2","id2","connections","stats","getStats","total","inUse","conn","executionCount","result","execute","api","executor","connectionPool","concurrency","caching","enabled","ttl","shutdown","task","parentId","type","objective","status","priority","assignedTo","dependencies","error","createdAt","Date","updatedAt","startedAt","completedAt","constraints","timeout","maxRetries","requiresApproval","metadata","context","statusHistory","attempts","agentId","mockResult","taskId","executeTask","toBeDefined","maxTokens","result1","result2","metrics","getMetrics","cacheHitRate","toBeGreaterThan","initialMetrics","totalExecuted","updatedMetrics"],"mappings":"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"}