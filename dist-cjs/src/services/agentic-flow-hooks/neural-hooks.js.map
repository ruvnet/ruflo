{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/neural-hooks.ts"],"sourcesContent":["/**\r\n * Neural training hooks for agentic-flow\r\n * \r\n * Enables learning from multi-model responses with\r\n * pattern detection and adaptive optimization.\r\n */\r\n\r\nimport { agenticHookManager } from './hook-manager.js';\r\nimport type {\r\n  AgenticHookContext,\r\n  HookHandlerResult,\r\n  NeuralHookPayload,\r\n  Pattern,\r\n  TrainingData,\r\n  Prediction,\r\n  Adaptation,\r\n  SideEffect,\r\n} from './types.js';\r\n\r\n// ===== Pre-Neural Train Hook =====\r\n\r\nexport const preNeuralTrainHook = {\r\n  id: 'agentic-pre-neural-train',\r\n  type: 'pre-neural-train' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: NeuralHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { operation, modelId, trainingData } = payload;\r\n    \r\n    if (operation !== 'train' || !trainingData) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Validate training data\r\n    const validation = validateTrainingData(trainingData);\r\n    if (!validation.valid) {\r\n      return {\r\n        continue: false,\r\n        sideEffects: [\r\n          {\r\n            type: 'log',\r\n            action: 'write',\r\n            data: {\r\n              level: 'error',\r\n              message: 'Invalid training data',\r\n              data: validation,\r\n            },\r\n          },\r\n        ],\r\n      };\r\n    }\r\n    \r\n    // Augment training data with historical patterns\r\n    const augmentedData = await augmentTrainingData(\r\n      trainingData,\r\n      modelId,\r\n      context\r\n    );\r\n    \r\n    // Balance dataset if needed\r\n    const balancedData = balanceTrainingData(augmentedData);\r\n    \r\n    // Apply data preprocessing\r\n    const preprocessedData = preprocessTrainingData(balancedData);\r\n    \r\n    // Store training session metadata\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `neural:training:${modelId}:${Date.now()}`,\r\n        value: {\r\n          originalSize: trainingData.inputs.length,\r\n          augmentedSize: augmentedData.inputs.length,\r\n          balancedSize: balancedData.inputs.length,\r\n          epochs: balancedData.epochs,\r\n          timestamp: Date.now(),\r\n        },\r\n        ttl: 86400, // 24 hours\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      modified: true,\r\n      payload: {\r\n        ...payload,\r\n        trainingData: preprocessedData,\r\n      },\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Post-Neural Train Hook =====\r\n\r\nexport const postNeuralTrainHook = {\r\n  id: 'agentic-post-neural-train',\r\n  type: 'post-neural-train' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: NeuralHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { modelId, accuracy, trainingData } = payload;\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Store training results\r\n    const trainingResult = {\r\n      modelId,\r\n      accuracy,\r\n      timestamp: Date.now(),\r\n      sessionId: context.sessionId,\r\n      dataSize: trainingData?.inputs.length || 0,\r\n      epochs: trainingData?.epochs || 0,\r\n    };\r\n    \r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `neural:results:${modelId}:${Date.now()}`,\r\n        value: trainingResult,\r\n        ttl: 604800, // 7 days\r\n      },\r\n    });\r\n    \r\n    // Update model performance history\r\n    await updateModelPerformance(modelId, accuracy, context);\r\n    \r\n    // Check if model should be promoted\r\n    const shouldPromote = await evaluateModelPromotion(modelId, accuracy, context);\r\n    if (shouldPromote) {\r\n      sideEffects.push({\r\n        type: 'notification',\r\n        action: 'emit',\r\n        data: {\r\n          event: 'neural:model:promoted',\r\n          data: { modelId, accuracy },\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Extract learned patterns\r\n    const patterns = await extractLearnedPatterns(modelId, context);\r\n    if (patterns.length > 0) {\r\n      sideEffects.push({\r\n        type: 'neural',\r\n        action: 'store-patterns',\r\n        data: { patterns },\r\n      });\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Neural Pattern Detected Hook =====\r\n\r\nexport const neuralPatternDetectedHook = {\r\n  id: 'agentic-neural-pattern-detected',\r\n  type: 'neural-pattern-detected' as const,\r\n  priority: 90,\r\n  handler: async (\r\n    payload: NeuralHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { patterns } = payload;\r\n    \r\n    if (!patterns || patterns.length === 0) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Analyze pattern significance\r\n    for (const pattern of patterns) {\r\n      const significance = calculatePatternSignificance(pattern);\r\n      \r\n      if (significance > 0.7) {\r\n        // High significance pattern\r\n        sideEffects.push({\r\n          type: 'memory',\r\n          action: 'store',\r\n          data: {\r\n            key: `pattern:significant:${pattern.id}`,\r\n            value: {\r\n              pattern,\r\n              significance,\r\n              detectedAt: Date.now(),\r\n              context: context.metadata,\r\n            },\r\n            ttl: 0, // Permanent\r\n          },\r\n        });\r\n        \r\n        // Trigger adaptation if needed\r\n        const adaptation = await generateAdaptation(pattern, context);\r\n        if (adaptation) {\r\n          sideEffects.push({\r\n            type: 'neural',\r\n            action: 'adapt',\r\n            data: { adaptation },\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Update pattern store\r\n      context.neural.patterns.add(pattern);\r\n    }\r\n    \r\n    // Check for pattern combinations\r\n    const combinations = findPatternCombinations(patterns, context);\r\n    if (combinations.length > 0) {\r\n      sideEffects.push({\r\n        type: 'log',\r\n        action: 'write',\r\n        data: {\r\n          level: 'info',\r\n          message: 'Pattern combinations detected',\r\n          data: { combinations },\r\n        },\r\n      });\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Neural Prediction Hook =====\r\n\r\nexport const neuralPredictionHook = {\r\n  id: 'agentic-neural-prediction',\r\n  type: 'neural-prediction' as const,\r\n  priority: 100,\r\n  handler: async (\r\n    payload: NeuralHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { prediction, modelId } = payload;\r\n    \r\n    if (!prediction) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Validate prediction confidence\r\n    if (prediction.confidence < 0.5) {\r\n      // Low confidence - consider alternatives\r\n      const alternatives = await generateAlternatives(\r\n        prediction.input,\r\n        modelId,\r\n        context\r\n      );\r\n      \r\n      if (alternatives.length > 0) {\r\n        return {\r\n          continue: true,\r\n          modified: true,\r\n          payload: {\r\n            ...payload,\r\n            prediction: {\r\n              ...prediction,\r\n              alternatives: [...prediction.alternatives, ...alternatives],\r\n            },\r\n          },\r\n          sideEffects: [\r\n            {\r\n              type: 'metric',\r\n              action: 'increment',\r\n              data: { name: 'neural.predictions.low_confidence' },\r\n            },\r\n          ],\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Store prediction for future training\r\n    sideEffects.push({\r\n      type: 'memory',\r\n      action: 'store',\r\n      data: {\r\n        key: `prediction:${modelId}:${Date.now()}`,\r\n        value: {\r\n          input: prediction.input,\r\n          output: prediction.output,\r\n          confidence: prediction.confidence,\r\n          timestamp: Date.now(),\r\n        },\r\n        ttl: 86400, // 24 hours\r\n      },\r\n    });\r\n    \r\n    // Track prediction metrics\r\n    sideEffects.push({\r\n      type: 'metric',\r\n      action: 'update',\r\n      data: {\r\n        name: `neural.predictions.confidence.${modelId}`,\r\n        value: prediction.confidence,\r\n      },\r\n    });\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Neural Adaptation Hook =====\r\n\r\nexport const neuralAdaptationHook = {\r\n  id: 'agentic-neural-adaptation',\r\n  type: 'neural-adaptation' as const,\r\n  priority: 90,\r\n  handler: async (\r\n    payload: NeuralHookPayload,\r\n    context: AgenticHookContext\r\n  ): Promise<HookHandlerResult> => {\r\n    const { adaptations, modelId } = payload;\r\n    \r\n    if (!adaptations || adaptations.length === 0) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    const sideEffects: SideEffect[] = [];\r\n    \r\n    // Validate adaptations\r\n    const validAdaptations = adaptations.filter(a => \r\n      validateAdaptation(a, modelId, context)\r\n    );\r\n    \r\n    if (validAdaptations.length === 0) {\r\n      return { continue: true };\r\n    }\r\n    \r\n    // Apply adaptations in order of impact\r\n    const sortedAdaptations = validAdaptations.sort((a, b) => \r\n      Math.abs(b.impact) - Math.abs(a.impact)\r\n    );\r\n    \r\n    for (const adaptation of sortedAdaptations) {\r\n      // Store adaptation history\r\n      sideEffects.push({\r\n        type: 'memory',\r\n        action: 'store',\r\n        data: {\r\n          key: `adaptation:${modelId}:${adaptation.target}:${Date.now()}`,\r\n          value: adaptation,\r\n          ttl: 604800, // 7 days\r\n        },\r\n      });\r\n      \r\n      // Apply adaptation based on type\r\n      switch (adaptation.type) {\r\n        case 'parameter':\r\n          await applyParameterAdaptation(adaptation, modelId, context);\r\n          break;\r\n          \r\n        case 'architecture':\r\n          await applyArchitectureAdaptation(adaptation, modelId, context);\r\n          break;\r\n          \r\n        case 'strategy':\r\n          await applyStrategyAdaptation(adaptation, modelId, context);\r\n          break;\r\n      }\r\n      \r\n      // Track adaptation metrics\r\n      sideEffects.push({\r\n        type: 'metric',\r\n        action: 'increment',\r\n        data: { name: `neural.adaptations.${adaptation.type}` },\r\n      });\r\n    }\r\n    \r\n    // Trigger retraining if significant adaptations\r\n    const totalImpact = sortedAdaptations.reduce((sum, a) => \r\n      sum + Math.abs(a.impact), 0\r\n    );\r\n    \r\n    if (totalImpact > 0.5) {\r\n      sideEffects.push({\r\n        type: 'neural',\r\n        action: 'retrain',\r\n        data: {\r\n          modelId,\r\n          reason: 'significant_adaptations',\r\n          adaptations: sortedAdaptations.length,\r\n        },\r\n      });\r\n    }\r\n    \r\n    return {\r\n      continue: true,\r\n      sideEffects,\r\n    };\r\n  },\r\n};\r\n\r\n// ===== Helper Functions =====\r\n\r\nfunction validateTrainingData(data: TrainingData): { valid: boolean; errors?: string[] } {\r\n  const errors: string[] = [];\r\n  \r\n  if (!data.inputs || data.inputs.length === 0) {\r\n    errors.push('No input data provided');\r\n  }\r\n  \r\n  if (!data.outputs || data.outputs.length === 0) {\r\n    errors.push('No output data provided');\r\n  }\r\n  \r\n  if (data.inputs.length !== data.outputs.length) {\r\n    errors.push('Input and output lengths do not match');\r\n  }\r\n  \r\n  if (data.batchSize <= 0) {\r\n    errors.push('Invalid batch size');\r\n  }\r\n  \r\n  if (data.epochs <= 0) {\r\n    errors.push('Invalid number of epochs');\r\n  }\r\n  \r\n  return {\r\n    valid: errors.length === 0,\r\n    errors: errors.length > 0 ? errors : undefined,\r\n  };\r\n}\r\n\r\nasync function augmentTrainingData(\r\n  data: TrainingData,\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<TrainingData> {\r\n  // Augment with historical successful patterns\r\n  const historicalPatterns = await loadHistoricalPatterns(modelId, context);\r\n  \r\n  const augmented: TrainingData = {\r\n    ...data,\r\n    inputs: [...data.inputs],\r\n    outputs: [...data.outputs],\r\n    labels: data.labels ? [...data.labels] : undefined,\r\n    weights: data.weights ? [...data.weights] : undefined,\r\n  };\r\n  \r\n  // Add successful patterns\r\n  for (const pattern of historicalPatterns) {\r\n    if (pattern.type === 'success' && pattern.confidence > 0.8) {\r\n      augmented.inputs.push(pattern.context.input);\r\n      augmented.outputs.push(pattern.context.output);\r\n      \r\n      if (augmented.weights) {\r\n        // Give higher weight to successful patterns\r\n        augmented.weights.push(pattern.confidence);\r\n      }\r\n    }\r\n  }\r\n  \r\n  return augmented;\r\n}\r\n\r\nfunction balanceTrainingData(data: TrainingData): TrainingData {\r\n  // Balance dataset to prevent bias\r\n  if (!data.labels) {\r\n    return data;\r\n  }\r\n  \r\n  // Count occurrences of each label\r\n  const labelCounts = new Map<string, number>();\r\n  for (const label of data.labels) {\r\n    labelCounts.set(label, (labelCounts.get(label) || 0) + 1);\r\n  }\r\n  \r\n  // Find minimum count\r\n  const minCount = Math.min(...labelCounts.values());\r\n  \r\n  // Balance by undersampling\r\n  const balanced: TrainingData = {\r\n    ...data,\r\n    inputs: [],\r\n    outputs: [],\r\n    labels: [],\r\n    weights: data.weights ? [] : undefined,\r\n  };\r\n  \r\n  const labelIndices = new Map<string, number[]>();\r\n  data.labels.forEach((label, i) => {\r\n    if (!labelIndices.has(label)) {\r\n      labelIndices.set(label, []);\r\n    }\r\n    labelIndices.get(label)!.push(i);\r\n  });\r\n  \r\n  // Sample equally from each label\r\n  for (const [label, indices] of labelIndices.entries()) {\r\n    const sampled = indices\r\n      .sort(() => Math.random() - 0.5)\r\n      .slice(0, minCount);\r\n    \r\n    for (const idx of sampled) {\r\n      balanced.inputs.push(data.inputs[idx]);\r\n      balanced.outputs.push(data.outputs[idx]);\r\n      balanced.labels!.push(label);\r\n      \r\n      if (data.weights && balanced.weights) {\r\n        balanced.weights.push(data.weights[idx]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  return balanced;\r\n}\r\n\r\nfunction preprocessTrainingData(data: TrainingData): TrainingData {\r\n  // Apply preprocessing transformations\r\n  const processed: TrainingData = {\r\n    ...data,\r\n    inputs: data.inputs.map(input => normalizeInput(input)),\r\n    outputs: data.outputs.map(output => normalizeOutput(output)),\r\n  };\r\n  \r\n  return processed;\r\n}\r\n\r\nfunction normalizeInput(input: any): any {\r\n  // Normalize input data\r\n  // Placeholder - actual implementation would depend on data type\r\n  return input;\r\n}\r\n\r\nfunction normalizeOutput(output: any): any {\r\n  // Normalize output data\r\n  // Placeholder - actual implementation would depend on data type\r\n  return output;\r\n}\r\n\r\nasync function updateModelPerformance(\r\n  modelId: string,\r\n  accuracy: number,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  const perfKey = `model:performance:${modelId}`;\r\n  const history = await context.memory.cache.get(perfKey) || [];\r\n  \r\n  history.push({\r\n    accuracy,\r\n    timestamp: Date.now(),\r\n    sessionId: context.sessionId,\r\n  });\r\n  \r\n  // Keep last 100 performance records\r\n  if (history.length > 100) {\r\n    history.shift();\r\n  }\r\n  \r\n  await context.memory.cache.set(perfKey, history);\r\n}\r\n\r\nasync function evaluateModelPromotion(\r\n  modelId: string,\r\n  accuracy: number,\r\n  context: AgenticHookContext\r\n): Promise<boolean> {\r\n  // Check if model should be promoted to production\r\n  const perfKey = `model:performance:${modelId}`;\r\n  const history = await context.memory.cache.get(perfKey) || [];\r\n  \r\n  if (history.length < 10) {\r\n    return false; // Not enough history\r\n  }\r\n  \r\n  // Calculate average accuracy over last 10 runs\r\n  const recent = history.slice(-10);\r\n  const avgAccuracy = recent.reduce((sum: number, h: any) => \r\n    sum + h.accuracy, 0\r\n  ) / recent.length;\r\n  \r\n  // Promote if consistently above threshold\r\n  return avgAccuracy > 0.85 && accuracy > 0.85;\r\n}\r\n\r\nasync function extractLearnedPatterns(\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<Pattern[]> {\r\n  // Extract patterns learned during training\r\n  // Placeholder implementation\r\n  return [];\r\n}\r\n\r\nfunction calculatePatternSignificance(pattern: Pattern): number {\r\n  // Calculate pattern significance score\r\n  const baseScore = pattern.confidence;\r\n  const occurrenceBonus = Math.min(pattern.occurrences / 100, 0.2);\r\n  \r\n  return Math.min(baseScore + occurrenceBonus, 1.0);\r\n}\r\n\r\nasync function generateAdaptation(\r\n  pattern: Pattern,\r\n  context: AgenticHookContext\r\n): Promise<Adaptation | null> {\r\n  // Generate adaptation based on pattern\r\n  if (pattern.type === 'failure' && pattern.confidence > 0.8) {\r\n    return {\r\n      type: 'parameter',\r\n      target: 'learning_rate',\r\n      oldValue: context.neural.training.learningRate,\r\n      newValue: context.neural.training.learningRate * 0.9,\r\n      reason: `High confidence failure pattern detected: ${pattern.id}`,\r\n      impact: -0.1,\r\n    };\r\n  }\r\n  \r\n  if (pattern.type === 'optimization' && pattern.confidence > 0.9) {\r\n    return {\r\n      type: 'strategy',\r\n      target: 'batch_size',\r\n      oldValue: 32,\r\n      newValue: 64,\r\n      reason: `Optimization opportunity detected: ${pattern.id}`,\r\n      impact: 0.2,\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction findPatternCombinations(\r\n  patterns: Pattern[],\r\n  context: AgenticHookContext\r\n): Array<{ patterns: Pattern[]; significance: number }> {\r\n  const combinations: Array<{ patterns: Pattern[]; significance: number }> = [];\r\n  \r\n  // Find co-occurring patterns\r\n  for (let i = 0; i < patterns.length; i++) {\r\n    for (let j = i + 1; j < patterns.length; j++) {\r\n      const pattern1 = patterns[i];\r\n      const pattern2 = patterns[j];\r\n      \r\n      // Check if patterns are related\r\n      if (areRelatedPatterns(pattern1, pattern2)) {\r\n        const significance = \r\n          (pattern1.confidence + pattern2.confidence) / 2 * 1.2;\r\n        \r\n        combinations.push({\r\n          patterns: [pattern1, pattern2],\r\n          significance: Math.min(significance, 1.0),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  return combinations;\r\n}\r\n\r\nfunction areRelatedPatterns(p1: Pattern, p2: Pattern): boolean {\r\n  // Check if patterns are related\r\n  // Simplified implementation\r\n  return p1.type === p2.type || \r\n    Object.keys(p1.context).some(key => key in p2.context);\r\n}\r\n\r\nasync function generateAlternatives(\r\n  input: any,\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<Array<{ output: any; confidence: number }>> {\r\n  // Generate alternative predictions\r\n  // Placeholder implementation\r\n  return [];\r\n}\r\n\r\nfunction validateAdaptation(\r\n  adaptation: Adaptation,\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): boolean {\r\n  // Validate adaptation is safe to apply\r\n  if (Math.abs(adaptation.impact) > 0.5) {\r\n    // Large impact adaptations need more validation\r\n    return context.neural.training.epoch > 10;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\nasync function applyParameterAdaptation(\r\n  adaptation: Adaptation,\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Apply parameter adaptation\r\n  // Placeholder implementation\r\n}\r\n\r\nasync function applyArchitectureAdaptation(\r\n  adaptation: Adaptation,\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Apply architecture adaptation\r\n  // Placeholder implementation\r\n}\r\n\r\nasync function applyStrategyAdaptation(\r\n  adaptation: Adaptation,\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<void> {\r\n  // Apply strategy adaptation\r\n  // Placeholder implementation\r\n}\r\n\r\nasync function loadHistoricalPatterns(\r\n  modelId: string,\r\n  context: AgenticHookContext\r\n): Promise<Pattern[]> {\r\n  // Load historical patterns\r\n  const patterns: Pattern[] = [];\r\n  \r\n  // Get recent patterns from memory\r\n  const patternKeys = await context.memory.cache.get(`patterns:${modelId}`) || [];\r\n  \r\n  for (const key of patternKeys.slice(-100)) {\r\n    const pattern = await context.memory.cache.get(key);\r\n    if (pattern) {\r\n      patterns.push(pattern);\r\n    }\r\n  }\r\n  \r\n  return patterns;\r\n}\r\n\r\n// ===== Register Hooks =====\r\n\r\nexport function registerNeuralHooks(): void {\r\n  agenticHookManager.register(preNeuralTrainHook);\r\n  agenticHookManager.register(postNeuralTrainHook);\r\n  agenticHookManager.register(neuralPatternDetectedHook);\r\n  agenticHookManager.register(neuralPredictionHook);\r\n  agenticHookManager.register(neuralAdaptationHook);\r\n}"],"names":["agenticHookManager","preNeuralTrainHook","id","type","priority","handler","payload","context","operation","modelId","trainingData","continue","sideEffects","validation","validateTrainingData","valid","action","data","level","message","augmentedData","augmentTrainingData","balancedData","balanceTrainingData","preprocessedData","preprocessTrainingData","push","key","Date","now","value","originalSize","inputs","length","augmentedSize","balancedSize","epochs","timestamp","ttl","modified","postNeuralTrainHook","accuracy","trainingResult","sessionId","dataSize","updateModelPerformance","shouldPromote","evaluateModelPromotion","event","patterns","extractLearnedPatterns","neuralPatternDetectedHook","pattern","significance","calculatePatternSignificance","detectedAt","metadata","adaptation","generateAdaptation","neural","add","combinations","findPatternCombinations","neuralPredictionHook","prediction","confidence","alternatives","generateAlternatives","input","name","output","neuralAdaptationHook","adaptations","validAdaptations","filter","a","validateAdaptation","sortedAdaptations","sort","b","Math","abs","impact","target","applyParameterAdaptation","applyArchitectureAdaptation","applyStrategyAdaptation","totalImpact","reduce","sum","reason","errors","outputs","batchSize","undefined","historicalPatterns","loadHistoricalPatterns","augmented","labels","weights","labelCounts","Map","label","set","get","minCount","min","values","balanced","labelIndices","forEach","i","has","indices","entries","sampled","random","slice","idx","processed","map","normalizeInput","normalizeOutput","perfKey","history","memory","cache","shift","recent","avgAccuracy","h","baseScore","occurrenceBonus","occurrences","oldValue","training","learningRate","newValue","j","pattern1","pattern2","areRelatedPatterns","p1","p2","Object","keys","some","epoch","patternKeys","registerNeuralHooks","register"],"mappings":"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"}