{"version":3,"sources":["../../../src/mcp/load-balancer.ts"],"sourcesContent":["/**\r\n * Load balancer and rate limiting for MCP\r\n */\r\n\r\nimport type { MCPLoadBalancerConfig, MCPRequest, MCPResponse, MCPSession } from '../utils/types.js';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { MCPError } from '../utils/errors.js';\r\n\r\nexport interface RequestMetrics {\r\n  requestId: string;\r\n  sessionId: string;\r\n  method: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  success?: boolean;\r\n  error?: string;\r\n}\r\n\r\nexport interface LoadBalancerMetrics {\r\n  totalRequests: number;\r\n  successfulRequests: number;\r\n  failedRequests: number;\r\n  rateLimitedRequests: number;\r\n  averageResponseTime: number;\r\n  requestsPerSecond: number;\r\n  circuitBreakerTrips: number;\r\n  lastReset: Date;\r\n}\r\n\r\nexport interface ILoadBalancer {\r\n  shouldAllowRequest(session: MCPSession, request: MCPRequest): Promise<boolean>;\r\n  recordRequestStart(session: MCPSession, request: MCPRequest): RequestMetrics;\r\n  recordRequestEnd(metrics: RequestMetrics, response?: MCPResponse, error?: Error): void;\r\n  getMetrics(): LoadBalancerMetrics;\r\n  resetMetrics(): void;\r\n  isCircuitBreakerOpen(): boolean;\r\n}\r\n\r\n/**\r\n * Circuit breaker state\r\n */\r\nenum CircuitBreakerState {\r\n  CLOSED = 'closed',\r\n  OPEN = 'open',\r\n  HALF_OPEN = 'half_open',\r\n}\r\n\r\n/**\r\n * Rate limiter using token bucket algorithm\r\n */\r\nclass RateLimiter {\r\n  private tokens: number;\r\n  private lastRefill: number;\r\n\r\n  constructor(\r\n    private maxTokens: number,\r\n    private refillRate: number, // tokens per second\r\n  ) {\r\n    this.tokens = maxTokens;\r\n    this.lastRefill = Date.now();\r\n  }\r\n\r\n  tryConsume(tokens = 1): boolean {\r\n    this.refill();\r\n\r\n    if (this.tokens >= tokens) {\r\n      this.tokens -= tokens;\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private refill(): void {\r\n    const now = Date.now();\r\n    const timePassed = (now - this.lastRefill) / 1000;\r\n    const tokensToAdd = Math.floor(timePassed * this.refillRate);\r\n\r\n    if (tokensToAdd > 0) {\r\n      this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\r\n      this.lastRefill = now;\r\n    }\r\n  }\r\n\r\n  getTokens(): number {\r\n    this.refill();\r\n    return this.tokens;\r\n  }\r\n}\r\n\r\n/**\r\n * Circuit breaker implementation\r\n */\r\nclass CircuitBreaker {\r\n  private state = CircuitBreakerState.CLOSED;\r\n  private failureCount = 0;\r\n  private lastFailureTime = 0;\r\n  private successCount = 0;\r\n\r\n  constructor(\r\n    private failureThreshold: number,\r\n    private recoveryTimeout: number, // milliseconds\r\n    private halfOpenMaxRequests = 3,\r\n  ) {}\r\n\r\n  canExecute(): boolean {\r\n    const now = Date.now();\r\n\r\n    switch (this.state) {\r\n      case CircuitBreakerState.CLOSED:\r\n        return true;\r\n\r\n      case CircuitBreakerState.OPEN:\r\n        if (now - this.lastFailureTime >= this.recoveryTimeout) {\r\n          this.state = CircuitBreakerState.HALF_OPEN;\r\n          this.successCount = 0;\r\n          return true;\r\n        }\r\n        return false;\r\n\r\n      case CircuitBreakerState.HALF_OPEN:\r\n        return this.successCount < this.halfOpenMaxRequests;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  recordSuccess(): void {\r\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\r\n      this.successCount++;\r\n      if (this.successCount >= this.halfOpenMaxRequests) {\r\n        this.state = CircuitBreakerState.CLOSED;\r\n        this.failureCount = 0;\r\n      }\r\n    } else if (this.state === CircuitBreakerState.CLOSED) {\r\n      this.failureCount = 0;\r\n    }\r\n  }\r\n\r\n  recordFailure(): void {\r\n    this.failureCount++;\r\n    this.lastFailureTime = Date.now();\r\n\r\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\r\n      this.state = CircuitBreakerState.OPEN;\r\n    } else if (\r\n      this.state === CircuitBreakerState.CLOSED &&\r\n      this.failureCount >= this.failureThreshold\r\n    ) {\r\n      this.state = CircuitBreakerState.OPEN;\r\n    }\r\n  }\r\n\r\n  getState(): CircuitBreakerState {\r\n    return this.state;\r\n  }\r\n\r\n  getMetrics(): { state: string; failureCount: number; successCount: number } {\r\n    return {\r\n      state: this.state,\r\n      failureCount: this.failureCount,\r\n      successCount: this.successCount,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Load balancer implementation\r\n */\r\nexport class LoadBalancer implements ILoadBalancer {\r\n  private rateLimiter: RateLimiter;\r\n  private circuitBreaker: CircuitBreaker;\r\n  private sessionRateLimiters = new Map<string, RateLimiter>();\r\n  private metrics: LoadBalancerMetrics;\r\n  private requestTimes: number[] = [];\r\n  private requestsInLastSecond = 0;\r\n  private lastSecondTimestamp = 0;\r\n\r\n  constructor(\r\n    private config: MCPLoadBalancerConfig,\r\n    private logger: ILogger,\r\n  ) {\r\n    this.rateLimiter = new RateLimiter(config.maxRequestsPerSecond, config.maxRequestsPerSecond);\r\n\r\n    this.circuitBreaker = new CircuitBreaker(\r\n      config.circuitBreakerThreshold,\r\n      30000, // 30 second recovery timeout\r\n    );\r\n\r\n    this.metrics = {\r\n      totalRequests: 0,\r\n      successfulRequests: 0,\r\n      failedRequests: 0,\r\n      rateLimitedRequests: 0,\r\n      averageResponseTime: 0,\r\n      requestsPerSecond: 0,\r\n      circuitBreakerTrips: 0,\r\n      lastReset: new Date(),\r\n    };\r\n\r\n    // Clean up old session rate limiters periodically\r\n    setInterval(() => {\r\n      this.cleanupSessionRateLimiters();\r\n    }, 300000); // Every 5 minutes\r\n  }\r\n\r\n  async shouldAllowRequest(session: MCPSession, request: MCPRequest): Promise<boolean> {\r\n    if (!this.config.enabled) {\r\n      return true;\r\n    }\r\n\r\n    // Check circuit breaker\r\n    if (!this.circuitBreaker.canExecute()) {\r\n      this.logger.warn('Request rejected by circuit breaker', {\r\n        sessionId: session.id,\r\n        method: request.method,\r\n        circuitState: this.circuitBreaker.getState(),\r\n      });\r\n      this.metrics.circuitBreakerTrips++;\r\n      return false;\r\n    }\r\n\r\n    // Check global rate limit\r\n    if (!this.rateLimiter.tryConsume()) {\r\n      this.logger.warn('Request rejected by global rate limiter', {\r\n        sessionId: session.id,\r\n        method: request.method,\r\n        remainingTokens: this.rateLimiter.getTokens(),\r\n      });\r\n      this.metrics.rateLimitedRequests++;\r\n      return false;\r\n    }\r\n\r\n    // Check per-session rate limit\r\n    const sessionRateLimiter = this.getSessionRateLimiter(session.id);\r\n    if (!sessionRateLimiter.tryConsume()) {\r\n      this.logger.warn('Request rejected by session rate limiter', {\r\n        sessionId: session.id,\r\n        method: request.method,\r\n        remainingTokens: sessionRateLimiter.getTokens(),\r\n      });\r\n      this.metrics.rateLimitedRequests++;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  recordRequestStart(session: MCPSession, request: MCPRequest): RequestMetrics {\r\n    const requestMetrics: RequestMetrics = {\r\n      requestId: request.id.toString(),\r\n      sessionId: session.id,\r\n      method: request.method,\r\n      startTime: Date.now(),\r\n    };\r\n\r\n    this.metrics.totalRequests++;\r\n    this.updateRequestsPerSecond();\r\n\r\n    this.logger.debug('Request started', {\r\n      requestId: requestMetrics.requestId,\r\n      sessionId: session.id,\r\n      method: request.method,\r\n    });\r\n\r\n    return requestMetrics;\r\n  }\r\n\r\n  recordRequestEnd(metrics: RequestMetrics, response?: MCPResponse, error?: Error): void {\r\n    metrics.endTime = Date.now();\r\n    const duration = metrics.endTime - metrics.startTime;\r\n\r\n    // Update response time tracking\r\n    this.requestTimes.push(duration);\r\n    if (this.requestTimes.length > 1000) {\r\n      this.requestTimes.shift(); // Keep only last 1000 requests\r\n    }\r\n\r\n    const success = !error && (!response || !response.error);\r\n    metrics.success = success;\r\n    const errorMessage = error?.message || response?.error?.message;\r\n    if (errorMessage) {\r\n      metrics.error = errorMessage;\r\n    }\r\n\r\n    if (success) {\r\n      this.metrics.successfulRequests++;\r\n      this.circuitBreaker.recordSuccess();\r\n    } else {\r\n      this.metrics.failedRequests++;\r\n      this.circuitBreaker.recordFailure();\r\n    }\r\n\r\n    // Update average response time\r\n    this.metrics.averageResponseTime = this.calculateAverageResponseTime();\r\n\r\n    this.logger.debug('Request completed', {\r\n      requestId: metrics.requestId,\r\n      sessionId: metrics.sessionId,\r\n      method: metrics.method,\r\n      duration,\r\n      success,\r\n      error: metrics.error,\r\n    });\r\n  }\r\n\r\n  getMetrics(): LoadBalancerMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  resetMetrics(): void {\r\n    this.metrics = {\r\n      totalRequests: 0,\r\n      successfulRequests: 0,\r\n      failedRequests: 0,\r\n      rateLimitedRequests: 0,\r\n      averageResponseTime: 0,\r\n      requestsPerSecond: 0,\r\n      circuitBreakerTrips: 0,\r\n      lastReset: new Date(),\r\n    };\r\n    this.requestTimes = [];\r\n\r\n    this.logger.info('Load balancer metrics reset');\r\n  }\r\n\r\n  isCircuitBreakerOpen(): boolean {\r\n    return this.circuitBreaker.getState() === CircuitBreakerState.OPEN;\r\n  }\r\n\r\n  getDetailedMetrics(): {\r\n    loadBalancer: LoadBalancerMetrics;\r\n    circuitBreaker: { state: string; failureCount: number; successCount: number };\r\n    rateLimiter: { tokens: number; maxTokens: number };\r\n    sessions: number;\r\n  } {\r\n    return {\r\n      loadBalancer: this.getMetrics(),\r\n      circuitBreaker: this.circuitBreaker.getMetrics(),\r\n      rateLimiter: {\r\n        tokens: this.rateLimiter.getTokens(),\r\n        maxTokens: this.config.maxRequestsPerSecond,\r\n      },\r\n      sessions: this.sessionRateLimiters.size,\r\n    };\r\n  }\r\n\r\n  private getSessionRateLimiter(sessionId: string): RateLimiter {\r\n    let rateLimiter = this.sessionRateLimiters.get(sessionId);\r\n\r\n    if (!rateLimiter) {\r\n      // Create a per-session rate limiter (more restrictive than global)\r\n      const sessionLimit = Math.max(1, Math.floor(this.config.maxRequestsPerSecond / 10));\r\n      rateLimiter = new RateLimiter(sessionLimit, sessionLimit);\r\n      this.sessionRateLimiters.set(sessionId, rateLimiter);\r\n    }\r\n\r\n    return rateLimiter;\r\n  }\r\n\r\n  private calculateAverageResponseTime(): number {\r\n    if (this.requestTimes.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const sum = this.requestTimes.reduce((acc, time) => acc + time, 0);\r\n    return sum / this.requestTimes.length;\r\n  }\r\n\r\n  private updateRequestsPerSecond(): void {\r\n    const now = Math.floor(Date.now() / 1000);\r\n\r\n    if (now !== this.lastSecondTimestamp) {\r\n      this.metrics.requestsPerSecond = this.requestsInLastSecond;\r\n      this.requestsInLastSecond = 1;\r\n      this.lastSecondTimestamp = now;\r\n    } else {\r\n      this.requestsInLastSecond++;\r\n    }\r\n  }\r\n\r\n  private cleanupSessionRateLimiters(): void {\r\n    // Remove rate limiters for sessions that haven't been used recently\r\n    const cutoffTime = Date.now() - 300000; // 5 minutes ago\r\n    let cleaned = 0;\r\n\r\n    for (const [sessionId, rateLimiter] of this.sessionRateLimiters.entries()) {\r\n      // If the rate limiter has full tokens, it hasn't been used recently\r\n      if (rateLimiter.getTokens() === this.config.maxRequestsPerSecond) {\r\n        this.sessionRateLimiters.delete(sessionId);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      this.logger.debug('Cleaned up session rate limiters', { count: cleaned });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Request queue for handling backpressure\r\n */\r\nexport class RequestQueue {\r\n  private queue: Array<{\r\n    session: MCPSession;\r\n    request: MCPRequest;\r\n    resolve: (result: any) => void;\r\n    reject: (error: Error) => void;\r\n    timestamp: number;\r\n  }> = [];\r\n\r\n  private processing = false;\r\n  private maxQueueSize: number;\r\n  private requestTimeout: number;\r\n\r\n  constructor(\r\n    maxQueueSize = 1000,\r\n    requestTimeout = 30000, // 30 seconds\r\n    private logger: ILogger,\r\n  ) {\r\n    this.maxQueueSize = maxQueueSize;\r\n    this.requestTimeout = requestTimeout;\r\n\r\n    // Clean up expired requests periodically\r\n    setInterval(() => {\r\n      this.cleanupExpiredRequests();\r\n    }, 10000); // Every 10 seconds\r\n  }\r\n\r\n  async enqueue<T>(\r\n    session: MCPSession,\r\n    request: MCPRequest,\r\n    processor: (session: MCPSession, request: MCPRequest) => Promise<T>,\r\n  ): Promise<T> {\r\n    if (this.queue.length >= this.maxQueueSize) {\r\n      throw new MCPError('Request queue is full');\r\n    }\r\n\r\n    return new Promise<T>((resolve, reject) => {\r\n      this.queue.push({\r\n        session,\r\n        request,\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now(),\r\n      });\r\n\r\n      if (!this.processing) {\r\n        this.processQueue(processor);\r\n      }\r\n    });\r\n  }\r\n\r\n  private async processQueue<T>(\r\n    processor: (session: MCPSession, request: MCPRequest) => Promise<T>,\r\n  ): Promise<void> {\r\n    if (this.processing) {\r\n      return;\r\n    }\r\n\r\n    this.processing = true;\r\n\r\n    while (this.queue.length > 0) {\r\n      const item = this.queue.shift()!;\r\n\r\n      // Check if request has expired\r\n      if (Date.now() - item.timestamp > this.requestTimeout) {\r\n        item.reject(new MCPError('Request timeout'));\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        const result = await processor(item.session, item.request);\r\n        item.resolve(result);\r\n      } catch (error) {\r\n        item.reject(error instanceof Error ? error : new Error(String(error)));\r\n      }\r\n    }\r\n\r\n    this.processing = false;\r\n  }\r\n\r\n  private cleanupExpiredRequests(): void {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n\r\n    this.queue = this.queue.filter((item) => {\r\n      if (now - item.timestamp > this.requestTimeout) {\r\n        item.reject(new MCPError('Request timeout'));\r\n        cleaned++;\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    if (cleaned > 0) {\r\n      this.logger.warn('Cleaned up expired requests from queue', { count: cleaned });\r\n    }\r\n  }\r\n\r\n  getQueueSize(): number {\r\n    return this.queue.length;\r\n  }\r\n\r\n  isProcessing(): boolean {\r\n    return this.processing;\r\n  }\r\n}\r\n"],"names":["MCPError","CircuitBreakerState","RateLimiter","tokens","lastRefill","maxTokens","refillRate","Date","now","tryConsume","refill","timePassed","tokensToAdd","Math","floor","min","getTokens","CircuitBreaker","state","failureCount","lastFailureTime","successCount","failureThreshold","recoveryTimeout","halfOpenMaxRequests","canExecute","recordSuccess","recordFailure","getState","getMetrics","LoadBalancer","rateLimiter","circuitBreaker","sessionRateLimiters","Map","metrics","requestTimes","requestsInLastSecond","lastSecondTimestamp","config","logger","maxRequestsPerSecond","circuitBreakerThreshold","totalRequests","successfulRequests","failedRequests","rateLimitedRequests","averageResponseTime","requestsPerSecond","circuitBreakerTrips","lastReset","setInterval","cleanupSessionRateLimiters","shouldAllowRequest","session","request","enabled","warn","sessionId","id","method","circuitState","remainingTokens","sessionRateLimiter","getSessionRateLimiter","recordRequestStart","requestMetrics","requestId","toString","startTime","updateRequestsPerSecond","debug","recordRequestEnd","response","error","endTime","duration","push","length","shift","success","errorMessage","message","calculateAverageResponseTime","resetMetrics","info","isCircuitBreakerOpen","getDetailedMetrics","loadBalancer","sessions","size","get","sessionLimit","max","set","sum","reduce","acc","time","cutoffTime","cleaned","entries","delete","count","RequestQueue","queue","processing","maxQueueSize","requestTimeout","cleanupExpiredRequests","enqueue","processor","Promise","resolve","reject","timestamp","processQueue","item","result","Error","String","filter","getQueueSize","isProcessing"],"mappings":"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"}