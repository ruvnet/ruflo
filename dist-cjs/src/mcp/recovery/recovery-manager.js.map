{"version":3,"sources":["../../../../src/mcp/recovery/recovery-manager.ts"],"sourcesContent":["/**\r\n * Recovery Manager for MCP\r\n * Orchestrates all recovery components for comprehensive connection stability\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport type { ILogger } from '../../core/logger.js';\r\nimport type { MCPClient } from '../client.js';\r\nimport { ConnectionHealthMonitor, HealthStatus } from './connection-health-monitor.js';\r\nimport { ReconnectionManager } from './reconnection-manager.js';\r\nimport { FallbackCoordinator } from './fallback-coordinator.js';\r\nimport { ConnectionStateManager } from './connection-state-manager.js';\r\nimport type { MCPConfig, MCPRequest } from '../../utils/types.js';\r\n\r\nexport interface RecoveryConfig {\r\n  enableRecovery: boolean;\r\n  healthMonitor?: {\r\n    heartbeatInterval?: number;\r\n    heartbeatTimeout?: number;\r\n    maxMissedHeartbeats?: number;\r\n  };\r\n  reconnection?: {\r\n    maxRetries?: number;\r\n    initialDelay?: number;\r\n    maxDelay?: number;\r\n    backoffMultiplier?: number;\r\n  };\r\n  fallback?: {\r\n    enableFallback?: boolean;\r\n    maxQueueSize?: number;\r\n    cliPath?: string;\r\n  };\r\n  state?: {\r\n    enablePersistence?: boolean;\r\n    stateDirectory?: string;\r\n  };\r\n}\r\n\r\nexport interface RecoveryStatus {\r\n  isRecoveryActive: boolean;\r\n  connectionHealth: HealthStatus;\r\n  reconnectionState: {\r\n    attempts: number;\r\n    isReconnecting: boolean;\r\n    nextDelay?: number;\r\n  };\r\n  fallbackState: {\r\n    isFallbackActive: boolean;\r\n    queuedOperations: number;\r\n  };\r\n  metrics: {\r\n    totalRecoveries: number;\r\n    successfulRecoveries: number;\r\n    failedRecoveries: number;\r\n    averageRecoveryTime: number;\r\n  };\r\n}\r\n\r\nexport class RecoveryManager extends EventEmitter {\r\n  private healthMonitor: ConnectionHealthMonitor;\r\n  private reconnectionManager: ReconnectionManager;\r\n  private fallbackCoordinator: FallbackCoordinator;\r\n  private stateManager: ConnectionStateManager;\r\n\r\n  private isRecoveryActive = false;\r\n  private recoveryStartTime?: Date;\r\n  private metrics = {\r\n    totalRecoveries: 0,\r\n    successfulRecoveries: 0,\r\n    failedRecoveries: 0,\r\n    totalRecoveryTime: 0,\r\n  };\r\n\r\n  constructor(\r\n    private client: MCPClient,\r\n    private mcpConfig: MCPConfig,\r\n    private logger: ILogger,\r\n    config?: RecoveryConfig,\r\n  ) {\r\n    super();\r\n\r\n    // Initialize components\r\n    this.healthMonitor = new ConnectionHealthMonitor(client, logger, config?.healthMonitor);\r\n\r\n    this.reconnectionManager = new ReconnectionManager(client, logger, config?.reconnection);\r\n\r\n    this.fallbackCoordinator = new FallbackCoordinator(logger, config?.fallback);\r\n\r\n    this.stateManager = new ConnectionStateManager(logger, config?.state);\r\n\r\n    // Set up component event handlers\r\n    this.setupEventHandlers();\r\n\r\n    this.logger.info('Recovery manager initialized');\r\n  }\r\n\r\n  /**\r\n   * Start recovery management\r\n   */\r\n  async start(): Promise<void> {\r\n    this.logger.info('Starting recovery manager');\r\n\r\n    // Start health monitoring\r\n    await this.healthMonitor.start();\r\n\r\n    // Restore any previous state\r\n    const previousState = this.stateManager.restoreState();\r\n    if (previousState && previousState.pendingRequests.length > 0) {\r\n      this.logger.info('Restored previous connection state', {\r\n        sessionId: previousState.sessionId,\r\n        pendingRequests: previousState.pendingRequests.length,\r\n      });\r\n\r\n      // Queue pending requests for retry\r\n      previousState.pendingRequests.forEach((request) => {\r\n        this.fallbackCoordinator.queueOperation({\r\n          type: 'tool',\r\n          method: request.method,\r\n          params: request.params,\r\n          priority: 'high',\r\n          retryable: true,\r\n        });\r\n      });\r\n    }\r\n\r\n    this.emit('started');\r\n  }\r\n\r\n  /**\r\n   * Stop recovery management\r\n   */\r\n  async stop(): Promise<void> {\r\n    this.logger.info('Stopping recovery manager');\r\n\r\n    // Stop all components\r\n    await this.healthMonitor.stop();\r\n    this.reconnectionManager.stopReconnection();\r\n    this.fallbackCoordinator.disableCLIFallback();\r\n    await this.stateManager.cleanup();\r\n\r\n    this.emit('stopped');\r\n  }\r\n\r\n  /**\r\n   * Get current recovery status\r\n   */\r\n  getStatus(): RecoveryStatus {\r\n    const healthStatus = this.healthMonitor.getHealthStatus();\r\n    const reconnectionState = this.reconnectionManager.getState();\r\n    const fallbackState = this.fallbackCoordinator.getState();\r\n\r\n    return {\r\n      isRecoveryActive: this.isRecoveryActive,\r\n      connectionHealth: healthStatus,\r\n      reconnectionState: {\r\n        attempts: reconnectionState.attempts,\r\n        isReconnecting: reconnectionState.isReconnecting,\r\n        nextDelay: reconnectionState.nextDelay,\r\n      },\r\n      fallbackState: {\r\n        isFallbackActive: fallbackState.isFallbackActive,\r\n        queuedOperations: fallbackState.queuedOperations,\r\n      },\r\n      metrics: {\r\n        totalRecoveries: this.metrics.totalRecoveries,\r\n        successfulRecoveries: this.metrics.successfulRecoveries,\r\n        failedRecoveries: this.metrics.failedRecoveries,\r\n        averageRecoveryTime:\r\n          this.metrics.totalRecoveries > 0\r\n            ? this.metrics.totalRecoveryTime / this.metrics.totalRecoveries\r\n            : 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Force a recovery attempt\r\n   */\r\n  async forceRecovery(): Promise<boolean> {\r\n    this.logger.info('Forcing recovery attempt');\r\n\r\n    // Check if already recovering\r\n    if (this.isRecoveryActive) {\r\n      this.logger.warn('Recovery already in progress');\r\n      return false;\r\n    }\r\n\r\n    return this.startRecovery('manual');\r\n  }\r\n\r\n  /**\r\n   * Handle a request that needs recovery consideration\r\n   */\r\n  async handleRequest(request: MCPRequest): Promise<void> {\r\n    // Add to pending requests if disconnected\r\n    if (!this.client.isConnected()) {\r\n      this.stateManager.addPendingRequest(request);\r\n\r\n      // Queue for fallback execution\r\n      this.fallbackCoordinator.queueOperation({\r\n        type: 'tool',\r\n        method: request.method,\r\n        params: request.params,\r\n        priority: 'medium',\r\n        retryable: true,\r\n      });\r\n    }\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    // Health monitor events\r\n    this.healthMonitor.on('connectionLost', async ({ error }) => {\r\n      this.logger.error('Connection lost, initiating recovery', error);\r\n      await this.startRecovery('health-check');\r\n    });\r\n\r\n    this.healthMonitor.on('healthChange', (newStatus, oldStatus) => {\r\n      this.emit('healthChange', newStatus, oldStatus);\r\n\r\n      // Record state change\r\n      this.stateManager.recordEvent({\r\n        type: newStatus.healthy ? 'connect' : 'disconnect',\r\n        sessionId: this.generateSessionId(),\r\n        details: { health: newStatus },\r\n      });\r\n    });\r\n\r\n    // Reconnection manager events\r\n    this.reconnectionManager.on('success', async ({ attempts, duration }) => {\r\n      this.logger.info('Reconnection successful', { attempts, duration });\r\n      await this.completeRecovery(true);\r\n    });\r\n\r\n    this.reconnectionManager.on('maxRetriesExceeded', async () => {\r\n      this.logger.error('Max reconnection attempts exceeded');\r\n      await this.completeRecovery(false);\r\n    });\r\n\r\n    this.reconnectionManager.on('attemptFailed', ({ attempt, error }) => {\r\n      this.emit('recoveryAttemptFailed', { attempt, error });\r\n    });\r\n\r\n    // Fallback coordinator events\r\n    this.fallbackCoordinator.on('fallbackEnabled', (state) => {\r\n      this.logger.warn('Fallback mode activated', state);\r\n      this.emit('fallbackActivated', state);\r\n    });\r\n\r\n    this.fallbackCoordinator.on('replayOperation', async (operation) => {\r\n      // Replay operation through MCP client\r\n      if (this.client.isConnected()) {\r\n        try {\r\n          await this.client.request(operation.method, operation.params);\r\n          this.stateManager.removePendingRequest(operation.id);\r\n        } catch (error) {\r\n          this.logger.error('Failed to replay operation', { operation, error });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private async startRecovery(trigger: string): Promise<boolean> {\r\n    if (this.isRecoveryActive) {\r\n      return false;\r\n    }\r\n\r\n    this.isRecoveryActive = true;\r\n    this.recoveryStartTime = new Date();\r\n    this.metrics.totalRecoveries++;\r\n\r\n    this.logger.info('Starting recovery process', { trigger });\r\n    this.emit('recoveryStart', { trigger });\r\n\r\n    // Save current state\r\n    this.stateManager.saveState({\r\n      sessionId: this.generateSessionId(),\r\n      lastConnected: new Date(),\r\n      pendingRequests: [],\r\n      configuration: this.mcpConfig,\r\n      metadata: { trigger },\r\n    });\r\n\r\n    // Enable fallback mode immediately\r\n    this.fallbackCoordinator.enableCLIFallback();\r\n\r\n    // Start reconnection attempts\r\n    this.reconnectionManager.startAutoReconnect();\r\n\r\n    return true;\r\n  }\r\n\r\n  private async completeRecovery(success: boolean): Promise<void> {\r\n    if (!this.isRecoveryActive) {\r\n      return;\r\n    }\r\n\r\n    const duration = this.recoveryStartTime ? Date.now() - this.recoveryStartTime.getTime() : 0;\r\n\r\n    this.isRecoveryActive = false;\r\n    this.recoveryStartTime = undefined;\r\n\r\n    if (success) {\r\n      this.metrics.successfulRecoveries++;\r\n      this.metrics.totalRecoveryTime += duration;\r\n\r\n      // Disable fallback mode\r\n      this.fallbackCoordinator.disableCLIFallback();\r\n\r\n      // Process any queued operations\r\n      await this.fallbackCoordinator.processQueue();\r\n\r\n      // Reset health monitor\r\n      this.healthMonitor.reset();\r\n\r\n      // Record reconnection\r\n      this.stateManager.recordEvent({\r\n        type: 'reconnect',\r\n        sessionId: this.generateSessionId(),\r\n        details: { duration },\r\n      });\r\n\r\n      this.logger.info('Recovery completed successfully', { duration });\r\n      this.emit('recoveryComplete', { success: true, duration });\r\n    } else {\r\n      this.metrics.failedRecoveries++;\r\n\r\n      this.logger.error('Recovery failed');\r\n      this.emit('recoveryComplete', { success: false, duration });\r\n\r\n      // Keep fallback active\r\n      this.emit('fallbackPermanent');\r\n    }\r\n  }\r\n\r\n  private generateSessionId(): string {\r\n    return `recovery-${Date.now()}-${Math.random().toString(36).slice(2)}`;\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   */\r\n  async cleanup(): Promise<void> {\r\n    await this.stop();\r\n  }\r\n}\r\n"],"names":["EventEmitter","ConnectionHealthMonitor","ReconnectionManager","FallbackCoordinator","ConnectionStateManager","RecoveryManager","healthMonitor","reconnectionManager","fallbackCoordinator","stateManager","isRecoveryActive","recoveryStartTime","metrics","totalRecoveries","successfulRecoveries","failedRecoveries","totalRecoveryTime","client","mcpConfig","logger","config","reconnection","fallback","state","setupEventHandlers","info","start","previousState","restoreState","pendingRequests","length","sessionId","forEach","request","queueOperation","type","method","params","priority","retryable","emit","stop","stopReconnection","disableCLIFallback","cleanup","getStatus","healthStatus","getHealthStatus","reconnectionState","getState","fallbackState","connectionHealth","attempts","isReconnecting","nextDelay","isFallbackActive","queuedOperations","averageRecoveryTime","forceRecovery","warn","startRecovery","handleRequest","isConnected","addPendingRequest","on","error","newStatus","oldStatus","recordEvent","healthy","generateSessionId","details","health","duration","completeRecovery","attempt","operation","removePendingRequest","id","trigger","Date","saveState","lastConnected","configuration","metadata","enableCLIFallback","startAutoReconnect","success","now","getTime","undefined","processQueue","reset","Math","random","toString","slice"],"mappings":"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"}