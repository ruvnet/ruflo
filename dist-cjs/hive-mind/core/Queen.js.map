{
  "version": 3,
  "sources": ["../../../src/hive-mind/core/Queen.ts"],
  "sourcesContent": ["/**\n * Queen Coordinator Class\n *\n * The Queen manages high-level coordination, decision-making,\n * and strategic planning for the Hive Mind swarm.\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Agent } from './Agent.js';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\nimport {\n  SwarmTopology,\n  Task,\n  AgentType,\n  QueenMode,\n  ConsensusProposal,\n  QueenDecision,\n  CoordinationStrategy,\n} from '../types.js';\n\ninterface QueenConfig {\n  swarmId: string;\n  mode: QueenMode;\n  topology: SwarmTopology;\n}\n\nexport class Queen extends EventEmitter {\n  private id: string;\n  private config: QueenConfig;\n  private agents: Map<string, Agent>;\n  private taskQueue: Map<string, Task>;\n  private strategies: Map<string, CoordinationStrategy>;\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private isActive: boolean = false;\n\n  constructor(config: QueenConfig) {\n    super();\n    this.id = uuidv4();\n    this.config = config;\n    this.agents = new Map();\n    this.taskQueue = new Map();\n    this.strategies = new Map();\n    this.initializeStrategies();\n  }\n\n  /**\n   * Initialize the Queen and her coordination capabilities\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n\n    // Create Queen as a special coordinator agent\n    await this.db.createAgent({\n      id: this.id,\n      swarmId: this.config.swarmId,\n      name: 'Queen',\n      type: 'coordinator',\n      capabilities: JSON.stringify([\n        'strategic_planning',\n        'task_allocation',\n        'consensus_coordination',\n        'performance_optimization',\n        'swarm_governance',\n      ]),\n      status: 'active',\n      metadata: JSON.stringify({ role: 'queen', mode: this.config.mode }),\n    });\n\n    this.isActive = true;\n\n    // Start coordination loops\n    this.startCoordinationLoop();\n    this.startOptimizationLoop();\n\n    this.emit('initialized');\n  }\n\n  /**\n   * Register a new agent with the Queen\n   */\n  async registerAgent(agent: Agent): Promise<void> {\n    this.agents.set(agent.id, agent);\n\n    // Analyze agent capabilities and update strategies\n    await this.analyzeAgentCapabilities(agent);\n\n    // Notify other agents in distributed mode\n    if (this.config.mode === 'distributed') {\n      await this.broadcastAgentRegistration(agent);\n    }\n\n    this.emit('agentRegistered', { agent });\n  }\n\n  /**\n   * Handle task submission\n   */\n  async onTaskSubmitted(task: Task): Promise<QueenDecision> {\n    this.taskQueue.set(task.id, task);\n\n    // Analyze task requirements\n    const analysis = await this.analyzeTask(task);\n\n    // Make strategic decision\n    const decision = await this.makeStrategicDecision(task, analysis);\n\n    // If consensus required, initiate consensus process\n    if (task.requireConsensus) {\n      await this.initiateConsensus(task, decision);\n    }\n\n    // Apply decision\n    await this.applyDecision(decision);\n\n    this.emit('taskDecision', { task, decision });\n\n    return decision;\n  }\n\n  /**\n   * Make a strategic decision about task execution\n   */\n  private async makeStrategicDecision(task: Task, analysis: any): Promise<QueenDecision> {\n    // Use MCP neural capabilities for decision making\n    const neuralAnalysis = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'task_strategy',\n      metadata: {\n        task: task.description,\n        priority: task.priority,\n        topology: this.config.topology,\n        availableAgents: this.getAvailableAgents().length,\n      },\n    });\n\n    // Select optimal strategy\n    const strategy = this.selectOptimalStrategy(task, analysis, neuralAnalysis);\n\n    // Identify best agents for the task\n    const selectedAgents = await this.selectAgentsForTask(task, strategy);\n\n    // Create execution plan\n    const executionPlan = this.createExecutionPlan(task, selectedAgents, strategy);\n\n    return {\n      id: uuidv4(),\n      taskId: task.id,\n      strategy,\n      selectedAgents: selectedAgents.map((a) => a.id),\n      executionPlan,\n      confidence: analysis.confidence || 0.85,\n      rationale: analysis.rationale || 'Strategic analysis completed',\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Select optimal coordination strategy\n   */\n  private selectOptimalStrategy(\n    task: Task,\n    analysis: any,\n    neuralAnalysis: any,\n  ): CoordinationStrategy {\n    // Strategy selection based on multiple factors\n    const factors = {\n      taskComplexity: analysis.complexity || 'medium',\n      agentAvailability: this.getAvailableAgents().length,\n      topology: this.config.topology,\n      priority: task.priority,\n      consensusRequired: task.requireConsensus,\n    };\n\n    // Use topology-specific strategies\n    if (this.config.topology === 'hierarchical' && factors.taskComplexity === 'high') {\n      return this.strategies.get('hierarchical-cascade')!;\n    }\n\n    if (this.config.topology === 'mesh' && factors.consensusRequired) {\n      return this.strategies.get('mesh-consensus')!;\n    }\n\n    if (factors.priority === 'critical') {\n      return this.strategies.get('priority-fast-track')!;\n    }\n\n    // Default adaptive strategy\n    return this.strategies.get('adaptive-default')!;\n  }\n\n  /**\n   * Select best agents for a task\n   */\n  private async selectAgentsForTask(task: Task, strategy: CoordinationStrategy): Promise<Agent[]> {\n    const availableAgents = this.getAvailableAgents();\n    const requiredCapabilities = task.requiredCapabilities || [];\n\n    // Score agents based on capabilities and current load\n    const scoredAgents = await Promise.all(\n      availableAgents.map(async (agent) => {\n        const score = await this.scoreAgentForTask(agent, task, requiredCapabilities);\n        return { agent, score };\n      }),\n    );\n\n    // Sort by score and select top agents\n    scoredAgents.sort((a, b) => b.score - a.score);\n\n    const maxAgents = Math.min(task.maxAgents, strategy.maxAgents || 3);\n    return scoredAgents.slice(0, maxAgents).map((sa) => sa.agent);\n  }\n\n  /**\n   * Score an agent for a specific task\n   */\n  private async scoreAgentForTask(\n    agent: Agent,\n    task: Task,\n    requiredCapabilities: string[],\n  ): Promise<number> {\n    let score = 0;\n\n    // Capability match\n    const capabilityMatches = requiredCapabilities.filter((cap) =>\n      agent.capabilities.includes(cap),\n    ).length;\n    score += capabilityMatches * 10;\n\n    // Agent type suitability\n    const typeSuitability = this.getTypeSuitabilityForTask(agent.type, task);\n    score += typeSuitability * 5;\n\n    // Current workload (prefer less busy agents)\n    if (agent.status === 'idle') score += 8;\n    else if (agent.status === 'active') score += 4;\n\n    // Historical performance (from database)\n    const performance = await this.db.getAgentPerformance(agent.id);\n    if (performance) {\n      score += performance.successRate * 10;\n    }\n\n    // Specialty bonus\n    if (agent.type === 'specialist' && requiredCapabilities.length > 0) {\n      score += 5;\n    }\n\n    return score;\n  }\n\n  /**\n   * Get type suitability score for a task\n   */\n  private getTypeSuitabilityForTask(agentType: AgentType, task: Task): number {\n    const suitabilityMap: Record<string, Record<AgentType, number>> = {\n      research: {\n        researcher: 10,\n        analyst: 8,\n        specialist: 6,\n        coder: 4,\n        coordinator: 5,\n        architect: 5,\n        tester: 3,\n        reviewer: 4,\n        optimizer: 4,\n        documenter: 6,\n        monitor: 3,\n      },\n      development: {\n        coder: 10,\n        architect: 8,\n        tester: 7,\n        reviewer: 6,\n        coordinator: 5,\n        specialist: 6,\n        researcher: 4,\n        analyst: 4,\n        optimizer: 5,\n        documenter: 4,\n        monitor: 3,\n      },\n      analysis: {\n        analyst: 10,\n        researcher: 8,\n        specialist: 6,\n        reviewer: 5,\n        coordinator: 5,\n        architect: 4,\n        coder: 4,\n        tester: 3,\n        optimizer: 5,\n        documenter: 4,\n        monitor: 4,\n      },\n      testing: {\n        tester: 10,\n        reviewer: 8,\n        analyst: 6,\n        coder: 5,\n        coordinator: 4,\n        specialist: 5,\n        researcher: 3,\n        architect: 4,\n        optimizer: 4,\n        documenter: 3,\n        monitor: 4,\n      },\n      optimization: {\n        optimizer: 10,\n        analyst: 8,\n        coder: 7,\n        architect: 6,\n        coordinator: 5,\n        specialist: 6,\n        researcher: 4,\n        tester: 4,\n        reviewer: 5,\n        documenter: 3,\n        monitor: 4,\n      },\n    };\n\n    // Detect task type from description\n    const taskType = this.detectTaskType(task.description);\n    return suitabilityMap[taskType]?.[agentType] || 5;\n  }\n\n  /**\n   * Detect task type from description\n   */\n  private detectTaskType(description: string): string {\n    const lower = description.toLowerCase();\n\n    if (lower.includes('research') || lower.includes('investigate') || lower.includes('explore')) {\n      return 'research';\n    }\n    if (\n      lower.includes('develop') ||\n      lower.includes('implement') ||\n      lower.includes('build') ||\n      lower.includes('create')\n    ) {\n      return 'development';\n    }\n    if (lower.includes('analyze') || lower.includes('review') || lower.includes('assess')) {\n      return 'analysis';\n    }\n    if (lower.includes('test') || lower.includes('validate') || lower.includes('verify')) {\n      return 'testing';\n    }\n    if (lower.includes('optimize') || lower.includes('improve') || lower.includes('enhance')) {\n      return 'optimization';\n    }\n\n    return 'general';\n  }\n\n  /**\n   * Create execution plan for task\n   */\n  private createExecutionPlan(task: Task, agents: Agent[], strategy: CoordinationStrategy): any {\n    return {\n      phases: strategy.phases || ['preparation', 'execution', 'validation'],\n      agentAssignments: agents.map((agent) => ({\n        agentId: agent.id,\n        role: this.determineAgentRole(agent, task),\n        responsibilities: this.getAgentResponsibilities(agent, task),\n      })),\n      coordinationPoints: strategy.coordinationPoints || ['start', 'midpoint', 'completion'],\n      checkpoints: this.createCheckpoints(task, strategy),\n      fallbackPlan: this.createFallbackPlan(task, agents),\n    };\n  }\n\n  /**\n   * Initiate consensus process\n   */\n  private async initiateConsensus(task: Task, decision: QueenDecision): Promise<void> {\n    const proposal: ConsensusProposal = {\n      id: uuidv4(),\n      swarmId: this.config.swarmId,\n      taskId: task.id,\n      proposal: {\n        decision,\n        task: task.description,\n        rationale: decision.rationale,\n      },\n      requiredThreshold: 0.66,\n      deadline: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\n    };\n\n    await this.db.createConsensusProposal(proposal);\n\n    // Notify all agents to vote\n    await this.broadcastConsensusRequest(proposal);\n  }\n\n  /**\n   * Apply Queen's decision\n   */\n  private async applyDecision(decision: QueenDecision): Promise<void> {\n    // Update task with assignments\n    await this.db.updateTask(decision.taskId, {\n      assigned_agents: JSON.stringify(decision.selectedAgents),\n      status: 'assigned',\n      assigned_at: new Date(),\n    });\n\n    // Notify selected agents\n    for (const agentId of decision.selectedAgents) {\n      const agent = this.agents.get(agentId);\n      if (agent) {\n        await agent.assignTask(decision.taskId, decision.executionPlan);\n      }\n    }\n\n    // Store decision in memory for learning\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `decision/${decision.taskId}`,\n      value: JSON.stringify(decision),\n      namespace: 'queen-decisions',\n      ttl: 86400 * 7, // 7 days\n    });\n  }\n\n  /**\n   * Start coordination loop\n   */\n  private startCoordinationLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Monitor agent health\n        await this.monitorAgentHealth();\n\n        // Check task progress\n        await this.checkTaskProgress();\n\n        // Rebalance if needed\n        await this.checkRebalancing();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 5000); // Every 5 seconds\n  }\n\n  /**\n   * Start optimization loop\n   */\n  private startOptimizationLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Analyze performance patterns\n        await this.analyzePerformancePatterns();\n\n        // Optimize strategies\n        await this.optimizeStrategies();\n\n        // Train neural patterns\n        await this.trainNeuralPatterns();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Initialize coordination strategies\n   */\n  private initializeStrategies(): void {\n    // Hierarchical cascade strategy\n    this.strategies.set('hierarchical-cascade', {\n      name: 'Hierarchical Cascade',\n      description: 'Top-down task distribution with clear delegation',\n      phases: ['planning', 'delegation', 'execution', 'aggregation'],\n      maxAgents: 5,\n      coordinationPoints: ['phase-transition', 'milestone', 'completion'],\n      suitable_for: ['complex-tasks', 'multi-phase-projects'],\n    });\n\n    // Mesh consensus strategy\n    this.strategies.set('mesh-consensus', {\n      name: 'Mesh Consensus',\n      description: 'Peer-to-peer coordination with consensus requirements',\n      phases: ['proposal', 'discussion', 'consensus', 'execution'],\n      maxAgents: 7,\n      coordinationPoints: ['consensus-check', 'progress-sync', 'final-vote'],\n      suitable_for: ['critical-decisions', 'collaborative-tasks'],\n    });\n\n    // Priority fast-track strategy\n    this.strategies.set('priority-fast-track', {\n      name: 'Priority Fast Track',\n      description: 'Rapid execution for critical tasks',\n      phases: ['immediate-assignment', 'parallel-execution', 'quick-validation'],\n      maxAgents: 3,\n      coordinationPoints: ['start', 'critical-path', 'completion'],\n      suitable_for: ['urgent-tasks', 'critical-fixes'],\n    });\n\n    // Adaptive default strategy\n    this.strategies.set('adaptive-default', {\n      name: 'Adaptive Default',\n      description: 'Flexible strategy that adapts to task requirements',\n      phases: ['analysis', 'planning', 'execution', 'review'],\n      maxAgents: 4,\n      coordinationPoints: ['checkpoint', 'adaptation-point', 'completion'],\n      suitable_for: ['general-tasks', 'unknown-complexity'],\n    });\n  }\n\n  /**\n   * Helper methods\n   */\n\n  private getAvailableAgents(): Agent[] {\n    return Array.from(this.agents.values()).filter(\n      (agent) => agent.status === 'idle' || agent.status === 'active',\n    );\n  }\n\n  private async analyzeTask(task: Task): Promise<any> {\n    // Use MCP tools to analyze task complexity and requirements\n    return this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'task_analysis',\n      metadata: {\n        description: task.description,\n        priority: task.priority,\n        dependencies: task.dependencies,\n      },\n    });\n  }\n\n  private async analyzeAgentCapabilities(agent: Agent): Promise<void> {\n    // Analyze and store agent capability patterns\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `agent-capabilities/${agent.id}`,\n      value: JSON.stringify({\n        type: agent.type,\n        capabilities: agent.capabilities,\n        registeredAt: new Date(),\n      }),\n      namespace: 'agent-registry',\n    });\n  }\n\n  private async broadcastAgentRegistration(agent: Agent): Promise<void> {\n    // In distributed mode, notify other Queens/coordinators\n    await this.db.createCommunication({\n      from_agent_id: this.id,\n      to_agent_id: null, // broadcast\n      swarm_id: this.config.swarmId,\n      message_type: 'broadcast',\n      content: JSON.stringify({\n        type: 'agent_registered',\n        agent: {\n          id: agent.id,\n          type: agent.type,\n          capabilities: agent.capabilities,\n        },\n      }),\n      priority: 'high',\n    });\n  }\n\n  private async broadcastConsensusRequest(proposal: ConsensusProposal): Promise<void> {\n    await this.db.createCommunication({\n      from_agent_id: this.id,\n      to_agent_id: null, // broadcast\n      swarm_id: this.config.swarmId,\n      message_type: 'consensus',\n      content: JSON.stringify(proposal),\n      priority: 'urgent',\n      requires_response: true,\n    });\n  }\n\n  private determineAgentRole(agent: Agent, task: Task): string {\n    // Determine specific role based on agent type and task\n    const roleMap: Record<AgentType, string> = {\n      coordinator: 'lead',\n      researcher: 'investigator',\n      coder: 'implementer',\n      analyst: 'evaluator',\n      architect: 'designer',\n      tester: 'validator',\n      reviewer: 'auditor',\n      optimizer: 'enhancer',\n      documenter: 'recorder',\n      monitor: 'observer',\n      specialist: 'expert',\n    };\n\n    return roleMap[agent.type] || 'contributor';\n  }\n\n  private getAgentResponsibilities(agent: Agent, task: Task): string[] {\n    // Define specific responsibilities based on role\n    const responsibilityMap: Record<AgentType, string[]> = {\n      coordinator: ['coordinate team', 'track progress', 'resolve conflicts'],\n      researcher: ['gather information', 'identify patterns', 'provide insights'],\n      coder: ['implement solution', 'write tests', 'debug issues'],\n      analyst: ['analyze data', 'identify bottlenecks', 'suggest improvements'],\n      architect: ['design system', 'define interfaces', 'ensure scalability'],\n      tester: ['write tests', 'find bugs', 'validate functionality'],\n      reviewer: ['review code', 'ensure quality', 'suggest improvements'],\n      optimizer: ['improve performance', 'reduce complexity', 'optimize resources'],\n      documenter: ['create documentation', 'update guides', 'maintain clarity'],\n      monitor: ['track metrics', 'alert on issues', 'ensure health'],\n      specialist: ['provide expertise', 'solve complex problems', 'guide implementation'],\n    };\n\n    return responsibilityMap[agent.type] || ['contribute to task'];\n  }\n\n  private createCheckpoints(task: Task, strategy: CoordinationStrategy): any[] {\n    return strategy.coordinationPoints.map((point, index) => ({\n      name: point,\n      expectedProgress: Math.round(((index + 1) / strategy.coordinationPoints.length) * 100),\n      actions: ['status_check', 'sync_progress', 'adjust_strategy'],\n    }));\n  }\n\n  private createFallbackPlan(task: Task, agents: Agent[]): any {\n    return {\n      triggers: ['agent_failure', 'deadline_approaching', 'consensus_failure'],\n      actions: [\n        'reassign_to_available_agents',\n        'escalate_to_queen',\n        'activate_backup_agents',\n        'simplify_task_requirements',\n      ],\n      escalation_path: ['team_lead', 'queen', 'human_operator'],\n    };\n  }\n\n  private async monitorAgentHealth(): Promise<void> {\n    for (const agent of this.agents.values()) {\n      if (agent.status === 'error' || !agent.isResponsive()) {\n        await this.handleAgentFailure(agent);\n      }\n    }\n  }\n\n  private async checkTaskProgress(): Promise<void> {\n    const activeTasks = await this.db.getActiveTasks(this.config.swarmId);\n\n    for (const task of activeTasks) {\n      if (this.isTaskStalled(task)) {\n        await this.handleStalledTask(task);\n      }\n    }\n  }\n\n  private async checkRebalancing(): Promise<void> {\n    const stats = await this.db.getSwarmStats(this.config.swarmId);\n\n    if (stats.agentUtilization > 0.9 || stats.taskBacklog > stats.agentCount * 2) {\n      this.emit('rebalanceNeeded', stats);\n    }\n  }\n\n  private async analyzePerformancePatterns(): Promise<void> {\n    const patterns = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'performance_patterns',\n      metadata: {\n        swarmId: this.config.swarmId,\n        timeframe: '1h',\n      },\n    });\n\n    if (patterns.recommendations) {\n      await this.applyPerformanceRecommendations(patterns.recommendations);\n    }\n  }\n\n  private async optimizeStrategies(): Promise<void> {\n    // Analyze strategy effectiveness and adjust\n    const strategyPerformance = await this.db.getStrategyPerformance(this.config.swarmId);\n\n    for (const [strategyName, performance] of Object.entries(strategyPerformance)) {\n      if (performance.successRate < 0.7) {\n        await this.adjustStrategy(strategyName, performance);\n      }\n    }\n  }\n\n  private async trainNeuralPatterns(): Promise<void> {\n    // Train neural network on successful patterns\n    const successfulDecisions = await this.db.getSuccessfulDecisions(this.config.swarmId);\n\n    if (successfulDecisions.length > 10) {\n      await this.mcpWrapper.trainNeural({\n        pattern_type: 'coordination',\n        training_data: JSON.stringify(successfulDecisions),\n        epochs: 50,\n      });\n    }\n  }\n\n  private async handleAgentFailure(agent: Agent): Promise<void> {\n    // Reassign agent's tasks\n    if (agent.currentTask) {\n      await this.reassignTask(agent.currentTask, agent.id);\n    }\n\n    // Mark agent as offline\n    await this.db.updateAgentStatus(agent.id, 'offline');\n\n    this.emit('agentFailed', { agent });\n  }\n\n  private async handleStalledTask(task: any): Promise<void> {\n    // Implement stalled task recovery\n    this.emit('taskStalled', { task });\n  }\n\n  private isTaskStalled(task: any): boolean {\n    // Check if task hasn't progressed in reasonable time\n    const stalledThreshold = 10 * 60 * 1000; // 10 minutes\n    return (\n      task.last_progress_update &&\n      Date.now() - new Date(task.last_progress_update).getTime() > stalledThreshold\n    );\n  }\n\n  private async reassignTask(taskId: string, fromAgentId: string): Promise<void> {\n    const availableAgents = this.getAvailableAgents().filter((a) => a.id !== fromAgentId);\n\n    if (availableAgents.length > 0) {\n      const newAgent = availableAgents[0]; // Simple selection, could be more sophisticated\n      await this.db.reassignTask(taskId, newAgent.id);\n      await newAgent.assignTask(taskId, {});\n    }\n  }\n\n  private async applyPerformanceRecommendations(recommendations: any[]): Promise<void> {\n    // Apply recommended optimizations\n    for (const rec of recommendations) {\n      this.emit('performanceRecommendation', rec);\n    }\n  }\n\n  private async adjustStrategy(strategyName: string, performance: any): Promise<void> {\n    const strategy = this.strategies.get(strategyName);\n    if (strategy) {\n      // Adjust strategy parameters based on performance\n      if (performance.avgCompletionTime > performance.targetTime) {\n        strategy.maxAgents = Math.min(strategy.maxAgents + 1, 10);\n      }\n\n      this.emit('strategyAdjusted', { strategyName, performance });\n    }\n  }\n\n  /**\n   * Shutdown the Queen\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n    this.emit('shutdown');\n  }\n}\n"],
  "mappings": "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",
  "names": ["uuidv4"]
}
