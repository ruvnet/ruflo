{"version":3,"sources":["../../../src/constants/agent-types.ts"],"sourcesContent":["/**\r\n * Agent Types - Dynamic loading from .claude/agents/ directory\r\n * This file provides type-safe access to dynamically loaded agent definitions\r\n */\r\n\r\nimport { \r\n  getAvailableAgentTypes, \r\n  isValidAgentType as validateAgentType,\r\n  resolveLegacyAgentType as resolveLegacy,\r\n  LEGACY_AGENT_MAPPING as LEGACY_MAPPING\r\n} from '../agents/agent-loader.js';\r\n\r\n// Dynamic agent type - will be a string that matches available agents\r\nexport type AgentType = string;\r\n\r\n// Re-export legacy mapping from agent-loader\r\nexport const LEGACY_AGENT_MAPPING = LEGACY_MAPPING;\r\n\r\n// Re-export getAvailableAgentTypes for MCP tools\r\nexport { getAvailableAgentTypes };\r\n\r\n/**\r\n * Get all valid agent types dynamically\r\n */\r\nexport async function getValidAgentTypes(): Promise<string[]> {\r\n  return await getAvailableAgentTypes();\r\n}\r\n\r\n/**\r\n * Helper function to validate agent type\r\n */\r\nexport async function isValidAgentType(type: string): Promise<boolean> {\r\n  return await validateAgentType(type);\r\n}\r\n\r\n/**\r\n * Resolve legacy agent types to current equivalents\r\n */\r\nexport const resolveLegacyAgentType = resolveLegacy;\r\n\r\n/**\r\n * Create JSON Schema for agent type validation (async)\r\n */\r\nexport async function getAgentTypeSchema() {\r\n  const validTypes = await getValidAgentTypes();\r\n  return {\r\n    type: 'string',\r\n    enum: validTypes,\r\n    description: 'Type of specialized AI agent',\r\n  };\r\n}\r\n\r\n// Strategy types\r\nexport const SWARM_STRATEGIES = {\r\n  AUTO: 'auto',\r\n  RESEARCH: 'research',\r\n  DEVELOPMENT: 'development',\r\n  ANALYSIS: 'analysis',\r\n  TESTING: 'testing',\r\n  OPTIMIZATION: 'optimization',\r\n  MAINTENANCE: 'maintenance',\r\n  CUSTOM: 'custom',\r\n} as const;\r\n\r\nexport type SwarmStrategy = (typeof SWARM_STRATEGIES)[keyof typeof SWARM_STRATEGIES];\r\nexport const VALID_SWARM_STRATEGIES = Object.values(SWARM_STRATEGIES);\r\n\r\n// Task orchestration strategies (different from swarm strategies)\r\nexport const ORCHESTRATION_STRATEGIES = {\r\n  PARALLEL: 'parallel',\r\n  SEQUENTIAL: 'sequential',\r\n  ADAPTIVE: 'adaptive',\r\n  BALANCED: 'balanced',\r\n} as const;\r\n\r\nexport type OrchestrationStrategy =\r\n  (typeof ORCHESTRATION_STRATEGIES)[keyof typeof ORCHESTRATION_STRATEGIES];\r\nexport const VALID_ORCHESTRATION_STRATEGIES = Object.values(ORCHESTRATION_STRATEGIES);\r\n"],"names":["getAvailableAgentTypes","isValidAgentType","validateAgentType","resolveLegacyAgentType","resolveLegacy","LEGACY_AGENT_MAPPING","LEGACY_MAPPING","getValidAgentTypes","type","getAgentTypeSchema","validTypes","enum","description","SWARM_STRATEGIES","AUTO","RESEARCH","DEVELOPMENT","ANALYSIS","TESTING","OPTIMIZATION","MAINTENANCE","CUSTOM","VALID_SWARM_STRATEGIES","Object","values","ORCHESTRATION_STRATEGIES","PARALLEL","SEQUENTIAL","ADAPTIVE","BALANCED","VALID_ORCHESTRATION_STRATEGIES"],"mappings":"AAKA,SACEA,sBAAsB,EACtBC,oBAAoBC,iBAAiB,EACrCC,0BAA0BC,aAAa,EACvCC,wBAAwBC,cAAc,QACjC,4BAA4B;AAMnC,OAAO,MAAMD,uBAAuBC,eAAe;AAGnD,SAASN,sBAAsB,GAAG;AAKlC,OAAO,eAAeO;IACpB,OAAO,MAAMP;AACf;AAKA,OAAO,eAAeC,iBAAiBO,IAAY;IACjD,OAAO,MAAMN,kBAAkBM;AACjC;AAKA,OAAO,MAAML,yBAAyBC,cAAc;AAKpD,OAAO,eAAeK;IACpB,MAAMC,aAAa,MAAMH;IACzB,OAAO;QACLC,MAAM;QACNG,MAAMD;QACNE,aAAa;IACf;AACF;AAGA,OAAO,MAAMC,mBAAmB;IAC9BC,MAAM;IACNC,UAAU;IACVC,aAAa;IACbC,UAAU;IACVC,SAAS;IACTC,cAAc;IACdC,aAAa;IACbC,QAAQ;AACV,EAAW;AAGX,OAAO,MAAMC,yBAAyBC,OAAOC,MAAM,CAACX,kBAAkB;AAGtE,OAAO,MAAMY,2BAA2B;IACtCC,UAAU;IACVC,YAAY;IACZC,UAAU;IACVC,UAAU;AACZ,EAAW;AAIX,OAAO,MAAMC,iCAAiCP,OAAOC,MAAM,CAACC,0BAA0B"}