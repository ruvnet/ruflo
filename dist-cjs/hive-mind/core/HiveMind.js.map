{
  "version": 3,
  "sources": ["../../../src/hive-mind/core/HiveMind.ts"],
  "sourcesContent": ["/**\n * HiveMind Core Class\n *\n * Main orchestrator for the collective intelligence swarm system.\n * Manages agents, tasks, memory, and coordination.\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Queen } from './Queen.js';\nimport { Agent } from './Agent.js';\nimport { Memory } from './Memory.js';\nimport { Communication } from './Communication.js';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { SwarmOrchestrator } from '../integration/SwarmOrchestrator.js';\nimport { ConsensusEngine } from '../integration/ConsensusEngine.js';\nimport {\n  HiveMindConfig,\n  SwarmTopology,\n  AgentType,\n  Task,\n  TaskPriority,\n  TaskStrategy,\n  SwarmStatus,\n  AgentSpawnOptions,\n  TaskSubmitOptions,\n} from '../types.js';\n\nexport class HiveMind extends EventEmitter {\n  private id: string;\n  private config: HiveMindConfig;\n  private queen: Queen;\n  private agents: Map<string, Agent>;\n  private memory: Memory;\n  private communication: Communication;\n  private orchestrator: SwarmOrchestrator;\n  private consensus: ConsensusEngine;\n  private db: DatabaseManager;\n  private started: boolean = false;\n  private startTime: number;\n\n  constructor(config: HiveMindConfig) {\n    super();\n    this.config = config;\n    this.id = uuidv4();\n    this.agents = new Map();\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Initialize the Hive Mind and all subsystems\n   */\n  async initialize(): Promise<string> {\n    try {\n      // Initialize database\n      this.db = await DatabaseManager.getInstance();\n\n      // Create swarm in database\n      await this.db.createSwarm({\n        id: this.id,\n        name: this.config.name,\n        topology: this.config.topology,\n        queenMode: this.config.queenMode,\n        maxAgents: this.config.maxAgents,\n        consensusThreshold: this.config.consensusThreshold,\n        memoryTTL: this.config.memoryTTL,\n        config: JSON.stringify(this.config),\n      });\n\n      // Initialize Queen\n      this.queen = new Queen({\n        swarmId: this.id,\n        mode: this.config.queenMode,\n        topology: this.config.topology,\n      });\n\n      // Initialize subsystems\n      this.memory = new Memory(this.id);\n      this.communication = new Communication(this.id);\n      this.orchestrator = new SwarmOrchestrator(this);\n      this.consensus = new ConsensusEngine(this.config.consensusThreshold);\n\n      // Initialize subsystems\n      await Promise.all([\n        this.queen.initialize(),\n        this.memory.initialize(),\n        this.communication.initialize(),\n        this.orchestrator.initialize(),\n      ]);\n\n      // Set as active swarm\n      await this.db.setActiveSwarm(this.id);\n\n      // Auto-spawn agents if configured\n      if (this.config.autoSpawn) {\n        await this.autoSpawnAgents();\n      }\n\n      this.started = true;\n      this.emit('initialized', { swarmId: this.id });\n\n      return this.id;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load an existing Hive Mind from the database\n   */\n  static async load(swarmId: string): Promise<HiveMind> {\n    const db = await DatabaseManager.getInstance();\n    const swarmData = await db.getSwarm(swarmId);\n\n    if (!swarmData) {\n      throw new Error(`Swarm ${swarmId} not found`);\n    }\n\n    const config = JSON.parse(swarmData.config);\n    const hiveMind = new HiveMind(config);\n    hiveMind.id = swarmId;\n\n    await hiveMind.initialize();\n\n    // Load existing agents\n    const agents = await db.getAgents(swarmId);\n    for (const agentData of agents) {\n      const agent = new Agent({\n        id: agentData.id,\n        name: agentData.name,\n        type: agentData.type,\n        swarmId: swarmId,\n        capabilities: JSON.parse(agentData.capabilities),\n      });\n\n      await agent.initialize();\n      hiveMind.agents.set(agent.id, agent);\n    }\n\n    return hiveMind;\n  }\n\n  /**\n   * Auto-spawn initial agents based on topology\n   */\n  async autoSpawnAgents(): Promise<Agent[]> {\n    const topologyConfigs = {\n      hierarchical: [\n        { type: 'coordinator', count: 1 },\n        { type: 'researcher', count: 2 },\n        { type: 'coder', count: 2 },\n        { type: 'analyst', count: 1 },\n        { type: 'tester', count: 1 },\n      ],\n      mesh: [\n        { type: 'coordinator', count: 2 },\n        { type: 'researcher', count: 2 },\n        { type: 'coder', count: 2 },\n        { type: 'specialist', count: 2 },\n      ],\n      ring: [\n        { type: 'coordinator', count: 1 },\n        { type: 'coder', count: 3 },\n        { type: 'reviewer', count: 2 },\n      ],\n      star: [\n        { type: 'coordinator', count: 1 },\n        { type: 'specialist', count: 4 },\n      ],\n      // Maestro specs-driven topology\n      'specs-driven': [\n        { type: 'requirements_analyst', count: 1 },\n        { type: 'design_architect', count: 2 },\n        { type: 'task_planner', count: 1 },\n        { type: 'implementation_coder', count: 2 },\n        { type: 'quality_reviewer', count: 1 },\n        { type: 'steering_documenter', count: 1 },\n      ],\n    };\n\n    const config = topologyConfigs[this.config.topology];\n    const spawnedAgents: Agent[] = [];\n\n    for (const agentConfig of config) {\n      for (let i = 0; i < agentConfig.count; i++) {\n        const agent = await this.spawnAgent({\n          type: agentConfig.type as AgentType,\n          name: `${agentConfig.type}-${i + 1}`,\n        });\n        spawnedAgents.push(agent);\n      }\n    }\n\n    return spawnedAgents;\n  }\n\n  /**\n   * Spawn a new agent into the swarm\n   */\n  async spawnAgent(options: AgentSpawnOptions): Promise<Agent> {\n    if (this.agents.size >= this.config.maxAgents) {\n      throw new Error('Maximum agent limit reached');\n    }\n\n    const agent = new Agent({\n      name: options.name || `${options.type}-${Date.now()}`,\n      type: options.type,\n      swarmId: this.id,\n      capabilities: options.capabilities || this.getDefaultCapabilities(options.type),\n    });\n\n    await agent.initialize();\n\n    // Register with Queen\n    await this.queen.registerAgent(agent);\n\n    // Store in database\n    await this.db.createAgent({\n      id: agent.id,\n      swarmId: this.id,\n      name: agent.name,\n      type: agent.type,\n      capabilities: JSON.stringify(agent.capabilities),\n      status: 'idle',\n    });\n\n    // Add to local map\n    this.agents.set(agent.id, agent);\n\n    // Setup communication channels\n    this.communication.addAgent(agent);\n\n    // Auto-assign to pending tasks if configured\n    if (options.autoAssign) {\n      await this.assignPendingTasksToAgent(agent);\n    }\n\n    this.emit('agentSpawned', { agent });\n\n    return agent;\n  }\n\n  /**\n   * Submit a task to the Hive Mind\n   */\n  async submitTask(options: TaskSubmitOptions): Promise<Task> {\n    const task: Task = {\n      id: uuidv4(),\n      swarmId: this.id,\n      description: options.description,\n      priority: options.priority,\n      strategy: options.strategy,\n      status: 'pending',\n      progress: 0,\n      dependencies: options.dependencies || [],\n      assignedAgents: [],\n      requireConsensus: options.requireConsensus || false,\n      maxAgents: options.maxAgents || 3,\n      requiredCapabilities: options.requiredCapabilities || [],\n      createdAt: new Date(),\n      metadata: options.metadata || {},\n    };\n\n    // Store in database\n    await this.db.createTask({\n      ...task,\n      dependencies: JSON.stringify(task.dependencies),\n      assignedAgents: JSON.stringify(task.assignedAgents),\n      requiredCapabilities: JSON.stringify(task.requiredCapabilities),\n      metadata: JSON.stringify(task.metadata),\n    });\n\n    // Submit to orchestrator\n    await this.orchestrator.submitTask(task);\n\n    // Notify Queen\n    await this.queen.onTaskSubmitted(task);\n\n    this.emit('taskSubmitted', { task });\n\n    return task;\n  }\n\n  /**\n   * Get full status of the Hive Mind\n   */\n  async getFullStatus(): Promise<SwarmStatus> {\n    const agents = Array.from(this.agents.values());\n    const tasks = await this.db.getTasks(this.id);\n    const memoryStats = await this.memory.getStats();\n    const communicationStats = await this.communication.getStats();\n\n    // Calculate agent statistics\n    const agentsByType = agents.reduce(\n      (acc, agent) => {\n        acc[agent.type] = (acc[agent.type] || 0) + 1;\n        return acc;\n      },\n      {} as Record<string, number>,\n    );\n\n    // Calculate task statistics\n    const taskStats = {\n      total: tasks.length,\n      pending: tasks.filter((t) => t.status === 'pending').length,\n      inProgress: tasks.filter((t) => t.status === 'in_progress').length,\n      completed: tasks.filter((t) => t.status === 'completed').length,\n      failed: tasks.filter((t) => t.status === 'failed').length,\n    };\n\n    // Calculate performance metrics\n    const performance = await this.calculatePerformanceMetrics();\n\n    // Determine health status\n    const health = this.determineHealth(agents, tasks, performance);\n\n    // Get any warnings\n    const warnings = this.getSystemWarnings(agents, tasks, performance);\n\n    return {\n      swarmId: this.id,\n      name: this.config.name,\n      topology: this.config.topology,\n      queenMode: this.config.queenMode,\n      health,\n      uptime: Date.now() - this.startTime,\n      agents: agents.map((a) => ({\n        id: a.id,\n        name: a.name,\n        type: a.type,\n        status: a.status,\n        currentTask: a.currentTask,\n        messageCount: a.messageCount,\n        createdAt: a.createdAt.getTime(),\n      })),\n      agentsByType,\n      tasks: tasks.map((t) => ({\n        id: t.id,\n        description: t.description,\n        status: t.status,\n        priority: t.priority,\n        progress: t.progress,\n        assignedAgent: t.assigned_agents ? JSON.parse(t.assigned_agents)[0] : null,\n      })),\n      taskStats,\n      memoryStats,\n      communicationStats,\n      performance,\n      warnings,\n    };\n  }\n\n  /**\n   * Get basic statistics\n   */\n  async getStats() {\n    const agents = Array.from(this.agents.values());\n    const tasks = await this.db.getTasks(this.id);\n\n    return {\n      totalAgents: agents.length,\n      activeAgents: agents.filter((a) => a.status === 'busy').length,\n      pendingTasks: tasks.filter((t) => t.status === 'pending').length,\n      availableCapacity: Math.round(\n        (1 - agents.filter((a) => a.status === 'busy').length / agents.length) * 100,\n      ),\n    };\n  }\n\n  /**\n   * Get list of agents\n   */\n  async getAgents(): Promise<Agent[]> {\n    return Array.from(this.agents.values());\n  }\n\n  /**\n   * Get list of tasks\n   */\n  async getTasks(): Promise<any[]> {\n    return this.db.getTasks(this.id);\n  }\n\n  /**\n   * Get specific task\n   */\n  async getTask(taskId: string): Promise<any> {\n    return this.db.getTask(taskId);\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(taskId: string): Promise<void> {\n    await this.orchestrator.cancelTask(taskId);\n    await this.db.updateTaskStatus(taskId, 'cancelled');\n    this.emit('taskCancelled', { taskId });\n  }\n\n  /**\n   * Retry a failed task\n   */\n  async retryTask(taskId: string): Promise<Task> {\n    const originalTask = await this.db.getTask(taskId);\n    if (!originalTask) {\n      throw new Error('Task not found');\n    }\n\n    const newTask = await this.submitTask({\n      description: originalTask.description + ' (Retry)',\n      priority: originalTask.priority,\n      strategy: originalTask.strategy,\n      dependencies: [],\n      requireConsensus: originalTask.require_consensus,\n      maxAgents: originalTask.max_agents,\n      requiredCapabilities: JSON.parse(originalTask.required_capabilities || '[]'),\n      metadata: {\n        ...JSON.parse(originalTask.metadata || '{}'),\n        retryOf: taskId,\n      },\n    });\n\n    return newTask;\n  }\n\n  /**\n   * Rebalance agents across tasks\n   */\n  async rebalanceAgents(): Promise<void> {\n    await this.orchestrator.rebalance();\n    this.emit('agentsRebalanced');\n  }\n\n  /**\n   * Shutdown the Hive Mind\n   */\n  async shutdown(): Promise<void> {\n    this.started = false;\n\n    // Shutdown all agents\n    for (const agent of this.agents.values()) {\n      await agent.shutdown();\n    }\n\n    // Shutdown subsystems\n    await Promise.all([\n      this.queen.shutdown(),\n      this.memory.shutdown(),\n      this.communication.shutdown(),\n      this.orchestrator.shutdown(),\n    ]);\n\n    this.emit('shutdown');\n  }\n\n  // Private helper methods\n\n  private getDefaultCapabilities(type: AgentType): string[] {\n    const capabilityMap: Record<AgentType, string[]> = {\n      coordinator: ['task_management', 'resource_allocation', 'consensus_building'],\n      researcher: ['information_gathering', 'pattern_recognition', 'knowledge_synthesis'],\n      coder: ['code_generation', 'refactoring', 'debugging'],\n      analyst: ['data_analysis', 'performance_metrics', 'bottleneck_detection'],\n      architect: ['system_design', 'architecture_patterns', 'integration_planning'],\n      tester: ['test_generation', 'quality_assurance', 'edge_case_detection'],\n      reviewer: ['code_review', 'standards_enforcement', 'best_practices'],\n      optimizer: ['performance_optimization', 'resource_optimization', 'algorithm_improvement'],\n      documenter: ['documentation_generation', 'api_docs', 'user_guides'],\n      monitor: ['system_monitoring', 'health_checks', 'alerting'],\n      specialist: ['domain_expertise', 'custom_capabilities', 'problem_solving'],\n      // Maestro specs-driven agent capabilities\n      requirements_analyst: ['requirements_analysis', 'user_story_creation', 'acceptance_criteria'],\n      design_architect: ['system_design', 'architecture', 'technical_writing', 'specs_driven_design'],\n      task_planner: ['task_management', 'workflow_orchestration', 'project_management'],\n      implementation_coder: ['code_generation', 'implementation', 'debugging', 'refactoring'],\n      quality_reviewer: ['code_review', 'quality_assurance', 'testing', 'standards_enforcement'],\n      steering_documenter: ['documentation_generation', 'governance', 'technical_writing'],\n    };\n\n    return capabilityMap[type] || [];\n  }\n\n  private async assignPendingTasksToAgent(agent: Agent): Promise<void> {\n    const pendingTasks = await this.db.getPendingTasks(this.id);\n\n    for (const task of pendingTasks) {\n      const requiredCapabilities = JSON.parse(task.required_capabilities || '[]');\n\n      // Check if agent has required capabilities\n      if (requiredCapabilities.every((cap: string) => agent.capabilities.includes(cap))) {\n        await this.orchestrator.assignTaskToAgent(task.id, agent.id);\n        break; // Only assign one task at a time\n      }\n    }\n  }\n\n  private async calculatePerformanceMetrics() {\n    // This would calculate real metrics from the database\n    return {\n      avgTaskCompletion: 3500,\n      messageThroughput: 120,\n      consensusSuccessRate: 92,\n      memoryHitRate: 85,\n      agentUtilization: 78,\n    };\n  }\n\n  private determineHealth(agents: Agent[], tasks: any[], performance: any): string {\n    if (agents.length === 0) return 'critical';\n\n    const busyAgents = agents.filter((a) => a.status === 'busy').length;\n    const utilization = busyAgents / agents.length;\n\n    if (utilization > 0.9) return 'degraded';\n    if (performance.consensusSuccessRate < 50) return 'degraded';\n    if (agents.filter((a) => a.status === 'error').length > agents.length * 0.2) return 'critical';\n\n    return 'healthy';\n  }\n\n  private getSystemWarnings(agents: Agent[], tasks: any[], performance: any): string[] {\n    const warnings: string[] = [];\n\n    const utilization = agents.filter((a) => a.status === 'busy').length / agents.length;\n    if (utilization > 0.8) {\n      warnings.push('High agent utilization - consider spawning more agents');\n    }\n\n    const pendingTasks = tasks.filter((t) => t.status === 'pending').length;\n    if (pendingTasks > agents.length * 2) {\n      warnings.push('Large task backlog - tasks may be delayed');\n    }\n\n    if (performance.memoryHitRate < 60) {\n      warnings.push('Low memory hit rate - consider optimizing memory usage');\n    }\n\n    return warnings;\n  }\n}\n"],
  "mappings": "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",
  "names": ["uuidv4"]
}
