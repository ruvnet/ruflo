{"version":3,"sources":["../../../src/mcp/server.ts"],"sourcesContent":["/**\n * MCP (Model Context Protocol) server implementation\n */\n\nimport {\n  MCPConfig,\n  MCPRequest,\n  MCPResponse,\n  MCPError,\n  MCPTool,\n  MCPInitializeParams,\n  MCPInitializeResult,\n  MCPSession,\n  MCPMetrics,\n  MCPProtocolVersion,\n  MCPCapabilities,\n  MCPContext,\n} from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError as MCPErrorClass, MCPMethodNotFoundError } from '../utils/errors.js';\nimport type { ITransport } from './transports/base.js';\nimport { StdioTransport } from './transports/stdio.js';\nimport { HttpTransport } from './transports/http.js';\nimport { ToolRegistry } from './tools.js';\nimport { RequestRouter } from './router.js';\nimport { SessionManager, ISessionManager } from './session-manager.js';\nimport { AuthManager, IAuthManager } from './auth.js';\nimport { LoadBalancer, ILoadBalancer, RequestQueue } from './load-balancer.js';\nimport { createClaudeFlowTools, ClaudeFlowToolContext } from './claude-flow-tools.js';\nimport { createSwarmTools, SwarmToolContext } from './swarm-tools.js';\nimport {\n  createRuvSwarmTools,\n  RuvSwarmToolContext,\n  isRuvSwarmAvailable,\n  initializeRuvSwarmIntegration,\n} from './ruv-swarm-tools.js';\nimport { platform, arch } from 'node:os';\nimport { performance } from 'node:perf_hooks';\nimport { loadToolFilterConfig } from './tool-filter-config.js';\n\nexport interface IMCPServer {\n  start(): Promise<void>;\n  stop(): Promise<void>;\n  registerTool(tool: MCPTool): void;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  getMetrics(): MCPMetrics;\n  getSessions(): MCPSession[];\n  getSession(sessionId: string): MCPSession | undefined;\n  terminateSession(sessionId: string): void;\n}\n\n/**\n * MCP server implementation\n */\nexport class MCPServer implements IMCPServer {\n  private transport: ITransport;\n  private toolRegistry: ToolRegistry;\n  private router: RequestRouter;\n  private sessionManager: ISessionManager;\n  private authManager: IAuthManager;\n  private loadBalancer?: ILoadBalancer;\n  private requestQueue?: RequestQueue;\n  private running = false;\n  private currentSession?: MCPSession | undefined;\n\n  private readonly serverInfo = {\n    name: 'Claude-Flow MCP Server',\n    version: '1.0.0',\n  };\n\n  private readonly supportedProtocolVersion: MCPProtocolVersion = {\n    major: 2024,\n    minor: 11,\n    patch: 5,\n  };\n\n  private readonly serverCapabilities: MCPCapabilities = {\n    logging: {\n      level: 'info',\n    },\n    tools: {\n      listChanged: true,\n    },\n    resources: {\n      listChanged: false,\n      subscribe: false,\n    },\n    prompts: {\n      listChanged: false,\n    },\n  };\n\n  constructor(\n    private config: MCPConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n    private orchestrator?: any, // Reference to orchestrator instance\n    private swarmCoordinator?: any, // Reference to swarm coordinator instance\n    private agentManager?: any, // Reference to agent manager instance\n    private resourceManager?: any, // Reference to resource manager instance\n    private messagebus?: any, // Reference to message bus instance\n    private monitor?: any, // Reference to real-time monitor instance\n  ) {\n    // Initialize transport\n    this.transport = this.createTransport();\n\n    // Initialize tool registry\n    this.toolRegistry = new ToolRegistry(logger, config.toolFilter);\n\n    // Initialize session manager\n    this.sessionManager = new SessionManager(config, logger);\n\n    // Initialize auth manager\n    this.authManager = new AuthManager(config.auth || { enabled: false, method: 'token' }, logger);\n\n    // Initialize load balancer if enabled\n    if (config.loadBalancer?.enabled) {\n      this.loadBalancer = new LoadBalancer(config.loadBalancer, logger);\n      this.requestQueue = new RequestQueue(1000, 30000, logger);\n    }\n\n    // Initialize request router\n    this.router = new RequestRouter(this.toolRegistry, logger);\n  }\n\n  async start(): Promise<void> {\n    if (this.running) {\n      throw new MCPErrorClass('MCP server already running');\n    }\n\n    this.logger.info('Starting MCP server', { transport: this.config.transport });\n\n    try {\n      // Set up request handler\n      this.transport.onRequest(async (request) => {\n        return await this.handleRequest(request);\n      });\n\n      // Start transport\n      await this.transport.start();\n\n      // Load tool filter config if not provided in config\n      if (!this.config.toolFilter) {\n        try {\n          const filterConfig = await loadToolFilterConfig(this.logger);\n          if (filterConfig) {\n            this.toolRegistry.setToolFilter(filterConfig.config);\n            this.logger.info('Tool filter loaded', { source: filterConfig.source });\n          }\n        } catch (error) {\n          this.logger.warn('Failed to load tool filter config', { error });\n        }\n      }\n\n      // Register built-in tools\n      await this.registerBuiltInTools();\n\n      this.running = true;\n      this.logger.info('MCP server started successfully');\n    } catch (error) {\n      this.logger.error('Failed to start MCP server', error);\n      throw new MCPErrorClass('Failed to start MCP server', { error });\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.running) {\n      return;\n    }\n\n    this.logger.info('Stopping MCP server');\n\n    try {\n      // Stop transport\n      await this.transport.stop();\n\n      // Clean up session manager\n      if (this.sessionManager && 'destroy' in this.sessionManager) {\n        (this.sessionManager as any).destroy();\n      }\n\n      // Clean up all sessions\n      for (const session of this.sessionManager.getActiveSessions()) {\n        this.sessionManager.removeSession(session.id);\n      }\n\n      this.running = false;\n      this.currentSession = undefined;\n      this.logger.info('MCP server stopped');\n    } catch (error) {\n      this.logger.error('Error stopping MCP server', error);\n      throw error;\n    }\n  }\n\n  registerTool(tool: MCPTool): void {\n    this.toolRegistry.register(tool);\n\n    // Log filter status\n    const filterStats = this.toolRegistry.getFilterStats();\n    if (filterStats?.enabled) {\n      this.logger.debug('Tool registered', {\n        name: tool.name,\n        filtered: filterStats.filteredTools,\n        total: filterStats.totalTools\n      });\n    }\n\n    this.logger.info('Tool registered', { name: tool.name });\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const transportHealth = await this.transport.getHealthStatus();\n      const registeredTools = this.toolRegistry.getToolCount();\n      const { totalRequests, successfulRequests, failedRequests } = this.router.getMetrics();\n      const sessionMetrics = this.sessionManager.getSessionMetrics();\n\n      const metrics: Record<string, number> = {\n        registeredTools,\n        totalRequests,\n        successfulRequests,\n        failedRequests,\n        totalSessions: sessionMetrics.total,\n        activeSessions: sessionMetrics.active,\n        authenticatedSessions: sessionMetrics.authenticated,\n        expiredSessions: sessionMetrics.expired,\n        ...transportHealth.metrics,\n      };\n\n      if (this.loadBalancer) {\n        const lbMetrics = this.loadBalancer.getMetrics();\n        metrics.rateLimitedRequests = lbMetrics.rateLimitedRequests;\n        metrics.averageResponseTime = lbMetrics.averageResponseTime;\n        metrics.requestsPerSecond = lbMetrics.requestsPerSecond;\n        metrics.circuitBreakerTrips = lbMetrics.circuitBreakerTrips;\n      }\n\n      const status: { healthy: boolean; error?: string; metrics?: Record<string, number> } = {\n        healthy: this.running && transportHealth.healthy,\n        metrics,\n      };\n      if (transportHealth.error !== undefined) {\n        status.error = transportHealth.error;\n      }\n      return status;\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  getMetrics(): MCPMetrics {\n    const routerMetrics = this.router.getMetrics();\n    const sessionMetrics = this.sessionManager.getSessionMetrics();\n    const lbMetrics = this.loadBalancer?.getMetrics();\n\n    return {\n      totalRequests: routerMetrics.totalRequests,\n      successfulRequests: routerMetrics.successfulRequests,\n      failedRequests: routerMetrics.failedRequests,\n      averageResponseTime: lbMetrics?.averageResponseTime || 0,\n      activeSessions: sessionMetrics.active,\n      toolInvocations: {}, // TODO: Implement tool-specific metrics\n      errors: {}, // TODO: Implement error categorization\n      lastReset: lbMetrics?.lastReset || new Date(),\n    };\n  }\n\n  getSessions(): MCPSession[] {\n    return this.sessionManager.getActiveSessions();\n  }\n\n  getSession(sessionId: string): MCPSession | undefined {\n    return this.sessionManager.getSession(sessionId);\n  }\n\n  terminateSession(sessionId: string): void {\n    this.sessionManager.removeSession(sessionId);\n    if (this.currentSession?.id === sessionId) {\n      this.currentSession = undefined;\n    }\n  }\n\n  private async handleRequest(request: MCPRequest): Promise<MCPResponse> {\n    this.logger.debug('Handling MCP request', {\n      id: request.id,\n      method: request.method,\n    });\n\n    try {\n      // Handle initialization request separately\n      if (request.method === 'initialize') {\n        return await this.handleInitialize(request);\n      }\n\n      // Get or create session\n      const session = this.getOrCreateSession();\n\n      // Check if session is initialized for non-initialize requests\n      if (!session.isInitialized) {\n        return {\n          jsonrpc: '2.0',\n          id: request.id,\n          error: {\n            code: -32002,\n            message: 'Server not initialized',\n          },\n        };\n      }\n\n      // Update session activity\n      this.sessionManager.updateActivity(session.id);\n\n      // Check load balancer constraints\n      if (this.loadBalancer) {\n        const allowed = await this.loadBalancer.shouldAllowRequest(session, request);\n        if (!allowed) {\n          return {\n            jsonrpc: '2.0',\n            id: request.id,\n            error: {\n              code: -32000,\n              message: 'Rate limit exceeded or circuit breaker open',\n            },\n          };\n        }\n      }\n\n      // Record request start\n      const requestMetrics = this.loadBalancer?.recordRequestStart(session, request);\n\n      try {\n        // Process request through router\n        const result = await this.router.route(request);\n\n        const response: MCPResponse = {\n          jsonrpc: '2.0',\n          id: request.id,\n          result,\n        };\n\n        // Record success\n        if (requestMetrics) {\n          this.loadBalancer?.recordRequestEnd(requestMetrics, response);\n        }\n\n        return response;\n      } catch (error) {\n        // Record failure\n        if (requestMetrics) {\n          this.loadBalancer?.recordRequestEnd(requestMetrics, undefined, error as Error);\n        }\n        throw error;\n      }\n    } catch (error) {\n      this.logger.error('Error handling MCP request', {\n        id: request.id,\n        method: request.method,\n        error,\n      });\n\n      return {\n        jsonrpc: '2.0',\n        id: request.id,\n        error: this.errorToMCPError(error),\n      };\n    }\n  }\n\n  private async handleInitialize(request: MCPRequest): Promise<MCPResponse> {\n    try {\n      const params = request.params as MCPInitializeParams;\n\n      if (!params) {\n        return {\n          jsonrpc: '2.0',\n          id: request.id,\n          error: {\n            code: -32602,\n            message: 'Invalid params',\n          },\n        };\n      }\n\n      // Create session\n      const session = this.sessionManager.createSession(this.config.transport);\n      this.currentSession = session;\n\n      // Initialize session\n      this.sessionManager.initializeSession(session.id, params);\n\n      // Prepare response\n      const result: MCPInitializeResult = {\n        protocolVersion: this.supportedProtocolVersion,\n        capabilities: this.serverCapabilities,\n        serverInfo: this.serverInfo,\n        instructions: 'Claude-Flow MCP Server ready for tool execution',\n      };\n\n      this.logger.info('Session initialized', {\n        sessionId: session.id,\n        clientInfo: params.clientInfo,\n        protocolVersion: params.protocolVersion,\n      });\n\n      return {\n        jsonrpc: '2.0',\n        id: request.id,\n        result,\n      };\n    } catch (error) {\n      this.logger.error('Error during initialization', error);\n      return {\n        jsonrpc: '2.0',\n        id: request.id,\n        error: this.errorToMCPError(error),\n      };\n    }\n  }\n\n  private getOrCreateSession(): MCPSession {\n    if (this.currentSession) {\n      return this.currentSession;\n    }\n\n    // For stdio transport, create a default session\n    const session = this.sessionManager.createSession(this.config.transport);\n    this.currentSession = session;\n    return session;\n  }\n\n  private createTransport(): ITransport {\n    switch (this.config.transport) {\n      case 'stdio':\n        return new StdioTransport(this.logger);\n\n      case 'http':\n        return new HttpTransport(\n          this.config.host || 'localhost',\n          this.config.port || 3000,\n          this.config.tlsEnabled || false,\n          this.logger,\n        );\n\n      default:\n        throw new MCPErrorClass(`Unknown transport type: ${this.config.transport}`);\n    }\n  }\n\n  private async registerBuiltInTools(): Promise<void> {\n    // System information tool\n    this.registerTool({\n      name: 'system/info',\n      description: 'Get system information',\n      inputSchema: {\n        type: 'object',\n        properties: {},\n      },\n      handler: async () => {\n        return {\n          version: '1.0.0',\n          platform: platform(),\n          arch: arch(),\n          runtime: 'Node.js',\n          uptime: performance.now(),\n        };\n      },\n    });\n\n    // Health check tool\n    this.registerTool({\n      name: 'system/health',\n      description: 'Get system health status',\n      inputSchema: {\n        type: 'object',\n        properties: {},\n      },\n      handler: async () => {\n        return await this.getHealthStatus();\n      },\n    });\n\n    // List tools\n    this.registerTool({\n      name: 'tools/list',\n      description: 'List all available tools',\n      inputSchema: {\n        type: 'object',\n        properties: {},\n      },\n      handler: async () => {\n        return this.toolRegistry.listTools();\n      },\n    });\n\n    // Tool schema\n    this.registerTool({\n      name: 'tools/schema',\n      description: 'Get schema for a specific tool',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          name: { type: 'string' },\n        },\n        required: ['name'],\n      },\n      handler: async (input: any) => {\n        const tool = this.toolRegistry.getTool(input.name);\n        if (!tool) {\n          throw new Error(`Tool not found: ${input.name}`);\n        }\n        return {\n          name: tool.name,\n          description: tool.description,\n          inputSchema: tool.inputSchema,\n        };\n      },\n    });\n\n    // Register Claude-Flow specific tools if orchestrator is available\n    if (this.orchestrator) {\n      const claudeFlowTools = await createClaudeFlowTools(this.logger);\n\n      for (const tool of claudeFlowTools) {\n        // Wrap the handler to inject orchestrator context\n        const originalHandler = tool.handler;\n        tool.handler = async (input: unknown, context?: MCPContext) => {\n          const claudeFlowContext: ClaudeFlowToolContext = {\n            ...context,\n            orchestrator: this.orchestrator,\n          } as ClaudeFlowToolContext;\n\n          return await originalHandler(input, claudeFlowContext);\n        };\n\n        this.registerTool(tool);\n      }\n\n      this.logger.info('Registered Claude-Flow tools', { count: claudeFlowTools.length });\n    } else {\n      this.logger.warn('Orchestrator not available - Claude-Flow tools not registered');\n    }\n\n    // Register Swarm-specific tools if swarm components are available\n    if (this.swarmCoordinator || this.agentManager || this.resourceManager) {\n      const swarmTools = createSwarmTools(this.logger);\n\n      for (const tool of swarmTools) {\n        // Wrap the handler to inject swarm context\n        const originalHandler = tool.handler;\n        tool.handler = async (input: unknown, context?: MCPContext) => {\n          const swarmContext: SwarmToolContext = {\n            ...context,\n            swarmCoordinator: this.swarmCoordinator,\n            agentManager: this.agentManager,\n            resourceManager: this.resourceManager,\n            messageBus: this.messagebus,\n            monitor: this.monitor,\n          } as SwarmToolContext;\n\n          return await originalHandler(input, swarmContext);\n        };\n\n        this.registerTool(tool);\n      }\n\n      this.logger.info('Registered Swarm tools', { count: swarmTools.length });\n    } else {\n      this.logger.warn('Swarm components not available - Swarm tools not registered');\n    }\n\n    // Register ruv-swarm MCP tools if available\n    this.registerRuvSwarmTools();\n  }\n\n  /**\n   * Register ruv-swarm MCP tools if available\n   */\n  private async registerRuvSwarmTools(): Promise<void> {\n    try {\n      // Check if ruv-swarm is available\n      const available = await isRuvSwarmAvailable(this.logger);\n\n      if (!available) {\n        this.logger.info('ruv-swarm not available - skipping ruv-swarm MCP tools registration');\n        return;\n      }\n\n      // Initialize ruv-swarm integration\n      const workingDirectory = process.cwd();\n      const integration = await initializeRuvSwarmIntegration(workingDirectory, this.logger);\n\n      if (!integration.success) {\n        this.logger.warn('Failed to initialize ruv-swarm integration', {\n          error: integration.error,\n        });\n        return;\n      }\n\n      // Create ruv-swarm tools\n      const ruvSwarmTools = createRuvSwarmTools(this.logger);\n\n      for (const tool of ruvSwarmTools) {\n        // Wrap the handler to inject ruv-swarm context\n        const originalHandler = tool.handler;\n        tool.handler = async (input: unknown, context?: MCPContext) => {\n          const ruvSwarmContext: RuvSwarmToolContext = {\n            ...context,\n            workingDirectory,\n            sessionId: `mcp-session-${Date.now()}`,\n            swarmId: process.env.CLAUDE_SWARM_ID || `mcp-swarm-${Date.now()}`,\n          };\n\n          return await originalHandler(input, ruvSwarmContext);\n        };\n\n        this.registerTool(tool);\n      }\n\n      this.logger.info('Registered ruv-swarm MCP tools', {\n        count: ruvSwarmTools.length,\n        integration: integration.data,\n      });\n    } catch (error) {\n      this.logger.error('Error registering ruv-swarm MCP tools', error);\n    }\n  }\n\n  private errorToMCPError(error): MCPError {\n    if (error instanceof MCPMethodNotFoundError) {\n      return {\n        code: -32601,\n        message: error instanceof Error ? error.message : String(error),\n        data: error.details,\n      };\n    }\n\n    if (error instanceof MCPErrorClass) {\n      return {\n        code: -32603,\n        message: error instanceof Error ? error.message : String(error),\n        data: error.details,\n      };\n    }\n\n    if (error instanceof Error) {\n      return {\n        code: -32603,\n        message: error instanceof Error ? error.message : String(error),\n      };\n    }\n\n    return {\n      code: -32603,\n      message: 'Internal error',\n      data: error,\n    };\n  }\n}\n"],"names":["MCPError","MCPErrorClass","MCPMethodNotFoundError","StdioTransport","HttpTransport","ToolRegistry","RequestRouter","SessionManager","AuthManager","LoadBalancer","RequestQueue","createClaudeFlowTools","createSwarmTools","createRuvSwarmTools","isRuvSwarmAvailable","initializeRuvSwarmIntegration","platform","arch","performance","loadToolFilterConfig","MCPServer","transport","toolRegistry","router","sessionManager","authManager","loadBalancer","requestQueue","running","currentSession","serverInfo","name","version","supportedProtocolVersion","major","minor","patch","serverCapabilities","logging","level","tools","listChanged","resources","subscribe","prompts","config","eventBus","logger","orchestrator","swarmCoordinator","agentManager","resourceManager","messagebus","monitor","createTransport","toolFilter","auth","enabled","method","start","info","onRequest","request","handleRequest","filterConfig","setToolFilter","source","error","warn","registerBuiltInTools","stop","destroy","session","getActiveSessions","removeSession","id","undefined","registerTool","tool","register","filterStats","getFilterStats","debug","filtered","filteredTools","total","totalTools","getHealthStatus","transportHealth","registeredTools","getToolCount","totalRequests","successfulRequests","failedRequests","getMetrics","sessionMetrics","getSessionMetrics","metrics","totalSessions","activeSessions","active","authenticatedSessions","authenticated","expiredSessions","expired","lbMetrics","rateLimitedRequests","averageResponseTime","requestsPerSecond","circuitBreakerTrips","status","healthy","Error","message","routerMetrics","toolInvocations","errors","lastReset","Date","getSessions","getSession","sessionId","terminateSession","handleInitialize","getOrCreateSession","isInitialized","jsonrpc","code","updateActivity","allowed","shouldAllowRequest","requestMetrics","recordRequestStart","result","route","response","recordRequestEnd","errorToMCPError","params","createSession","initializeSession","protocolVersion","capabilities","instructions","clientInfo","host","port","tlsEnabled","description","inputSchema","type","properties","handler","runtime","uptime","now","listTools","required","input","getTool","claudeFlowTools","originalHandler","context","claudeFlowContext","count","length","swarmTools","swarmContext","messageBus","registerRuvSwarmTools","available","workingDirectory","process","cwd","integration","success","ruvSwarmTools","ruvSwarmContext","swarmId","env","CLAUDE_SWARM_ID","data","String","details"],"mappings":"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"}