{
  "version": 3,
  "sources": ["../../../src/services/agentic-flow-hooks/performance-hooks.ts"],
  "sourcesContent": ["/**\n * Performance optimization hooks for agentic-flow\n * \n * Tracks metrics, identifies bottlenecks, and provides\n * optimization suggestions based on provider performance.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  PerformanceHookPayload,\n  PerformanceMetric,\n  BottleneckAnalysis,\n  OptimizationSuggestion,\n  SideEffect,\n} from './types.js';\n\n// ===== Performance Metric Hook =====\n\nexport const performanceMetricHook = {\n  id: 'agentic-performance-metric',\n  type: 'performance-metric' as const,\n  priority: 100,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { metric, value, unit, threshold } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Store metric\n    const metricData: PerformanceMetric = {\n      name: metric,\n      value,\n      unit,\n      timestamp: Date.now(),\n      tags: extractTags(payload.context),\n    };\n    \n    context.performance.metrics.set(metric, metricData);\n    \n    // Check threshold violations\n    if (threshold !== undefined) {\n      const violated = checkThreshold(value, threshold, payload.context);\n      \n      if (violated) {\n        sideEffects.push({\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'performance:threshold:violated',\n            data: {\n              metric,\n              value,\n              threshold,\n              unit,\n            },\n          },\n        });\n        \n        // Generate optimization suggestion\n        const suggestion = await generateOptimizationSuggestion(\n          metric,\n          value,\n          threshold,\n          context\n        );\n        \n        if (suggestion) {\n          context.performance.optimizations.push(suggestion);\n          sideEffects.push({\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'info',\n              message: 'Optimization suggestion generated',\n              data: suggestion,\n            },\n          });\n        }\n      }\n    }\n    \n    // Update rolling averages\n    await updateRollingAverages(metric, value, context);\n    \n    // Detect anomalies\n    const anomaly = await detectAnomaly(metric, value, context);\n    if (anomaly) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:anomaly:detected',\n          data: { metric, value, anomaly },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Performance Bottleneck Hook =====\n\nexport const performanceBottleneckHook = {\n  id: 'agentic-performance-bottleneck',\n  type: 'performance-bottleneck' as const,\n  priority: 90,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { bottleneck } = payload;\n    \n    if (!bottleneck) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Analyze bottleneck severity\n    const analysis: BottleneckAnalysis = {\n      component: bottleneck.location,\n      severity: mapSeverity(bottleneck.severity),\n      impact: bottleneck.severity / 10, // Normalize to 0-1\n      suggestions: bottleneck.suggestions,\n    };\n    \n    context.performance.bottlenecks.push(analysis);\n    \n    // Store for historical analysis\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `bottleneck:${analysis.component}:${Date.now()}`,\n        value: analysis,\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    // Check for recurring bottlenecks\n    const recurrence = await checkBottleneckRecurrence(\n      analysis.component,\n      context\n    );\n    \n    if (recurrence.count > 3) {\n      // Recurring bottleneck - escalate\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:bottleneck:recurring',\n          data: {\n            component: analysis.component,\n            occurrences: recurrence.count,\n            timespan: recurrence.timespan,\n          },\n        },\n      });\n      \n      // Generate advanced optimization\n      const optimization = await generateAdvancedOptimization(\n        analysis,\n        recurrence,\n        context\n      );\n      \n      if (optimization) {\n        context.performance.optimizations.push(optimization);\n      }\n    }\n    \n    // Correlate with other metrics\n    const correlations = await findMetricCorrelations(\n      analysis.component,\n      context\n    );\n    \n    if (correlations.length > 0) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Bottleneck correlations found',\n          data: { bottleneck: analysis, correlations },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Performance Optimization Hook =====\n\nexport const performanceOptimizationHook = {\n  id: 'agentic-performance-optimization',\n  type: 'performance-optimization' as const,\n  priority: 80,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { optimization } = payload;\n    \n    if (!optimization) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate optimization\n    const validation = await validateOptimization(optimization, context);\n    if (!validation.valid) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'warning',\n          message: 'Optimization validation failed',\n          data: { optimization, validation },\n        },\n      });\n      return { continue: true, sideEffects };\n    }\n    \n    // Simulate optimization impact\n    const simulation = await simulateOptimization(optimization, context);\n    \n    if (simulation.expectedImprovement < 0.1) {\n      // Low impact - skip\n      return { continue: true };\n    }\n    \n    // Store optimization recommendation\n    const recommendation = {\n      optimization,\n      simulation,\n      timestamp: Date.now(),\n      autoApply: optimization.applied && simulation.risk === 'low',\n    };\n    \n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `optimization:${optimization.type}:${Date.now()}`,\n        value: recommendation,\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Auto-apply low-risk optimizations\n    if (recommendation.autoApply) {\n      await applyOptimization(optimization, context);\n      \n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:optimization:applied',\n          data: { optimization, automatic: true },\n        },\n      });\n    } else {\n      // Queue for manual review\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:optimization:suggested',\n          data: { optimization, simulation },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Performance Threshold Hook =====\n\nexport const performanceThresholdHook = {\n  id: 'agentic-performance-threshold',\n  type: 'performance-threshold' as const,\n  priority: 95,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { metric, value, threshold } = payload;\n    \n    if (threshold === undefined) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Dynamic threshold adjustment\n    const historicalData = await getMetricHistory(metric, context);\n    const adjustedThreshold = calculateDynamicThreshold(\n      threshold,\n      historicalData\n    );\n    \n    if (adjustedThreshold !== threshold) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Threshold dynamically adjusted',\n          data: {\n            metric,\n            original: threshold,\n            adjusted: adjustedThreshold,\n          },\n        },\n      });\n    }\n    \n    // Predict threshold violations\n    const prediction = await predictThresholdViolation(\n      metric,\n      value,\n      adjustedThreshold,\n      historicalData\n    );\n    \n    if (prediction.willViolate && prediction.confidence > 0.7) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:threshold:predicted',\n          data: {\n            metric,\n            currentValue: value,\n            threshold: adjustedThreshold,\n            predictedTime: prediction.timeToViolation,\n            confidence: prediction.confidence,\n          },\n        },\n      });\n      \n      // Proactive optimization\n      const proactiveOpt = await generateProactiveOptimization(\n        metric,\n        prediction,\n        context\n      );\n      \n      if (proactiveOpt) {\n        context.performance.optimizations.push(proactiveOpt);\n      }\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nfunction extractTags(context: Record<string, any>): string[] {\n  const tags: string[] = [];\n  \n  if (context.provider) tags.push(`provider:${context.provider}`);\n  if (context.model) tags.push(`model:${context.model}`);\n  if (context.operation) tags.push(`op:${context.operation}`);\n  if (context.component) tags.push(`component:${context.component}`);\n  \n  return tags;\n}\n\nfunction checkThreshold(\n  value: number,\n  threshold: number,\n  context: Record<string, any>\n): boolean {\n  // Check if threshold is violated based on context\n  const operator = context.thresholdOperator || 'gt';\n  \n  switch (operator) {\n    case 'gt': return value > threshold;\n    case 'gte': return value >= threshold;\n    case 'lt': return value < threshold;\n    case 'lte': return value <= threshold;\n    case 'eq': return value === threshold;\n    case 'ne': return value !== threshold;\n    default: return value > threshold;\n  }\n}\n\nasync function generateOptimizationSuggestion(\n  metric: string,\n  value: number,\n  threshold: number,\n  context: AgenticHookContext\n): Promise<OptimizationSuggestion | null> {\n  // Generate optimization based on metric type\n  const metricType = getMetricType(metric);\n  \n  switch (metricType) {\n    case 'latency':\n      if (value > threshold * 2) {\n        return {\n          type: 'cache',\n          target: metric,\n          expectedImprovement: 50,\n          implementation: 'Enable response caching for frequently accessed data',\n          risk: 'low',\n        };\n      } else if (value > threshold * 1.5) {\n        return {\n          type: 'parallel',\n          target: metric,\n          expectedImprovement: 30,\n          implementation: 'Parallelize independent operations',\n          risk: 'medium',\n        };\n      }\n      break;\n      \n    case 'throughput':\n      if (value < threshold * 0.5) {\n        return {\n          type: 'batch',\n          target: metric,\n          expectedImprovement: 40,\n          implementation: 'Batch similar requests together',\n          risk: 'low',\n        };\n      }\n      break;\n      \n    case 'memory':\n      if (value > threshold * 0.9) {\n        return {\n          type: 'resource',\n          target: metric,\n          expectedImprovement: 20,\n          implementation: 'Implement memory pooling and recycling',\n          risk: 'medium',\n        };\n      }\n      break;\n  }\n  \n  return null;\n}\n\nasync function updateRollingAverages(\n  metric: string,\n  value: number,\n  context: AgenticHookContext\n): Promise<void> {\n  const avgKey = `avg:${metric}`;\n  const history = await context.memory.cache.get(avgKey) || [];\n  \n  history.push({ value, timestamp: Date.now() });\n  \n  // Keep last 1000 values\n  if (history.length > 1000) {\n    history.shift();\n  }\n  \n  await context.memory.cache.set(avgKey, history);\n}\n\nasync function detectAnomaly(\n  metric: string,\n  value: number,\n  context: AgenticHookContext\n): Promise<any | null> {\n  const avgKey = `avg:${metric}`;\n  const history = await context.memory.cache.get(avgKey) || [];\n  \n  if (history.length < 100) {\n    return null; // Not enough data\n  }\n  \n  // Calculate statistics\n  const values = history.map((h: any) => h.value);\n  const mean = values.reduce((a: number, b: number) => a + b, 0) / values.length;\n  const variance = values.reduce((a: number, b: number) => \n    a + Math.pow(b - mean, 2), 0\n  ) / values.length;\n  const stdDev = Math.sqrt(variance);\n  \n  // Check if value is anomalous (> 3 standard deviations)\n  const zScore = Math.abs((value - mean) / stdDev);\n  \n  if (zScore > 3) {\n    return {\n      type: 'statistical',\n      zScore,\n      mean,\n      stdDev,\n      severity: zScore > 5 ? 'high' : 'medium',\n    };\n  }\n  \n  return null;\n}\n\nfunction mapSeverity(severity: number): BottleneckAnalysis['severity'] {\n  if (severity >= 8) return 'critical';\n  if (severity >= 6) return 'high';\n  if (severity >= 4) return 'medium';\n  return 'low';\n}\n\nasync function checkBottleneckRecurrence(\n  component: string,\n  context: AgenticHookContext\n): Promise<{ count: number; timespan: number }> {\n  const historyKey = `bottleneck:history:${component}`;\n  const history = await context.memory.cache.get(historyKey) || [];\n  \n  const now = Date.now();\n  const dayAgo = now - 86400000;\n  \n  // Count occurrences in last 24 hours\n  const recentOccurrences = history.filter((h: any) => \n    h.timestamp > dayAgo\n  );\n  \n  return {\n    count: recentOccurrences.length,\n    timespan: 86400000, // 24 hours in ms\n  };\n}\n\nasync function generateAdvancedOptimization(\n  bottleneck: BottleneckAnalysis,\n  recurrence: { count: number; timespan: number },\n  context: AgenticHookContext\n): Promise<OptimizationSuggestion | null> {\n  // Generate advanced optimization for recurring bottlenecks\n  if (bottleneck.severity === 'critical' && recurrence.count > 5) {\n    return {\n      type: 'algorithm',\n      target: bottleneck.component,\n      expectedImprovement: 60,\n      implementation: `Redesign ${bottleneck.component} algorithm for better scalability`,\n      risk: 'high',\n    };\n  }\n  \n  if (bottleneck.severity === 'high' && recurrence.count > 3) {\n    return {\n      type: 'cache',\n      target: bottleneck.component,\n      expectedImprovement: 40,\n      implementation: `Implement distributed caching for ${bottleneck.component}`,\n      risk: 'medium',\n    };\n  }\n  \n  return null;\n}\n\nasync function findMetricCorrelations(\n  component: string,\n  context: AgenticHookContext\n): Promise<Array<{ metric: string; correlation: number }>> {\n  const correlations: Array<{ metric: string; correlation: number }> = [];\n  \n  // Check correlations with other metrics\n  for (const [metric, data] of context.performance.metrics) {\n    if (data.tags.includes(`component:${component}`)) {\n      // Simple correlation check\n      correlations.push({\n        metric: data.name,\n        correlation: 0.7, // Placeholder\n      });\n    }\n  }\n  \n  return correlations;\n}\n\nasync function validateOptimization(\n  optimization: any,\n  context: AgenticHookContext\n): Promise<{ valid: boolean; reason?: string }> {\n  // Validate optimization is safe to apply\n  if (!optimization.type || !optimization.details) {\n    return {\n      valid: false,\n      reason: 'Missing required optimization fields',\n    };\n  }\n  \n  // Check risk level\n  if (optimization.details === 'high' && !context.metadata.allowHighRisk) {\n    return {\n      valid: false,\n      reason: 'High-risk optimizations not allowed',\n    };\n  }\n  \n  return { valid: true };\n}\n\nasync function simulateOptimization(\n  optimization: any,\n  context: AgenticHookContext\n): Promise<any> {\n  // Simulate optimization impact\n  const baseline = await getBaselineMetrics(optimization.type, context);\n  \n  const simulation = {\n    expectedImprovement: optimization.improvement || 0.2,\n    risk: calculateRisk(optimization),\n    affectedMetrics: identifyAffectedMetrics(optimization),\n    rollbackPlan: generateRollbackPlan(optimization),\n  };\n  \n  return simulation;\n}\n\nasync function applyOptimization(\n  optimization: any,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply optimization\n  // Placeholder implementation\n  const timestamp = Date.now();\n  \n  // Store optimization application\n  await context.memory.cache.set(\n    `applied:${optimization.type}:${timestamp}`,\n    {\n      optimization,\n      appliedAt: timestamp,\n      appliedBy: 'automatic',\n    }\n  );\n}\n\nasync function getMetricHistory(\n  metric: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  const historyKey = `history:${metric}`;\n  return await context.memory.cache.get(historyKey) || [];\n}\n\nfunction calculateDynamicThreshold(\n  baseThreshold: number,\n  historicalData: any[]\n): number {\n  if (historicalData.length < 50) {\n    return baseThreshold; // Not enough data\n  }\n  \n  // Calculate percentile-based threshold\n  const values = historicalData\n    .map(d => d.value)\n    .sort((a, b) => a - b);\n  \n  const p95 = values[Math.floor(values.length * 0.95)];\n  \n  // Adjust threshold based on historical performance\n  return Math.max(baseThreshold, p95 * 1.1);\n}\n\nasync function predictThresholdViolation(\n  metric: string,\n  currentValue: number,\n  threshold: number,\n  historicalData: any[]\n): Promise<any> {\n  if (historicalData.length < 10) {\n    return {\n      willViolate: false,\n      confidence: 0,\n    };\n  }\n  \n  // Simple linear trend prediction\n  const recentValues = historicalData.slice(-10).map(d => d.value);\n  const trend = calculateTrend(recentValues);\n  \n  if (trend > 0 && currentValue > threshold * 0.8) {\n    const timeToViolation = (threshold - currentValue) / trend;\n    \n    return {\n      willViolate: true,\n      timeToViolation,\n      confidence: Math.min(trend * 10, 0.9),\n    };\n  }\n  \n  return {\n    willViolate: false,\n    confidence: 0,\n  };\n}\n\nasync function generateProactiveOptimization(\n  metric: string,\n  prediction: any,\n  context: AgenticHookContext\n): Promise<OptimizationSuggestion | null> {\n  // Generate proactive optimization to prevent violation\n  const metricType = getMetricType(metric);\n  \n  if (metricType === 'latency' && prediction.timeToViolation < 300000) {\n    return {\n      type: 'cache',\n      target: metric,\n      expectedImprovement: 30,\n      implementation: 'Preemptively cache high-latency operations',\n      risk: 'low',\n    };\n  }\n  \n  return null;\n}\n\nfunction getMetricType(metric: string): string {\n  if (metric.includes('latency')) return 'latency';\n  if (metric.includes('throughput')) return 'throughput';\n  if (metric.includes('memory')) return 'memory';\n  if (metric.includes('cpu')) return 'cpu';\n  return 'unknown';\n}\n\nasync function getBaselineMetrics(\n  type: string,\n  context: AgenticHookContext\n): Promise<any> {\n  // Get baseline metrics for comparison\n  // Placeholder implementation\n  return {};\n}\n\nfunction calculateRisk(optimization: any): string {\n  // Calculate optimization risk level\n  if (optimization.type === 'algorithm') return 'high';\n  if (optimization.type === 'architecture') return 'high';\n  if (optimization.type === 'cache') return 'low';\n  if (optimization.type === 'batch') return 'low';\n  return 'medium';\n}\n\nfunction identifyAffectedMetrics(optimization: any): string[] {\n  // Identify metrics affected by optimization\n  const affected: string[] = [];\n  \n  switch (optimization.type) {\n    case 'cache':\n      affected.push('latency', 'memory_usage');\n      break;\n    case 'parallel':\n      affected.push('latency', 'cpu_usage', 'throughput');\n      break;\n    case 'batch':\n      affected.push('throughput', 'latency');\n      break;\n    case 'algorithm':\n      affected.push('latency', 'cpu_usage', 'memory_usage');\n      break;\n  }\n  \n  return affected;\n}\n\nfunction generateRollbackPlan(optimization: any): any {\n  // Generate rollback plan\n  return {\n    steps: [\n      'Capture current metrics',\n      'Apply optimization',\n      'Monitor for 5 minutes',\n      'Rollback if metrics degrade',\n    ],\n    triggers: {\n      errorRate: 0.05,\n      latencyIncrease: 1.5,\n    },\n  };\n}\n\nfunction calculateTrend(values: number[]): number {\n  if (values.length < 2) return 0;\n  \n  // Simple linear regression\n  const n = values.length;\n  const sumX = values.reduce((a, _, i) => a + i, 0);\n  const sumY = values.reduce((a, b) => a + b, 0);\n  const sumXY = values.reduce((a, b, i) => a + i * b, 0);\n  const sumX2 = values.reduce((a, _, i) => a + i * i, 0);\n  \n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  \n  return slope;\n}\n\n// ===== Register Hooks =====\n\nexport function registerPerformanceHooks(): void {\n  agenticHookManager.register(performanceMetricHook);\n  agenticHookManager.register(performanceBottleneckHook);\n  agenticHookManager.register(performanceOptimizationHook);\n  agenticHookManager.register(performanceThresholdHook);\n}"],
  "mappings": "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",
  "names": []
}
