{"version":3,"sources":["../../../../src/hive-mind/core/Queen.ts"],"sourcesContent":["/**\r\n * Queen Coordinator Class\r\n *\r\n * The Queen manages high-level coordination, decision-making,\r\n * and strategic planning for the Hive Mind swarm.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { Agent } from './Agent.js';\r\nimport { DatabaseManager } from './DatabaseManager.js';\r\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\r\nimport {\r\n  SwarmTopology,\r\n  Task,\r\n  AgentType,\r\n  QueenMode,\r\n  ConsensusProposal,\r\n  QueenDecision,\r\n  CoordinationStrategy,\r\n} from '../types.js';\r\n\r\ninterface QueenConfig {\r\n  swarmId: string;\r\n  mode: QueenMode;\r\n  topology: SwarmTopology;\r\n}\r\n\r\nexport class Queen extends EventEmitter {\r\n  private id: string;\r\n  private config: QueenConfig;\r\n  private agents: Map<string, Agent>;\r\n  private taskQueue: Map<string, Task>;\r\n  private strategies: Map<string, CoordinationStrategy>;\r\n  private db: DatabaseManager;\r\n  private mcpWrapper: MCPToolWrapper;\r\n  private isActive: boolean = false;\r\n\r\n  constructor(config: QueenConfig) {\r\n    super();\r\n    this.id = uuidv4();\r\n    this.config = config;\r\n    this.agents = new Map();\r\n    this.taskQueue = new Map();\r\n    this.strategies = new Map();\r\n    this.initializeStrategies();\r\n  }\r\n\r\n  /**\r\n   * Initialize the Queen and her coordination capabilities\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.db = await DatabaseManager.getInstance();\r\n    this.mcpWrapper = new MCPToolWrapper();\r\n\r\n    // Create Queen as a special coordinator agent\r\n    await this.db.createAgent({\r\n      id: this.id,\r\n      swarmId: this.config.swarmId,\r\n      name: 'Queen',\r\n      type: 'coordinator',\r\n      capabilities: JSON.stringify([\r\n        'strategic_planning',\r\n        'task_allocation',\r\n        'consensus_coordination',\r\n        'performance_optimization',\r\n        'swarm_governance',\r\n      ]),\r\n      status: 'active',\r\n      metadata: JSON.stringify({ role: 'queen', mode: this.config.mode }),\r\n    });\r\n\r\n    this.isActive = true;\r\n\r\n    // Start coordination loops\r\n    this.startCoordinationLoop();\r\n    this.startOptimizationLoop();\r\n\r\n    this.emit('initialized');\r\n  }\r\n\r\n  /**\r\n   * Register a new agent with the Queen\r\n   */\r\n  async registerAgent(agent: Agent): Promise<void> {\r\n    this.agents.set(agent.id, agent);\r\n\r\n    // Analyze agent capabilities and update strategies\r\n    await this.analyzeAgentCapabilities(agent);\r\n\r\n    // Notify other agents in distributed mode\r\n    if (this.config.mode === 'distributed') {\r\n      await this.broadcastAgentRegistration(agent);\r\n    }\r\n\r\n    this.emit('agentRegistered', { agent });\r\n  }\r\n\r\n  /**\r\n   * Handle task submission\r\n   */\r\n  async onTaskSubmitted(task: Task): Promise<QueenDecision> {\r\n    this.taskQueue.set(task.id, task);\r\n\r\n    // Analyze task requirements\r\n    const analysis = await this.analyzeTask(task);\r\n\r\n    // Make strategic decision\r\n    const decision = await this.makeStrategicDecision(task, analysis);\r\n\r\n    // If consensus required, initiate consensus process\r\n    if (task.requireConsensus) {\r\n      await this.initiateConsensus(task, decision);\r\n    }\r\n\r\n    // Apply decision\r\n    await this.applyDecision(decision);\r\n\r\n    this.emit('taskDecision', { task, decision });\r\n\r\n    return decision;\r\n  }\r\n\r\n  /**\r\n   * Make a strategic decision about task execution\r\n   */\r\n  private async makeStrategicDecision(task: Task, analysis: any): Promise<QueenDecision> {\r\n    // Use MCP neural capabilities for decision making\r\n    const neuralAnalysis = await this.mcpWrapper.analyzePattern({\r\n      action: 'analyze',\r\n      operation: 'task_strategy',\r\n      metadata: {\r\n        task: task.description,\r\n        priority: task.priority,\r\n        topology: this.config.topology,\r\n        availableAgents: this.getAvailableAgents().length,\r\n      },\r\n    });\r\n\r\n    // Select optimal strategy\r\n    const strategy = this.selectOptimalStrategy(task, analysis, neuralAnalysis);\r\n\r\n    // Identify best agents for the task\r\n    const selectedAgents = await this.selectAgentsForTask(task, strategy);\r\n\r\n    // Create execution plan\r\n    const executionPlan = this.createExecutionPlan(task, selectedAgents, strategy);\r\n\r\n    return {\r\n      id: uuidv4(),\r\n      taskId: task.id,\r\n      strategy,\r\n      selectedAgents: selectedAgents.map((a) => a.id),\r\n      executionPlan,\r\n      confidence: analysis.confidence || 0.85,\r\n      rationale: analysis.rationale || 'Strategic analysis completed',\r\n      timestamp: new Date(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Select optimal coordination strategy\r\n   */\r\n  private selectOptimalStrategy(\r\n    task: Task,\r\n    analysis: any,\r\n    neuralAnalysis: any,\r\n  ): CoordinationStrategy {\r\n    // Strategy selection based on multiple factors\r\n    const factors = {\r\n      taskComplexity: analysis.complexity || 'medium',\r\n      agentAvailability: this.getAvailableAgents().length,\r\n      topology: this.config.topology,\r\n      priority: task.priority,\r\n      consensusRequired: task.requireConsensus,\r\n    };\r\n\r\n    // Use topology-specific strategies\r\n    if (this.config.topology === 'hierarchical' && factors.taskComplexity === 'high') {\r\n      return this.strategies.get('hierarchical-cascade')!;\r\n    }\r\n\r\n    if (this.config.topology === 'mesh' && factors.consensusRequired) {\r\n      return this.strategies.get('mesh-consensus')!;\r\n    }\r\n\r\n    if (factors.priority === 'critical') {\r\n      return this.strategies.get('priority-fast-track')!;\r\n    }\r\n\r\n    // Default adaptive strategy\r\n    return this.strategies.get('adaptive-default')!;\r\n  }\r\n\r\n  /**\r\n   * Select best agents for a task\r\n   */\r\n  private async selectAgentsForTask(task: Task, strategy: CoordinationStrategy): Promise<Agent[]> {\r\n    const availableAgents = this.getAvailableAgents();\r\n    const requiredCapabilities = task.requiredCapabilities || [];\r\n\r\n    // Score agents based on capabilities and current load\r\n    const scoredAgents = await Promise.all(\r\n      availableAgents.map(async (agent) => {\r\n        const score = await this.scoreAgentForTask(agent, task, requiredCapabilities);\r\n        return { agent, score };\r\n      }),\r\n    );\r\n\r\n    // Sort by score and select top agents\r\n    scoredAgents.sort((a, b) => b.score - a.score);\r\n\r\n    const maxAgents = Math.min(task.maxAgents, strategy.maxAgents || 3);\r\n    return scoredAgents.slice(0, maxAgents).map((sa) => sa.agent);\r\n  }\r\n\r\n  /**\r\n   * Score an agent for a specific task\r\n   */\r\n  private async scoreAgentForTask(\r\n    agent: Agent,\r\n    task: Task,\r\n    requiredCapabilities: string[],\r\n  ): Promise<number> {\r\n    let score = 0;\r\n\r\n    // Capability match\r\n    const capabilityMatches = requiredCapabilities.filter((cap) =>\r\n      agent.capabilities.includes(cap),\r\n    ).length;\r\n    score += capabilityMatches * 10;\r\n\r\n    // Agent type suitability\r\n    const typeSuitability = this.getTypeSuitabilityForTask(agent.type, task);\r\n    score += typeSuitability * 5;\r\n\r\n    // Current workload (prefer less busy agents)\r\n    if (agent.status === 'idle') score += 8;\r\n    else if (agent.status === 'active') score += 4;\r\n\r\n    // Historical performance (from database)\r\n    const performance = await this.db.getAgentPerformance(agent.id);\r\n    if (performance) {\r\n      score += performance.successRate * 10;\r\n    }\r\n\r\n    // Specialty bonus\r\n    if (agent.type === 'specialist' && requiredCapabilities.length > 0) {\r\n      score += 5;\r\n    }\r\n\r\n    return score;\r\n  }\r\n\r\n  /**\r\n   * Get type suitability score for a task\r\n   */\r\n  private getTypeSuitabilityForTask(agentType: AgentType, task: Task): number {\r\n    const suitabilityMap: Record<string, Record<AgentType, number>> = {\r\n      research: {\r\n        researcher: 10,\r\n        analyst: 8,\r\n        specialist: 6,\r\n        coder: 4,\r\n        coordinator: 5,\r\n        architect: 5,\r\n        tester: 3,\r\n        reviewer: 4,\r\n        optimizer: 4,\r\n        documenter: 6,\r\n        monitor: 3,\r\n      },\r\n      development: {\r\n        coder: 10,\r\n        architect: 8,\r\n        tester: 7,\r\n        reviewer: 6,\r\n        coordinator: 5,\r\n        specialist: 6,\r\n        researcher: 4,\r\n        analyst: 4,\r\n        optimizer: 5,\r\n        documenter: 4,\r\n        monitor: 3,\r\n      },\r\n      analysis: {\r\n        analyst: 10,\r\n        researcher: 8,\r\n        specialist: 6,\r\n        reviewer: 5,\r\n        coordinator: 5,\r\n        architect: 4,\r\n        coder: 4,\r\n        tester: 3,\r\n        optimizer: 5,\r\n        documenter: 4,\r\n        monitor: 4,\r\n      },\r\n      testing: {\r\n        tester: 10,\r\n        reviewer: 8,\r\n        analyst: 6,\r\n        coder: 5,\r\n        coordinator: 4,\r\n        specialist: 5,\r\n        researcher: 3,\r\n        architect: 4,\r\n        optimizer: 4,\r\n        documenter: 3,\r\n        monitor: 4,\r\n      },\r\n      optimization: {\r\n        optimizer: 10,\r\n        analyst: 8,\r\n        coder: 7,\r\n        architect: 6,\r\n        coordinator: 5,\r\n        specialist: 6,\r\n        researcher: 4,\r\n        tester: 4,\r\n        reviewer: 5,\r\n        documenter: 3,\r\n        monitor: 4,\r\n      },\r\n    };\r\n\r\n    // Detect task type from description\r\n    const taskType = this.detectTaskType(task.description);\r\n    return suitabilityMap[taskType]?.[agentType] || 5;\r\n  }\r\n\r\n  /**\r\n   * Detect task type from description\r\n   */\r\n  private detectTaskType(description: string): string {\r\n    const lower = description.toLowerCase();\r\n\r\n    if (lower.includes('research') || lower.includes('investigate') || lower.includes('explore')) {\r\n      return 'research';\r\n    }\r\n    if (\r\n      lower.includes('develop') ||\r\n      lower.includes('implement') ||\r\n      lower.includes('build') ||\r\n      lower.includes('create')\r\n    ) {\r\n      return 'development';\r\n    }\r\n    if (lower.includes('analyze') || lower.includes('review') || lower.includes('assess')) {\r\n      return 'analysis';\r\n    }\r\n    if (lower.includes('test') || lower.includes('validate') || lower.includes('verify')) {\r\n      return 'testing';\r\n    }\r\n    if (lower.includes('optimize') || lower.includes('improve') || lower.includes('enhance')) {\r\n      return 'optimization';\r\n    }\r\n\r\n    return 'general';\r\n  }\r\n\r\n  /**\r\n   * Create execution plan for task\r\n   */\r\n  private createExecutionPlan(task: Task, agents: Agent[], strategy: CoordinationStrategy): any {\r\n    return {\r\n      phases: strategy.phases || ['preparation', 'execution', 'validation'],\r\n      agentAssignments: agents.map((agent) => ({\r\n        agentId: agent.id,\r\n        role: this.determineAgentRole(agent, task),\r\n        responsibilities: this.getAgentResponsibilities(agent, task),\r\n      })),\r\n      coordinationPoints: strategy.coordinationPoints || ['start', 'midpoint', 'completion'],\r\n      checkpoints: this.createCheckpoints(task, strategy),\r\n      fallbackPlan: this.createFallbackPlan(task, agents),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initiate consensus process\r\n   */\r\n  private async initiateConsensus(task: Task, decision: QueenDecision): Promise<void> {\r\n    const proposal: ConsensusProposal = {\r\n      id: uuidv4(),\r\n      swarmId: this.config.swarmId,\r\n      taskId: task.id,\r\n      proposal: {\r\n        decision,\r\n        task: task.description,\r\n        rationale: decision.rationale,\r\n      },\r\n      requiredThreshold: 0.66,\r\n      deadline: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\r\n    };\r\n\r\n    await this.db.createConsensusProposal(proposal);\r\n\r\n    // Notify all agents to vote\r\n    await this.broadcastConsensusRequest(proposal);\r\n  }\r\n\r\n  /**\r\n   * Apply Queen's decision\r\n   */\r\n  private async applyDecision(decision: QueenDecision): Promise<void> {\r\n    // Update task with assignments\r\n    await this.db.updateTask(decision.taskId, {\r\n      assigned_agents: JSON.stringify(decision.selectedAgents),\r\n      status: 'assigned',\r\n      assigned_at: new Date(),\r\n    });\r\n\r\n    // Notify selected agents\r\n    for (const agentId of decision.selectedAgents) {\r\n      const agent = this.agents.get(agentId);\r\n      if (agent) {\r\n        await agent.assignTask(decision.taskId, decision.executionPlan);\r\n      }\r\n    }\r\n\r\n    // Store decision in memory for learning\r\n    await this.mcpWrapper.storeMemory({\r\n      action: 'store',\r\n      key: `decision/${decision.taskId}`,\r\n      value: JSON.stringify(decision),\r\n      namespace: 'queen-decisions',\r\n      ttl: 86400 * 7, // 7 days\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start coordination loop\r\n   */\r\n  private startCoordinationLoop(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      try {\r\n        // Monitor agent health\r\n        await this.monitorAgentHealth();\r\n\r\n        // Check task progress\r\n        await this.checkTaskProgress();\r\n\r\n        // Rebalance if needed\r\n        await this.checkRebalancing();\r\n      } catch (error) {\r\n        this.emit('error', error);\r\n      }\r\n    }, 5000); // Every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Start optimization loop\r\n   */\r\n  private startOptimizationLoop(): void {\r\n    setInterval(async () => {\r\n      if (!this.isActive) return;\r\n\r\n      try {\r\n        // Analyze performance patterns\r\n        await this.analyzePerformancePatterns();\r\n\r\n        // Optimize strategies\r\n        await this.optimizeStrategies();\r\n\r\n        // Train neural patterns\r\n        await this.trainNeuralPatterns();\r\n      } catch (error) {\r\n        this.emit('error', error);\r\n      }\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * Initialize coordination strategies\r\n   */\r\n  private initializeStrategies(): void {\r\n    // Hierarchical cascade strategy\r\n    this.strategies.set('hierarchical-cascade', {\r\n      name: 'Hierarchical Cascade',\r\n      description: 'Top-down task distribution with clear delegation',\r\n      phases: ['planning', 'delegation', 'execution', 'aggregation'],\r\n      maxAgents: 5,\r\n      coordinationPoints: ['phase-transition', 'milestone', 'completion'],\r\n      suitable_for: ['complex-tasks', 'multi-phase-projects'],\r\n    });\r\n\r\n    // Mesh consensus strategy\r\n    this.strategies.set('mesh-consensus', {\r\n      name: 'Mesh Consensus',\r\n      description: 'Peer-to-peer coordination with consensus requirements',\r\n      phases: ['proposal', 'discussion', 'consensus', 'execution'],\r\n      maxAgents: 7,\r\n      coordinationPoints: ['consensus-check', 'progress-sync', 'final-vote'],\r\n      suitable_for: ['critical-decisions', 'collaborative-tasks'],\r\n    });\r\n\r\n    // Priority fast-track strategy\r\n    this.strategies.set('priority-fast-track', {\r\n      name: 'Priority Fast Track',\r\n      description: 'Rapid execution for critical tasks',\r\n      phases: ['immediate-assignment', 'parallel-execution', 'quick-validation'],\r\n      maxAgents: 3,\r\n      coordinationPoints: ['start', 'critical-path', 'completion'],\r\n      suitable_for: ['urgent-tasks', 'critical-fixes'],\r\n    });\r\n\r\n    // Adaptive default strategy\r\n    this.strategies.set('adaptive-default', {\r\n      name: 'Adaptive Default',\r\n      description: 'Flexible strategy that adapts to task requirements',\r\n      phases: ['analysis', 'planning', 'execution', 'review'],\r\n      maxAgents: 4,\r\n      coordinationPoints: ['checkpoint', 'adaptation-point', 'completion'],\r\n      suitable_for: ['general-tasks', 'unknown-complexity'],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Helper methods\r\n   */\r\n\r\n  private getAvailableAgents(): Agent[] {\r\n    return Array.from(this.agents.values()).filter(\r\n      (agent) => agent.status === 'idle' || agent.status === 'active',\r\n    );\r\n  }\r\n\r\n  private async analyzeTask(task: Task): Promise<any> {\r\n    // Use MCP tools to analyze task complexity and requirements\r\n    return this.mcpWrapper.analyzePattern({\r\n      action: 'analyze',\r\n      operation: 'task_analysis',\r\n      metadata: {\r\n        description: task.description,\r\n        priority: task.priority,\r\n        dependencies: task.dependencies,\r\n      },\r\n    });\r\n  }\r\n\r\n  private async analyzeAgentCapabilities(agent: Agent): Promise<void> {\r\n    // Analyze and store agent capability patterns\r\n    await this.mcpWrapper.storeMemory({\r\n      action: 'store',\r\n      key: `agent-capabilities/${agent.id}`,\r\n      value: JSON.stringify({\r\n        type: agent.type,\r\n        capabilities: agent.capabilities,\r\n        registeredAt: new Date(),\r\n      }),\r\n      namespace: 'agent-registry',\r\n    });\r\n  }\r\n\r\n  private async broadcastAgentRegistration(agent: Agent): Promise<void> {\r\n    // In distributed mode, notify other Queens/coordinators\r\n    await this.db.createCommunication({\r\n      from_agent_id: this.id,\r\n      to_agent_id: null, // broadcast\r\n      swarm_id: this.config.swarmId,\r\n      message_type: 'broadcast',\r\n      content: JSON.stringify({\r\n        type: 'agent_registered',\r\n        agent: {\r\n          id: agent.id,\r\n          type: agent.type,\r\n          capabilities: agent.capabilities,\r\n        },\r\n      }),\r\n      priority: 'high',\r\n    });\r\n  }\r\n\r\n  private async broadcastConsensusRequest(proposal: ConsensusProposal): Promise<void> {\r\n    await this.db.createCommunication({\r\n      from_agent_id: this.id,\r\n      to_agent_id: null, // broadcast\r\n      swarm_id: this.config.swarmId,\r\n      message_type: 'consensus',\r\n      content: JSON.stringify(proposal),\r\n      priority: 'urgent',\r\n      requires_response: true,\r\n    });\r\n  }\r\n\r\n  private determineAgentRole(agent: Agent, task: Task): string {\r\n    // Determine specific role based on agent type and task\r\n    const roleMap: Record<AgentType, string> = {\r\n      coordinator: 'lead',\r\n      researcher: 'investigator',\r\n      coder: 'implementer',\r\n      analyst: 'evaluator',\r\n      architect: 'designer',\r\n      tester: 'validator',\r\n      reviewer: 'auditor',\r\n      optimizer: 'enhancer',\r\n      documenter: 'recorder',\r\n      monitor: 'observer',\r\n      specialist: 'expert',\r\n    };\r\n\r\n    return roleMap[agent.type] || 'contributor';\r\n  }\r\n\r\n  private getAgentResponsibilities(agent: Agent, task: Task): string[] {\r\n    // Define specific responsibilities based on role\r\n    const responsibilityMap: Record<AgentType, string[]> = {\r\n      coordinator: ['coordinate team', 'track progress', 'resolve conflicts'],\r\n      researcher: ['gather information', 'identify patterns', 'provide insights'],\r\n      coder: ['implement solution', 'write tests', 'debug issues'],\r\n      analyst: ['analyze data', 'identify bottlenecks', 'suggest improvements'],\r\n      architect: ['design system', 'define interfaces', 'ensure scalability'],\r\n      tester: ['write tests', 'find bugs', 'validate functionality'],\r\n      reviewer: ['review code', 'ensure quality', 'suggest improvements'],\r\n      optimizer: ['improve performance', 'reduce complexity', 'optimize resources'],\r\n      documenter: ['create documentation', 'update guides', 'maintain clarity'],\r\n      monitor: ['track metrics', 'alert on issues', 'ensure health'],\r\n      specialist: ['provide expertise', 'solve complex problems', 'guide implementation'],\r\n    };\r\n\r\n    return responsibilityMap[agent.type] || ['contribute to task'];\r\n  }\r\n\r\n  private createCheckpoints(task: Task, strategy: CoordinationStrategy): any[] {\r\n    return strategy.coordinationPoints.map((point, index) => ({\r\n      name: point,\r\n      expectedProgress: Math.round(((index + 1) / strategy.coordinationPoints.length) * 100),\r\n      actions: ['status_check', 'sync_progress', 'adjust_strategy'],\r\n    }));\r\n  }\r\n\r\n  private createFallbackPlan(task: Task, agents: Agent[]): any {\r\n    return {\r\n      triggers: ['agent_failure', 'deadline_approaching', 'consensus_failure'],\r\n      actions: [\r\n        'reassign_to_available_agents',\r\n        'escalate_to_queen',\r\n        'activate_backup_agents',\r\n        'simplify_task_requirements',\r\n      ],\r\n      escalation_path: ['team_lead', 'queen', 'human_operator'],\r\n    };\r\n  }\r\n\r\n  private async monitorAgentHealth(): Promise<void> {\r\n    for (const agent of this.agents.values()) {\r\n      if (agent.status === 'error' || !agent.isResponsive()) {\r\n        await this.handleAgentFailure(agent);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async checkTaskProgress(): Promise<void> {\r\n    const activeTasks = await this.db.getActiveTasks(this.config.swarmId);\r\n\r\n    for (const task of activeTasks) {\r\n      if (this.isTaskStalled(task)) {\r\n        await this.handleStalledTask(task);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async checkRebalancing(): Promise<void> {\r\n    const stats = await this.db.getSwarmStats(this.config.swarmId);\r\n\r\n    if (stats.agentUtilization > 0.9 || stats.taskBacklog > stats.agentCount * 2) {\r\n      this.emit('rebalanceNeeded', stats);\r\n    }\r\n  }\r\n\r\n  private async analyzePerformancePatterns(): Promise<void> {\r\n    const patterns = await this.mcpWrapper.analyzePattern({\r\n      action: 'analyze',\r\n      operation: 'performance_patterns',\r\n      metadata: {\r\n        swarmId: this.config.swarmId,\r\n        timeframe: '1h',\r\n      },\r\n    });\r\n\r\n    if (patterns.recommendations) {\r\n      await this.applyPerformanceRecommendations(patterns.recommendations);\r\n    }\r\n  }\r\n\r\n  private async optimizeStrategies(): Promise<void> {\r\n    // Analyze strategy effectiveness and adjust\r\n    const strategyPerformance = await this.db.getStrategyPerformance(this.config.swarmId);\r\n\r\n    for (const [strategyName, performance] of Object.entries(strategyPerformance)) {\r\n      if (performance.successRate < 0.7) {\r\n        await this.adjustStrategy(strategyName, performance);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async trainNeuralPatterns(): Promise<void> {\r\n    // Train neural network on successful patterns\r\n    const successfulDecisions = await this.db.getSuccessfulDecisions(this.config.swarmId);\r\n\r\n    if (successfulDecisions.length > 10) {\r\n      await this.mcpWrapper.trainNeural({\r\n        pattern_type: 'coordination',\r\n        training_data: JSON.stringify(successfulDecisions),\r\n        epochs: 50,\r\n      });\r\n    }\r\n  }\r\n\r\n  private async handleAgentFailure(agent: Agent): Promise<void> {\r\n    // Reassign agent's tasks\r\n    if (agent.currentTask) {\r\n      await this.reassignTask(agent.currentTask, agent.id);\r\n    }\r\n\r\n    // Mark agent as offline\r\n    await this.db.updateAgentStatus(agent.id, 'offline');\r\n\r\n    this.emit('agentFailed', { agent });\r\n  }\r\n\r\n  private async handleStalledTask(task: any): Promise<void> {\r\n    // Implement stalled task recovery\r\n    this.emit('taskStalled', { task });\r\n  }\r\n\r\n  private isTaskStalled(task: any): boolean {\r\n    // Check if task hasn't progressed in reasonable time\r\n    const stalledThreshold = 10 * 60 * 1000; // 10 minutes\r\n    return (\r\n      task.last_progress_update &&\r\n      Date.now() - new Date(task.last_progress_update).getTime() > stalledThreshold\r\n    );\r\n  }\r\n\r\n  private async reassignTask(taskId: string, fromAgentId: string): Promise<void> {\r\n    const availableAgents = this.getAvailableAgents().filter((a) => a.id !== fromAgentId);\r\n\r\n    if (availableAgents.length > 0) {\r\n      const newAgent = availableAgents[0]; // Simple selection, could be more sophisticated\r\n      await this.db.reassignTask(taskId, newAgent.id);\r\n      await newAgent.assignTask(taskId, {});\r\n    }\r\n  }\r\n\r\n  private async applyPerformanceRecommendations(recommendations: any[]): Promise<void> {\r\n    // Apply recommended optimizations\r\n    for (const rec of recommendations) {\r\n      this.emit('performanceRecommendation', rec);\r\n    }\r\n  }\r\n\r\n  private async adjustStrategy(strategyName: string, performance: any): Promise<void> {\r\n    const strategy = this.strategies.get(strategyName);\r\n    if (strategy) {\r\n      // Adjust strategy parameters based on performance\r\n      if (performance.avgCompletionTime > performance.targetTime) {\r\n        strategy.maxAgents = Math.min(strategy.maxAgents + 1, 10);\r\n      }\r\n\r\n      this.emit('strategyAdjusted', { strategyName, performance });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shutdown the Queen\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    this.isActive = false;\r\n    this.emit('shutdown');\r\n  }\r\n}\r\n"],"names":["EventEmitter","v4","uuidv4","DatabaseManager","MCPToolWrapper","Queen","id","config","agents","taskQueue","strategies","db","mcpWrapper","isActive","Map","initializeStrategies","initialize","getInstance","createAgent","swarmId","name","type","capabilities","JSON","stringify","status","metadata","role","mode","startCoordinationLoop","startOptimizationLoop","emit","registerAgent","agent","set","analyzeAgentCapabilities","broadcastAgentRegistration","onTaskSubmitted","task","analysis","analyzeTask","decision","makeStrategicDecision","requireConsensus","initiateConsensus","applyDecision","neuralAnalysis","analyzePattern","action","operation","description","priority","topology","availableAgents","getAvailableAgents","length","strategy","selectOptimalStrategy","selectedAgents","selectAgentsForTask","executionPlan","createExecutionPlan","taskId","map","a","confidence","rationale","timestamp","Date","factors","taskComplexity","complexity","agentAvailability","consensusRequired","get","requiredCapabilities","scoredAgents","Promise","all","score","scoreAgentForTask","sort","b","maxAgents","Math","min","slice","sa","capabilityMatches","filter","cap","includes","typeSuitability","getTypeSuitabilityForTask","performance","getAgentPerformance","successRate","agentType","suitabilityMap","research","researcher","analyst","specialist","coder","coordinator","architect","tester","reviewer","optimizer","documenter","monitor","development","testing","optimization","taskType","detectTaskType","lower","toLowerCase","phases","agentAssignments","agentId","determineAgentRole","responsibilities","getAgentResponsibilities","coordinationPoints","checkpoints","createCheckpoints","fallbackPlan","createFallbackPlan","proposal","requiredThreshold","deadline","now","createConsensusProposal","broadcastConsensusRequest","updateTask","assigned_agents","assigned_at","assignTask","storeMemory","key","value","namespace","ttl","setInterval","monitorAgentHealth","checkTaskProgress","checkRebalancing","error","analyzePerformancePatterns","optimizeStrategies","trainNeuralPatterns","suitable_for","Array","from","values","dependencies","registeredAt","createCommunication","from_agent_id","to_agent_id","swarm_id","message_type","content","requires_response","roleMap","responsibilityMap","point","index","expectedProgress","round","actions","triggers","escalation_path","isResponsive","handleAgentFailure","activeTasks","getActiveTasks","isTaskStalled","handleStalledTask","stats","getSwarmStats","agentUtilization","taskBacklog","agentCount","patterns","timeframe","recommendations","applyPerformanceRecommendations","strategyPerformance","getStrategyPerformance","strategyName","Object","entries","adjustStrategy","successfulDecisions","getSuccessfulDecisions","trainNeural","pattern_type","training_data","epochs","currentTask","reassignTask","updateAgentStatus","stalledThreshold","last_progress_update","getTime","fromAgentId","newAgent","rec","avgCompletionTime","targetTime","shutdown"],"mappings":"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"}