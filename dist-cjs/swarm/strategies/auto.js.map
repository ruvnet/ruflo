{
  "version": 3,
  "sources": ["../../../src/swarm/strategies/auto.ts"],
  "sourcesContent": ["// Extended TaskType for auto strategy (extends base TaskType)\nexport type ExtendedTaskType =\n  | 'data-analysis'\n  | 'performance-analysis'\n  | 'statistical-analysis'\n  | 'visualization'\n  | 'predictive-modeling'\n  | 'anomaly-detection'\n  | 'trend-analysis'\n  | 'business-intelligence'\n  | 'quality-analysis'\n  | 'system-design'\n  | 'architecture-review'\n  | 'api-design'\n  | 'cloud-architecture'\n  | 'microservices-design'\n  | 'security-architecture'\n  | 'scalability-design'\n  | 'database-architecture'\n  | 'code-generation'\n  | 'code-review'\n  | 'refactoring'\n  | 'debugging'\n  | 'api-development'\n  | 'database-design'\n  | 'performance-optimization'\n  | 'task-orchestration'\n  | 'progress-tracking'\n  | 'resource-allocation'\n  | 'workflow-management'\n  | 'team-coordination'\n  | 'status-reporting'\n  | 'fact-check'\n  | 'literature-review'\n  | 'market-analysis'\n  | 'unit-testing'\n  | 'integration-testing'\n  | 'e2e-testing'\n  | 'performance-testing'\n  | 'security-testing'\n  | 'api-testing'\n  | 'test-automation'\n  | 'test-analysis';\n\n/**\n * Optimized AUTO Strategy Implementation\n * Uses machine learning-inspired heuristics and intelligent task decomposition\n */\n\nimport { BaseStrategy } from './base.js';\nimport type { DecompositionResult, TaskBatch, AgentAllocation, TaskPattern } from './base.js';\nimport type {\n  SwarmObjective,\n  TaskDefinition,\n  AgentState,\n  TaskType,\n  TaskPriority,\n  TaskId,\n  AgentType,\n} from '../types.js';\nimport { generateId } from '../../utils/helpers.js';\n\ninterface MLHeuristics {\n  taskTypeWeights: Record<string, number>;\n  agentPerformanceHistory: Map<string, number>;\n  complexityFactors: Record<string, number>;\n  parallelismOpportunities: string[];\n}\n\ninterface PredictiveSchedule {\n  timeline: ScheduleSlot[];\n  resourceUtilization: Record<string, number>;\n  bottlenecks: string[];\n  optimizationSuggestions: string[];\n}\n\ninterface ScheduleSlot {\n  startTime: number;\n  endTime: number;\n  tasks: string[];\n  agents: string[];\n  dependencies: string[];\n}\n\nexport class AutoStrategy extends BaseStrategy {\n  private mlHeuristics: MLHeuristics;\n  private decompositionCache: Map<string, DecompositionResult>;\n  private patternCache: Map<string, TaskPattern[]>;\n  private performanceHistory: Map<string, number[]>;\n\n  constructor(config: any) {\n    super(config);\n    this.mlHeuristics = this.initializeMLHeuristics();\n    this.decompositionCache = new Map();\n    this.patternCache = new Map();\n    this.performanceHistory = new Map();\n  }\n\n  /**\n   * Enhanced objective decomposition with async processing and intelligent batching\n   */\n  override async decomposeObjective(objective: SwarmObjective): Promise<DecompositionResult> {\n    const startTime = Date.now();\n    const cacheKey = this.getCacheKey(objective);\n\n    // Check cache first\n    if (this.decompositionCache.has(cacheKey)) {\n      this.metrics.cacheHitRate = (this.metrics.cacheHitRate + 1) / 2;\n      return this.decompositionCache.get(cacheKey)!;\n    }\n\n    // Parallel pattern detection and task type analysis\n    const [detectedPatterns, taskTypes, complexity] = await Promise.all([\n      this.detectPatternsAsync(objective.description),\n      this.analyzeTaskTypesAsync(objective.description),\n      this.estimateComplexityAsync(objective.description),\n    ]);\n\n    // Generate tasks based on detected patterns and strategy\n    const tasks = await this.generateTasksWithBatching(\n      objective,\n      detectedPatterns,\n      taskTypes,\n      complexity,\n    );\n\n    // Analyze dependencies and create batches\n    const dependencies = this.analyzeDependencies(tasks);\n    const batchGroups = this.createTaskBatches(tasks, dependencies);\n\n    // Estimate total duration with parallel processing consideration\n    const estimatedDuration = this.calculateOptimizedDuration(batchGroups);\n\n    const result: DecompositionResult = {\n      tasks,\n      dependencies,\n      estimatedDuration,\n      recommendedStrategy: this.selectOptimalStrategy(objective, complexity),\n      complexity,\n      batchGroups,\n      timestamp: new Date(),\n      ttl: 1800000, // 30 minutes\n      accessCount: 0,\n      lastAccessed: new Date(),\n      data: { objectiveId: objective.id, strategy: 'auto' },\n    };\n\n    // Cache the result\n    this.decompositionCache.set(cacheKey, result);\n    this.updateMetrics(result, Date.now() - startTime);\n\n    return result;\n  }\n\n  /**\n   * ML-inspired agent selection with performance history consideration\n   */\n  override async selectAgentForTask(\n    task: TaskDefinition,\n    availableAgents: AgentState[],\n  ): Promise<string | null> {\n    if (availableAgents.length === 0) return null;\n\n    // Score agents using ML heuristics\n    const scoredAgents = await Promise.all(\n      availableAgents.map(async (agent) => ({\n        agent,\n        score: await this.calculateAgentScore(agent, task),\n      })),\n    );\n\n    // Sort by score and select best agent\n    scoredAgents.sort((a, b) => b.score - a.score);\n\n    // Update performance history\n    const selectedAgent = scoredAgents[0].agent;\n    this.updateAgentPerformanceHistory(selectedAgent.id.id, scoredAgents[0].score);\n\n    return selectedAgent.id.id;\n  }\n\n  /**\n   * Predictive task scheduling with dynamic agent allocation\n   */\n  override async optimizeTaskSchedule(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n  ): Promise<AgentAllocation[]> {\n    const schedule = await this.createPredictiveSchedule(tasks, agents);\n\n    return this.allocateAgentsOptimally(tasks, agents, schedule);\n  }\n\n  // Private implementation methods\n\n  private initializeMLHeuristics(): MLHeuristics {\n    return {\n      taskTypeWeights: {\n        development: 1.0,\n        testing: 0.8,\n        analysis: 0.9,\n        documentation: 0.6,\n        optimization: 1.1,\n        research: 0.7,\n      },\n      agentPerformanceHistory: new Map(),\n      complexityFactors: {\n        integration: 1.5,\n        system: 1.3,\n        api: 1.2,\n        database: 1.4,\n        ui: 1.1,\n        algorithm: 1.6,\n      },\n      parallelismOpportunities: [\n        'independent modules',\n        'separate components',\n        'different layers',\n        'parallel testing',\n        'concurrent analysis',\n      ],\n    };\n  }\n\n  private async detectPatternsAsync(description: string): Promise<TaskPattern[]> {\n    const cacheKey = `patterns-${description.slice(0, 50)}`;\n\n    if (this.patternCache.has(cacheKey)) {\n      return this.patternCache.get(cacheKey)!;\n    }\n\n    // Simulate async pattern detection with enhanced matching\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const patterns = this.taskPatterns.filter((pattern) => pattern.pattern.test(description));\n\n        // Add dynamic patterns based on content analysis\n        const dynamicPatterns = this.generateDynamicPatterns(description);\n        const allPatterns = [...patterns, ...dynamicPatterns];\n\n        this.patternCache.set(cacheKey, allPatterns);\n        resolve(allPatterns);\n      }, 10); // Simulate async processing\n    });\n  }\n\n  private async analyzeTaskTypesAsync(description: string): Promise<string[]> {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const types = [];\n\n        // Enhanced task type detection\n        if (/create|build|implement|develop|code/i.test(description)) {\n          types.push('development');\n        }\n        if (/test|verify|validate|check/i.test(description)) {\n          types.push('testing');\n        }\n        if (/analyze|research|investigate|study/i.test(description)) {\n          types.push('analysis');\n        }\n        if (/document|write|explain|describe/i.test(description)) {\n          types.push('documentation');\n        }\n        if (/optimize|improve|enhance|refactor/i.test(description)) {\n          types.push('optimization');\n        }\n        if (/deploy|install|configure|setup/i.test(description)) {\n          types.push('deployment');\n        }\n\n        resolve(types.length > 0 ? types : ['generic']);\n      }, 5);\n    });\n  }\n\n  private async estimateComplexityAsync(description: string): Promise<number> {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        let complexity = this.estimateComplexity(description);\n\n        // Apply ML heuristics for complexity adjustment\n        for (const [factor, weight] of Object.entries(this.mlHeuristics.complexityFactors)) {\n          if (description.toLowerCase().includes(factor)) {\n            complexity *= weight;\n          }\n        }\n\n        resolve(Math.min(Math.round(complexity), 5));\n      }, 5);\n    });\n  }\n\n  private generateDynamicPatterns(description: string): TaskPattern[] {\n    const patterns: TaskPattern[] = [];\n\n    // Generate patterns based on specific keywords and context\n    if (description.includes('API') || description.includes('endpoint')) {\n      patterns.push({\n        pattern: /api|endpoint|service/i,\n        type: 'api-development',\n        complexity: 3,\n        estimatedDuration: 20 * 60 * 1000,\n        requiredAgents: 2,\n        priority: 2,\n      });\n    }\n\n    if (description.includes('database') || description.includes('data')) {\n      patterns.push({\n        pattern: /database|data|storage/i,\n        type: 'data-management',\n        complexity: 3,\n        estimatedDuration: 18 * 60 * 1000,\n        requiredAgents: 2,\n        priority: 2,\n      });\n    }\n\n    return patterns;\n  }\n\n  private async generateTasksWithBatching(\n    objective: SwarmObjective,\n    patterns: TaskPattern[],\n    taskTypes: string[],\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n\n    // Determine strategy-specific task generation\n    if (objective.strategy === 'development') {\n      tasks.push(...(await this.generateDevelopmentTasks(objective, complexity)));\n    } else if (objective.strategy === 'analysis') {\n      tasks.push(...(await this.generateAnalysisTasks(objective, complexity)));\n    } else {\n      // Auto strategy - intelligent task generation based on patterns\n      tasks.push(...(await this.generateAutoTasks(objective, patterns, taskTypes, complexity)));\n    }\n\n    return tasks;\n  }\n\n  private async generateDevelopmentTasks(\n    objective: SwarmObjective,\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n    const baseId = generateId('task');\n\n    // Analysis and Planning Phase\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-analysis`,\n        type: 'analysis' as TaskType,\n        name: 'Requirements Analysis and Planning',\n        description: `Analyze requirements and create implementation plan for: ${objective.description}`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(5 * 60 * 1000, complexity * 3 * 60 * 1000),\n        capabilities: ['analysis', 'documentation', 'research'],\n      }),\n    );\n\n    // Implementation Phase (can be parallelized)\n    const implementationTasks = this.createParallelImplementationTasks(\n      objective,\n      complexity,\n      baseId,\n    );\n    tasks.push(...implementationTasks);\n\n    // Testing Phase\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-testing`,\n        type: 'testing' as TaskType,\n        name: 'Comprehensive Testing',\n        description: `Create and execute tests for the implementation`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(8 * 60 * 1000, complexity * 4 * 60 * 1000),\n        capabilities: ['testing', 'code-generation'],\n        dependencies: implementationTasks.map((t) => t.id.id),\n      }),\n    );\n\n    // Documentation Phase\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-documentation`,\n        type: 'documentation' as TaskType,\n        name: 'Documentation Creation',\n        description: `Create comprehensive documentation`,\n        priority: 'medium' as TaskPriority,\n        estimatedDuration: Math.max(5 * 60 * 1000, complexity * 2 * 60 * 1000),\n        capabilities: ['documentation'],\n        dependencies: implementationTasks.map((t) => t.id.id),\n      }),\n    );\n\n    return tasks;\n  }\n\n  private createParallelImplementationTasks(\n    objective: SwarmObjective,\n    complexity: number,\n    baseId: string,\n  ): TaskDefinition[] {\n    const tasks: TaskDefinition[] = [];\n\n    // Determine if we can split implementation into parallel tasks\n    const canParallelize = this.canParallelizeImplementation(objective.description);\n\n    if (canParallelize && complexity >= 3) {\n      // Create multiple parallel implementation tasks\n      const components = this.identifyComponents(objective.description);\n\n      components.forEach((component, index) => {\n        tasks.push(\n          this.createTaskDefinition({\n            id: `${baseId}-impl-${index}`,\n            type: 'coding' as TaskType,\n            name: `Implement ${component}`,\n            description: `Implement ${component} component for: ${objective.description}`,\n            priority: 'high' as TaskPriority,\n            estimatedDuration: Math.max(10 * 60 * 1000, complexity * 5 * 60 * 1000),\n            capabilities: ['code-generation', 'file-system'],\n            dependencies: [`${baseId}-analysis`],\n          }),\n        );\n      });\n    } else {\n      // Single implementation task\n      tasks.push(\n        this.createTaskDefinition({\n          id: `${baseId}-implementation`,\n          type: 'coding' as TaskType,\n          name: 'Core Implementation',\n          description: `Implement the solution for: ${objective.description}`,\n          priority: 'high' as TaskPriority,\n          estimatedDuration: Math.max(15 * 60 * 1000, complexity * 8 * 60 * 1000),\n          capabilities: ['code-generation', 'file-system'],\n          dependencies: [`${baseId}-analysis`],\n        }),\n      );\n    }\n\n    return tasks;\n  }\n\n  private async generateAnalysisTasks(\n    objective: SwarmObjective,\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n    const baseId = generateId('task');\n\n    // Data Collection\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-collection`,\n        type: 'research' as TaskType,\n        name: 'Data Collection and Research',\n        description: `Collect and research data for: ${objective.description}`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(8 * 60 * 1000, complexity * 4 * 60 * 1000),\n        capabilities: ['research', 'analysis', 'web-search'],\n      }),\n    );\n\n    // Analysis\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-analysis`,\n        type: 'analysis' as TaskType,\n        name: 'Data Analysis',\n        description: `Analyze collected data and generate insights`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(10 * 60 * 1000, complexity * 5 * 60 * 1000),\n        capabilities: ['analysis', 'documentation'],\n        dependencies: [`${baseId}-collection`],\n      }),\n    );\n\n    // Reporting\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-reporting`,\n        type: 'documentation' as TaskType,\n        name: 'Analysis Report',\n        description: `Create comprehensive analysis report`,\n        priority: 'medium' as TaskPriority,\n        estimatedDuration: Math.max(6 * 60 * 1000, complexity * 3 * 60 * 1000),\n        capabilities: ['documentation', 'analysis'],\n        dependencies: [`${baseId}-analysis`],\n      }),\n    );\n\n    return tasks;\n  }\n\n  private async generateAutoTasks(\n    objective: SwarmObjective,\n    patterns: TaskPattern[],\n    taskTypes: string[],\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n    const baseId = generateId('task');\n\n    // Use ML heuristics to determine optimal task structure\n    const optimalStructure = this.determineOptimalTaskStructure(patterns, taskTypes, complexity);\n\n    if (optimalStructure.requiresAnalysis) {\n      tasks.push(\n        this.createTaskDefinition({\n          id: `${baseId}-analysis`,\n          type: 'analysis' as TaskType,\n          name: 'Intelligent Analysis',\n          description: `Analyze and understand: ${objective.description}`,\n          priority: 'high' as TaskPriority,\n          estimatedDuration: optimalStructure.analysisDuration,\n          capabilities: ['analysis', 'research'],\n        }),\n      );\n    }\n\n    if (optimalStructure.requiresImplementation) {\n      const implTasks = this.createOptimalImplementationTasks(objective, optimalStructure, baseId);\n      tasks.push(...implTasks);\n    }\n\n    if (optimalStructure.requiresTesting) {\n      tasks.push(\n        this.createTaskDefinition({\n          id: `${baseId}-testing`,\n          type: 'testing' as TaskType,\n          name: 'Intelligent Testing',\n          description: `Test and validate the solution`,\n          priority: 'high' as TaskPriority,\n          estimatedDuration: optimalStructure.testingDuration,\n          capabilities: ['testing', 'validation'],\n          dependencies: tasks.filter((t) => t.type === 'coding').map((t) => t.id.id),\n        }),\n      );\n    }\n\n    return tasks;\n  }\n\n  private createTaskDefinition(params: {\n    id: string;\n    type: TaskType;\n    name: string;\n    description: string;\n    priority: TaskPriority;\n    estimatedDuration: number;\n    capabilities: string[];\n    dependencies?: string[];\n  }): TaskDefinition {\n    const taskId: TaskId = {\n      id: params.id,\n      swarmId: 'auto-strategy',\n      sequence: 1,\n      priority: 1,\n    };\n\n    return {\n      id: taskId,\n      type: params.type,\n      name: params.name,\n      description: params.description,\n      instructions: params.description,\n      requirements: {\n        capabilities: params.capabilities,\n        tools: this.getRequiredTools(params.type),\n        permissions: ['read', 'write', 'execute'],\n      },\n      constraints: {\n        dependencies: (params.dependencies || []).map((dep) => ({\n          id: dep,\n          swarmId: 'auto-strategy',\n          sequence: 1,\n          priority: 1,\n        })),\n        dependents: [],\n        conflicts: [],\n        maxRetries: 3,\n        timeoutAfter: params.estimatedDuration,\n      },\n      priority: params.priority,\n      input: { description: params.description },\n      context: {},\n      examples: [],\n      status: 'created',\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      attempts: [],\n      statusHistory: [\n        {\n          timestamp: new Date(),\n          from: 'created',\n          to: 'created',\n          reason: 'Task created by AutoStrategy',\n          triggeredBy: 'system',\n        },\n      ],\n    };\n  }\n\n  private getRequiredTools(type: TaskType): string[] {\n    const toolMap: Record<string, string[]> = {\n      coding: ['file-system', 'terminal', 'editor'],\n      testing: ['test-runner', 'file-system', 'terminal'],\n      analysis: ['analyst', 'file-system', 'web-search'],\n      documentation: ['editor', 'file-system'],\n      research: ['web-search', 'analyst', 'file-system'],\n      review: ['analyst', 'file-system'],\n      deployment: ['terminal', 'file-system', 'deployment-tools'],\n      monitoring: ['monitoring-tools', 'analyst'],\n      coordination: ['communication-tools'],\n      communication: ['communication-tools'],\n      maintenance: ['file-system', 'terminal', 'monitoring-tools'],\n      optimization: ['analyst', 'profiler', 'file-system'],\n      validation: ['validator', 'test-runner'],\n      integration: ['integration-tools', 'file-system', 'terminal'],\n      custom: ['file-system'],\n    };\n\n    return toolMap[type] || ['file-system'];\n  }\n\n  // Additional helper methods would continue here...\n  // (Truncated for brevity - the full implementation would include all helper methods)\n\n  private canParallelizeImplementation(description: string): boolean {\n    const parallelKeywords = ['components', 'modules', 'services', 'layers', 'parts'];\n    return parallelKeywords.some((keyword) => description.toLowerCase().includes(keyword));\n  }\n\n  private identifyComponents(description: string): string[] {\n    // Simple component identification - in a real implementation this would be more sophisticated\n    const components = ['Core Logic', 'User Interface', 'Data Layer'];\n\n    if (description.toLowerCase().includes('api')) {\n      components.push('API Layer');\n    }\n    if (description.toLowerCase().includes('database')) {\n      components.push('Database Integration');\n    }\n\n    return components.slice(0, 3); // Limit to 3 parallel components\n  }\n\n  private determineOptimalTaskStructure(\n    patterns: TaskPattern[],\n    taskTypes: string[],\n    complexity: number,\n  ) {\n    return {\n      requiresAnalysis: complexity >= 2 || taskTypes.includes('analysis'),\n      requiresImplementation: taskTypes.includes('development') || taskTypes.includes('coding'),\n      requiresTesting: complexity >= 2 || taskTypes.includes('testing'),\n      analysisDuration: Math.max(5 * 60 * 1000, complexity * 3 * 60 * 1000),\n      testingDuration: Math.max(5 * 60 * 1000, complexity * 4 * 60 * 1000),\n    };\n  }\n\n  private createOptimalImplementationTasks(\n    objective: SwarmObjective,\n    structure: any,\n    baseId: string,\n  ): TaskDefinition[] {\n    return [\n      this.createTaskDefinition({\n        id: `${baseId}-implementation`,\n        type: 'coding' as TaskType,\n        name: 'Optimal Implementation',\n        description: `Implement solution for: ${objective.description}`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(15 * 60 * 1000, structure.complexity * 8 * 60 * 1000),\n        capabilities: ['code-generation', 'file-system'],\n        dependencies: structure.requiresAnalysis ? [`${baseId}-analysis`] : [],\n      }),\n    ];\n  }\n\n  private analyzeDependencies(tasks: TaskDefinition[]): Map<string, string[]> {\n    const dependencies = new Map<string, string[]>();\n\n    tasks.forEach((task) => {\n      if (task.constraints.dependencies.length > 0) {\n        dependencies.set(\n          task.id.id,\n          task.constraints.dependencies.map((dep) => dep.id),\n        );\n      }\n    });\n\n    return dependencies;\n  }\n\n  private createTaskBatches(\n    tasks: TaskDefinition[],\n    dependencies: Map<string, string[]>,\n  ): TaskBatch[] {\n    const batches: TaskBatch[] = [];\n    const processed = new Set<string>();\n    let batchIndex = 0;\n\n    while (processed.size < tasks.length) {\n      const batchTasks = tasks.filter(\n        (task) =>\n          !processed.has(task.id.id) &&\n          task.constraints.dependencies.every((dep) => processed.has(dep.id)),\n      );\n\n      if (batchTasks.length === 0) break; // Prevent infinite loop\n\n      const batch: TaskBatch = {\n        id: `batch-${batchIndex++}`,\n        tasks: batchTasks,\n        canRunInParallel: batchTasks.length > 1,\n        estimatedDuration: Math.max(...batchTasks.map((t) => t.constraints.timeoutAfter || 0)),\n        requiredResources: this.calculateBatchResources(batchTasks),\n      };\n\n      batches.push(batch);\n      batchTasks.forEach((task) => processed.add(task.id.id));\n    }\n\n    return batches;\n  }\n\n  private calculateBatchResources(tasks: TaskDefinition[]): Record<string, number> {\n    return {\n      agents: tasks.length,\n      memory: tasks.length * 512, // MB\n      cpu: tasks.length * 0.5, // CPU cores\n    };\n  }\n\n  private calculateOptimizedDuration(batches: TaskBatch[]): number {\n    return batches.reduce((total, batch) => total + batch.estimatedDuration, 0);\n  }\n\n  private selectOptimalStrategy(objective: SwarmObjective, complexity: number): string {\n    if (complexity >= 4) return 'development';\n    if (objective.description.toLowerCase().includes('analyze')) return 'analysis';\n    if (objective.description.toLowerCase().includes('test')) return 'testing';\n    return 'auto';\n  }\n\n  private async calculateAgentScore(agent: AgentState, task: TaskDefinition): Promise<number> {\n    let score = 0;\n\n    // Capability matching (40%)\n    const capabilityMatch = this.calculateCapabilityMatch(agent, task);\n    score += capabilityMatch * 0.4;\n\n    // Performance history (30%)\n    const performanceScore = this.getAgentPerformanceScore(agent.id.id);\n    score += performanceScore * 0.3;\n\n    // Current workload (20%)\n    const workloadScore = 1 - agent.workload;\n    score += workloadScore * 0.2;\n\n    // ML heuristics adjustment (10%)\n    const mlScore = this.applyMLHeuristics(agent, task);\n    score += mlScore * 0.1;\n\n    return score;\n  }\n\n  private calculateCapabilityMatch(agent: AgentState, task: TaskDefinition): number {\n    const requiredCaps = task.requirements.capabilities;\n    let matches = 0;\n\n    for (const cap of requiredCaps) {\n      if (this.agentHasCapability(agent, cap)) {\n        matches++;\n      }\n    }\n\n    return requiredCaps.length > 0 ? matches / requiredCaps.length : 1.0;\n  }\n\n  private agentHasCapability(agent: AgentState, capability: string): boolean {\n    const caps = agent.capabilities;\n\n    switch (capability) {\n      case 'code-generation':\n        return caps.codeGeneration;\n      case 'code-review':\n        return caps.codeReview;\n      case 'testing':\n        return caps.testing;\n      case 'documentation':\n        return caps.documentation;\n      case 'research':\n        return caps.research;\n      case 'analysis':\n        return caps.analysis;\n      case 'web-search':\n        return caps.webSearch;\n      case 'api-integration':\n        return caps.apiIntegration;\n      case 'file-system':\n        return caps.fileSystem;\n      case 'terminal-access':\n        return caps.terminalAccess;\n      default:\n        return (\n          caps.domains.includes(capability) ||\n          caps.languages.includes(capability) ||\n          caps.frameworks.includes(capability) ||\n          caps.tools.includes(capability)\n        );\n    }\n  }\n\n  private getAgentPerformanceScore(agentId: string): number {\n    const history = this.performanceHistory.get(agentId);\n    if (!history || history.length === 0) return 0.8; // Default score\n\n    const average = history.reduce((sum, score) => sum + score, 0) / history.length;\n    return Math.min(average, 1.0);\n  }\n\n  private applyMLHeuristics(agent: AgentState, task: TaskDefinition): number {\n    const taskType = this.detectTaskType(task.description);\n    const weight = this.mlHeuristics.taskTypeWeights[taskType] || 1.0;\n\n    // Apply agent type bonus\n    let bonus = 0;\n    if (agent.type === 'coder' && taskType === 'development') bonus = 0.2;\n    if (agent.type === 'tester' && taskType === 'testing') bonus = 0.2;\n    if (agent.type === 'analyst' && taskType === 'analysis') bonus = 0.2;\n\n    return Math.min(weight + bonus, 1.0);\n  }\n\n  private updateAgentPerformanceHistory(agentId: string, score: number): void {\n    if (!this.performanceHistory.has(agentId)) {\n      this.performanceHistory.set(agentId, []);\n    }\n\n    const history = this.performanceHistory.get(agentId)!;\n    history.push(score);\n\n    // Keep only last 10 scores\n    if (history.length > 10) {\n      history.shift();\n    }\n  }\n\n  private async createPredictiveSchedule(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n  ): Promise<PredictiveSchedule> {\n    // Simplified predictive scheduling implementation\n    const timeline: ScheduleSlot[] = [];\n    let currentTime = Date.now();\n\n    for (const task of tasks) {\n      const duration = task.constraints.timeoutAfter || 300000; // 5 min default\n      timeline.push({\n        startTime: currentTime,\n        endTime: currentTime + duration,\n        tasks: [task.id.id],\n        agents: [], // To be filled by allocation\n        dependencies: task.constraints.dependencies.map((dep) => dep.id),\n      });\n      currentTime += duration;\n    }\n\n    return {\n      timeline,\n      resourceUtilization: { cpu: 0.7, memory: 0.6 },\n      bottlenecks: [],\n      optimizationSuggestions: ['Consider parallel execution for independent tasks'],\n    };\n  }\n\n  private allocateAgentsOptimally(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n    schedule: PredictiveSchedule,\n  ): AgentAllocation[] {\n    const allocations: AgentAllocation[] = [];\n\n    agents.forEach((agent) => {\n      const suitableTasks = tasks.filter(\n        (task) => this.calculateCapabilityMatch(agent, task) > 0.5,\n      );\n\n      if (suitableTasks.length > 0) {\n        allocations.push({\n          agentId: agent.id.id,\n          tasks: suitableTasks.slice(0, 3).map((t) => t.id.id), // Limit to 3 tasks per agent\n          estimatedWorkload: suitableTasks.length * 0.3,\n          capabilities: Object.keys(agent.capabilities).filter(\n            (cap) => (agent.capabilities as any)[cap] === true,\n          ),\n        });\n      }\n    });\n\n    return allocations;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
