{
  "version": 3,
  "sources": ["../../src/coordination/conflict-resolution.ts"],
  "sourcesContent": ["/**\n * Conflict resolution mechanisms for multi-agent coordination\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { Task, Resource } from '../utils/types.js';\n\nexport interface ResourceConflict {\n  id: string;\n  resourceId: string;\n  agents: string[];\n  timestamp: Date;\n  resolved: boolean;\n  resolution?: ConflictResolution;\n}\n\nexport interface TaskConflict {\n  id: string;\n  taskId: string;\n  agents: string[];\n  type: 'assignment' | 'dependency' | 'output';\n  timestamp: Date;\n  resolved: boolean;\n  resolution?: ConflictResolution;\n}\n\nexport interface ConflictResolution {\n  type: 'priority' | 'timestamp' | 'vote' | 'manual' | 'retry';\n  winner?: string;\n  losers?: string[];\n  reason: string;\n  timestamp: Date;\n}\n\nexport interface ConflictResolutionStrategy {\n  name: string;\n  resolve(conflict: ResourceConflict | TaskConflict, context: any): Promise<ConflictResolution>;\n}\n\n/**\n * Priority-based resolution strategy\n */\nexport class PriorityResolutionStrategy implements ConflictResolutionStrategy {\n  name = 'priority';\n\n  async resolve(\n    conflict: ResourceConflict | TaskConflict,\n    context: { agentPriorities: Map<string, number> },\n  ): Promise<ConflictResolution> {\n    const priorities = conflict.agents.map((agentId) => ({\n      agentId,\n      priority: context.agentPriorities.get(agentId) || 0,\n    }));\n\n    // Sort by priority (descending)\n    priorities.sort((a, b) => b.priority - a.priority);\n\n    const winner = priorities[0].agentId;\n    const losers = priorities.slice(1).map((p) => p.agentId);\n\n    return {\n      type: 'priority',\n      winner,\n      losers,\n      reason: `Agent ${winner} has highest priority (${priorities[0].priority})`,\n      timestamp: new Date(),\n    };\n  }\n}\n\n/**\n * First-come-first-served resolution strategy\n */\nexport class TimestampResolutionStrategy implements ConflictResolutionStrategy {\n  name = 'timestamp';\n\n  async resolve(\n    conflict: ResourceConflict | TaskConflict,\n    context: { requestTimestamps: Map<string, Date> },\n  ): Promise<ConflictResolution> {\n    const timestamps = conflict.agents.map((agentId) => ({\n      agentId,\n      timestamp: context.requestTimestamps.get(agentId) || new Date(),\n    }));\n\n    // Sort by timestamp (ascending - earliest first)\n    timestamps.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    const winner = timestamps[0].agentId;\n    const losers = timestamps.slice(1).map((t) => t.agentId);\n\n    return {\n      type: 'timestamp',\n      winner,\n      losers,\n      reason: `Agent ${winner} made the earliest request`,\n      timestamp: new Date(),\n    };\n  }\n}\n\n/**\n * Voting-based resolution strategy (for multi-agent consensus)\n */\nexport class VotingResolutionStrategy implements ConflictResolutionStrategy {\n  name = 'vote';\n\n  async resolve(\n    conflict: ResourceConflict | TaskConflict,\n    context: { votes: Map<string, string[]> }, // agentId -> votes for that agent\n  ): Promise<ConflictResolution> {\n    const voteCounts = new Map<string, number>();\n\n    // Count votes\n    for (const [agentId, voters] of context.votes) {\n      voteCounts.set(agentId, voters.length);\n    }\n\n    // Find winner\n    let maxVotes = 0;\n    let winner = '';\n    const losers: string[] = [];\n\n    for (const [agentId, votes] of voteCounts) {\n      if (votes > maxVotes) {\n        if (winner) {\n          losers.push(winner);\n        }\n        maxVotes = votes;\n        winner = agentId;\n      } else {\n        losers.push(agentId);\n      }\n    }\n\n    return {\n      type: 'vote',\n      winner,\n      losers,\n      reason: `Agent ${winner} received the most votes (${maxVotes})`,\n      timestamp: new Date(),\n    };\n  }\n}\n\n/**\n * Conflict resolution manager\n */\nexport class ConflictResolver {\n  private strategies = new Map<string, ConflictResolutionStrategy>();\n  private conflicts = new Map<string, ResourceConflict | TaskConflict>();\n  private resolutionHistory: ConflictResolution[] = [];\n\n  constructor(\n    private logger: ILogger,\n    private eventBus: IEventBus,\n  ) {\n    // Register default strategies\n    this.registerStrategy(new PriorityResolutionStrategy());\n    this.registerStrategy(new TimestampResolutionStrategy());\n    this.registerStrategy(new VotingResolutionStrategy());\n  }\n\n  /**\n   * Register a conflict resolution strategy\n   */\n  registerStrategy(strategy: ConflictResolutionStrategy): void {\n    this.strategies.set(strategy.name, strategy);\n    this.logger.info('Registered conflict resolution strategy', { name: strategy.name });\n  }\n\n  /**\n   * Report a resource conflict\n   */\n  async reportResourceConflict(resourceId: string, agents: string[]): Promise<ResourceConflict> {\n    const conflict: ResourceConflict = {\n      id: `conflict-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      resourceId,\n      agents,\n      timestamp: new Date(),\n      resolved: false,\n    };\n\n    this.conflicts.set(conflict.id, conflict);\n    this.logger.warn('Resource conflict reported', conflict);\n\n    // Emit conflict event\n    this.eventBus.emit('conflict:resource', conflict);\n\n    return conflict;\n  }\n\n  /**\n   * Report a task conflict\n   */\n  async reportTaskConflict(\n    taskId: string,\n    agents: string[],\n    type: TaskConflict['type'],\n  ): Promise<TaskConflict> {\n    const conflict: TaskConflict = {\n      id: `conflict-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      taskId,\n      agents,\n      type,\n      timestamp: new Date(),\n      resolved: false,\n    };\n\n    this.conflicts.set(conflict.id, conflict);\n    this.logger.warn('Task conflict reported', conflict);\n\n    // Emit conflict event\n    this.eventBus.emit('conflict:task', conflict);\n\n    return conflict;\n  }\n\n  /**\n   * Resolve a conflict using a specific strategy\n   */\n  async resolveConflict(\n    conflictId: string,\n    strategyName: string,\n    context: any,\n  ): Promise<ConflictResolution> {\n    const conflict = this.conflicts.get(conflictId);\n    if (!conflict) {\n      throw new Error(`Conflict not found: ${conflictId}`);\n    }\n\n    if (conflict.resolved) {\n      throw new Error(`Conflict already resolved: ${conflictId}`);\n    }\n\n    const strategy = this.strategies.get(strategyName);\n    if (!strategy) {\n      throw new Error(`Strategy not found: ${strategyName}`);\n    }\n\n    // Resolve the conflict\n    const resolution = await strategy.resolve(conflict, context);\n\n    // Update conflict\n    conflict.resolved = true;\n    conflict.resolution = resolution;\n\n    // Store in history\n    this.resolutionHistory.push(resolution);\n\n    // Emit resolution event\n    this.eventBus.emit('conflict:resolved', {\n      conflict,\n      resolution,\n    });\n\n    this.logger.info('Conflict resolved', {\n      conflictId,\n      strategy: strategyName,\n      resolution,\n    });\n\n    return resolution;\n  }\n\n  /**\n   * Auto-resolve conflicts based on configuration\n   */\n  async autoResolve(\n    conflictId: string,\n    preferredStrategy: string = 'priority',\n  ): Promise<ConflictResolution> {\n    const conflict = this.conflicts.get(conflictId);\n    if (!conflict) {\n      throw new Error(`Conflict not found: ${conflictId}`);\n    }\n\n    // Build context based on conflict type\n    let context: any = {};\n\n    if (preferredStrategy === 'priority') {\n      // In a real implementation, fetch agent priorities from configuration\n      context.agentPriorities = new Map(\n        conflict.agents.map((id, index) => [id, conflict.agents.length - index]),\n      );\n    } else if (preferredStrategy === 'timestamp') {\n      // In a real implementation, fetch request timestamps\n      context.requestTimestamps = new Map(\n        conflict.agents.map((id, index) => [id, new Date(Date.now() - index * 1000)]),\n      );\n    }\n\n    return this.resolveConflict(conflictId, preferredStrategy, context);\n  }\n\n  /**\n   * Get active conflicts\n   */\n  getActiveConflicts(): Array<ResourceConflict | TaskConflict> {\n    return Array.from(this.conflicts.values()).filter((c) => !c.resolved);\n  }\n\n  /**\n   * Get conflict history\n   */\n  getConflictHistory(limit?: number): ConflictResolution[] {\n    if (limit) {\n      return this.resolutionHistory.slice(-limit);\n    }\n    return [...this.resolutionHistory];\n  }\n\n  /**\n   * Clear resolved conflicts older than a certain age\n   */\n  cleanupOldConflicts(maxAgeMs: number): number {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [id, conflict] of this.conflicts) {\n      if (conflict.resolved && now - conflict.timestamp.getTime() > maxAgeMs) {\n        this.conflicts.delete(id);\n        removed++;\n      }\n    }\n\n    // Also cleanup old history\n    const cutoffTime = now - maxAgeMs;\n    this.resolutionHistory = this.resolutionHistory.filter(\n      (r) => r.timestamp.getTime() > cutoffTime,\n    );\n\n    return removed;\n  }\n\n  /**\n   * Get conflict statistics\n   */\n  getStats(): Record<string, unknown> {\n    const stats = {\n      totalConflicts: this.conflicts.size,\n      activeConflicts: 0,\n      resolvedConflicts: 0,\n      resolutionsByStrategy: {} as Record<string, number>,\n      conflictsByType: {\n        resource: 0,\n        task: 0,\n      },\n    };\n\n    for (const conflict of this.conflicts.values()) {\n      if (conflict.resolved) {\n        stats.resolvedConflicts++;\n\n        if (conflict.resolution) {\n          const strategy = conflict.resolution.type;\n          stats.resolutionsByStrategy[strategy] = (stats.resolutionsByStrategy[strategy] || 0) + 1;\n        }\n      } else {\n        stats.activeConflicts++;\n      }\n\n      if ('resourceId' in conflict) {\n        stats.conflictsByType.resource++;\n      } else {\n        stats.conflictsByType.task++;\n      }\n    }\n\n    return stats;\n  }\n}\n\n/**\n * Optimistic concurrency control for resource updates\n */\nexport class OptimisticLockManager {\n  private versions = new Map<string, number>();\n  private locks = new Map<string, { version: number; holder: string; timestamp: Date }>();\n\n  constructor(private logger: ILogger) {}\n\n  /**\n   * Acquire an optimistic lock\n   */\n  acquireLock(resourceId: string, agentId: string): number {\n    const currentVersion = this.versions.get(resourceId) || 0;\n\n    this.locks.set(resourceId, {\n      version: currentVersion,\n      holder: agentId,\n      timestamp: new Date(),\n    });\n\n    this.logger.debug('Optimistic lock acquired', {\n      resourceId,\n      agentId,\n      version: currentVersion,\n    });\n\n    return currentVersion;\n  }\n\n  /**\n   * Validate and update with optimistic lock\n   */\n  validateAndUpdate(resourceId: string, agentId: string, expectedVersion: number): boolean {\n    const currentVersion = this.versions.get(resourceId) || 0;\n    const lock = this.locks.get(resourceId);\n\n    // Check if versions match\n    if (currentVersion !== expectedVersion) {\n      this.logger.warn('Optimistic lock conflict', {\n        resourceId,\n        agentId,\n        expectedVersion,\n        currentVersion,\n      });\n      return false;\n    }\n\n    // Check if this agent holds the lock\n    if (!lock || lock.holder !== agentId) {\n      this.logger.warn('Agent does not hold lock', {\n        resourceId,\n        agentId,\n      });\n      return false;\n    }\n\n    // Update version\n    this.versions.set(resourceId, currentVersion + 1);\n    this.locks.delete(resourceId);\n\n    this.logger.debug('Optimistic update successful', {\n      resourceId,\n      agentId,\n      newVersion: currentVersion + 1,\n    });\n\n    return true;\n  }\n\n  /**\n   * Release a lock without updating\n   */\n  releaseLock(resourceId: string, agentId: string): void {\n    const lock = this.locks.get(resourceId);\n\n    if (lock && lock.holder === agentId) {\n      this.locks.delete(resourceId);\n      this.logger.debug('Optimistic lock released', {\n        resourceId,\n        agentId,\n      });\n    }\n  }\n\n  /**\n   * Clean up stale locks\n   */\n  cleanupStaleLocks(maxAgeMs: number): number {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [resourceId, lock] of this.locks) {\n      if (now - lock.timestamp.getTime() > maxAgeMs) {\n        this.locks.delete(resourceId);\n        removed++;\n\n        this.logger.warn('Removed stale lock', {\n          resourceId,\n          holder: lock.holder,\n          age: now - lock.timestamp.getTime(),\n        });\n      }\n    }\n\n    return removed;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2CO,MAAM,2BAAiE;AAAA,EA3C9E,OA2C8E;AAAA;AAAA;AAAA,EAC5E,OAAO;AAAA,EAEP,MAAM,QACJ,UACA,SAC6B;AAC7B,UAAM,aAAa,SAAS,OAAO,IAAI,CAAC,aAAa;AAAA,MACnD;AAAA,MACA,UAAU,QAAQ,gBAAgB,IAAI,OAAO,KAAK;AAAA,IACpD,EAAE;AAGF,eAAW,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,QAAQ;AAEjD,UAAM,SAAS,WAAW,CAAC,EAAE;AAC7B,UAAM,SAAS,WAAW,MAAM,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO;AAEvD,WAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,QAAQ,SAAS,MAAM,0BAA0B,WAAW,CAAC,EAAE,QAAQ;AAAA,MACvE,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AACF;AAKO,MAAM,4BAAkE;AAAA,EA1E/E,OA0E+E;AAAA;AAAA;AAAA,EAC7E,OAAO;AAAA,EAEP,MAAM,QACJ,UACA,SAC6B;AAC7B,UAAM,aAAa,SAAS,OAAO,IAAI,CAAC,aAAa;AAAA,MACnD;AAAA,MACA,WAAW,QAAQ,kBAAkB,IAAI,OAAO,KAAK,oBAAI,KAAK;AAAA,IAChE,EAAE;AAGF,eAAW,KAAK,CAAC,GAAG,MAAM,EAAE,UAAU,QAAQ,IAAI,EAAE,UAAU,QAAQ,CAAC;AAEvE,UAAM,SAAS,WAAW,CAAC,EAAE;AAC7B,UAAM,SAAS,WAAW,MAAM,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO;AAEvD,WAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,QAAQ,SAAS,MAAM;AAAA,MACvB,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AACF;AAKO,MAAM,yBAA+D;AAAA,EAzG5E,OAyG4E;AAAA;AAAA;AAAA,EAC1E,OAAO;AAAA,EAEP,MAAM,QACJ,UACA,SAC6B;AAC7B,UAAM,aAAa,oBAAI,IAAoB;AAG3C,eAAW,CAAC,SAAS,MAAM,KAAK,QAAQ,OAAO;AAC7C,iBAAW,IAAI,SAAS,OAAO,MAAM;AAAA,IACvC;AAGA,QAAI,WAAW;AACf,QAAI,SAAS;AACb,UAAM,SAAmB,CAAC;AAE1B,eAAW,CAAC,SAAS,KAAK,KAAK,YAAY;AACzC,UAAI,QAAQ,UAAU;AACpB,YAAI,QAAQ;AACV,iBAAO,KAAK,MAAM;AAAA,QACpB;AACA,mBAAW;AACX,iBAAS;AAAA,MACX,OAAO;AACL,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA,IACF;AAEA,WAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,QAAQ,SAAS,MAAM,6BAA6B,QAAQ;AAAA,MAC5D,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AACF;AAKO,MAAM,iBAAiB;AAAA,EAK5B,YACU,QACA,UACR;AAFQ;AACA;AAGR,SAAK,iBAAiB,IAAI,2BAA2B,CAAC;AACtD,SAAK,iBAAiB,IAAI,4BAA4B,CAAC;AACvD,SAAK,iBAAiB,IAAI,yBAAyB,CAAC;AAAA,EACtD;AAAA,EAlKF,OAqJ8B;AAAA;AAAA;AAAA,EACpB,aAAa,oBAAI,IAAwC;AAAA,EACzD,YAAY,oBAAI,IAA6C;AAAA,EAC7D,oBAA0C,CAAC;AAAA;AAAA;AAAA;AAAA,EAenD,iBAAiB,UAA4C;AAC3D,SAAK,WAAW,IAAI,SAAS,MAAM,QAAQ;AAC3C,SAAK,OAAO,KAAK,2CAA2C,EAAE,MAAM,SAAS,KAAK,CAAC;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,YAAoB,QAA6C;AAC5F,UAAM,WAA6B;AAAA,MACjC,IAAI,YAAY,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAAA,MACrE;AAAA,MACA;AAAA,MACA,WAAW,oBAAI,KAAK;AAAA,MACpB,UAAU;AAAA,IACZ;AAEA,SAAK,UAAU,IAAI,SAAS,IAAI,QAAQ;AACxC,SAAK,OAAO,KAAK,8BAA8B,QAAQ;AAGvD,SAAK,SAAS,KAAK,qBAAqB,QAAQ;AAEhD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBACJ,QACA,QACA,MACuB;AACvB,UAAM,WAAyB;AAAA,MAC7B,IAAI,YAAY,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAAA,MACrE;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW,oBAAI,KAAK;AAAA,MACpB,UAAU;AAAA,IACZ;AAEA,SAAK,UAAU,IAAI,SAAS,IAAI,QAAQ;AACxC,SAAK,OAAO,KAAK,0BAA0B,QAAQ;AAGnD,SAAK,SAAS,KAAK,iBAAiB,QAAQ;AAE5C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBACJ,YACA,cACA,SAC6B;AAC7B,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU;AAC9C,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,uBAAuB,UAAU,EAAE;AAAA,IACrD;AAEA,QAAI,SAAS,UAAU;AACrB,YAAM,IAAI,MAAM,8BAA8B,UAAU,EAAE;AAAA,IAC5D;AAEA,UAAM,WAAW,KAAK,WAAW,IAAI,YAAY;AACjD,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,uBAAuB,YAAY,EAAE;AAAA,IACvD;AAGA,UAAM,aAAa,MAAM,SAAS,QAAQ,UAAU,OAAO;AAG3D,aAAS,WAAW;AACpB,aAAS,aAAa;AAGtB,SAAK,kBAAkB,KAAK,UAAU;AAGtC,SAAK,SAAS,KAAK,qBAAqB;AAAA,MACtC;AAAA,MACA;AAAA,IACF,CAAC;AAED,SAAK,OAAO,KAAK,qBAAqB;AAAA,MACpC;AAAA,MACA,UAAU;AAAA,MACV;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YACJ,YACA,oBAA4B,YACC;AAC7B,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU;AAC9C,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,uBAAuB,UAAU,EAAE;AAAA,IACrD;AAGA,QAAI,UAAe,CAAC;AAEpB,QAAI,sBAAsB,YAAY;AAEpC,cAAQ,kBAAkB,IAAI;AAAA,QAC5B,SAAS,OAAO,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,SAAS,OAAO,SAAS,KAAK,CAAC;AAAA,MACzE;AAAA,IACF,WAAW,sBAAsB,aAAa;AAE5C,cAAQ,oBAAoB,IAAI;AAAA,QAC9B,SAAS,OAAO,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,QAAQ,GAAI,CAAC,CAAC;AAAA,MAC9E;AAAA,IACF;AAEA,WAAO,KAAK,gBAAgB,YAAY,mBAAmB,OAAO;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKA,qBAA6D;AAC3D,WAAO,MAAM,KAAK,KAAK,UAAU,OAAO,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,QAAQ;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,OAAsC;AACvD,QAAI,OAAO;AACT,aAAO,KAAK,kBAAkB,MAAM,CAAC,KAAK;AAAA,IAC5C;AACA,WAAO,CAAC,GAAG,KAAK,iBAAiB;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB,UAA0B;AAC5C,UAAM,MAAM,KAAK,IAAI;AACrB,QAAI,UAAU;AAEd,eAAW,CAAC,IAAI,QAAQ,KAAK,KAAK,WAAW;AAC3C,UAAI,SAAS,YAAY,MAAM,SAAS,UAAU,QAAQ,IAAI,UAAU;AACtE,aAAK,UAAU,OAAO,EAAE;AACxB;AAAA,MACF;AAAA,IACF;AAGA,UAAM,aAAa,MAAM;AACzB,SAAK,oBAAoB,KAAK,kBAAkB;AAAA,MAC9C,CAAC,MAAM,EAAE,UAAU,QAAQ,IAAI;AAAA,IACjC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,WAAoC;AAClC,UAAM,QAAQ;AAAA,MACZ,gBAAgB,KAAK,UAAU;AAAA,MAC/B,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,MACnB,uBAAuB,CAAC;AAAA,MACxB,iBAAiB;AAAA,QACf,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,IACF;AAEA,eAAW,YAAY,KAAK,UAAU,OAAO,GAAG;AAC9C,UAAI,SAAS,UAAU;AACrB,cAAM;AAEN,YAAI,SAAS,YAAY;AACvB,gBAAM,WAAW,SAAS,WAAW;AACrC,gBAAM,sBAAsB,QAAQ,KAAK,MAAM,sBAAsB,QAAQ,KAAK,KAAK;AAAA,QACzF;AAAA,MACF,OAAO;AACL,cAAM;AAAA,MACR;AAEA,UAAI,gBAAgB,UAAU;AAC5B,cAAM,gBAAgB;AAAA,MACxB,OAAO;AACL,cAAM,gBAAgB;AAAA,MACxB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAKO,MAAM,sBAAsB;AAAA,EAIjC,YAAoB,QAAiB;AAAjB;AAAA,EAAkB;AAAA,EA7XxC,OAyXmC;AAAA;AAAA;AAAA,EACzB,WAAW,oBAAI,IAAoB;AAAA,EACnC,QAAQ,oBAAI,IAAkE;AAAA;AAAA;AAAA;AAAA,EAOtF,YAAY,YAAoB,SAAyB;AACvD,UAAM,iBAAiB,KAAK,SAAS,IAAI,UAAU,KAAK;AAExD,SAAK,MAAM,IAAI,YAAY;AAAA,MACzB,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,WAAW,oBAAI,KAAK;AAAA,IACtB,CAAC;AAED,SAAK,OAAO,MAAM,4BAA4B;AAAA,MAC5C;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,YAAoB,SAAiB,iBAAkC;AACvF,UAAM,iBAAiB,KAAK,SAAS,IAAI,UAAU,KAAK;AACxD,UAAM,OAAO,KAAK,MAAM,IAAI,UAAU;AAGtC,QAAI,mBAAmB,iBAAiB;AACtC,WAAK,OAAO,KAAK,4BAA4B;AAAA,QAC3C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AAGA,QAAI,CAAC,QAAQ,KAAK,WAAW,SAAS;AACpC,WAAK,OAAO,KAAK,4BAA4B;AAAA,QAC3C;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AAGA,SAAK,SAAS,IAAI,YAAY,iBAAiB,CAAC;AAChD,SAAK,MAAM,OAAO,UAAU;AAE5B,SAAK,OAAO,MAAM,gCAAgC;AAAA,MAChD;AAAA,MACA;AAAA,MACA,YAAY,iBAAiB;AAAA,IAC/B,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,YAAoB,SAAuB;AACrD,UAAM,OAAO,KAAK,MAAM,IAAI,UAAU;AAEtC,QAAI,QAAQ,KAAK,WAAW,SAAS;AACnC,WAAK,MAAM,OAAO,UAAU;AAC5B,WAAK,OAAO,MAAM,4BAA4B;AAAA,QAC5C;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,UAA0B;AAC1C,UAAM,MAAM,KAAK,IAAI;AACrB,QAAI,UAAU;AAEd,eAAW,CAAC,YAAY,IAAI,KAAK,KAAK,OAAO;AAC3C,UAAI,MAAM,KAAK,UAAU,QAAQ,IAAI,UAAU;AAC7C,aAAK,MAAM,OAAO,UAAU;AAC5B;AAEA,aAAK,OAAO,KAAK,sBAAsB;AAAA,UACrC;AAAA,UACA,QAAQ,KAAK;AAAA,UACb,KAAK,MAAM,KAAK,UAAU,QAAQ;AAAA,QACpC,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;",
  "names": []
}
