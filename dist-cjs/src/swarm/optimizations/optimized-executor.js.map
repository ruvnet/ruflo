{"version":3,"sources":["../../../../src/swarm/optimizations/optimized-executor.ts"],"sourcesContent":["/**\r\n * Optimized Task Executor\r\n * Implements async execution with connection pooling and caching\r\n */\r\n\r\nimport { EventEmitter } from 'node:events';\r\nimport { Logger } from '../../core/logger.js';\r\nimport { ClaudeConnectionPool } from './connection-pool.js';\r\nimport { AsyncFileManager } from './async-file-manager.js';\r\nimport { TTLMap } from './ttl-map.js';\r\nimport { CircularBuffer } from './circular-buffer.js';\r\nimport PQueue from 'p-queue';\r\nimport type {\r\n  TaskDefinition,\r\n  TaskResult,\r\n  AgentId,\r\n  TaskStatus,\r\n  TaskType,\r\n  TaskPriority,\r\n} from '../types.js';\r\n\r\nexport interface ExecutorConfig {\r\n  connectionPool?: {\r\n    min?: number;\r\n    max?: number;\r\n  };\r\n  concurrency?: number;\r\n  caching?: {\r\n    enabled?: boolean;\r\n    ttl?: number;\r\n    maxSize?: number;\r\n  };\r\n  fileOperations?: {\r\n    outputDir?: string;\r\n    concurrency?: number;\r\n  };\r\n  monitoring?: {\r\n    metricsInterval?: number;\r\n    slowTaskThreshold?: number;\r\n  };\r\n}\r\n\r\nexport interface ExecutionMetrics {\r\n  totalExecuted: number;\r\n  totalSucceeded: number;\r\n  totalFailed: number;\r\n  avgExecutionTime: number;\r\n  cacheHitRate: number;\r\n  queueLength: number;\r\n  activeExecutions: number;\r\n}\r\n\r\nexport class OptimizedExecutor extends EventEmitter {\r\n  private logger: Logger;\r\n  private connectionPool: ClaudeConnectionPool;\r\n  private fileManager: AsyncFileManager;\r\n  private executionQueue: PQueue;\r\n  private resultCache: TTLMap<string, TaskResult>;\r\n  private executionHistory: CircularBuffer<{\r\n    taskId: string;\r\n    duration: number;\r\n    status: 'success' | 'failed';\r\n    timestamp: Date;\r\n  }>;\r\n\r\n  private metrics = {\r\n    totalExecuted: 0,\r\n    totalSucceeded: 0,\r\n    totalFailed: 0,\r\n    totalExecutionTime: 0,\r\n    cacheHits: 0,\r\n    cacheMisses: 0,\r\n  };\r\n\r\n  private activeExecutions = new Set<string>();\r\n\r\n  constructor(private config: ExecutorConfig = {}) {\r\n    super();\r\n\r\n    // Use test-safe logger configuration\r\n    const loggerConfig =\r\n      process.env.CLAUDE_FLOW_ENV === 'test'\r\n        ? { level: 'error' as const, format: 'json' as const, destination: 'console' as const }\r\n        : { level: 'info' as const, format: 'json' as const, destination: 'console' as const };\r\n\r\n    this.logger = new Logger(loggerConfig, { component: 'OptimizedExecutor' });\r\n\r\n    // Initialize connection pool\r\n    this.connectionPool = new ClaudeConnectionPool({\r\n      min: config.connectionPool?.min || 2,\r\n      max: config.connectionPool?.max || 10,\r\n    });\r\n\r\n    // Initialize file manager\r\n    this.fileManager = new AsyncFileManager({\r\n      write: config.fileOperations?.concurrency || 10,\r\n      read: config.fileOperations?.concurrency || 20,\r\n    });\r\n\r\n    // Initialize execution queue\r\n    this.executionQueue = new PQueue({\r\n      concurrency: config.concurrency || 10,\r\n    });\r\n\r\n    // Initialize result cache\r\n    this.resultCache = new TTLMap({\r\n      defaultTTL: config.caching?.ttl || 3600000, // 1 hour\r\n      maxSize: config.caching?.maxSize || 1000,\r\n      onExpire: (key, value) => {\r\n        this.logger.debug('Cache entry expired', { taskId: key });\r\n      },\r\n    });\r\n\r\n    // Initialize execution history\r\n    this.executionHistory = new CircularBuffer(1000);\r\n\r\n    // Start monitoring if configured\r\n    if (config.monitoring?.metricsInterval) {\r\n      setInterval(() => {\r\n        this.emitMetrics();\r\n      }, config.monitoring.metricsInterval);\r\n    }\r\n  }\r\n\r\n  async executeTask(task: TaskDefinition, agentId: AgentId): Promise<TaskResult> {\r\n    const startTime = Date.now();\r\n    const taskKey = this.getTaskCacheKey(task);\r\n\r\n    // Check cache if enabled\r\n    if (this.config.caching?.enabled) {\r\n      const cached = this.resultCache.get(taskKey);\r\n      if (cached) {\r\n        this.metrics.cacheHits++;\r\n        this.logger.debug('Cache hit for task', { taskId: task.id });\r\n        return cached;\r\n      }\r\n      this.metrics.cacheMisses++;\r\n    }\r\n\r\n    // Add to active executions\r\n    this.activeExecutions.add(task.id);\r\n\r\n    // Queue the execution\r\n    const result = await this.executionQueue.add(async () => {\r\n      try {\r\n        // Execute with connection pool\r\n        const executionResult = await this.connectionPool.execute(async (api) => {\r\n          const response = await api.complete({\r\n            messages: this.buildMessages(task),\r\n            model: task.metadata?.model || 'claude-3-5-sonnet-20241022',\r\n            max_tokens: task.constraints.maxTokens || 4096,\r\n            temperature: task.metadata?.temperature || 0.7,\r\n          });\r\n\r\n          return {\r\n            success: true,\r\n            output: response.content[0]?.text || '',\r\n            usage: {\r\n              inputTokens: response.usage?.input_tokens || 0,\r\n              outputTokens: response.usage?.output_tokens || 0,\r\n            },\r\n          };\r\n        });\r\n\r\n        // Save result to file asynchronously\r\n        if (this.config.fileOperations?.outputDir) {\r\n          const outputPath = `${this.config.fileOperations.outputDir}/${task.id}.json`;\r\n          await this.fileManager.writeJSON(outputPath, {\r\n            taskId: task.id,\r\n            agentId: agentId.id,\r\n            result: executionResult,\r\n            timestamp: new Date(),\r\n          });\r\n        }\r\n\r\n        // Create task result\r\n        const taskResult: TaskResult = {\r\n          taskId: task.id,\r\n          agentId: agentId.id,\r\n          success: executionResult.success,\r\n          output: executionResult.output,\r\n          error: undefined,\r\n          executionTime: Date.now() - startTime,\r\n          tokensUsed: executionResult.usage,\r\n          timestamp: new Date(),\r\n        };\r\n\r\n        // Cache result if enabled\r\n        if (this.config.caching?.enabled && executionResult.success) {\r\n          this.resultCache.set(taskKey, taskResult);\r\n        }\r\n\r\n        // Update metrics\r\n        this.metrics.totalExecuted++;\r\n        this.metrics.totalSucceeded++;\r\n        this.metrics.totalExecutionTime += taskResult.executionTime;\r\n\r\n        // Record in history\r\n        this.executionHistory.push({\r\n          taskId: task.id,\r\n          duration: taskResult.executionTime,\r\n          status: 'success',\r\n          timestamp: new Date(),\r\n        });\r\n\r\n        // Check if slow task\r\n        if (\r\n          this.config.monitoring?.slowTaskThreshold &&\r\n          taskResult.executionTime > this.config.monitoring.slowTaskThreshold\r\n        ) {\r\n          this.logger.warn('Slow task detected', {\r\n            taskId: task.id,\r\n            duration: taskResult.executionTime,\r\n            threshold: this.config.monitoring.slowTaskThreshold,\r\n          });\r\n        }\r\n\r\n        this.emit('task:completed', taskResult);\r\n        return taskResult;\r\n      } catch (error) {\r\n        this.metrics.totalExecuted++;\r\n        this.metrics.totalFailed++;\r\n\r\n        const errorResult: TaskResult = {\r\n          taskId: task.id,\r\n          agentId: agentId.id,\r\n          success: false,\r\n          output: '',\r\n          error: {\r\n            type: error instanceof Error ? error.constructor.name : 'UnknownError',\r\n            message: error instanceof Error ? error.message : 'Unknown error',\r\n            code: (error as any).code,\r\n            stack: error instanceof Error ? error.stack : undefined,\r\n            context: { taskId: task.id, agentId: agentId.id },\r\n            recoverable: this.isRecoverableError(error),\r\n            retryable: this.isRetryableError(error),\r\n          },\r\n          executionTime: Date.now() - startTime,\r\n          timestamp: new Date(),\r\n        };\r\n\r\n        // Record in history\r\n        this.executionHistory.push({\r\n          taskId: task.id,\r\n          duration: errorResult.executionTime,\r\n          status: 'failed',\r\n          timestamp: new Date(),\r\n        });\r\n\r\n        this.emit('task:failed', errorResult);\r\n        throw error;\r\n      } finally {\r\n        this.activeExecutions.delete(task.id);\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  async executeBatch(tasks: TaskDefinition[], agentId: AgentId): Promise<TaskResult[]> {\r\n    return Promise.all(tasks.map((task) => this.executeTask(task, agentId)));\r\n  }\r\n\r\n  private buildMessages(task: TaskDefinition): any[] {\r\n    const messages = [];\r\n\r\n    // Add system message if needed\r\n    if (task.metadata?.systemPrompt) {\r\n      messages.push({\r\n        role: 'system',\r\n        content: task.metadata.systemPrompt,\r\n      });\r\n    }\r\n\r\n    // Add main task objective\r\n    messages.push({\r\n      role: 'user',\r\n      content: task.objective,\r\n    });\r\n\r\n    // Add context if available\r\n    if (task.context) {\r\n      if (task.context.previousResults?.length) {\r\n        messages.push({\r\n          role: 'assistant',\r\n          content:\r\n            'Previous results:\\n' + task.context.previousResults.map((r) => r.output).join('\\n\\n'),\r\n        });\r\n      }\r\n\r\n      if (task.context.relatedTasks?.length) {\r\n        messages.push({\r\n          role: 'user',\r\n          content:\r\n            'Related context:\\n' + task.context.relatedTasks.map((t) => t.objective).join('\\n'),\r\n        });\r\n      }\r\n    }\r\n\r\n    return messages;\r\n  }\r\n\r\n  private getTaskCacheKey(task: TaskDefinition): string {\r\n    // Create a cache key based on task properties\r\n    return `${task.type}-${task.objective}-${JSON.stringify(task.metadata || {})}`;\r\n  }\r\n\r\n  private isRecoverableError(error: any): boolean {\r\n    if (!error) return false;\r\n\r\n    // Network errors are often recoverable\r\n    if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT' || error.code === 'ENOTFOUND') {\r\n      return true;\r\n    }\r\n\r\n    // Rate limit errors are recoverable with backoff\r\n    if (error.status === 429) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private isRetryableError(error: any): boolean {\r\n    if (!error) return false;\r\n\r\n    // Most recoverable errors are retryable\r\n    if (this.isRecoverableError(error)) {\r\n      return true;\r\n    }\r\n\r\n    // Server errors might be temporary\r\n    if (error.status >= 500 && error.status < 600) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  getMetrics(): ExecutionMetrics {\r\n    const history = this.executionHistory.getAll();\r\n    const avgExecutionTime =\r\n      this.metrics.totalExecuted > 0\r\n        ? this.metrics.totalExecutionTime / this.metrics.totalExecuted\r\n        : 0;\r\n\r\n    const cacheTotal = this.metrics.cacheHits + this.metrics.cacheMisses;\r\n    const cacheHitRate = cacheTotal > 0 ? this.metrics.cacheHits / cacheTotal : 0;\r\n\r\n    return {\r\n      totalExecuted: this.metrics.totalExecuted,\r\n      totalSucceeded: this.metrics.totalSucceeded,\r\n      totalFailed: this.metrics.totalFailed,\r\n      avgExecutionTime,\r\n      cacheHitRate,\r\n      queueLength: this.executionQueue.size,\r\n      activeExecutions: this.activeExecutions.size,\r\n    };\r\n  }\r\n\r\n  private emitMetrics(): void {\r\n    const metrics = this.getMetrics();\r\n    this.emit('metrics', metrics);\r\n\r\n    // Also log if configured\r\n    this.logger.info('Executor metrics', metrics);\r\n  }\r\n\r\n  async waitForPendingExecutions(): Promise<void> {\r\n    await this.executionQueue.onIdle();\r\n    await this.fileManager.waitForPendingOperations();\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    this.logger.info('Shutting down optimized executor');\r\n\r\n    // Clear the queue\r\n    this.executionQueue.clear();\r\n\r\n    // Wait for active executions\r\n    await this.waitForPendingExecutions();\r\n\r\n    // Drain connection pool\r\n    await this.connectionPool.drain();\r\n\r\n    // Clear caches\r\n    this.resultCache.destroy();\r\n\r\n    this.logger.info('Optimized executor shut down');\r\n  }\r\n\r\n  /**\r\n   * Get execution history for analysis\r\n   */\r\n  getExecutionHistory() {\r\n    return this.executionHistory.snapshot();\r\n  }\r\n\r\n  /**\r\n   * Get connection pool statistics\r\n   */\r\n  getConnectionPoolStats() {\r\n    return this.connectionPool.getStats();\r\n  }\r\n\r\n  /**\r\n   * Get file manager metrics\r\n   */\r\n  getFileManagerMetrics() {\r\n    return this.fileManager.getMetrics();\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getCacheStats() {\r\n    return this.resultCache.getStats();\r\n  }\r\n}\r\n"],"names":["EventEmitter","Logger","ClaudeConnectionPool","AsyncFileManager","TTLMap","CircularBuffer","PQueue","OptimizedExecutor","logger","connectionPool","fileManager","executionQueue","resultCache","executionHistory","metrics","totalExecuted","totalSucceeded","totalFailed","totalExecutionTime","cacheHits","cacheMisses","activeExecutions","Set","config","loggerConfig","process","env","CLAUDE_FLOW_ENV","level","format","destination","component","min","max","write","fileOperations","concurrency","read","defaultTTL","caching","ttl","maxSize","onExpire","key","value","debug","taskId","monitoring","metricsInterval","setInterval","emitMetrics","executeTask","task","agentId","startTime","Date","now","taskKey","getTaskCacheKey","enabled","cached","get","id","add","result","executionResult","execute","api","response","complete","messages","buildMessages","model","metadata","max_tokens","constraints","maxTokens","temperature","success","output","content","text","usage","inputTokens","input_tokens","outputTokens","output_tokens","outputDir","outputPath","writeJSON","timestamp","taskResult","error","undefined","executionTime","tokensUsed","set","push","duration","status","slowTaskThreshold","warn","threshold","emit","errorResult","type","Error","name","message","code","stack","context","recoverable","isRecoverableError","retryable","isRetryableError","delete","executeBatch","tasks","Promise","all","map","systemPrompt","role","objective","previousResults","length","r","join","relatedTasks","t","JSON","stringify","getMetrics","history","getAll","avgExecutionTime","cacheTotal","cacheHitRate","queueLength","size","info","waitForPendingExecutions","onIdle","waitForPendingOperations","shutdown","clear","drain","destroy","getExecutionHistory","snapshot","getConnectionPoolStats","getStats","getFileManagerMetrics","getCacheStats"],"mappings":"AAKA,SAASA,YAAY,QAAQ,cAAc;AAC3C,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,SAASC,MAAM,QAAQ,eAAe;AACtC,SAASC,cAAc,QAAQ,uBAAuB;AACtD,OAAOC,YAAY,UAAU;AAyC7B,OAAO,MAAMC,0BAA0BP;;IAC7BQ,OAAe;IACfC,eAAqC;IACrCC,YAA8B;IAC9BC,eAAuB;IACvBC,YAAwC;IACxCC,iBAKL;IAEKC,UAAU;QAChBC,eAAe;QACfC,gBAAgB;QAChBC,aAAa;QACbC,oBAAoB;QACpBC,WAAW;QACXC,aAAa;IACf,EAAE;IAEMC,mBAAmB,IAAIC,MAAc;IAE7C,YAAY,AAAQC,SAAyB,CAAC,CAAC,CAAE;QAC/C,KAAK,SADaA,SAAAA;QAIlB,MAAMC,eACJC,QAAQC,GAAG,CAACC,eAAe,KAAK,SAC5B;YAAEC,OAAO;YAAkBC,QAAQ;YAAiBC,aAAa;QAAmB,IACpF;YAAEF,OAAO;YAAiBC,QAAQ;YAAiBC,aAAa;QAAmB;QAEzF,IAAI,CAACtB,MAAM,GAAG,IAAIP,OAAOuB,cAAc;YAAEO,WAAW;QAAoB;QAGxE,IAAI,CAACtB,cAAc,GAAG,IAAIP,qBAAqB;YAC7C8B,KAAKT,OAAOd,cAAc,EAAEuB,OAAO;YACnCC,KAAKV,OAAOd,cAAc,EAAEwB,OAAO;QACrC;QAGA,IAAI,CAACvB,WAAW,GAAG,IAAIP,iBAAiB;YACtC+B,OAAOX,OAAOY,cAAc,EAAEC,eAAe;YAC7CC,MAAMd,OAAOY,cAAc,EAAEC,eAAe;QAC9C;QAGA,IAAI,CAACzB,cAAc,GAAG,IAAIL,OAAO;YAC/B8B,aAAab,OAAOa,WAAW,IAAI;QACrC;QAGA,IAAI,CAACxB,WAAW,GAAG,IAAIR,OAAO;YAC5BkC,YAAYf,OAAOgB,OAAO,EAAEC,OAAO;YACnCC,SAASlB,OAAOgB,OAAO,EAAEE,WAAW;YACpCC,UAAU,CAACC,KAAKC;gBACd,IAAI,CAACpC,MAAM,CAACqC,KAAK,CAAC,uBAAuB;oBAAEC,QAAQH;gBAAI;YACzD;QACF;QAGA,IAAI,CAAC9B,gBAAgB,GAAG,IAAIR,eAAe;QAG3C,IAAIkB,OAAOwB,UAAU,EAAEC,iBAAiB;YACtCC,YAAY;gBACV,IAAI,CAACC,WAAW;YAClB,GAAG3B,OAAOwB,UAAU,CAACC,eAAe;QACtC;IACF;IAEA,MAAMG,YAAYC,IAAoB,EAAEC,OAAgB,EAAuB;QAC7E,MAAMC,YAAYC,KAAKC,GAAG;QAC1B,MAAMC,UAAU,IAAI,CAACC,eAAe,CAACN;QAGrC,IAAI,IAAI,CAAC7B,MAAM,CAACgB,OAAO,EAAEoB,SAAS;YAChC,MAAMC,SAAS,IAAI,CAAChD,WAAW,CAACiD,GAAG,CAACJ;YACpC,IAAIG,QAAQ;gBACV,IAAI,CAAC9C,OAAO,CAACK,SAAS;gBACtB,IAAI,CAACX,MAAM,CAACqC,KAAK,CAAC,sBAAsB;oBAAEC,QAAQM,KAAKU,EAAE;gBAAC;gBAC1D,OAAOF;YACT;YACA,IAAI,CAAC9C,OAAO,CAACM,WAAW;QAC1B;QAGA,IAAI,CAACC,gBAAgB,CAAC0C,GAAG,CAACX,KAAKU,EAAE;QAGjC,MAAME,SAAS,MAAM,IAAI,CAACrD,cAAc,CAACoD,GAAG,CAAC;YAC3C,IAAI;gBAEF,MAAME,kBAAkB,MAAM,IAAI,CAACxD,cAAc,CAACyD,OAAO,CAAC,OAAOC;oBAC/D,MAAMC,WAAW,MAAMD,IAAIE,QAAQ,CAAC;wBAClCC,UAAU,IAAI,CAACC,aAAa,CAACnB;wBAC7BoB,OAAOpB,KAAKqB,QAAQ,EAAED,SAAS;wBAC/BE,YAAYtB,KAAKuB,WAAW,CAACC,SAAS,IAAI;wBAC1CC,aAAazB,KAAKqB,QAAQ,EAAEI,eAAe;oBAC7C;oBAEA,OAAO;wBACLC,SAAS;wBACTC,QAAQX,SAASY,OAAO,CAAC,EAAE,EAAEC,QAAQ;wBACrCC,OAAO;4BACLC,aAAaf,SAASc,KAAK,EAAEE,gBAAgB;4BAC7CC,cAAcjB,SAASc,KAAK,EAAEI,iBAAiB;wBACjD;oBACF;gBACF;gBAGA,IAAI,IAAI,CAAC/D,MAAM,CAACY,cAAc,EAAEoD,WAAW;oBACzC,MAAMC,aAAa,GAAG,IAAI,CAACjE,MAAM,CAACY,cAAc,CAACoD,SAAS,CAAC,CAAC,EAAEnC,KAAKU,EAAE,CAAC,KAAK,CAAC;oBAC5E,MAAM,IAAI,CAACpD,WAAW,CAAC+E,SAAS,CAACD,YAAY;wBAC3C1C,QAAQM,KAAKU,EAAE;wBACfT,SAASA,QAAQS,EAAE;wBACnBE,QAAQC;wBACRyB,WAAW,IAAInC;oBACjB;gBACF;gBAGA,MAAMoC,aAAyB;oBAC7B7C,QAAQM,KAAKU,EAAE;oBACfT,SAASA,QAAQS,EAAE;oBACnBgB,SAASb,gBAAgBa,OAAO;oBAChCC,QAAQd,gBAAgBc,MAAM;oBAC9Ba,OAAOC;oBACPC,eAAevC,KAAKC,GAAG,KAAKF;oBAC5ByC,YAAY9B,gBAAgBiB,KAAK;oBACjCQ,WAAW,IAAInC;gBACjB;gBAGA,IAAI,IAAI,CAAChC,MAAM,CAACgB,OAAO,EAAEoB,WAAWM,gBAAgBa,OAAO,EAAE;oBAC3D,IAAI,CAAClE,WAAW,CAACoF,GAAG,CAACvC,SAASkC;gBAChC;gBAGA,IAAI,CAAC7E,OAAO,CAACC,aAAa;gBAC1B,IAAI,CAACD,OAAO,CAACE,cAAc;gBAC3B,IAAI,CAACF,OAAO,CAACI,kBAAkB,IAAIyE,WAAWG,aAAa;gBAG3D,IAAI,CAACjF,gBAAgB,CAACoF,IAAI,CAAC;oBACzBnD,QAAQM,KAAKU,EAAE;oBACfoC,UAAUP,WAAWG,aAAa;oBAClCK,QAAQ;oBACRT,WAAW,IAAInC;gBACjB;gBAGA,IACE,IAAI,CAAChC,MAAM,CAACwB,UAAU,EAAEqD,qBACxBT,WAAWG,aAAa,GAAG,IAAI,CAACvE,MAAM,CAACwB,UAAU,CAACqD,iBAAiB,EACnE;oBACA,IAAI,CAAC5F,MAAM,CAAC6F,IAAI,CAAC,sBAAsB;wBACrCvD,QAAQM,KAAKU,EAAE;wBACfoC,UAAUP,WAAWG,aAAa;wBAClCQ,WAAW,IAAI,CAAC/E,MAAM,CAACwB,UAAU,CAACqD,iBAAiB;oBACrD;gBACF;gBAEA,IAAI,CAACG,IAAI,CAAC,kBAAkBZ;gBAC5B,OAAOA;YACT,EAAE,OAAOC,OAAO;gBACd,IAAI,CAAC9E,OAAO,CAACC,aAAa;gBAC1B,IAAI,CAACD,OAAO,CAACG,WAAW;gBAExB,MAAMuF,cAA0B;oBAC9B1D,QAAQM,KAAKU,EAAE;oBACfT,SAASA,QAAQS,EAAE;oBACnBgB,SAAS;oBACTC,QAAQ;oBACRa,OAAO;wBACLa,MAAMb,iBAAiBc,QAAQd,MAAM,WAAW,CAACe,IAAI,GAAG;wBACxDC,SAAShB,iBAAiBc,QAAQd,MAAMgB,OAAO,GAAG;wBAClDC,MAAM,AAACjB,MAAciB,IAAI;wBACzBC,OAAOlB,iBAAiBc,QAAQd,MAAMkB,KAAK,GAAGjB;wBAC9CkB,SAAS;4BAAEjE,QAAQM,KAAKU,EAAE;4BAAET,SAASA,QAAQS,EAAE;wBAAC;wBAChDkD,aAAa,IAAI,CAACC,kBAAkB,CAACrB;wBACrCsB,WAAW,IAAI,CAACC,gBAAgB,CAACvB;oBACnC;oBACAE,eAAevC,KAAKC,GAAG,KAAKF;oBAC5BoC,WAAW,IAAInC;gBACjB;gBAGA,IAAI,CAAC1C,gBAAgB,CAACoF,IAAI,CAAC;oBACzBnD,QAAQM,KAAKU,EAAE;oBACfoC,UAAUM,YAAYV,aAAa;oBACnCK,QAAQ;oBACRT,WAAW,IAAInC;gBACjB;gBAEA,IAAI,CAACgD,IAAI,CAAC,eAAeC;gBACzB,MAAMZ;YACR,SAAU;gBACR,IAAI,CAACvE,gBAAgB,CAAC+F,MAAM,CAAChE,KAAKU,EAAE;YACtC;QACF;QAEA,OAAOE;IACT;IAEA,MAAMqD,aAAaC,KAAuB,EAAEjE,OAAgB,EAAyB;QACnF,OAAOkE,QAAQC,GAAG,CAACF,MAAMG,GAAG,CAAC,CAACrE,OAAS,IAAI,CAACD,WAAW,CAACC,MAAMC;IAChE;IAEQkB,cAAcnB,IAAoB,EAAS;QACjD,MAAMkB,WAAW,EAAE;QAGnB,IAAIlB,KAAKqB,QAAQ,EAAEiD,cAAc;YAC/BpD,SAAS2B,IAAI,CAAC;gBACZ0B,MAAM;gBACN3C,SAAS5B,KAAKqB,QAAQ,CAACiD,YAAY;YACrC;QACF;QAGApD,SAAS2B,IAAI,CAAC;YACZ0B,MAAM;YACN3C,SAAS5B,KAAKwE,SAAS;QACzB;QAGA,IAAIxE,KAAK2D,OAAO,EAAE;YAChB,IAAI3D,KAAK2D,OAAO,CAACc,eAAe,EAAEC,QAAQ;gBACxCxD,SAAS2B,IAAI,CAAC;oBACZ0B,MAAM;oBACN3C,SACE,wBAAwB5B,KAAK2D,OAAO,CAACc,eAAe,CAACJ,GAAG,CAAC,CAACM,IAAMA,EAAEhD,MAAM,EAAEiD,IAAI,CAAC;gBACnF;YACF;YAEA,IAAI5E,KAAK2D,OAAO,CAACkB,YAAY,EAAEH,QAAQ;gBACrCxD,SAAS2B,IAAI,CAAC;oBACZ0B,MAAM;oBACN3C,SACE,uBAAuB5B,KAAK2D,OAAO,CAACkB,YAAY,CAACR,GAAG,CAAC,CAACS,IAAMA,EAAEN,SAAS,EAAEI,IAAI,CAAC;gBAClF;YACF;QACF;QAEA,OAAO1D;IACT;IAEQZ,gBAAgBN,IAAoB,EAAU;QAEpD,OAAO,GAAGA,KAAKqD,IAAI,CAAC,CAAC,EAAErD,KAAKwE,SAAS,CAAC,CAAC,EAAEO,KAAKC,SAAS,CAAChF,KAAKqB,QAAQ,IAAI,CAAC,IAAI;IAChF;IAEQwC,mBAAmBrB,KAAU,EAAW;QAC9C,IAAI,CAACA,OAAO,OAAO;QAGnB,IAAIA,MAAMiB,IAAI,KAAK,gBAAgBjB,MAAMiB,IAAI,KAAK,eAAejB,MAAMiB,IAAI,KAAK,aAAa;YAC3F,OAAO;QACT;QAGA,IAAIjB,MAAMO,MAAM,KAAK,KAAK;YACxB,OAAO;QACT;QAEA,OAAO;IACT;IAEQgB,iBAAiBvB,KAAU,EAAW;QAC5C,IAAI,CAACA,OAAO,OAAO;QAGnB,IAAI,IAAI,CAACqB,kBAAkB,CAACrB,QAAQ;YAClC,OAAO;QACT;QAGA,IAAIA,MAAMO,MAAM,IAAI,OAAOP,MAAMO,MAAM,GAAG,KAAK;YAC7C,OAAO;QACT;QAEA,OAAO;IACT;IAEAkC,aAA+B;QAC7B,MAAMC,UAAU,IAAI,CAACzH,gBAAgB,CAAC0H,MAAM;QAC5C,MAAMC,mBACJ,IAAI,CAAC1H,OAAO,CAACC,aAAa,GAAG,IACzB,IAAI,CAACD,OAAO,CAACI,kBAAkB,GAAG,IAAI,CAACJ,OAAO,CAACC,aAAa,GAC5D;QAEN,MAAM0H,aAAa,IAAI,CAAC3H,OAAO,CAACK,SAAS,GAAG,IAAI,CAACL,OAAO,CAACM,WAAW;QACpE,MAAMsH,eAAeD,aAAa,IAAI,IAAI,CAAC3H,OAAO,CAACK,SAAS,GAAGsH,aAAa;QAE5E,OAAO;YACL1H,eAAe,IAAI,CAACD,OAAO,CAACC,aAAa;YACzCC,gBAAgB,IAAI,CAACF,OAAO,CAACE,cAAc;YAC3CC,aAAa,IAAI,CAACH,OAAO,CAACG,WAAW;YACrCuH;YACAE;YACAC,aAAa,IAAI,CAAChI,cAAc,CAACiI,IAAI;YACrCvH,kBAAkB,IAAI,CAACA,gBAAgB,CAACuH,IAAI;QAC9C;IACF;IAEQ1F,cAAoB;QAC1B,MAAMpC,UAAU,IAAI,CAACuH,UAAU;QAC/B,IAAI,CAAC9B,IAAI,CAAC,WAAWzF;QAGrB,IAAI,CAACN,MAAM,CAACqI,IAAI,CAAC,oBAAoB/H;IACvC;IAEA,MAAMgI,2BAA0C;QAC9C,MAAM,IAAI,CAACnI,cAAc,CAACoI,MAAM;QAChC,MAAM,IAAI,CAACrI,WAAW,CAACsI,wBAAwB;IACjD;IAEA,MAAMC,WAA0B;QAC9B,IAAI,CAACzI,MAAM,CAACqI,IAAI,CAAC;QAGjB,IAAI,CAAClI,cAAc,CAACuI,KAAK;QAGzB,MAAM,IAAI,CAACJ,wBAAwB;QAGnC,MAAM,IAAI,CAACrI,cAAc,CAAC0I,KAAK;QAG/B,IAAI,CAACvI,WAAW,CAACwI,OAAO;QAExB,IAAI,CAAC5I,MAAM,CAACqI,IAAI,CAAC;IACnB;IAKAQ,sBAAsB;QACpB,OAAO,IAAI,CAACxI,gBAAgB,CAACyI,QAAQ;IACvC;IAKAC,yBAAyB;QACvB,OAAO,IAAI,CAAC9I,cAAc,CAAC+I,QAAQ;IACrC;IAKAC,wBAAwB;QACtB,OAAO,IAAI,CAAC/I,WAAW,CAAC2H,UAAU;IACpC;IAKAqB,gBAAgB;QACd,OAAO,IAAI,CAAC9I,WAAW,CAAC4I,QAAQ;IAClC;AACF"}