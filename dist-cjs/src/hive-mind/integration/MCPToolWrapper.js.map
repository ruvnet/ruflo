{"version":3,"sources":["../../../../src/hive-mind/integration/MCPToolWrapper.ts"],"sourcesContent":["/**\r\n * MCPToolWrapper Class\r\n *\r\n * Wraps all MCP tools for use within the Hive Mind system,\r\n * providing a unified interface for swarm coordination, neural processing,\r\n * and memory management.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { exec } from 'child_process';\r\nimport { promisify } from 'util';\r\nimport { getErrorMessage } from '../../utils/type-guards.js';\r\n\r\nconst execAsync = promisify(exec);\r\n\r\ninterface MCPToolResponse {\r\n  success: boolean;\r\n  data?: any;\r\n  error?: string;\r\n}\r\n\r\nexport class MCPToolWrapper extends EventEmitter {\r\n  private toolPrefix = 'mcp__ruv-swarm__';\r\n  private isInitialized = false;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Initialize MCP tools\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      // Check if MCP tools are available\r\n      await this.checkToolAvailability();\r\n      this.isInitialized = true;\r\n      this.emit('initialized');\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if MCP tools are available\r\n   */\r\n  private async checkToolAvailability(): Promise<void> {\r\n    try {\r\n      const { stdout } = await execAsync('npx ruv-swarm --version');\r\n      if (!stdout) {\r\n        throw new Error('ruv-swarm MCP tools not found');\r\n      }\r\n    } catch (error) {\r\n      throw new Error('MCP tools not available. Please ensure ruv-swarm is installed.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute MCP tool via CLI\r\n   */\r\n  private async executeTool(toolName: string, params: any): Promise<MCPToolResponse> {\r\n    try {\r\n      const command = `npx ruv-swarm mcp-execute ${toolName} '${JSON.stringify(params)}'`;\r\n      const { stdout, stderr } = await execAsync(command);\r\n\r\n      if (stderr) {\r\n        return { success: false, error: stderr };\r\n      }\r\n\r\n      const result = JSON.parse(stdout);\r\n      return { success: true, data: result };\r\n    } catch (error) {\r\n      return { success: false, error: getErrorMessage(error) };\r\n    }\r\n  }\r\n\r\n  // Swarm coordination tools\r\n\r\n  async initSwarm(params: {\r\n    topology: string;\r\n    maxAgents?: number;\r\n    strategy?: string;\r\n  }): Promise<any> {\r\n    return this.executeTool('swarm_init', params);\r\n  }\r\n\r\n  async spawnAgent(params: {\r\n    type: string;\r\n    name?: string;\r\n    swarmId?: string;\r\n    capabilities?: string[];\r\n  }): Promise<any> {\r\n    return this.executeTool('agent_spawn', params);\r\n  }\r\n\r\n  async orchestrateTask(params: {\r\n    task: string;\r\n    priority?: string;\r\n    strategy?: string;\r\n    dependencies?: string[];\r\n  }): Promise<any> {\r\n    return this.executeTool('task_orchestrate', params);\r\n  }\r\n\r\n  async getSwarmStatus(swarmId?: string): Promise<any> {\r\n    return this.executeTool('swarm_status', { swarmId });\r\n  }\r\n\r\n  async monitorSwarm(params: { swarmId?: string; interval?: number }): Promise<any> {\r\n    return this.executeTool('swarm_monitor', params);\r\n  }\r\n\r\n  // Neural and pattern tools\r\n\r\n  async analyzePattern(params: {\r\n    action: string;\r\n    operation?: string;\r\n    metadata?: any;\r\n  }): Promise<any> {\r\n    return this.executeTool('neural_patterns', params);\r\n  }\r\n\r\n  async trainNeural(params: {\r\n    pattern_type: string;\r\n    training_data: string;\r\n    epochs?: number;\r\n  }): Promise<any> {\r\n    return this.executeTool('neural_train', params);\r\n  }\r\n\r\n  async predict(params: { modelId: string; input: string }): Promise<any> {\r\n    return this.executeTool('neural_predict', params);\r\n  }\r\n\r\n  async getNeuralStatus(modelId?: string): Promise<any> {\r\n    return this.executeTool('neural_status', { modelId });\r\n  }\r\n\r\n  // Memory management tools\r\n\r\n  async storeMemory(params: {\r\n    action: 'store';\r\n    key: string;\r\n    value: string;\r\n    namespace?: string;\r\n    ttl?: number;\r\n  }): Promise<any> {\r\n    return this.executeTool('memory_usage', params);\r\n  }\r\n\r\n  async retrieveMemory(params: {\r\n    action: 'retrieve';\r\n    key: string;\r\n    namespace?: string;\r\n  }): Promise<any> {\r\n    const result = await this.executeTool('memory_usage', params);\r\n    return result.success ? result.data : null;\r\n  }\r\n\r\n  async searchMemory(params: {\r\n    pattern: string;\r\n    namespace?: string;\r\n    limit?: number;\r\n  }): Promise<any> {\r\n    return this.executeTool('memory_search', params);\r\n  }\r\n\r\n  async deleteMemory(params: { action: 'delete'; key: string; namespace?: string }): Promise<any> {\r\n    return this.executeTool('memory_usage', params);\r\n  }\r\n\r\n  async listMemory(params: { action: 'list'; namespace?: string }): Promise<any> {\r\n    return this.executeTool('memory_usage', params);\r\n  }\r\n\r\n  // Performance and monitoring tools\r\n\r\n  async getPerformanceReport(params?: { format?: string; timeframe?: string }): Promise<any> {\r\n    return this.executeTool('performance_report', params || {});\r\n  }\r\n\r\n  async analyzeBottlenecks(params?: { component?: string; metrics?: string[] }): Promise<any> {\r\n    return this.executeTool('bottleneck_analyze', params || {});\r\n  }\r\n\r\n  async getTokenUsage(params?: { operation?: string; timeframe?: string }): Promise<any> {\r\n    return this.executeTool('token_usage', params || {});\r\n  }\r\n\r\n  // Agent management tools\r\n\r\n  async listAgents(swarmId?: string): Promise<any> {\r\n    return this.executeTool('agent_list', { swarmId });\r\n  }\r\n\r\n  async getAgentMetrics(agentId: string): Promise<any> {\r\n    return this.executeTool('agent_metrics', { agentId });\r\n  }\r\n\r\n  // Task management tools\r\n\r\n  async getTaskStatus(taskId: string): Promise<any> {\r\n    return this.executeTool('task_status', { taskId });\r\n  }\r\n\r\n  async getTaskResults(taskId: string): Promise<any> {\r\n    return this.executeTool('task_results', { taskId });\r\n  }\r\n\r\n  // Advanced coordination tools\r\n\r\n  async optimizeTopology(swarmId?: string): Promise<any> {\r\n    return this.executeTool('topology_optimize', { swarmId });\r\n  }\r\n\r\n  async loadBalance(params: { swarmId?: string; tasks: any[] }): Promise<any> {\r\n    return this.executeTool('load_balance', params);\r\n  }\r\n\r\n  async syncCoordination(swarmId?: string): Promise<any> {\r\n    return this.executeTool('coordination_sync', { swarmId });\r\n  }\r\n\r\n  async scaleSwarm(params: { swarmId?: string; targetSize: number }): Promise<any> {\r\n    return this.executeTool('swarm_scale', params);\r\n  }\r\n\r\n  // SPARC mode integration\r\n\r\n  async runSparcMode(params: {\r\n    mode: string;\r\n    task_description: string;\r\n    options?: any;\r\n  }): Promise<any> {\r\n    return this.executeTool('sparc_mode', params);\r\n  }\r\n\r\n  // Workflow tools\r\n\r\n  async createWorkflow(params: { name: string; steps: any[]; triggers?: any[] }): Promise<any> {\r\n    return this.executeTool('workflow_create', params);\r\n  }\r\n\r\n  async executeWorkflow(params: { workflowId: string; params?: any }): Promise<any> {\r\n    return this.executeTool('workflow_execute', params);\r\n  }\r\n\r\n  // GitHub integration tools\r\n\r\n  async analyzeRepository(params: { repo: string; analysis_type?: string }): Promise<any> {\r\n    return this.executeTool('github_repo_analyze', params);\r\n  }\r\n\r\n  async manageGitHubPR(params: { repo: string; action: string; pr_number?: number }): Promise<any> {\r\n    return this.executeTool('github_pr_manage', params);\r\n  }\r\n\r\n  // Dynamic Agent Architecture tools\r\n\r\n  async createDynamicAgent(params: {\r\n    agent_type: string;\r\n    capabilities?: string[];\r\n    resources?: any;\r\n  }): Promise<any> {\r\n    return this.executeTool('daa_agent_create', params);\r\n  }\r\n\r\n  async matchCapabilities(params: {\r\n    task_requirements: string[];\r\n    available_agents?: any[];\r\n  }): Promise<any> {\r\n    return this.executeTool('daa_capability_match', params);\r\n  }\r\n\r\n  // System tools\r\n\r\n  async runBenchmark(suite?: string): Promise<any> {\r\n    return this.executeTool('benchmark_run', { suite });\r\n  }\r\n\r\n  async collectMetrics(components?: string[]): Promise<any> {\r\n    return this.executeTool('metrics_collect', { components });\r\n  }\r\n\r\n  async analyzeTrends(params: { metric: string; period?: string }): Promise<any> {\r\n    return this.executeTool('trend_analysis', params);\r\n  }\r\n\r\n  async analyzeCost(timeframe?: string): Promise<any> {\r\n    return this.executeTool('cost_analysis', { timeframe });\r\n  }\r\n\r\n  async assessQuality(params: { target: string; criteria?: string[] }): Promise<any> {\r\n    return this.executeTool('quality_assess', params);\r\n  }\r\n\r\n  async healthCheck(components?: string[]): Promise<any> {\r\n    return this.executeTool('health_check', { components });\r\n  }\r\n\r\n  // Batch operations\r\n\r\n  async batchProcess(params: { items: any[]; operation: string }): Promise<any> {\r\n    return this.executeTool('batch_process', params);\r\n  }\r\n\r\n  async parallelExecute(tasks: any[]): Promise<any> {\r\n    return this.executeTool('parallel_execute', { tasks });\r\n  }\r\n\r\n  /**\r\n   * Generic tool execution for custom tools\r\n   */\r\n  async executeMCPTool(toolName: string, params: any): Promise<any> {\r\n    return this.executeTool(toolName, params);\r\n  }\r\n\r\n  /**\r\n   * Helper to format tool responses\r\n   */\r\n  private formatResponse(response: MCPToolResponse): any {\r\n    if (response.success) {\r\n      return response.data;\r\n    } else {\r\n      throw new Error(`MCP Tool Error: ${response.error}`);\r\n    }\r\n  }\r\n}\r\n"],"names":["EventEmitter","exec","promisify","getErrorMessage","execAsync","MCPToolWrapper","toolPrefix","isInitialized","initialize","checkToolAvailability","emit","error","stdout","Error","executeTool","toolName","params","command","JSON","stringify","stderr","success","result","parse","data","initSwarm","spawnAgent","orchestrateTask","getSwarmStatus","swarmId","monitorSwarm","analyzePattern","trainNeural","predict","getNeuralStatus","modelId","storeMemory","retrieveMemory","searchMemory","deleteMemory","listMemory","getPerformanceReport","analyzeBottlenecks","getTokenUsage","listAgents","getAgentMetrics","agentId","getTaskStatus","taskId","getTaskResults","optimizeTopology","loadBalance","syncCoordination","scaleSwarm","runSparcMode","createWorkflow","executeWorkflow","analyzeRepository","manageGitHubPR","createDynamicAgent","matchCapabilities","runBenchmark","suite","collectMetrics","components","analyzeTrends","analyzeCost","timeframe","assessQuality","healthCheck","batchProcess","parallelExecute","tasks","executeMCPTool","formatResponse","response"],"mappings":"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"}