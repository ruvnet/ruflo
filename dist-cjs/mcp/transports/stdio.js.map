{
  "version": 3,
  "sources": ["../../../src/mcp/transports/stdio.ts"],
  "sourcesContent": ["/**\n * Standard I/O transport for MCP\n */\n\nimport { createReadStream, createWriteStream } from 'node:fs';\nimport { stdin, stdout } from 'node:process';\nimport { createInterface, Interface } from 'node:readline';\nimport type { ITransport, RequestHandler, NotificationHandler } from './base.js';\nimport type { MCPRequest, MCPResponse, MCPNotification } from '../../utils/types.js';\nimport type { ILogger } from '../../core/logger.js';\nimport { MCPTransportError } from '../../utils/errors.js';\n\n/**\n * Stdio transport implementation\n */\nexport class StdioTransport implements ITransport {\n  private requestHandler?: RequestHandler;\n  private notificationHandler?: NotificationHandler;\n  private readline?: Interface;\n  private messageCount = 0;\n  private notificationCount = 0;\n  private running = false;\n\n  constructor(private logger: ILogger) {}\n\n  async start(): Promise<void> {\n    if (this.running) {\n      throw new MCPTransportError('Transport already running');\n    }\n\n    this.logger.info('Starting stdio transport');\n\n    try {\n      // Create readline interface for stdin\n      this.readline = createInterface({\n        input: stdin,\n        output: stdout,\n        terminal: false,\n      });\n\n      // Set up line handler\n      this.readline.on('line', (line: string) => {\n        this.processMessage(line.trim()).catch((error) => {\n          this.logger.error('Error processing message', { line, error });\n        });\n      });\n\n      this.readline.on('close', () => {\n        this.logger.info('Stdin closed');\n        this.running = false;\n      });\n\n      this.running = true;\n      this.logger.info('Stdio transport started');\n    } catch (error) {\n      throw new MCPTransportError('Failed to start stdio transport', { error });\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.running) {\n      return;\n    }\n\n    this.logger.info('Stopping stdio transport');\n\n    this.running = false;\n\n    if (this.readline) {\n      this.readline.close();\n      this.readline = undefined;\n    }\n\n    this.logger.info('Stdio transport stopped');\n  }\n\n  onRequest(handler: RequestHandler): void {\n    this.requestHandler = handler;\n  }\n\n  onNotification(handler: NotificationHandler): void {\n    this.notificationHandler = handler;\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    return {\n      healthy: this.running,\n      metrics: {\n        messagesReceived: this.messageCount,\n        notificationsSent: this.notificationCount,\n        stdinOpen: this.readline ? 1 : 0,\n      },\n    };\n  }\n\n  private async processMessage(line: string): Promise<void> {\n    let message: any;\n\n    try {\n      message = JSON.parse(line);\n\n      if (!message.jsonrpc || message.jsonrpc !== '2.0') {\n        throw new Error('Invalid JSON-RPC version');\n      }\n\n      if (!message.method) {\n        throw new Error('Missing method');\n      }\n    } catch (error) {\n      this.logger.error('Failed to parse message', { line, error });\n\n      // Send error response if we can extract an ID\n      let id = 'unknown';\n      try {\n        const parsed = JSON.parse(line);\n        if (parsed.id !== undefined) {\n          id = parsed.id;\n        }\n      } catch {\n        // Ignore parse error for ID extraction\n      }\n\n      await this.sendResponse({\n        jsonrpc: '2.0',\n        id,\n        error: {\n          code: -32700,\n          message: 'Parse error',\n        },\n      });\n      return;\n    }\n\n    this.messageCount++;\n\n    // Check if this is a notification (no id field) or a request\n    if (message.id === undefined) {\n      // This is a notification\n      await this.handleNotification(message as MCPNotification);\n    } else {\n      // This is a request\n      await this.handleRequest(message as MCPRequest);\n    }\n  }\n\n  private async handleRequest(request: MCPRequest): Promise<void> {\n    if (!this.requestHandler) {\n      await this.sendResponse({\n        jsonrpc: '2.0',\n        id: request.id,\n        error: {\n          code: -32603,\n          message: 'No request handler registered',\n        },\n      });\n      return;\n    }\n\n    try {\n      const response = await this.requestHandler(request);\n      await this.sendResponse(response);\n    } catch (error) {\n      this.logger.error('Request handler error', { request, error });\n\n      await this.sendResponse({\n        jsonrpc: '2.0',\n        id: request.id,\n        error: {\n          code: -32603,\n          message: 'Internal error',\n          data: error instanceof Error ? error.message : String(error),\n        },\n      });\n    }\n  }\n\n  private async handleNotification(notification: MCPNotification): Promise<void> {\n    if (!this.notificationHandler) {\n      this.logger.warn('Received notification but no handler registered', {\n        method: notification.method,\n      });\n      return;\n    }\n\n    try {\n      await this.notificationHandler(notification);\n    } catch (error) {\n      this.logger.error('Notification handler error', { notification, error });\n      // Notifications don't send error responses\n    }\n  }\n\n  private async sendResponse(response: MCPResponse): Promise<void> {\n    try {\n      const json = JSON.stringify(response);\n      stdout.write(json + '\\n');\n    } catch (error) {\n      this.logger.error('Failed to send response', { response, error });\n    }\n  }\n\n  async connect(): Promise<void> {\n    // For STDIO transport, connect is handled by start()\n    if (!this.running) {\n      await this.start();\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    // For STDIO transport, disconnect is handled by stop()\n    await this.stop();\n  }\n\n  async sendRequest(request: MCPRequest): Promise<MCPResponse> {\n    // Send request to stdout\n    const json = JSON.stringify(request);\n    stdout.write(json + '\\n');\n\n    // In STDIO transport, responses are handled asynchronously\n    // This would need a proper request/response correlation mechanism\n    throw new Error('STDIO transport sendRequest requires request/response correlation');\n  }\n\n  async sendNotification(notification: MCPNotification): Promise<void> {\n    try {\n      const json = JSON.stringify(notification);\n      stdout.write(json + '\\n');\n      this.notificationCount++;\n    } catch (error) {\n      this.logger.error('Failed to send notification', { notification, error });\n      throw error;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
