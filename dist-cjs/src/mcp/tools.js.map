{"version":3,"sources":["../../../src/mcp/tools.ts"],"sourcesContent":["/**\r\n * Enhanced Tool registry for MCP with capability negotiation and discovery\r\n */\r\n\r\nimport type { MCPTool, MCPCapabilities, MCPProtocolVersion } from '../utils/types.js';\r\nimport type { ILogger } from '../core/logger.js';\r\nimport { MCPError } from '../utils/errors.js';\r\nimport { EventEmitter } from 'node:events';\r\n\r\nexport interface ToolCapability {\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  category: string;\r\n  tags: string[];\r\n  requiredPermissions?: string[];\r\n  supportedProtocolVersions: MCPProtocolVersion[];\r\n  dependencies?: string[];\r\n  deprecated?: boolean;\r\n  deprecationMessage?: string;\r\n}\r\n\r\nexport interface ToolMetrics {\r\n  name: string;\r\n  totalInvocations: number;\r\n  successfulInvocations: number;\r\n  failedInvocations: number;\r\n  averageExecutionTime: number;\r\n  lastInvoked?: Date;\r\n  totalExecutionTime: number;\r\n}\r\n\r\nexport interface ToolDiscoveryQuery {\r\n  category?: string;\r\n  tags?: string[];\r\n  capabilities?: string[];\r\n  protocolVersion?: MCPProtocolVersion;\r\n  includeDeprecated?: boolean;\r\n  permissions?: string[];\r\n}\r\n\r\n/**\r\n * Enhanced Tool registry implementation with capability negotiation\r\n */\r\nexport class ToolRegistry extends EventEmitter {\r\n  private tools = new Map<string, MCPTool>();\r\n  private capabilities = new Map<string, ToolCapability>();\r\n  private metrics = new Map<string, ToolMetrics>();\r\n  private categories = new Set<string>();\r\n  private tags = new Set<string>();\r\n\r\n  constructor(private logger: ILogger) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Registers a new tool with enhanced capability information\r\n   */\r\n  register(tool: MCPTool, capability?: ToolCapability): void {\r\n    if (this.tools.has(tool.name)) {\r\n      throw new MCPError(`Tool already registered: ${tool.name}`);\r\n    }\r\n\r\n    // Validate tool schema\r\n    this.validateTool(tool);\r\n\r\n    // Register tool\r\n    this.tools.set(tool.name, tool);\r\n\r\n    // Register capability if provided\r\n    if (capability) {\r\n      this.registerCapability(tool.name, capability);\r\n    } else {\r\n      // Create default capability\r\n      const defaultCapability: ToolCapability = {\r\n        name: tool.name,\r\n        version: '1.0.0',\r\n        description: tool.description,\r\n        category: this.extractCategory(tool.name),\r\n        tags: this.extractTags(tool),\r\n        supportedProtocolVersions: [{ major: 2024, minor: 11, patch: 5 }],\r\n      };\r\n      this.registerCapability(tool.name, defaultCapability);\r\n    }\r\n\r\n    // Initialize metrics\r\n    this.metrics.set(tool.name, {\r\n      name: tool.name,\r\n      totalInvocations: 0,\r\n      successfulInvocations: 0,\r\n      failedInvocations: 0,\r\n      averageExecutionTime: 0,\r\n      totalExecutionTime: 0,\r\n    });\r\n\r\n    this.logger.debug('Tool registered', { name: tool.name });\r\n    this.emit('toolRegistered', { name: tool.name, capability });\r\n  }\r\n\r\n  /**\r\n   * Unregisters a tool\r\n   */\r\n  unregister(name: string): void {\r\n    if (!this.tools.has(name)) {\r\n      throw new MCPError(`Tool not found: ${name}`);\r\n    }\r\n\r\n    this.tools.delete(name);\r\n    this.logger.debug('Tool unregistered', { name });\r\n  }\r\n\r\n  /**\r\n   * Gets a tool by name\r\n   */\r\n  getTool(name: string): MCPTool | undefined {\r\n    return this.tools.get(name);\r\n  }\r\n\r\n  /**\r\n   * Lists all registered tools\r\n   */\r\n  listTools(): Array<{ name: string; description: string }> {\r\n    return Array.from(this.tools.values()).map((tool) => ({\r\n      name: tool.name,\r\n      description: tool.description,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Gets the number of registered tools\r\n   */\r\n  getToolCount(): number {\r\n    return this.tools.size;\r\n  }\r\n\r\n  /**\r\n   * Executes a tool with metrics tracking\r\n   */\r\n  async executeTool(name: string, input: unknown, context?: any): Promise<unknown> {\r\n    const tool = this.tools.get(name);\r\n    if (!tool) {\r\n      throw new MCPError(`Tool not found: ${name}`);\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const metrics = this.metrics.get(name);\r\n\r\n    this.logger.debug('Executing tool', { name, input });\r\n\r\n    try {\r\n      // Validate input against schema\r\n      this.validateInput(tool, input);\r\n\r\n      // Check tool capabilities and permissions\r\n      await this.checkToolCapabilities(name, context);\r\n\r\n      // Execute tool handler\r\n      const result = await tool.handler(input, context);\r\n\r\n      // Update success metrics\r\n      if (metrics) {\r\n        const executionTime = Date.now() - startTime;\r\n        metrics.totalInvocations++;\r\n        metrics.successfulInvocations++;\r\n        metrics.totalExecutionTime += executionTime;\r\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\r\n        metrics.lastInvoked = new Date();\r\n      }\r\n\r\n      this.logger.debug('Tool executed successfully', {\r\n        name,\r\n        executionTime: Date.now() - startTime,\r\n      });\r\n      this.emit('toolExecuted', { name, success: true, executionTime: Date.now() - startTime });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      // Update failure metrics\r\n      if (metrics) {\r\n        const executionTime = Date.now() - startTime;\r\n        metrics.totalInvocations++;\r\n        metrics.failedInvocations++;\r\n        metrics.totalExecutionTime += executionTime;\r\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\r\n        metrics.lastInvoked = new Date();\r\n      }\r\n\r\n      this.logger.error('Tool execution failed', {\r\n        name,\r\n        error,\r\n        executionTime: Date.now() - startTime,\r\n      });\r\n      this.emit('toolExecuted', {\r\n        name,\r\n        success: false,\r\n        error,\r\n        executionTime: Date.now() - startTime,\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates tool definition\r\n   */\r\n  private validateTool(tool: MCPTool): void {\r\n    if (!tool.name || typeof tool.name !== 'string') {\r\n      throw new MCPError('Tool name must be a non-empty string');\r\n    }\r\n\r\n    if (!tool.description || typeof tool.description !== 'string') {\r\n      throw new MCPError('Tool description must be a non-empty string');\r\n    }\r\n\r\n    if (typeof tool.handler !== 'function') {\r\n      throw new MCPError('Tool handler must be a function');\r\n    }\r\n\r\n    if (!tool.inputSchema || typeof tool.inputSchema !== 'object') {\r\n      throw new MCPError('Tool inputSchema must be an object');\r\n    }\r\n\r\n    // Validate tool name format (namespace/name)\r\n    if (!tool.name.includes('/')) {\r\n      throw new MCPError('Tool name must be in format: namespace/name');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates input against tool schema\r\n   */\r\n  private validateInput(tool: MCPTool, input: unknown): void {\r\n    // Simple validation - in production, use a JSON Schema validator\r\n    const schema = tool.inputSchema as any;\r\n\r\n    if (schema.type === 'object' && schema.properties) {\r\n      if (typeof input !== 'object' || input === null) {\r\n        throw new MCPError('Input must be an object');\r\n      }\r\n\r\n      const inputObj = input as Record<string, unknown>;\r\n\r\n      // Check required properties\r\n      if (schema.required && Array.isArray(schema.required)) {\r\n        for (const prop of schema.required) {\r\n          if (!(prop in inputObj)) {\r\n            throw new MCPError(`Missing required property: ${prop}`);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check property types\r\n      for (const [prop, propSchema] of Object.entries(schema.properties)) {\r\n        if (prop in inputObj) {\r\n          const value = inputObj[prop];\r\n          const expectedType = (propSchema as any).type;\r\n\r\n          if (expectedType && !this.checkType(value, expectedType)) {\r\n            throw new MCPError(`Invalid type for property ${prop}: expected ${expectedType}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if a value matches a JSON Schema type\r\n   */\r\n  private checkType(value: unknown, type: string): boolean {\r\n    switch (type) {\r\n      case 'string':\r\n        return typeof value === 'string';\r\n      case 'number':\r\n        return typeof value === 'number';\r\n      case 'boolean':\r\n        return typeof value === 'boolean';\r\n      case 'object':\r\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\r\n      case 'array':\r\n        return Array.isArray(value);\r\n      case 'null':\r\n        return value === null;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register tool capability information\r\n   */\r\n  private registerCapability(toolName: string, capability: ToolCapability): void {\r\n    this.capabilities.set(toolName, capability);\r\n    this.categories.add(capability.category);\r\n    capability.tags.forEach((tag) => this.tags.add(tag));\r\n  }\r\n\r\n  /**\r\n   * Extract category from tool name\r\n   */\r\n  private extractCategory(toolName: string): string {\r\n    const parts = toolName.split('/');\r\n    return parts.length > 1 ? parts[0] : 'general';\r\n  }\r\n\r\n  /**\r\n   * Extract tags from tool definition\r\n   */\r\n  private extractTags(tool: MCPTool): string[] {\r\n    const tags: string[] = [];\r\n\r\n    // Extract from description\r\n    if (tool.description.toLowerCase().includes('file')) tags.push('filesystem');\r\n    if (tool.description.toLowerCase().includes('search')) tags.push('search');\r\n    if (tool.description.toLowerCase().includes('memory')) tags.push('memory');\r\n    if (tool.description.toLowerCase().includes('swarm')) tags.push('swarm');\r\n    if (tool.description.toLowerCase().includes('task')) tags.push('orchestration');\r\n\r\n    return tags.length > 0 ? tags : ['general'];\r\n  }\r\n\r\n  /**\r\n   * Check tool capabilities and permissions\r\n   */\r\n  private async checkToolCapabilities(toolName: string, context?: any): Promise<void> {\r\n    const capability = this.capabilities.get(toolName);\r\n    if (!capability) {\r\n      return; // No capability checks needed\r\n    }\r\n\r\n    // Check if tool is deprecated\r\n    if (capability.deprecated) {\r\n      this.logger.warn('Using deprecated tool', {\r\n        name: toolName,\r\n        message: capability.deprecationMessage,\r\n      });\r\n    }\r\n\r\n    // Check required permissions\r\n    if (capability.requiredPermissions && context?.permissions) {\r\n      const hasAllPermissions = capability.requiredPermissions.every((permission) =>\r\n        context.permissions.includes(permission),\r\n      );\r\n\r\n      if (!hasAllPermissions) {\r\n        throw new MCPError(\r\n          `Insufficient permissions for tool ${toolName}. Required: ${capability.requiredPermissions.join(', ')}`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check protocol version compatibility\r\n    if (context?.protocolVersion) {\r\n      const isCompatible = capability.supportedProtocolVersions.some((version) =>\r\n        this.isProtocolVersionCompatible(context.protocolVersion, version),\r\n      );\r\n\r\n      if (!isCompatible) {\r\n        throw new MCPError(\r\n          `Tool ${toolName} is not compatible with protocol version ${context.protocolVersion.major}.${context.protocolVersion.minor}.${context.protocolVersion.patch}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check protocol version compatibility\r\n   */\r\n  private isProtocolVersionCompatible(\r\n    client: MCPProtocolVersion,\r\n    supported: MCPProtocolVersion,\r\n  ): boolean {\r\n    if (client.major !== supported.major) {\r\n      return false;\r\n    }\r\n\r\n    if (client.minor > supported.minor) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Discover tools based on query criteria\r\n   */\r\n  discoverTools(\r\n    query: ToolDiscoveryQuery = {},\r\n  ): Array<{ tool: MCPTool; capability: ToolCapability }> {\r\n    const results: Array<{ tool: MCPTool; capability: ToolCapability }> = [];\r\n\r\n    for (const [name, tool] of this.tools) {\r\n      const capability = this.capabilities.get(name);\r\n      if (!capability) continue;\r\n\r\n      // Filter by category\r\n      if (query.category && capability.category !== query.category) {\r\n        continue;\r\n      }\r\n\r\n      // Filter by tags\r\n      if (query.tags && !query.tags.some((tag) => capability.tags.includes(tag))) {\r\n        continue;\r\n      }\r\n\r\n      // Filter by capabilities\r\n      if (query.capabilities && !query.capabilities.every((cap) => capability.tags.includes(cap))) {\r\n        continue;\r\n      }\r\n\r\n      // Filter by protocol version\r\n      if (query.protocolVersion) {\r\n        const isCompatible = capability.supportedProtocolVersions.some((version) =>\r\n          this.isProtocolVersionCompatible(query.protocolVersion!, version),\r\n        );\r\n        if (!isCompatible) continue;\r\n      }\r\n\r\n      // Filter deprecated tools\r\n      if (!query.includeDeprecated && capability.deprecated) {\r\n        continue;\r\n      }\r\n\r\n      // Filter by permissions\r\n      if (query.permissions && capability.requiredPermissions) {\r\n        const hasAllPermissions = capability.requiredPermissions.every((permission) =>\r\n          query.permissions!.includes(permission),\r\n        );\r\n        if (!hasAllPermissions) continue;\r\n      }\r\n\r\n      results.push({ tool, capability });\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Get tool capability information\r\n   */\r\n  getToolCapability(name: string): ToolCapability | undefined {\r\n    return this.capabilities.get(name);\r\n  }\r\n\r\n  /**\r\n   * Get tool metrics\r\n   */\r\n  getToolMetrics(name?: string): ToolMetrics | ToolMetrics[] {\r\n    if (name) {\r\n      const metrics = this.metrics.get(name);\r\n      if (!metrics) {\r\n        throw new MCPError(`Metrics not found for tool: ${name}`);\r\n      }\r\n      return metrics;\r\n    }\r\n\r\n    return Array.from(this.metrics.values());\r\n  }\r\n\r\n  /**\r\n   * Get all available categories\r\n   */\r\n  getCategories(): string[] {\r\n    return Array.from(this.categories);\r\n  }\r\n\r\n  /**\r\n   * Get all available tags\r\n   */\r\n  getTags(): string[] {\r\n    return Array.from(this.tags);\r\n  }\r\n\r\n  /**\r\n   * Reset metrics for a tool or all tools\r\n   */\r\n  resetMetrics(toolName?: string): void {\r\n    if (toolName) {\r\n      const metrics = this.metrics.get(toolName);\r\n      if (metrics) {\r\n        Object.assign(metrics, {\r\n          totalInvocations: 0,\r\n          successfulInvocations: 0,\r\n          failedInvocations: 0,\r\n          averageExecutionTime: 0,\r\n          totalExecutionTime: 0,\r\n          lastInvoked: undefined,\r\n        });\r\n      }\r\n    } else {\r\n      for (const metrics of this.metrics.values()) {\r\n        Object.assign(metrics, {\r\n          totalInvocations: 0,\r\n          successfulInvocations: 0,\r\n          failedInvocations: 0,\r\n          averageExecutionTime: 0,\r\n          totalExecutionTime: 0,\r\n          lastInvoked: undefined,\r\n        });\r\n      }\r\n    }\r\n\r\n    this.emit('metricsReset', { toolName });\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive registry statistics\r\n   */\r\n  getRegistryStats(): {\r\n    totalTools: number;\r\n    toolsByCategory: Record<string, number>;\r\n    toolsByTag: Record<string, number>;\r\n    totalInvocations: number;\r\n    successRate: number;\r\n    averageExecutionTime: number;\r\n  } {\r\n    const stats = {\r\n      totalTools: this.tools.size,\r\n      toolsByCategory: {} as Record<string, number>,\r\n      toolsByTag: {} as Record<string, number>,\r\n      totalInvocations: 0,\r\n      successRate: 0,\r\n      averageExecutionTime: 0,\r\n    };\r\n\r\n    // Count by category\r\n    for (const capability of this.capabilities.values()) {\r\n      stats.toolsByCategory[capability.category] =\r\n        (stats.toolsByCategory[capability.category] || 0) + 1;\r\n\r\n      for (const tag of capability.tags) {\r\n        stats.toolsByTag[tag] = (stats.toolsByTag[tag] || 0) + 1;\r\n      }\r\n    }\r\n\r\n    // Calculate execution stats\r\n    let totalExecutionTime = 0;\r\n    let totalSuccessful = 0;\r\n\r\n    for (const metrics of this.metrics.values()) {\r\n      stats.totalInvocations += metrics.totalInvocations;\r\n      totalSuccessful += metrics.successfulInvocations;\r\n      totalExecutionTime += metrics.totalExecutionTime;\r\n    }\r\n\r\n    if (stats.totalInvocations > 0) {\r\n      stats.successRate = (totalSuccessful / stats.totalInvocations) * 100;\r\n      stats.averageExecutionTime = totalExecutionTime / stats.totalInvocations;\r\n    }\r\n\r\n    return stats;\r\n  }\r\n}\r\n"],"names":["MCPError","EventEmitter","ToolRegistry","tools","Map","capabilities","metrics","categories","Set","tags","logger","register","tool","capability","has","name","validateTool","set","registerCapability","defaultCapability","version","description","category","extractCategory","extractTags","supportedProtocolVersions","major","minor","patch","totalInvocations","successfulInvocations","failedInvocations","averageExecutionTime","totalExecutionTime","debug","emit","unregister","delete","getTool","get","listTools","Array","from","values","map","getToolCount","size","executeTool","input","context","startTime","Date","now","validateInput","checkToolCapabilities","result","handler","executionTime","lastInvoked","success","error","inputSchema","includes","schema","type","properties","inputObj","required","isArray","prop","propSchema","Object","entries","value","expectedType","checkType","toolName","add","forEach","tag","parts","split","length","toLowerCase","push","deprecated","warn","message","deprecationMessage","requiredPermissions","permissions","hasAllPermissions","every","permission","join","protocolVersion","isCompatible","some","isProtocolVersionCompatible","client","supported","discoverTools","query","results","cap","includeDeprecated","getToolCapability","getToolMetrics","getCategories","getTags","resetMetrics","assign","undefined","getRegistryStats","stats","totalTools","toolsByCategory","toolsByTag","successRate","totalSuccessful"],"mappings":"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"}